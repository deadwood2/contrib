diff -Naur SDL-1.2.15-orig/aros/sdl-config SDL-1.2.15/aros/sdl-config
--- SDL-1.2.15-orig/aros/sdl-config	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.15/aros/sdl-config	2015-05-09 15:09:59.750739542 +0200
@@ -0,0 +1,58 @@
+#!/bin/sh
+
+prefix=/Development
+exec_prefix=${prefix}
+exec_prefix_set=no
+libdir=${exec_prefix}/lib
+
+usage="\
+Usage: sdl-config [--prefix[=DIR]] [--exec-prefix[=DIR]] [--version] [--cflags] [--libs]"
+#Usage: sdl-config [--prefix[=DIR]] [--exec-prefix[=DIR]] [--version] [--cflags] [--libs] [--static-libs]"
+
+if test $# -eq 0; then
+      echo "${usage}" 1>&2
+      exit 1
+fi
+
+while test $# -gt 0; do
+  case "$1" in
+  -*=*) optarg=`echo "$1" | LC_ALL="C" sed 's/[-_a-zA-Z0-9]*=//'` ;;
+  *) optarg= ;;
+  esac
+
+  case $1 in
+    --prefix=*)
+      prefix=$optarg
+      if test $exec_prefix_set = no ; then
+        exec_prefix=$optarg
+      fi
+      ;;
+    --prefix)
+      echo $prefix
+      ;;
+    --exec-prefix=*)
+      exec_prefix=$optarg
+      exec_prefix_set=yes
+      ;;
+    --exec-prefix)
+      echo $exec_prefix
+      ;;
+    --version)
+      echo 1.2.15
+      ;;
+    --cflags)
+      echo -I${prefix}/include/SDL -D_GNU_SOURCE=1
+      ;;
+    --libs)
+      echo -L${exec_prefix}/lib  -lSDL 
+      ;;
+    --static-libs)
+      echo -L${exec_prefix}/lib  -lSDL_static -lm -lGL
+      ;;
+    *)
+      echo "${usage}" 1>&2
+      exit 1
+      ;;
+  esac
+  shift
+done
diff -Naur SDL-1.2.15-orig/aros/sdl.pc SDL-1.2.15/aros/sdl.pc
--- SDL-1.2.15-orig/aros/sdl.pc	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.15/aros/sdl.pc	2015-05-09 15:09:59.750739542 +0200
@@ -0,0 +1,15 @@
+# sdl pkg-config source file
+
+prefix=/PROGDIR
+exec_prefix=${prefix}
+libdir=${exec_prefix}/lib
+includedir=${prefix}/include
+
+Name: sdl
+Description: Simple DirectMedia Layer is a cross-platform multimedia library designed to provide low level access to audio, keyboard, mouse, joystick, 3D hardware via OpenGL, and 2D video framebuffer.
+Version: 1.2.15
+Requires:
+Conflicts:
+Libs: -L${libdir}  -lSDL 
+Libs.private: -lSDL   -lm -lGL
+Cflags: -I${includedir}/SDL -D_GNU_SOURCE=1
diff -Naur SDL-1.2.15-orig/aros_init.c SDL-1.2.15/aros_init.c
--- SDL-1.2.15-orig/aros_init.c	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.15/aros_init.c	2015-05-09 15:09:59.750739542 +0200
@@ -0,0 +1,148 @@
+/* Copyright 2013 The AROS Development Team. All rights reserved. */
+
+#include <aros/debug.h>
+
+
+#include <proto/stdc.h>
+
+#include <aros/symbolsets.h>
+#include LC_LIBDEFS_FILE
+
+#include "SDL_intern.h"
+#include "video/SDL_sysvideo.h"
+#include "video/cgx/SDL_cgxgl_c.h"
+
+static int GM_UNIQUENAME(LibInit)(LIBBASETYPEPTR LIBBASE)
+{
+    D(bug("SDL.library->Init(%p)\n", LIBBASE));
+
+    return TRUE;
+}
+
+static int GM_UNIQUENAME(LibOpen)(LIBBASETYPEPTR LIBBASE)
+{
+    D(bug("SDL.library->Open(%p)\n", LIBBASE));
+
+    LIBBASE->copy_row_base = AllocMem(4096 * 2, MEMF_CLEAR);
+    LIBBASE->copy_row = (APTR)(((IPTR)LIBBASE->copy_row_base + 4096) & ~0xFFF);
+    D(bug("SDL.library->Open: root base @ 0x%p\n", LIBBASE->rootSDLBase));
+    D(
+        struct Task *opener = FindTask(NULL);
+        bug("SDL.library->Open: StdCBase @ 0x%p for task @ 0x%p ('%s')\n", __aros_getbase_StdCBase(), opener, ((struct Node *)opener)->ln_Name);
+      )
+    D(bug("SDL.library->Open: copy_row @ 0x%p\n", LIBBASE->copy_row));
+
+    LIBBASE->SDL_initialized = 0;
+#if !SDL_TIMERS_DISABLED
+    LIBBASE->ticks_started = 0;
+#endif
+#ifdef CHECK_LEAKS
+    LIBBASE->surfaces_allocated = 0;
+#endif
+
+    LIBBASE->SDL_timer_started = 0;
+    LIBBASE->SDL_timer_running = 0;
+    LIBBASE->timer_alive = 0;
+    LIBBASE->timer_thread = NULL;
+
+    LIBBASE->SDL_alarm_interval = 0;
+    LIBBASE->SDL_alarm_callback = NULL;
+
+    LIBBASE->SDL_timer_threaded = 0;
+
+    LIBBASE->SDL_timers = NULL;
+    LIBBASE->SDL_timer_mutex = NULL;
+    LIBBASE->list_changed = SDL_FALSE;
+
+    LIBBASE->SDL_maxthreads = 0;
+    LIBBASE->SDL_numthreads = 0;
+    LIBBASE->SDL_Threads = NULL;
+    LIBBASE->SDL_ThreadLock = NULL;
+    LIBBASE->SDL_ThreadLockCreated = 0;
+    memset(&LIBBASE->SDL_global_error, 0, sizeof(LIBBASE->SDL_global_error));
+
+    LIBBASE->SDL_appstate = 0;
+
+    LIBBASE->SDL_EventOK = NULL;
+    LIBBASE->SDL_eventstate = 0;
+    LIBBASE->SDL_EventThread = NULL;
+
+    LIBBASE->SDL_MouseX = 0;
+    LIBBASE->SDL_MouseY = 0;
+    LIBBASE->SDL_DeltaX = 0;
+    LIBBASE->SDL_DeltaY = 0;
+    LIBBASE->SDL_MouseMaxX = 0;
+    LIBBASE->SDL_MouseMaxY = 0;
+    LIBBASE->SDL_ButtonState = 0;
+
+    LIBBASE->SDL_TranslateUNICODE = 0;
+
+    LIBBASE->SDL_cursorstate = CURSOR_VISIBLE;
+    LIBBASE->SDL_cursor = NULL;
+    LIBBASE->SDL_defcursor = NULL;
+    LIBBASE->SDL_cursorlock = NULL;
+    LIBBASE->palette_changed = 1;
+
+    LIBBASE->GLBase = NULL;
+
+    LIBBASE->SDL_cdinitted = 0;
+
+    LIBBASE->_lib.lib_OpenCnt++;
+
+    return TRUE;
+}
+
+static int GM_UNIQUENAME(LibClose)(LIBBASETYPEPTR LIBBASE)
+{
+   D(bug("SDL.library->Close(%p)\n", LIBBASE));
+
+    if (LIBBASE->_lib.lib_OpenCnt-- > 0)
+    {
+       D(bug("SDL.library->Close: %u threads still runing\n", LIBBASE->_lib.lib_OpenCnt));
+        LIBBASE->_lib.lib_Flags |= LIBF_DELEXP;
+    }
+    else
+    {
+        if (LIBBASE->current_video && LIBBASE->current_video->gl_config.driver_loaded)
+        {
+            if (LIBBASE->GLBase != NULL)
+            {
+                CGX_GL_DestroyContext(LIBBASE->current_video);
+                CloseLibrary(LIBBASE->GLBase);
+            }
+        }
+
+        if (LIBBASE->GLBase != NULL)
+            LIBBASE->GLBase = NULL;
+    }
+   return TRUE;
+}
+
+ADD2INITLIB(GM_UNIQUENAME(LibInit), 0)
+ADD2OPENLIB(GM_UNIQUENAME(LibOpen), 0)
+ADD2CLOSELIB(GM_UNIQUENAME(LibClose), 0)
+
+#include <errno.h>
+#include <signal.h>
+
+/* TODO: Should we emulate sigaction() ? */
+int sigaction (int signum, const  struct  sigaction  *act, struct sigaction *oldact)
+{
+    errno=ENOSYS; return -1;
+}
+
+/* Bind StdCBase to PosicCBase */
+#include <aros/symbolsets.h>
+#include <proto/stdc.h>
+#include <libraries/posixc.h>
+
+static int __posixc_startup(void)
+{
+    struct PosixCBase *PosixCBase = __aros_getbase_PosixCBase();
+
+    PosixCBase->StdCBase = __aros_getbase_StdCBase();
+
+    return PosixCBase->StdCBase != NULL;
+}
+
+ADD2OPENLIB(__posixc_startup, -50);
diff -Naur SDL-1.2.15-orig/include/SDL_active.h SDL-1.2.15/include/SDL_active.h
--- SDL-1.2.15-orig/include/SDL_active.h	2015-05-09 17:47:54.271774326 +0200
+++ SDL-1.2.15/include/SDL_active.h	2015-05-09 15:09:59.750739542 +0200
@@ -51,8 +51,9 @@
  * SDL_APPACTIVE.  If SDL_APPACTIVE is set, then the user is able to
  * see your application, otherwise it has been iconified or disabled.
  */
+#if !defined(PROTO_SDL_H)
 extern DECLSPEC Uint8 SDLCALL SDL_GetAppState(void);
-
+#endif /* !PROTO_SDL_H */
 
 /* Ends C function definitions when using C++ */
 #ifdef __cplusplus
diff -Naur SDL-1.2.15-orig/include/SDL_audio.h SDL-1.2.15/include/SDL_audio.h
--- SDL-1.2.15-orig/include/SDL_audio.h	2015-05-09 17:47:54.271774326 +0200
+++ SDL-1.2.15/include/SDL_audio.h	2015-05-09 15:09:59.750739542 +0200
@@ -88,7 +88,11 @@
 	 *  Once the callback returns, the buffer will no longer be valid.
 	 *  Stereo samples are stored in a LRLRLR ordering.
 	 */
+#if !defined(PROTO_SDL_H)
 	void (SDLCALL *callback)(void *userdata, Uint8 *stream, int len);
+#else
+	void (SDLCALL *callback)(void *userdata, Uint8 *stream, int len, struct Library *SDLBase);
+#endif
 	void  *userdata;
 } SDL_AudioSpec;
 
@@ -133,7 +137,11 @@
 	int    len_cvt;			/**< Length of converted audio buffer */
 	int    len_mult;		/**< buffer must be len*len_mult big */
 	double len_ratio; 	/**< Given len, final size is len*len_ratio */
+#if !defined(PROTO_SDL_H)
 	void (SDLCALL *filters[10])(struct SDL_AudioCVT *cvt, Uint16 format);
+#else
+	void (SDLCALL *filters[10])(struct SDL_AudioCVT *cvt, Uint16 format, struct Library *SDLBase);
+#endif
 	int filter_index;		/**< Current audio conversion function */
 } SDL_AudioCVT;
 
@@ -147,6 +155,7 @@
  * You should normally use SDL_Init() or SDL_InitSubSystem().
  */
 /*@{*/
+#if !defined(PROTO_SDL_H)
 extern DECLSPEC int SDLCALL SDL_AudioInit(const char *driver_name);
 extern DECLSPEC void SDLCALL SDL_AudioQuit(void);
 /*@}*/
@@ -176,6 +185,7 @@
  * @sa SDL_AudioSpec
  */
 extern DECLSPEC int SDLCALL SDL_OpenAudio(SDL_AudioSpec *desired, SDL_AudioSpec *obtained);
+#endif /* !PROTO_SDL_H */
 
 typedef enum {
 	SDL_AUDIO_STOPPED = 0,
@@ -184,6 +194,7 @@
 } SDL_audiostatus;
 
 /** Get the current audio state */
+#if !defined(PROTO_SDL_H)
 extern DECLSPEC SDL_audiostatus SDLCALL SDL_GetAudioStatus(void);
 
 /**
@@ -213,6 +224,7 @@
  * corrupt.  Currently raw and MS-ADPCM WAVE files are supported.
  */
 extern DECLSPEC SDL_AudioSpec * SDLCALL SDL_LoadWAV_RW(SDL_RWops *src, int freesrc, SDL_AudioSpec *spec, Uint8 **audio_buf, Uint32 *audio_len);
+#endif /* !PROTO_SDL_H */
 
 /** Compatibility convenience function -- loads a WAV from a file */
 #define SDL_LoadWAV(file, spec, audio_buf, audio_len) \
@@ -221,6 +233,7 @@
 /**
  * This function frees data previously allocated with SDL_LoadWAV_RW()
  */
+#if !defined(PROTO_SDL_H)
 extern DECLSPEC void SDLCALL SDL_FreeWAV(Uint8 *audio_buf);
 
 /**
@@ -245,7 +258,7 @@
  * SDL_BuildAudioCVT(), and should be cvt->len*cvt->len_mult bytes long.
  */
 extern DECLSPEC int SDLCALL SDL_ConvertAudio(SDL_AudioCVT *cvt);
-
+#endif /* !PROTO_SDL_H */
 
 #define SDL_MIX_MAXVOLUME 128
 /**
@@ -255,6 +268,7 @@
  * for full audio volume.  Note this does not change hardware volume.
  * This is provided for convenience -- you can mix your own audio data.
  */
+#if !defined(PROTO_SDL_H)
 extern DECLSPEC void SDLCALL SDL_MixAudio(Uint8 *dst, const Uint8 *src, Uint32 len, int volume);
 
 /**
@@ -273,7 +287,7 @@
  * This function shuts down audio processing and closes the audio device.
  */
 extern DECLSPEC void SDLCALL SDL_CloseAudio(void);
-
+#endif /* !PROTO_SDL_H */
 
 /* Ends C function definitions when using C++ */
 #ifdef __cplusplus
diff -Naur SDL-1.2.15-orig/include/SDL_cdrom.h SDL-1.2.15/include/SDL_cdrom.h
--- SDL-1.2.15-orig/include/SDL_cdrom.h	2015-05-09 17:47:54.271774326 +0200
+++ SDL-1.2.15/include/SDL_cdrom.h	2015-05-09 15:09:59.750739542 +0200
@@ -111,6 +111,7 @@
  *  Returns the number of CD-ROM drives on the system, or -1 if
  *  SDL_Init() has not been called with the SDL_INIT_CDROM flag.
  */
+#if !defined(PROTO_SDL_H)
 extern DECLSPEC int SDLCALL SDL_CDNumDrives(void);
 
 /**
@@ -191,7 +192,7 @@
 
 /** Closes the handle for the CD-ROM drive */
 extern DECLSPEC void SDLCALL SDL_CDClose(SDL_CD *cdrom);
-
+#endif /* !PROTO_SDL_H */
 
 /* Ends C function definitions when using C++ */
 #ifdef __cplusplus
diff -Naur SDL-1.2.15-orig/include/SDL_config_aros.h SDL-1.2.15/include/SDL_config_aros.h
--- SDL-1.2.15-orig/include/SDL_config_aros.h	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.15/include/SDL_config_aros.h	2015-05-09 15:09:59.750739542 +0200
@@ -0,0 +1,152 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2012 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+
+#ifndef _SDL_config_aros_h
+#define _SDL_config_aros_h
+
+#include "SDL_platform.h"
+
+/* This is the minimal configuration that can be used to build SDL */
+#include <aros/cpu.h>
+#include <dos/dos.h>
+
+#define SDL_HAS_64BIT_TYPE 1
+
+/* Endianness */
+#if AROS_BIG_ENDIAN
+#define SDL_BYTEORDER 4321
+#else
+#define SDL_BYTEORDER 1234
+#endif
+
+
+/* Comment this if you want to build without any C library requirements */
+#define HAVE_LIBC 1
+#if HAVE_LIBC
+
+/* Useful headers */
+#define HAVE_ALLOCA_H 1
+#define HAVE_SYS_TYPES_H 1
+#define HAVE_STDIO_H 1
+#define STDC_HEADERS 1
+#ifndef HAVE_STDLIB_H
+#define HAVE_STDLIB_H 1
+#endif
+#define HAVE_STDARG_H 1
+
+#define HAVE_MEMORY_H 1
+#define HAVE_STRING_H 1
+#define HAVE_STRINGS_H 1
+#define HAVE_INTTYPES_H 1
+#define HAVE_STDINT_H 1
+#define HAVE_CTYPE_H 1
+#define HAVE_MATH_H 1
+#define HAVE_ICONV_H 1
+#define HAVE_SIGNAL_H 1
+
+/* C library functions */
+#define HAVE_MALLOC 1
+#define HAVE_CALLOC 1
+#define HAVE_REALLOC 1
+#define HAVE_FREE 1
+#define HAVE_ALLOCA 1
+
+#define HAVE_GETENV 1
+#define HAVE_PUTENV 1
+#define HAVE_UNSETENV 1
+
+#define HAVE_QSORT 1
+#define HAVE_ABS 1
+#define HAVE_BCOPY 1
+#define HAVE_MEMSET 1
+#define HAVE_MEMCPY 1
+#define HAVE_MEMMOVE 1
+#define HAVE_MEMCMP 1
+#define HAVE_STRLEN 1
+#define HAVE_STRLCPY 1
+#define HAVE_STRLCAT 1
+#define HAVE_STRDUP 1
+#define HAVE_STRCHR 1
+#define HAVE_STRRCHR 1
+#define HAVE_STRSTR 1
+#define HAVE_STRTOL 1
+#define HAVE_STRTOUL 1
+#define HAVE_STRTOLL 1
+#define HAVE_STRTOULL 1
+#define HAVE_STRTOD 1
+#define HAVE_ATOI 1
+#define HAVE_ATOF 1
+#define HAVE_STRCMP 1
+#define HAVE_STRNCMP 1
+#define HAVE_STRCASECMP 1
+#define HAVE_STRNCASECMP 1
+#define HAVE_SSCANF 1
+#define HAVE_SNPRINTF 1
+#define HAVE_VSNPRINTF 1
+#define HAVE_ICONV 1
+#define HAVE_SIGACTION 1
+#define HAVE_SETJMP 1
+#define HAVE_OPENGL 1
+
+#else
+/* We may need some replacement for stdarg.h here */
+#include <stdarg.h>
+#endif /* HAVE_LIBC */
+
+/* Allow disabling of core subsystems */
+#define SDL_LOADSO_DISABLED 1
+
+/* Enable various audio drivers */
+#define SDL_AUDIO_DRIVER_DISK 1
+#define SDL_AUDIO_DRIVER_DUMMY 1
+#define SDL_AUDIO_DRIVER_AHI 1
+
+/* Enable various cdrom drivers */
+#define SDL_CDROM_AROS 1
+
+/* Enable various input drivers */
+#define SDL_JOYSTICK_AROS 1
+
+/* Enable various shared object loading systems */
+
+/* Enable various threading systems */
+#define SDL_THREAD_AROS 1
+
+/* Enable various timer systems */
+#define SDL_TIMER_AROS 1
+
+/* Enable various video drivers */
+#define SDL_VIDEO_DRIVER_DUMMY 1
+#define SDL_VIDEO_DRIVER_CGX 1
+
+/* Enable OpenGL support */
+#define SDL_VIDEO_OPENGL 1
+
+/* Disable screensaver */
+#define SDL_VIDEO_DISABLE_SCREENSAVER 1
+
+/* Enable assembly routines */
+#define SDL_ASSEMBLY_ROUTINES 1
+
+//#define AMIGADEBUG 1
+
+#endif /* _SDL_config_aros_h */
diff -Naur SDL-1.2.15-orig/include/SDL_config.h SDL-1.2.15/include/SDL_config.h
--- SDL-1.2.15-orig/include/SDL_config.h	2015-05-09 17:47:54.271774326 +0200
+++ SDL-1.2.15/include/SDL_config.h	2015-05-09 15:09:59.750739542 +0200
@@ -26,7 +26,9 @@
 #include "SDL_platform.h"
 
 /* Add any platform that doesn't build using the configure system */
-#if defined(__DREAMCAST__)
+#if defined(__AROS__)
+#include "SDL_config_aros.h"
+#elif defined(__DREAMCAST__)
 #include "SDL_config_dreamcast.h"
 #elif defined(__MACOS__)
 #include "SDL_config_macos.h"
diff -Naur SDL-1.2.15-orig/include/SDL_cpuinfo.h SDL-1.2.15/include/SDL_cpuinfo.h
--- SDL-1.2.15-orig/include/SDL_cpuinfo.h	2015-05-09 17:47:54.271774326 +0200
+++ SDL-1.2.15/include/SDL_cpuinfo.h	2015-05-09 15:09:59.750739542 +0200
@@ -36,6 +36,7 @@
 extern "C" {
 #endif
 
+#if !defined(PROTO_SDL_H)
 /** This function returns true if the CPU has the RDTSC instruction */
 extern DECLSPEC SDL_bool SDLCALL SDL_HasRDTSC(void);
 
@@ -59,6 +60,7 @@
 
 /** This function returns true if the CPU has AltiVec features */
 extern DECLSPEC SDL_bool SDLCALL SDL_HasAltiVec(void);
+#endif /* !PROTO_SDL_H */
 
 /* Ends C function definitions when using C++ */
 #ifdef __cplusplus
diff -Naur SDL-1.2.15-orig/include/SDL_error.h SDL-1.2.15/include/SDL_error.h
--- SDL-1.2.15-orig/include/SDL_error.h	2015-05-09 17:47:54.271774326 +0200
+++ SDL-1.2.15/include/SDL_error.h	2015-05-09 15:09:59.750739542 +0200
@@ -40,9 +40,23 @@
  *  @name Public functions
  */
 /*@{*/
+#if !defined(PROTO_SDL_H)
+#if defined(__AROS__)
+#include <aros/preprocessor/variadic/cast2iptr.hpp>
+
+extern DECLSPEC void SDLCALL SDL_SetErrorA(const char *fmt, CONST IPTR *params);
+
+#define SDL_SetError(arg1, ...) \
+({ \
+    IPTR __args[] = { AROS_PP_VARIADIC_CAST2IPTR(__VA_ARGS__) }; \
+    SDL_SetErrorA((arg1), __args); \
+})
+#else
 extern DECLSPEC void SDLCALL SDL_SetError(const char *fmt, ...);
+#endif
 extern DECLSPEC char * SDLCALL SDL_GetError(void);
 extern DECLSPEC void SDLCALL SDL_ClearError(void);
+#endif /* !PROTO_SDL_H */
 /*@}*/
 
 /**
@@ -52,6 +66,7 @@
 /*@{*/
 #define SDL_OutOfMemory()	SDL_Error(SDL_ENOMEM)
 #define SDL_Unsupported()	SDL_Error(SDL_UNSUPPORTED)
+
 typedef enum {
 	SDL_ENOMEM,
 	SDL_EFREAD,
@@ -60,7 +75,10 @@
 	SDL_UNSUPPORTED,
 	SDL_LASTERROR
 } SDL_errorcode;
+
+#if !defined(PROTO_SDL_H)
 extern DECLSPEC void SDLCALL SDL_Error(SDL_errorcode code);
+#endif /* !PROTO_SDL_H */
 /*@}*/
 
 /* Ends C function definitions when using C++ */
diff -Naur SDL-1.2.15-orig/include/SDL_events.h SDL-1.2.15/include/SDL_events.h
--- SDL-1.2.15-orig/include/SDL_events.h	2015-05-09 17:47:54.271774326 +0200
+++ SDL-1.2.15/include/SDL_events.h	2015-05-09 15:09:59.750739542 +0200
@@ -248,7 +248,9 @@
  *  This function updates the event queue and internal input device state.
  *  This should only be run in the thread that sets the video mode.
  */
+#if !defined(PROTO_SDL_H)
 extern DECLSPEC void SDLCALL SDL_PumpEvents(void);
+#endif /* !PROTO_SDL_H */
 
 typedef enum {
 	SDL_ADDEVENT,
@@ -274,6 +276,7 @@
  *
  *  This function is thread-safe.
  */
+#if !defined(PROTO_SDL_H)
 extern DECLSPEC int SDLCALL SDL_PeepEvents(SDL_Event *events, int numevents,
 				SDL_eventaction action, Uint32 mask);
 
@@ -294,7 +297,7 @@
  *  or there was some other error.
  */
 extern DECLSPEC int SDLCALL SDL_PushEvent(SDL_Event *event);
-
+#endif /* !PROTO_SDL_H */
 /** @name Event Filtering */
 /*@{*/
 typedef int (SDLCALL *SDL_EventFilter)(const SDL_Event *event);
@@ -320,6 +323,7 @@
  * If the quit event is generated by an interrupt signal, it will bypass the
  * internal queue and be delivered to the application at the next event poll.
  */
+#if !defined(PROTO_SDL_H)
 extern DECLSPEC void SDLCALL SDL_SetEventFilter(SDL_EventFilter filter);
 
 /**
@@ -327,6 +331,7 @@
  *  If there is no event filter set, this function returns NULL.
  */
 extern DECLSPEC SDL_EventFilter SDLCALL SDL_GetEventFilter(void);
+#endif /* !PROTO_SDL_H */
 /*@}*/
 
 /** @name Event State */
@@ -345,7 +350,9 @@
 * If 'state' is set to SDL_QUERY, SDL_EventState() will return the 
 * current processing state of the specified event.
 */
+#if !defined(PROTO_SDL_H)
 extern DECLSPEC Uint8 SDLCALL SDL_EventState(Uint8 type, int state);
+#endif /* !PROTO_SDL_H */
 
 /* Ends C function definitions when using C++ */
 #ifdef __cplusplus
diff -Naur SDL-1.2.15-orig/include/SDL_joystick.h SDL-1.2.15/include/SDL_joystick.h
--- SDL-1.2.15-orig/include/SDL_joystick.h	2015-05-09 17:47:54.271774326 +0200
+++ SDL-1.2.15/include/SDL_joystick.h	2015-05-09 15:09:59.751739540 +0200
@@ -50,6 +50,7 @@
 /**
  * Count the number of joysticks attached to the system
  */
+#if !defined(PROTO_SDL_H)
 extern DECLSPEC int SDLCALL SDL_NumJoysticks(void);
 
 /**
@@ -132,7 +133,7 @@
  * @return The state is a value ranging from -32768 to 32767.
  */
 extern DECLSPEC Sint16 SDLCALL SDL_JoystickGetAxis(SDL_Joystick *joystick, int axis);
-
+#endif /* !PROTO_SDL_H */
 /**
  *  @name Hat Positions
  *  The return value of SDL_JoystickGetHat() is one of the following positions:
@@ -154,6 +155,7 @@
  *
  *  @param[in] hat The hat indices start at index 0.
  */
+#if !defined(PROTO_SDL_H)
 extern DECLSPEC Uint8 SDLCALL SDL_JoystickGetHat(SDL_Joystick *joystick, int hat);
 
 /**
@@ -176,7 +178,7 @@
  * Close a joystick previously opened with SDL_JoystickOpen()
  */
 extern DECLSPEC void SDLCALL SDL_JoystickClose(SDL_Joystick *joystick);
-
+#endif /* !PROTO_SDL_H */
 
 /* Ends C function definitions when using C++ */
 #ifdef __cplusplus
diff -Naur SDL-1.2.15-orig/include/SDL_keyboard.h SDL-1.2.15/include/SDL_keyboard.h
--- SDL-1.2.15-orig/include/SDL_keyboard.h	2015-05-09 17:47:54.271774326 +0200
+++ SDL-1.2.15/include/SDL_keyboard.h	2015-05-09 15:09:59.751739540 +0200
@@ -79,7 +79,9 @@
  *
  * @return It returns the previous state of keyboard translation.
  */
+#if !defined(PROTO_SDL_H)
 extern DECLSPEC int SDLCALL SDL_EnableUNICODE(int enable);
+#endif /* !PROTO_SDL_H */
 
 #define SDL_DEFAULT_REPEAT_DELAY	500
 #define SDL_DEFAULT_REPEAT_INTERVAL	30
@@ -95,6 +97,7 @@
  *
  *  If 'delay' is set to 0, keyboard repeat is disabled.
  */
+ #if !defined(PROTO_SDL_H)
 extern DECLSPEC int SDLCALL SDL_EnableKeyRepeat(int delay, int interval);
 extern DECLSPEC void SDLCALL SDL_GetKeyRepeat(int *delay, int *interval);
 
@@ -124,7 +127,7 @@
  * Get the name of an SDL virtual keysym
  */
 extern DECLSPEC char * SDLCALL SDL_GetKeyName(SDLKey key);
-
+#endif /* !PROTO_SDL_H */
 
 /* Ends C function definitions when using C++ */
 #ifdef __cplusplus
diff -Naur SDL-1.2.15-orig/include/SDL_loadso.h SDL-1.2.15/include/SDL_loadso.h
--- SDL-1.2.15-orig/include/SDL_loadso.h	2015-05-09 17:47:54.271774326 +0200
+++ SDL-1.2.15/include/SDL_loadso.h	2015-05-09 15:09:59.751739540 +0200
@@ -57,6 +57,7 @@
  * to the object handle (or NULL if there was an error).
  * The 'sofile' parameter is a system dependent name of the object file.
  */
+ #if !defined(PROTO_SDL_H)
 extern DECLSPEC void * SDLCALL SDL_LoadObject(const char *sofile);
 
 /**
@@ -68,6 +69,7 @@
 
 /** Unload a shared object from memory */
 extern DECLSPEC void SDLCALL SDL_UnloadObject(void *handle);
+#endif /* !PROTO_SDL_H */
 
 /* Ends C function definitions when using C++ */
 #ifdef __cplusplus
diff -Naur SDL-1.2.15-orig/include/SDL_main.h SDL-1.2.15/include/SDL_main.h
--- SDL-1.2.15-orig/include/SDL_main.h	2015-05-09 17:47:54.271774326 +0200
+++ SDL-1.2.15/include/SDL_main.h	2015-05-09 15:09:59.751739540 +0200
@@ -66,12 +66,14 @@
 extern "C" {
 #endif
 
+#if !defined(PROTO_SDL_H)
 /** This should be called from your WinMain() function, if any */
 extern DECLSPEC void SDLCALL SDL_SetModuleHandle(void *hInst);
 /** This can also be called, but is no longer necessary */
 extern DECLSPEC int SDLCALL SDL_RegisterApp(char *name, Uint32 style, void *hInst);
 /** This can also be called, but is no longer necessary (SDL_Quit calls it) */
 extern DECLSPEC void SDLCALL SDL_UnregisterApp(void);
+#endif /* !PROTO_SDL_H */
 #ifdef __cplusplus
 }
 #endif
@@ -88,11 +90,13 @@
 extern "C" {
 #endif
 
+#if !defined(PROTO_SDL_H)
 /** Forward declaration so we don't need to include QuickDraw.h */
 struct QDGlobals;
 
 /** This should be called from your main() function, if any */
 extern DECLSPEC void SDLCALL SDL_InitQuickDraw(struct QDGlobals *the_qd);
+#endif /* !PROTO_SDL_H */
 
 #ifdef __cplusplus
 }
diff -Naur SDL-1.2.15-orig/include/SDL_mouse.h SDL-1.2.15/include/SDL_mouse.h
--- SDL-1.2.15-orig/include/SDL_mouse.h	2015-05-09 17:47:54.271774326 +0200
+++ SDL-1.2.15/include/SDL_mouse.h	2015-05-09 15:09:59.751739540 +0200
@@ -54,6 +54,7 @@
  * be tested using the SDL_BUTTON(X) macros, and x and y are set to the
  * current mouse cursor position.  You can pass NULL for either x or y.
  */
+#if !defined(PROTO_SDL_H)
 extern DECLSPEC Uint8 SDLCALL SDL_GetMouseState(int *x, int *y);
 
 /**
@@ -110,6 +111,7 @@
  * state by passing a 'toggle' value of -1.
  */
 extern DECLSPEC int SDLCALL SDL_ShowCursor(int toggle);
+#endif /* !PROTO_SDL_H */
 
 /*@{*/
 /** Used as a mask when testing buttons in buttonstate
diff -Naur SDL-1.2.15-orig/include/SDL_mutex.h SDL-1.2.15/include/SDL_mutex.h
--- SDL-1.2.15-orig/include/SDL_mutex.h	2015-05-09 17:47:54.271774326 +0200
+++ SDL-1.2.15/include/SDL_mutex.h	2015-05-09 15:09:59.751739540 +0200
@@ -56,13 +56,17 @@
 typedef struct SDL_mutex SDL_mutex;
 
 /** Create a mutex, initialized unlocked */
+#if !defined(PROTO_SDL_H)
 extern DECLSPEC SDL_mutex * SDLCALL SDL_CreateMutex(void);
+#endif /* !PROTO_SDL_H */
 
 #define SDL_LockMutex(m)	SDL_mutexP(m)
 /** Lock the mutex
  *  @return 0, or -1 on error
  */
+#if !defined(PROTO_SDL_H)
 extern DECLSPEC int SDLCALL SDL_mutexP(SDL_mutex *mutex);
+#endif /* !PROTO_SDL_H */
 
 #define SDL_UnlockMutex(m)	SDL_mutexV(m)
 /** Unlock the mutex
@@ -71,21 +75,22 @@
  *  It is an error to unlock a mutex that has not been locked by
  *  the current thread, and doing so results in undefined behavior.
  */
+#if !defined(PROTO_SDL_H)
 extern DECLSPEC int SDLCALL SDL_mutexV(SDL_mutex *mutex);
 
 /** Destroy a mutex */
 extern DECLSPEC void SDLCALL SDL_DestroyMutex(SDL_mutex *mutex);
+#endif /* !PROTO_SDL_H */
 
 /*@}*/
 
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
 /** @name Semaphore functions                                    */ /*@{*/
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
-
 /** The SDL semaphore structure, defined in SDL_sem.c */
 struct SDL_semaphore;
 typedef struct SDL_semaphore SDL_sem;
-
+#if !defined(PROTO_SDL_H)
 /** Create a semaphore, initialized with value, returns NULL on failure. */
 extern DECLSPEC SDL_sem * SDLCALL SDL_CreateSemaphore(Uint32 initial_value);
 
@@ -121,7 +126,7 @@
 
 /** Returns the current count of the semaphore */
 extern DECLSPEC Uint32 SDLCALL SDL_SemValue(SDL_sem *sem);
-
+#endif /* !PROTO_SDL_H */
 /*@}*/
 
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
@@ -134,6 +139,7 @@
 typedef struct SDL_cond SDL_cond;
 /*@}*/
 
+#if !defined(PROTO_SDL_H)
 /** Create a condition variable */
 extern DECLSPEC SDL_cond * SDLCALL SDL_CreateCond(void);
 
@@ -164,7 +170,7 @@
  *  of 1 ms, and so should be avoided if possible.
  */
 extern DECLSPEC int SDLCALL SDL_CondWaitTimeout(SDL_cond *cond, SDL_mutex *mutex, Uint32 ms);
-
+#endif /* !PROTO_SDL_H */
 /*@}*/
 
 /* Ends C function definitions when using C++ */
diff -Naur SDL-1.2.15-orig/include/SDL_rwops.h SDL-1.2.15/include/SDL_rwops.h
--- SDL-1.2.15-orig/include/SDL_rwops.h	2015-05-09 17:47:54.271774326 +0200
+++ SDL-1.2.15/include/SDL_rwops.h	2015-05-09 15:09:59.751739540 +0200
@@ -60,7 +60,6 @@
 
 	/** Close and free an allocated SDL_FSops structure */
 	int (SDLCALL *close)(struct SDL_RWops *context);
-
 	Uint32 type;
 	union {
 #if defined(__WIN32__) && !defined(__SYMBIAN32__)
@@ -89,13 +88,16 @@
 		void *data1;
 	    } unknown;
 	} hidden;
-
+#if defined(__AROS__)
+        struct Library *SDLLib;
+#endif
 } SDL_RWops;
 
 
 /** @name Functions to create SDL_RWops structures from various data sources */
 /*@{*/
 
+#if !defined(PROTO_SDL_H)
 extern DECLSPEC SDL_RWops * SDLCALL SDL_RWFromFile(const char *file, const char *mode);
 
 #ifdef HAVE_STDIO_H
@@ -107,7 +109,7 @@
 
 extern DECLSPEC SDL_RWops * SDLCALL SDL_AllocRW(void);
 extern DECLSPEC void SDLCALL SDL_FreeRW(SDL_RWops *area);
-
+#endif /* !PROTO_SDL_H */
 /*@}*/
 
 /** @name Seek Reference Points */
@@ -124,10 +126,12 @@
 #define SDL_RWread(ctx, ptr, size, n)	(ctx)->read(ctx, ptr, size, n)
 #define SDL_RWwrite(ctx, ptr, size, n)	(ctx)->write(ctx, ptr, size, n)
 #define SDL_RWclose(ctx)		(ctx)->close(ctx)
+
 /*@}*/
 
 /** @name Read an item of the specified endianness and return in native format */
 /*@{*/
+#if !defined(PROTO_SDL_H)
 extern DECLSPEC Uint16 SDLCALL SDL_ReadLE16(SDL_RWops *src);
 extern DECLSPEC Uint16 SDLCALL SDL_ReadBE16(SDL_RWops *src);
 extern DECLSPEC Uint32 SDLCALL SDL_ReadLE32(SDL_RWops *src);
@@ -144,6 +148,7 @@
 extern DECLSPEC int SDLCALL SDL_WriteBE32(SDL_RWops *dst, Uint32 value);
 extern DECLSPEC int SDLCALL SDL_WriteLE64(SDL_RWops *dst, Uint64 value);
 extern DECLSPEC int SDLCALL SDL_WriteBE64(SDL_RWops *dst, Uint64 value);
+#endif /* !PROTO_SDL_H */
 /*@}*/
 
 /* Ends C function definitions when using C++ */
diff -Naur SDL-1.2.15-orig/include/SDL_syswm.h SDL-1.2.15/include/SDL_syswm.h
--- SDL-1.2.15-orig/include/SDL_syswm.h	2015-05-09 17:47:54.271774326 +0200
+++ SDL-1.2.15/include/SDL_syswm.h	2015-05-09 15:09:59.751739540 +0200
@@ -214,8 +214,9 @@
  * if ( SDL_GetWMInfo(&info) ) { ... }
  * @endcode
  */
+#if !defined(PROTO_SDL_H)
 extern DECLSPEC int SDLCALL SDL_GetWMInfo(SDL_SysWMinfo *info);
-
+#endif /* !PROTO_SDL_H */
 
 /* Ends C function definitions when using C++ */
 #ifdef __cplusplus
diff -Naur SDL-1.2.15-orig/include/SDL_thread.h SDL-1.2.15/include/SDL_thread.h
--- SDL-1.2.15-orig/include/SDL_thread.h	2015-05-09 17:47:54.271774326 +0200
+++ SDL-1.2.15/include/SDL_thread.h	2015-05-09 15:09:59.752739538 +0200
@@ -75,7 +75,9 @@
 typedef void (__cdecl *pfnSDL_CurrentEndThread)(unsigned code);
 #endif
 
+#if !defined(PROTO_SDL_H)
 extern DECLSPEC SDL_Thread * SDLCALL SDL_CreateThread(int (SDLCALL *fn)(void *), void *data, pfnSDL_CurrentBeginThread pfnBeginThread, pfnSDL_CurrentEndThread pfnEndThread);
+#endif /* !PROTO_SDL_H */
 
 #ifdef __OS2__
 #define SDL_CreateThread(fn, data) SDL_CreateThread(fn, data, _beginthread, _endthread)
@@ -85,10 +87,13 @@
 #define SDL_CreateThread(fn, data) SDL_CreateThread(fn, data, _beginthreadex, _endthreadex)
 #endif
 #else
+#if !defined(PROTO_SDL_H)
 extern DECLSPEC SDL_Thread * SDLCALL SDL_CreateThread(int (SDLCALL *fn)(void *), void *data);
+#endif /* !PROTO_SDL_H */
 #endif
 
 /** Get the 32-bit thread identifier for the current thread */
+#if !defined(PROTO_SDL_H)
 extern DECLSPEC Uint32 SDLCALL SDL_ThreadID(void);
 
 /** Get the 32-bit thread identifier for the specified thread,
@@ -104,7 +109,7 @@
 
 /** Forcefully kill a thread without worrying about its state */
 extern DECLSPEC void SDLCALL SDL_KillThread(SDL_Thread *thread);
-
+#endif /* !PROTO_SDL_H */
 
 /* Ends C function definitions when using C++ */
 #ifdef __cplusplus
diff -Naur SDL-1.2.15-orig/include/SDL_timer.h SDL-1.2.15/include/SDL_timer.h
--- SDL-1.2.15-orig/include/SDL_timer.h	2015-05-09 17:47:54.271774326 +0200
+++ SDL-1.2.15/include/SDL_timer.h	2015-05-09 15:09:59.752739538 +0200
@@ -46,10 +46,12 @@
  * Get the number of milliseconds since the SDL library initialization.
  * Note that this value wraps if the program runs for more than ~49 days.
  */ 
+#if !defined(PROTO_SDL_H)
 extern DECLSPEC Uint32 SDLCALL SDL_GetTicks(void);
 
 /** Wait a specified number of milliseconds before returning */
 extern DECLSPEC void SDLCALL SDL_Delay(Uint32 ms);
+#endif /* !PROTO_SDL_H */
 
 /** Function prototype for the timer callback function */
 typedef Uint32 (SDLCALL *SDL_TimerCallback)(Uint32 interval);
@@ -83,7 +85,9 @@
  *
  * This function returns 0 if successful, or -1 if there was an error.
  */
+#if !defined(PROTO_SDL_H)
 extern DECLSPEC int SDLCALL SDL_SetTimer(Uint32 interval, SDL_TimerCallback callback);
+#endif /* !PROTO_SDL_H */
 
 /** @name New timer API
  * New timer API, supports multiple timers
@@ -106,6 +110,7 @@
 /** Add a new timer to the pool of timers already running.
  *  Returns a timer ID, or NULL when an error occurs.
  */
+#if !defined(PROTO_SDL_H)
 extern DECLSPEC SDL_TimerID SDLCALL SDL_AddTimer(Uint32 interval, SDL_NewTimerCallback callback, void *param);
 
 /**
@@ -113,7 +118,7 @@
  * Returns a boolean value indicating success.
  */
 extern DECLSPEC SDL_bool SDLCALL SDL_RemoveTimer(SDL_TimerID t);
-
+#endif /* !PROTO_SDL_H */
 /*@}*/
 
 /* Ends C function definitions when using C++ */
diff -Naur SDL-1.2.15-orig/include/SDL_version.h SDL-1.2.15/include/SDL_version.h
--- SDL-1.2.15-orig/include/SDL_version.h	2015-05-09 17:47:54.271774326 +0200
+++ SDL-1.2.15/include/SDL_version.h	2015-05-09 15:09:59.752739538 +0200
@@ -80,7 +80,9 @@
  *  it should NOT be used to fill a version structure, instead you should
  *  use the SDL_Version() macro.
  */
+#if !defined(PROTO_SDL_H)
 extern DECLSPEC const SDL_version * SDLCALL SDL_Linked_Version(void);
+#endif /* !PROTO_SDL_H */
 
 /* Ends C function definitions when using C++ */
 #ifdef __cplusplus
diff -Naur SDL-1.2.15-orig/include/SDL_video.h SDL-1.2.15/include/SDL_video.h
--- SDL-1.2.15-orig/include/SDL_video.h	2015-05-09 17:47:54.271774326 +0200
+++ SDL-1.2.15/include/SDL_video.h	2015-05-09 15:09:59.752739538 +0200
@@ -119,6 +119,9 @@
 
 	/** Reference count -- used when freeing surface */
 	int refcount;				/**< Read-mostly */
+#if defined(__AROS__)
+    struct Library *SDLLib;
+#endif
 } SDL_Surface;
 
 /** @name SDL_Surface Flags
@@ -166,7 +169,6 @@
 typedef int (*SDL_blit)(struct SDL_Surface *src, SDL_Rect *srcrect,
 			struct SDL_Surface *dst, SDL_Rect *dstrect);
 
-
 /** Useful for determining the video hardware capabilities */
 typedef struct SDL_VideoInfo {
 	Uint32 hw_available :1;	/**< Flag: Can you create hardware surfaces? */
@@ -272,6 +274,7 @@
  * SDL_Init() before opening the sound device, otherwise under Win32 DirectX,
  * you won't be able to set full-screen display modes.
  */
+#if !defined(PROTO_SDL_H)
 extern DECLSPEC int SDLCALL SDL_VideoInit(const char *driver_name, Uint32 flags);
 extern DECLSPEC void SDLCALL SDL_VideoQuit(void);
 /*@}*/
@@ -513,9 +516,12 @@
 extern DECLSPEC void SDLCALL SDL_GetRGBA(Uint32 pixel,
 				const SDL_PixelFormat * const fmt,
 				Uint8 *r, Uint8 *g, Uint8 *b, Uint8 *a);
+#endif /* ! PROTO_SDL_H */
 
 /** @sa SDL_CreateRGBSurface */
 #define SDL_AllocSurface    SDL_CreateRGBSurface
+
+#if !defined(PROTO_SDL_H)
 /**
  * Allocate and free an RGB surface (must be called after SDL_SetVideoMode)
  * If the depth is 4 or 8 bits, an empty palette is allocated for the surface.
@@ -586,11 +592,14 @@
  * Returns the new surface, or NULL if there was an error.
  * The new surface should be freed with SDL_FreeSurface().
  */
+
 extern DECLSPEC SDL_Surface * SDLCALL SDL_LoadBMP_RW(SDL_RWops *src, int freesrc);
+#endif /* ! PROTO_SDL_H */
 
 /** Convenience macro -- load a surface from a file */
 #define SDL_LoadBMP(file)	SDL_LoadBMP_RW(SDL_RWFromFile(file, "rb"), 1)
 
+#if !defined(PROTO_SDL_H)
 /**
  * Save a surface to a seekable SDL data source (memory or file.)
  * If 'freedst' is non-zero, the source will be closed after being written.
@@ -598,11 +607,12 @@
  */
 extern DECLSPEC int SDLCALL SDL_SaveBMP_RW
 		(SDL_Surface *surface, SDL_RWops *dst, int freedst);
-
+#endif /* ! PROTO_SDL_H */
 /** Convenience macro -- save a surface to a file */
 #define SDL_SaveBMP(surface, file) \
 		SDL_SaveBMP_RW(surface, SDL_RWFromFile(file, "wb"), 1)
 
+#if !defined(PROTO_SDL_H)
 /**
  * Sets the color key (transparent pixel) in a blittable surface.
  * If 'flag' is SDL_SRCCOLORKEY (optionally OR'd with SDL_RLEACCEL), 
@@ -740,8 +750,10 @@
  * You should call SDL_BlitSurface() unless you know exactly how SDL
  * blitting works internally and how to use the other blit functions.
  */
+ #endif /* ! PROTO_SDL_H */
 #define SDL_BlitSurface SDL_UpperBlit
 
+#if !defined(PROTO_SDL_H)
 /** This is the public blit function, SDL_BlitSurface(), and it performs
  *  rectangle validation and clipping before passing it to SDL_LowerBlit()
  */
@@ -920,12 +932,16 @@
  */
 extern DECLSPEC int SDLCALL SDL_WM_ToggleFullScreen(SDL_Surface *surface);
 
+#endif /* ! PROTO_SDL_H */
+
 typedef enum {
 	SDL_GRAB_QUERY = -1,
 	SDL_GRAB_OFF = 0,
 	SDL_GRAB_ON = 1,
 	SDL_GRAB_FULLSCREEN	/**< Used internally */
 } SDL_GrabMode;
+
+#if !defined(PROTO_SDL_H)
 /**
  * This function allows you to set and query the input grab state of
  * the application.  It returns the new input grab state.
@@ -941,7 +957,9 @@
 /** @internal Not in public API at the moment - do not use! */
 extern DECLSPEC int SDLCALL SDL_SoftStretch(SDL_Surface *src, SDL_Rect *srcrect,
                                     SDL_Surface *dst, SDL_Rect *dstrect);
-                    
+
+#endif /* ! PROTO_SDL_H */
+
 /* Ends C function definitions when using C++ */
 #ifdef __cplusplus
 }
diff -Naur SDL-1.2.15-orig/SDL.conf SDL-1.2.15/SDL.conf
--- SDL-1.2.15-orig/SDL.conf	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.15/SDL.conf	2015-05-09 15:09:59.752739538 +0200
@@ -0,0 +1,241 @@
+##begin config
+basename SDL
+libbase SDLBase
+libbasetype struct SDLBase
+rootbase_field rootSDLBase
+version 1.215
+date 30.08.2016
+copyright Copyright (C) 2013-216 The AROS Development Team, 1997-2012 Sam Lantinga
+options peropenerbase
+rellib posixc
+rellib stdc
+##end config
+
+##begin cdefprivate
+#include "SDL_intern.h"
+##end cdefprivate
+
+##begin cdef
+#ifndef _SDL_H
+#include <SDL/SDL.h>
+#endif
+
+#include <SDL/SDL_active.h>
+#include <SDL/SDL_audio.h>
+#include <SDL/SDL_byteorder.h>
+#include <SDL/SDL_cdrom.h>
+#include <SDL/SDL_copying.h>
+#include <SDL/SDL_cpuinfo.h>
+#include <SDL/SDL_endian.h>
+#include <SDL/SDL_error.h>
+#include <SDL/SDL_events.h>
+#include <SDL/SDL_getenv.h>
+#include <SDL/SDL_joystick.h>
+#include <SDL/SDL_keyboard.h>
+#include <SDL/SDL_keysym.h>
+#include <SDL/SDL_loadso.h>
+#include <SDL/SDL_main.h>
+#include <SDL/SDL_mouse.h>
+#include <SDL/SDL_mutex.h>
+#include <SDL/SDL_name.h>
+#include <SDL/SDL_quit.h>
+#include <SDL/SDL_rwops.h>
+#include <SDL/SDL_syswm.h>
+#include <SDL/SDL_thread.h>
+#include <SDL/SDL_timer.h>
+#include <SDL/SDL_types.h>
+#include <SDL/SDL_version.h>
+#include <SDL/SDL_video.h>
+
+##end cdef
+
+##begin functionlist
+.skip 6
+int SDL_Init(Uint32 flags) (D0)
+const SDL_version * SDL_Linked_Version() ()
+Uint32 SDL_WasInit(Uint32 flags) (D0)
+void SDL_Quit() ()
+int SDL_InitSubSystem(Uint32 flags) (D0)
+void SDL_QuitSubSystem(Uint32 flags) (D0)
+SDL_RWops *SDL_RWFromFile(const char *file, const char *mode) (A0, A1)
+SDL_RWops * SDL_RWFromFP(FILE *fp, int autoclose) (A0, D0)
+SDL_RWops * SDL_RWFromMem(void *mem, int size) (A0, D0)
+SDL_RWops * SDL_AllocRW() ()
+void SDL_FreeRW(SDL_RWops *area) (A0)
+SDL_Surface * SDL_LoadBMP_RW(SDL_RWops *src, int freesrc) (A0, D0)
+SDL_Surface * SDL_DisplayFormat(SDL_Surface *surface) (A0)
+void SDL_FreeSurface(SDL_Surface *surface) (A0)
+int SDL_FillRect(SDL_Surface *dst, SDL_Rect *dstrect, Uint32 color) (A0, A1, D0)
+int SDL_UpperBlit(SDL_Surface *src, SDL_Rect *srcrect, SDL_Surface *dst, SDL_Rect *dstrect) (A0, A1, A2, A3)
+int SDL_LowerBlit(SDL_Surface *src, SDL_Rect *srcrect, SDL_Surface *dst, SDL_Rect *dstrect) (A0, A1, A2, A3)
+int SDL_Flip(SDL_Surface *screen) (A0)
+void SDL_UpdateRects(SDL_Surface *screen, int numrects, SDL_Rect *rects) (A0, D0, A1)
+void SDL_UpdateRect(SDL_Surface *screen, Sint32 x, Sint32 y, Uint32 w, Uint32 h) (A0, D0, D1, D2, D3)
+SDL_Surface *SDL_SetVideoMode(int width, int height, int bpp, Uint32 flags) (D0, D1, D2, D3)
+Uint32 SDL_MapRGB(SDL_PixelFormat *format, Uint8 r, Uint8 g, Uint8 b) (A0, D0, D1, D2)
+Uint32 SDL_MapRGBA(SDL_PixelFormat *format, Uint8 r, Uint8 g, Uint8 b, Uint8 a) (A0, D0, D1, D2, D3)
+.novararg
+int SDL_VideoInit(const char *driver_name, Uint32 flags) (A0, D0)
+const SDL_VideoInfo * SDL_GetVideoInfo() ()
+char *SDL_VideoDriverName(char *namebuf, int maxlen) (A0, D0)
+void SDL_VideoQuit() ()
+SDL_Surface * SDL_GetVideoSurface() ()
+int SDL_VideoModeOK(int width, int height, int bpp, Uint32 flags) (D0, D1, D2, D3)
+SDL_Rect ** SDL_ListModes(SDL_PixelFormat *format, Uint32 flags) (A0, D0)
+int SDL_SetGamma(float red, float green, float blue) (D0, D1, D2)
+int SDL_SetGammaRamp(const Uint16 *red, const Uint16 *green, const Uint16 *blue) (A0, A1, A2)
+int SDL_GetGammaRamp(Uint16 *red, Uint16 *green, Uint16 *blue) (A0, A1, A2)
+int SDL_SetColors(SDL_Surface *surface, SDL_Color *colors, int firstcolor, int ncolors) (A0, A1, D0, D1)
+int SDL_SetPalette(SDL_Surface *surface, int flags, SDL_Color *colors, int firstcolor, int ncolors) (A0, D0, A1, D1, D2)
+void SDL_GetRGB(Uint32 pix, SDL_PixelFormat *fmt, Uint8 *r, Uint8 *g, Uint8 *b) (D0, A0, A1, A2, A3)
+void SDL_GetRGBA(Uint32 pix, SDL_PixelFormat *fmt, Uint8 *r, Uint8 *g, Uint8 *b, Uint8 *a) (D0, A0, A1, A2, A3, A4)
+.novararg
+SDL_Surface *SDL_CreateRGBSurface(Uint32 flags, int width, int height, int depth, Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask) (D0, D1, D2, D3, D4, D5, D6, D7)
+SDL_Surface *SDL_CreateRGBSurfaceFrom(void *pixels, int width, int height, int depth, int pitch, Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask) (A0, D0, D1, D2, D3, D4, D5, D6, D7)
+int SDL_LockSurface(SDL_Surface *surface) (A0)
+void SDL_UnlockSurface(SDL_Surface *surface) (A0)
+int SDL_SaveBMP_RW(SDL_Surface *surface, SDL_RWops *dst, int freedst) (A0, A1, D0)
+int SDL_SetColorKey(SDL_Surface *surface, Uint32 flag, Uint32 key) (A0, D0, D1)
+int SDL_SetAlpha(SDL_Surface *surface, Uint32 flag, Uint8 alpha) (A0, D0, D1)
+SDL_bool SDL_SetClipRect(SDL_Surface *surface, const SDL_Rect *rect) (A0, A1)
+void SDL_GetClipRect(SDL_Surface *surface, SDL_Rect *rect) (A0, A1)
+SDL_Surface *SDL_ConvertSurface(SDL_Surface *src, SDL_PixelFormat *fmt, Uint32 flags) (A0, A1, D0)
+SDL_Surface * SDL_DisplayFormatAlpha(SDL_Surface *surface) (A0)
+SDL_Overlay *SDL_CreateYUVOverlay(int width, int height,Uint32 format, SDL_Surface *display) (D0, D1, D2, A0)
+int SDL_LockYUVOverlay(SDL_Overlay *overlay) (A0)
+void SDL_UnlockYUVOverlay(SDL_Overlay *overlay) (A0)
+int SDL_DisplayYUVOverlay(SDL_Overlay *overlay, SDL_Rect *dstrect) (A0, A1)
+void SDL_FreeYUVOverlay(SDL_Overlay *overlay) (A0)
+int SDL_GL_LoadLibrary(const char *path) (A0)
+void *SDL_GL_GetProcAddress(const char* proc) (A0)
+int SDL_GL_SetAttribute(SDL_GLattr attr, int value) (D0, D1)
+int SDL_GL_GetAttribute(SDL_GLattr attr, int* value) (D0, A0)
+void SDL_GL_SwapBuffers() ()
+void SDL_GL_UpdateRects(int numrects, SDL_Rect* rects) (D0, A0)
+void SDL_GL_Lock() ()
+void SDL_GL_Unlock() ()
+void SDL_WM_SetCaption(const char *title, const char *icon) (A0, A1)
+void SDL_WM_GetCaption(char **title, char **icon) (A0, A1)
+void SDL_WM_SetIcon(SDL_Surface *icon, Uint8 *mask) (A0, A1)
+int SDL_WM_IconifyWindow() ()
+int SDL_WM_ToggleFullScreen(SDL_Surface *surface) (A0)
+SDL_GrabMode SDL_WM_GrabInput(SDL_GrabMode mode) (D0)
+Uint32 SDL_GetTicks() ()
+void SDL_Delay(Uint32 ms) (D0)
+int SDL_SetTimer(Uint32 interval, SDL_TimerCallback callback) (D0, A0)
+SDL_TimerID SDL_AddTimer(Uint32 interval, SDL_NewTimerCallback callback, void *param) (D0, A0, A1)
+SDL_bool SDL_RemoveTimer(SDL_TimerID t) (D0)
+void SDL_PumpEvents() ()
+int SDL_PollEvent(SDL_Event *event) (A0)
+int SDL_WaitEvent(SDL_Event *event) (A0)
+int SDL_PeepEvents(SDL_Event *events, int numevents,SDL_eventaction action, Uint32 mask) (A0, D0, D1, D2)
+int SDL_PushEvent(SDL_Event *event) (A0)
+void SDL_SetEventFilter(SDL_EventFilter filter) (D0)
+SDL_EventFilter SDL_GetEventFilter() ()
+Uint8 SDL_EventState(Uint8 type, int state) (D0, D1)
+int SDL_NumJoysticks() ()
+const char *SDL_JoystickName(int device_index) (D0)
+SDL_Joystick *SDL_JoystickOpen(int device_index) (D0)
+int SDL_JoystickOpened(int device_index) (D0)
+int SDL_JoystickIndex(SDL_Joystick *joystick) (A0)
+int SDL_JoystickNumAxes(SDL_Joystick *joystick) (A0)
+int SDL_JoystickNumBalls(SDL_Joystick *joystick) (A0)
+int SDL_JoystickNumHats(SDL_Joystick *joystick) (A0)
+int SDL_JoystickNumButtons(SDL_Joystick *joystick) (A0)
+void SDL_JoystickUpdate() ()
+int SDL_JoystickEventState(int state) (D0)
+Sint16 SDL_JoystickGetAxis(SDL_Joystick *joystick, int axis) (A0, D0)
+Uint8 SDL_JoystickGetHat(SDL_Joystick *joystick, int hat) (A0, D0)
+int SDL_JoystickGetBall(SDL_Joystick *joystick, int ball, int *dx, int *dy) (A0, D0, A1, A2)
+Uint8 SDL_JoystickGetButton(SDL_Joystick *joystick, int button) (A0, D0)
+void SDL_JoystickClose(SDL_Joystick *joystick) (A0)
+int SDL_EnableUNICODE(int enable) (D0)
+int SDL_EnableKeyRepeat(int delay, int interval) (D0, D1)
+Uint8 * SDL_GetKeyState(int *numkeys) (A0)
+SDLMod SDL_GetModState() ()
+void SDL_SetModState(SDLMod modstate) (D0)
+char * SDL_GetKeyName(SDLKey key) (D0)
+Uint8 SDL_GetMouseState(int *x, int *y) (A0, A1)
+Uint8 SDL_GetRelativeMouseState(int *x, int *y) (A0, A1)
+void SDL_WarpMouse(Uint16 x, Uint16 y) (D0, D1)
+SDL_Cursor *SDL_CreateCursor(Uint8 *data, Uint8 *mask, int w, int h, int hot_x, int hot_y) (A0, A1, D0, D1, D2, D3)
+void SDL_SetCursor(SDL_Cursor *cursor) (A0)
+SDL_Cursor * SDL_GetCursor() ()
+void SDL_FreeCursor(SDL_Cursor *cursor) (A0)
+int SDL_ShowCursor(int toggle) (D0)
+Uint8 SDL_GetAppState() ()
+void SDL_SetErrorA(const char *fmt, CONST IPTR *params) (A0, A1)
+char *SDL_GetError() ()
+void SDL_ClearError() ()
+int SDL_AudioInit(const char *driver_name) (A0)
+char *SDL_AudioDriverName(char *namebuf, int maxlen) (A0, D0)
+void SDL_AudioQuit() ()
+int SDL_OpenAudio(SDL_AudioSpec *desired, SDL_AudioSpec *obtained) (A0, D0)
+SDL_audiostatus SDL_GetAudioStatus() ()
+void SDL_PauseAudio(int pause_on) (D0)
+void SDL_Audio_SetCaption(const char *caption) (A0)
+SDL_AudioSpec *SDL_LoadWAV_RW(SDL_RWops *src, int freesrc,SDL_AudioSpec *spec, Uint8 **audio_buf, Uint32 *audio_len) (A0, D0, A1, A2, A3)
+void SDL_FreeWAV(Uint8 *audio_buf) (A0)
+int SDL_BuildAudioCVT(SDL_AudioCVT *cvt,Uint16 src_format, Uint8 src_channels, int src_rate,Uint16 dst_format, Uint8 dst_channels, int dst_rate) (A0, D0, D1, D2, D3, D4, D5)
+int SDL_ConvertAudio(SDL_AudioCVT *cvt) (A0)
+void SDL_MixAudio(Uint8 *dst, const Uint8 *src, Uint32 len, int volume) (A0, A1, D0, D1)
+void SDL_LockAudio() ()
+void SDL_UnlockAudio() ()
+void SDL_CloseAudio() ()
+SDL_Thread * SDL_CreateThread(void *fn, void *data) (A0, A1)
+Uint32 SDL_ThreadID() ()
+Uint32 SDL_GetThreadID(SDL_Thread *thread) (A0)
+void SDL_WaitThread(SDL_Thread *thread, int *status) (A0, A1)
+void SDL_KillThread(SDL_Thread *thread) (A0)
+int SDL_SoftStretch(SDL_Surface *src, SDL_Rect *srcrect, SDL_Surface *dst, SDL_Rect *dstrect) (A0, A1, A2, A3)
+int SDL_CDNumDrives() ()
+const char *SDL_CDName(int drive) (D0)
+SDL_CD *SDL_CDOpen(int drive) (D0)
+CDstatus SDL_CDStatus(SDL_CD *cdrom) (A0)
+int SDL_CDPlay(SDL_CD *cdrom, int sframe, int length) (A0, D0, D1)
+int SDL_CDPlayTracks(SDL_CD *cdrom, int strack, int sframe, int ntracks, int nframes) (A0, D0, D1, D2, D3)
+int SDL_CDPause(SDL_CD *cdrom) (A0)
+int SDL_CDResume(SDL_CD *cdrom) (A0)
+int SDL_CDStop(SDL_CD *cdrom) (A0)
+int SDL_CDEject(SDL_CD *cdrom) (A0)
+void SDL_CDClose(SDL_CD *cdrom) (A0)
+SDL_mutex *SDL_CreateMutex() ()
+void SDL_DestroyMutex(SDL_mutex *mutex) (A0)
+int SDL_mutexP(SDL_mutex *mutex) (A0)
+int SDL_mutexV(SDL_mutex *mutex) (A0)
+SDL_sem * SDL_CreateSemaphore(Uint32 initial_value) (D0)
+void SDL_DestroySemaphore(SDL_sem *sem) (A0)
+int SDL_SemTryWait(SDL_sem *sem) (A0)
+int SDL_SemWaitTimeout(SDL_sem *sem, Uint32 timeout) (A0, D0)
+int SDL_SemWait(SDL_sem *sem) (A0)
+Uint32 SDL_SemValue(SDL_sem *sem) (A0)
+int SDL_SemPost(SDL_sem *sem) (A0)
+void SDL_Error(SDL_errorcode code) (D0)
+SDL_cond * SDL_CreateCond() ()
+void SDL_DestroyCond(SDL_cond *cond) (A0)
+int SDL_CondSignal(SDL_cond *cond) (A0)
+int SDL_CondBroadcast(SDL_cond *cond) (A0)
+int SDL_CondWaitTimeout(SDL_cond *cond, SDL_mutex *mutex, Uint32 ms) (A0, A1, D0)
+int SDL_CondWait(SDL_cond *cond, SDL_mutex *mutex) (A0, A1)
+Uint16 SDL_ReadLE16(SDL_RWops *src) (A0)
+Uint16 SDL_ReadBE16(SDL_RWops *src) (A0)
+Uint32 SDL_ReadLE32(SDL_RWops *src) (A0)
+Uint32 SDL_ReadBE32(SDL_RWops *src) (A0)
+Uint64 SDL_ReadLE64(SDL_RWops *src) (A0)
+Uint64 SDL_ReadBE64(SDL_RWops *src) (A0)
+int SDL_WriteLE16(SDL_RWops *dst, Uint16 value) (A0, D0)
+int SDL_WriteBE16(SDL_RWops *dst, Uint16 value) (A0, D0)
+int SDL_WriteLE32(SDL_RWops *dst, Uint32 value) (A0, D0)
+int SDL_WriteBE32(SDL_RWops *dst, Uint32 value) (A0, D0)
+int SDL_WriteLE64(SDL_RWops *dst, Uint64 value) (A0, D0)
+int SDL_WriteBE64(SDL_RWops *dst, Uint64 value) (A0, D0)
+SDL_bool SDL_HasAltiVec() ()
+SDL_bool SDL_HasRDTSC() ()
+SDL_bool SDL_HasMMX() ()
+SDL_bool SDL_Has3DNow() ()
+SDL_bool SDL_HasSSE() ()
+SDL_bool SDL_HasMMXExt() ()
+SDL_bool SDL_Has3DNowExt() ()
+SDL_bool SDL_HasSSE2() ()
+char *SDL_iconv_string(const char *tocode, const char *fromcode, const char *inbuf, size_t inbytesleft) (A0, A1, A2, D0)
+##end functionlist
diff -Naur SDL-1.2.15-orig/SDL_intern.h SDL-1.2.15/SDL_intern.h
--- SDL-1.2.15-orig/SDL_intern.h	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.15/SDL_intern.h	2015-05-09 15:09:59.753739536 +0200
@@ -0,0 +1,161 @@
+#ifndef	_SDL_INTERN_H
+#define	_SDL_INTERN_H
+
+#define PROTO_SDL_H
+
+#include <exec/libraries.h>
+#include <exec/semaphores.h>
+#include <devices/timer.h>
+
+#ifndef	_SDL_H
+#include <SDL/SDL.h>
+#endif
+
+#include <SDL/SDL_active.h>
+#include <SDL/SDL_audio.h>
+#include <SDL/SDL_byteorder.h>
+#include <SDL/SDL_cdrom.h>
+#include <SDL/SDL_copying.h>
+#include <SDL/SDL_cpuinfo.h>
+#include <SDL/SDL_endian.h>
+#include <SDL/SDL_error.h>
+#include <SDL/SDL_events.h>
+#include <SDL/SDL_getenv.h>
+#include <SDL/SDL_joystick.h>
+#include <SDL/SDL_keyboard.h>
+#include <SDL/SDL_keysym.h>
+#include <SDL/SDL_loadso.h>
+#include <SDL/SDL_main.h>
+#include <SDL/SDL_mouse.h>
+#include <SDL/SDL_mutex.h>
+#include <SDL/SDL_name.h>
+#include <SDL/SDL_quit.h>
+#include <SDL/SDL_rwops.h>
+#include <SDL/SDL_syswm.h>
+#include <SDL/SDL_thread.h>
+#include <SDL/SDL_timer.h>
+#include <SDL/SDL_types.h>
+#include <SDL/SDL_version.h>
+#include <SDL/SDL_video.h>
+
+#include "SDL_error_c.h"
+
+#define MAX_DRIVES	32
+#define CURSOR_VISIBLE	0x01
+
+struct SDLSizePair {
+    int w;
+    int h;
+};
+
+struct SDL_AudioDevice;
+struct SDL_VideoDevice;
+
+struct SDLBase
+{
+    struct Library      _lib;
+    struct SDLBase      *rootSDLBase;
+    struct Library      *LowLevelBase;
+    struct Library      *GLBase;
+
+    /** SDL.c **/
+    Uint32              SDL_initialized;
+    Uint32              ticks_started;
+    int                 surfaces_allocated;
+
+    /**timer/aros/SDL_systimer.c **/
+    int                 timer_alive;
+    SDL_Thread          *timer_thread;
+    struct timerequest  *TimerIO;
+    clock_t             start;
+    struct Device       *TimerBase;
+    struct timeval      basetime;
+    struct MsgPort      *TimerMP;
+    struct Task         *OwnerTask;
+    int                 fallback;
+
+    /** thread/SDL_thread.c **/
+    int                 SDL_maxthreads;
+    int                 SDL_numthreads;
+    SDL_Thread          **SDL_Threads;
+    struct SignalSemaphore     *SDL_ThreadLock;
+
+    /** thread/aros/SDL_thread.c **/
+    SDL_error           SDL_global_error;
+    int                 SDL_ThreadLockCreated;
+
+    /** events/SDL_active.c **/
+    Uint8               SDL_appstate;
+
+    /** events/SDL_events.c **/
+    SDL_EventFilter     SDL_EventOK;
+    Uint8               SDL_ProcessEvents[SDL_NUMEVENTS];
+    Uint32              SDL_eventstate;
+    SDL_Thread          *SDL_EventThread; /* Thread handle */
+    Uint32              event_thread; /* The event thread id */
+
+    /** events/SDL_mouse.c **/
+    Sint16              SDL_MouseX;
+    Sint16              SDL_MouseY;
+    Sint16              SDL_DeltaX;
+    Sint16              SDL_DeltaY;
+    Sint16              SDL_MouseMaxX;
+    Sint16              SDL_MouseMaxY;
+    Uint8               SDL_ButtonState;
+
+    /** events/SDL_keyboard.c **/
+    Uint8               SDL_KeyState[SDLK_LAST];
+    SDLMod              SDL_ModState;
+    int                 SDL_TranslateUNICODE;
+    const char          *keynames[SDLK_LAST];
+
+     /** events/SDL_resize.c **/
+    struct SDLSizePair  last_resize;
+
+    /** audio/SDL_audio.c **/
+    Uint32              has_obtained_spec;
+    struct SDL_AudioDevice *current_audio;
+    int                 format_idx;
+    int                 format_idx_sub;
+
+    /** audio/ahi/SDL_ahiaudio.c **/
+    Uint32              AHI_Volume;
+
+    /** video/SDL_video.c **/
+    struct SDL_VideoDevice *current_video;
+
+    /** video/SDL_cursor.c **/
+    volatile int        SDL_cursorstate;
+    SDL_Cursor          *SDL_cursor;
+    SDL_Cursor          *SDL_defcursor;
+    SDL_mutex           *SDL_cursorlock;
+    int                 palette_changed;
+    Uint8               pixels8[2];
+
+    /**video/SDL_stretch.c **/
+    unsigned char       *copy_row_base;
+    unsigned char       *copy_row;
+
+    /** timers/SDL_timer_c.h **/
+    int                 SDL_timer_started;
+    int                 SDL_timer_running;
+
+    Uint32 SDL_alarm_interval;
+    SDL_TimerCallback   SDL_alarm_callback;
+
+    int                 SDL_timer_threaded;
+
+    SDL_TimerID         SDL_timers;
+    SDL_mutex           *SDL_timer_mutex;
+    volatile SDL_bool   list_changed;
+
+    /** cdrom/SDL_cdrom.c **/
+    SDL_CD              *default_cdrom;
+    int                 SDL_cdinitted;
+    int                 SDL_numcds;
+
+    /**cdrom/aros/SDL_syscdrom.c **/
+    UBYTE               *CDList[MAX_DRIVES];
+};
+
+#endif
diff -Naur SDL-1.2.15-orig/src/audio/ahi/SDL_ahiaudio.c SDL-1.2.15/src/audio/ahi/SDL_ahiaudio.c
--- SDL-1.2.15-orig/src/audio/ahi/SDL_ahiaudio.c	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.15/src/audio/ahi/SDL_ahiaudio.c	2015-05-09 15:09:59.753739536 +0200
@@ -0,0 +1,528 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997, 1998  Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+    Sam Lantinga
+    5635-34 Springhouse Dr.
+    Pleasanton, CA 94588 (USA)
+    slouken@libsdl.org
+*/
+
+#include <proto/exec.h>
+
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
+#include "SDL_endian.h"
+#include "SDL_ahiaudio.h"
+#include "SDL_timer.h"
+#ifndef __AROS__
+#include "SDL_cgxasm.h"
+#endif
+#include <stdlib.h>
+#include "../../main/aros/mydebug.h"
+
+#if !defined(PROTO_SDL_H)
+extern Uint32 has_obtained_spec;
+static Fixed AHI_Volume;
+
+/* Audio driver functions */
+static int AHI_OpenAudio(_THIS, SDL_AudioSpec *spec);
+static void AHI_ThreadInit(_THIS);
+static void AHI_WaitAudio(_THIS);
+static void AHI_PlayAudio(_THIS);
+static Uint8 *AHI_GetAudioBuf(_THIS);
+static void AHI_CloseAudio(_THIS);
+#else
+#include "SDL_intern.h"
+#define has_obtained_spec SDLBase->has_obtained_spec
+#define AHI_Volume SDLBase->AHI_Volume
+
+/* Audio driver functions */
+static int AHI_OpenAudio(_THIS, SDL_AudioSpec *spec, struct SDLBase *SDLBase);
+static void AHI_ThreadInit(_THIS, struct SDLBase *SDLBase);
+static void AHI_WaitAudio(_THIS, struct SDLBase *SDLBase);
+static void AHI_PlayAudio(_THIS, struct SDLBase *SDLBase);
+static Uint8 *AHI_GetAudioBuf(_THIS, struct SDLBase *SDLBase);
+static void AHI_CloseAudio(_THIS, struct SDLBase *SDLBase);
+#endif
+
+#if !defined(PROTO_SDL_H)
+/* Internal functions */
+void AHI_Mute(ULONG mute)
+#else
+void AHI_Mute(ULONG mute, struct SDLBase *SDLBase)
+#endif
+{
+	AHI_Volume = mute ? 0 : 0x10000;
+}
+
+/* Audio driver bootstrap functions */
+
+#if !defined(PROTO_SDL_H)
+static int Audio_Available(void)
+#else
+static int Audio_Available(struct SDLBase *SDLBase)
+#endif
+{
+	/* AHI always available */
+
+	return 1;
+}
+
+#if !defined(PROTO_SDL_H)
+static void Audio_DeleteDevice(SDL_AudioDevice *device)
+#else
+static void Audio_DeleteDevice(SDL_AudioDevice *device, struct SDLBase *SDLBase)
+#endif
+{
+	D(bug("[SDL] Audio_DeleteDevice()\n"));
+	free(device->hidden);
+	free(device);
+}
+
+#if !defined(PROTO_SDL_H)
+static SDL_AudioDevice *Audio_CreateDevice(int devindex)
+#else
+static SDL_AudioDevice *Audio_CreateDevice(int devindex, struct SDLBase *SDLBase)
+#endif
+{
+	struct SDL_PrivateAudioData *hidden;
+	SDL_AudioDevice *this;
+
+	D(bug("[SDL] Audio_CreateDevice()\n"));
+
+	/* Initialize all variables that we clean on shutdown */
+	this = (SDL_AudioDevice *)malloc(sizeof(SDL_AudioDevice));
+	hidden = (struct SDL_PrivateAudioData *)malloc((sizeof *hidden));
+
+	if (this == NULL || hidden == NULL)
+	{
+		SDL_OutOfMemory();
+
+		if (this)
+			free(this);
+
+		if (hidden)
+			free(hidden);
+
+		return(0);
+	}
+
+	memset(this, 0, (sizeof *this));
+	memset(hidden, 0, (sizeof *hidden));
+
+	NEWLIST(&hidden->dummy_mp.mp_MsgList);
+	hidden->dummy_mp.mp_Node.ln_Type = NT_MSGPORT;
+	hidden->dummy_mp.mp_Flags = PA_SIGNAL;
+	hidden->dummy_mp.mp_SigBit = SIGB_SINGLE;
+	hidden->dummy_mp.mp_SigTask = FindTask(NULL);
+
+	this->hidden = hidden;
+
+	/* Set the function pointers */
+	this->OpenAudio = AHI_OpenAudio;
+	this->ThreadInit = AHI_ThreadInit;
+	this->WaitAudio = AHI_WaitAudio;
+	this->PlayAudio = AHI_PlayAudio;
+	this->GetAudioBuf = AHI_GetAudioBuf;
+	this->CloseAudio = AHI_CloseAudio;
+
+	this->free = Audio_DeleteDevice;
+
+        AHI_Volume = 0x10000;
+
+	return this;
+}
+
+AudioBootStrap AHI_bootstrap = {
+	"AHI",
+	"MorphOS ahi.device SDL audio",
+	Audio_Available,
+	Audio_CreateDevice
+};
+
+#if !defined(PROTO_SDL_H)
+void static AHI_WaitAudio(_THIS)
+#else
+void static AHI_WaitAudio(_THIS, struct SDLBase *SDLBase)
+#endif
+{
+	struct AHIRequest *req;
+
+	D(bug("[SDL] AHI_WaitAudio()\n"));
+
+	req = &this->hidden->audio_req[this->hidden->current_buffer];
+
+	//if (!CheckIO((struct IORequest *)req)
+	if (req->ahir_Std.io_Data)
+	{
+		WaitIO((struct IORequest *)req);
+		req->ahir_Std.io_Data = NULL;
+
+		GetMsg(&this->hidden->thread_audio_mp);
+		GetMsg(&this->hidden->thread_audio_mp);
+	}
+}
+
+#if !defined(PROTO_SDL_H)
+static void AHI_PlayAudio(_THIS)
+#else
+static void AHI_PlayAudio(_THIS, struct SDLBase *SDLBase)
+#endif
+{
+	struct SDL_PrivateAudioData *hidden = this->hidden;
+	struct AHIRequest *req;
+	APTR   mixbuf;
+	ULONG current, current2;
+	LONG mixbufsize;
+
+	D(bug("[SDL] AHI_PlayAudio()\n"));
+
+	current  = hidden->current_buffer;
+	current2 = current ^ 1;
+	req = &hidden->audio_req[current];
+
+	/* Write the audio data out */
+
+	mixbufsize = hidden->size; /* Note: this is an audio buffer size in _bytes_ */
+	mixbuf	  = hidden->mixbuf[current];
+
+	req->ahir_Std.io_Data    = mixbuf;
+	req->ahir_Std.io_Length  = mixbufsize;
+	req->ahir_Std.io_Offset  = 0;
+	req->ahir_Std.io_Command = CMD_WRITE;
+	req->ahir_Frequency      = hidden->freq;
+	req->ahir_Volume         = AHI_Volume;	//0x10000;
+	req->ahir_Type           = hidden->type;
+	req->ahir_Position       = 0x8000;
+	req->ahir_Link           = (hidden->playing ? &hidden->audio_req[current2] : NULL);
+
+	switch (hidden->convert)
+	{
+		case AHI_CONVERT_8:
+		{
+			BYTE *buf = mixbuf;
+
+			do
+			{
+				*(buf++) -= 128;
+				mixbufsize--;
+			}
+			while (mixbufsize);
+		}
+		break;
+
+		case AHI_CONVERT_16:
+		{
+			WORD *buf = mixbuf;
+
+			do
+			{
+				*(buf++) -= 32768;
+				mixbufsize -= 2;
+			}
+			while (mixbufsize > 0);
+		}
+		break;
+
+		case AHI_CONVERT_S16LSB:
+#ifndef __AROS__
+			copy_and_swap16(mixbuf, mixbuf, mixbufsize / 2);
+			break;
+#endif
+		case AHI_CONVERT_U16LSB:
+		{
+			UWORD j, *buf = mixbuf;
+
+			j = hidden->convert == AHI_CONVERT_U16LSB ? 32768 : 0;
+
+			do
+			{
+				UWORD sample = *buf;
+				*buf++ = ((sample >> 8) | (sample << 8)) - j;
+				mixbufsize -= 2;
+			}
+			while (mixbufsize > 0);
+		}
+		break;
+	}
+
+	SendIO((struct IORequest *)req);
+	hidden->current_buffer = current2;
+	hidden->playing = 1;
+}
+
+#if !defined(PROTO_SDL_H)
+static Uint8 *AHI_GetAudioBuf(_THIS)
+#else
+static Uint8 *AHI_GetAudioBuf(_THIS, struct SDLBase *SDLBase)
+#endif
+{
+	D(bug("[SDL] AHI_GetAudioBuf()\n"));
+	return(this->hidden->mixbuf[this->hidden->current_buffer]);
+}
+
+#if !defined(PROTO_SDL_H)
+static void AHI_CloseAudio(_THIS)
+#else
+static void AHI_CloseAudio(_THIS, struct SDLBase *SDLBase)
+#endif
+{
+	struct SDL_PrivateAudioData *hidden = this->hidden;
+
+	D(bug("[SDL] AHI_CloseAudio()\n"));
+
+	if (hidden->have_ahi)
+	{
+		CloseDevice((struct IORequest *)&hidden->ctrl_req);
+	}
+
+	if (hidden->mixbuf[0])
+		FreeMem(hidden->mixbuf[0], hidden->size);
+
+	if (hidden->mixbuf[1])
+		FreeMem(hidden->mixbuf[1], hidden->size);
+
+	hidden->mixbuf[0]  = NULL;
+	hidden->mixbuf[1]  = NULL;
+	hidden->have_ahi   = 0;
+	hidden->playing    = 0;
+}
+
+#if !defined(PROTO_SDL_H)
+static int AHI_OpenAudio(_THIS, SDL_AudioSpec *spec)
+#else
+static int AHI_OpenAudio(_THIS, SDL_AudioSpec *spec, struct SDLBase *SDLBase)
+#endif
+{	
+	struct SDL_PrivateAudioData *hidden = this->hidden;
+#ifndef __AROS__
+	int altivec_align = 0;
+#endif
+
+	D(bug("[SDL] AHI_OpenAudio()\n"));
+
+	if (spec->channels > 2)
+	{
+		D(bug("More than 2 channels not currently supported, forcing conversion...\n"));
+		spec->channels = 2;
+	}
+
+	D(bug("requested samples is %ld\n", spec->samples));
+
+	/* Fiddle with this to find out working combination with games
+	 *
+	 * Recommended testing: E-UAE, Bolcatoid
+	 */
+
+	if (has_obtained_spec && spec->samples > 1024)
+	{
+		spec->samples = spec->freq / 20;
+
+		if (spec->samples < 256)
+			spec->samples = 256;
+
+		D(bug("[SDL] Changed sample count. New count is %ld.\n", spec->samples));
+	}
+
+	hidden->convert = AHI_NO_CONVERSION;
+
+	/* Determine the audio parameters from the AudioSpec */
+	switch (spec->format)
+	{
+		case AUDIO_U8:
+			hidden->convert = AHI_CONVERT_8;
+		case AUDIO_S8:
+			hidden->bytespersample = 1;
+			hidden->type = spec->channels == 1 ? AHIST_M8S : AHIST_S8S;
+			break;
+#ifndef __AROS__
+		case AUDIO_S16LSB:
+			altivec_align = 1;
+			hidden->convert = AHI_CONVERT_S16LSB;
+			hidden->bytespersample = 2;
+			hidden->type = spec->channels == 1 ? AHIST_M16S : AHIST_S16S;
+			break;
+		case AUDIO_U16LSB:
+			hidden->convert = AHI_CONVERT_U16LSB;
+			hidden->bytespersample = 2;
+			hidden->type = spec->channels == 1 ? AHIST_M16S : AHIST_S16S;
+			break;
+		case AUDIO_U16MSB:
+			hidden->convert = AHI_CONVERT_16;
+			hidden->bytespersample = 2;
+			hidden->type = spec->channels == 1 ? AHIST_M16S : AHIST_S16S;
+			break;
+		case AUDIO_S16MSB:
+			hidden->bytespersample = 2;
+			hidden->type = spec->channels == 1 ? AHIST_M16S : AHIST_S16S;
+			break;
+#else
+#if AROS_BIG_ENDIAN
+		case AUDIO_S16LSB:
+			// SWAP
+			hidden->convert = AHI_CONVERT_S16LSB;
+			hidden->bytespersample = 2;
+			hidden->type = spec->channels == 1 ? AHIST_M16S : AHIST_S16S;
+			break;
+		case AUDIO_U16LSB:
+			// SWAP + SIGN
+			hidden->convert = AHI_CONVERT_U16LSB;
+			hidden->bytespersample = 2;
+			hidden->type = spec->channels == 1 ? AHIST_M16S : AHIST_S16S;
+			break;
+		case AUDIO_U16MSB:
+			// SIGN
+			hidden->convert = AHI_CONVERT_16;
+			hidden->bytespersample = 2;
+			hidden->type = spec->channels == 1 ? AHIST_M16S : AHIST_S16S;
+			break;
+		case AUDIO_S16MSB:
+			// NOTHING TO BE DONE
+			hidden->bytespersample = 2;
+			hidden->type = spec->channels == 1 ? AHIST_M16S : AHIST_S16S;
+			break;
+#else
+		case AUDIO_S16LSB:
+			// NOTHING TO BE DONE
+			hidden->bytespersample = 2;
+			hidden->type = spec->channels == 1 ? AHIST_M16S : AHIST_S16S;
+			break;
+		case AUDIO_U16LSB:
+			// SIGN
+			hidden->convert = AHI_CONVERT_16;
+			hidden->bytespersample = 2;
+			hidden->type = spec->channels == 1 ? AHIST_M16S : AHIST_S16S;
+			break;
+		case AUDIO_U16MSB:
+			// SWAP + SIGN
+			hidden->convert = AHI_CONVERT_U16LSB;
+			hidden->bytespersample = 2;
+			hidden->type = spec->channels == 1 ? AHIST_M16S : AHIST_S16S;
+			break;
+		case AUDIO_S16MSB:
+			// SWAP
+			hidden->convert = AHI_CONVERT_S16LSB;
+			hidden->bytespersample = 2;
+			hidden->type = spec->channels == 1 ? AHIST_M16S : AHIST_S16S;
+			break;
+#endif
+#endif
+			
+		default:
+			SDL_SetError("Unsupported audio format");
+			return(-1);
+	}
+
+	/* Update the fragment size as size in bytes */
+	SDL_CalculateAudioSpec(spec);
+
+	hidden->ctrl_req.ahir_Std.io_Message.mn_ReplyPort = &hidden->dummy_mp;
+	hidden->ctrl_req.ahir_Std.io_Message.mn_Length = sizeof(struct AHIRequest);
+	hidden->ctrl_req.ahir_Version = 4;
+
+	if (OpenDevice(AHINAME, 0, (struct IORequest *)&hidden->ctrl_req, 0) != 0)
+	{
+		D(bug("could not open ahi\n"));
+		SDL_SetError("Unable to open AHI device! Error code %d.\n", hidden->ctrl_req.ahir_Std.io_Error);
+		//DeleteIORequest((struct IORequest *)hidden->ctrl_req);
+		return -1;
+	}
+
+	hidden->have_ahi = 1;
+#ifndef __AROS__
+	/* Align size to multiples of 16 bytes */
+	if (altivec_align)
+		spec->size = (spec->size + 15) & ~15;
+#endif
+	/* Set output frequency and size */
+	hidden->freq = spec->freq;
+	hidden->size = spec->size;
+
+	/* Allocate mixing buffer */
+#ifndef __AROS__
+	if (altivec_align)
+	{
+		hidden->mixbuf[0] = (Uint8 *)AllocMemAligned(spec->size, MEMF_ANY, 32, 0);
+		hidden->mixbuf[1] = (Uint8 *)AllocMemAligned(spec->size, MEMF_ANY, 32, 0);
+	}
+	else
+#endif
+	{
+		hidden->mixbuf[0] = (Uint8 *)AllocMem(spec->size, MEMF_ANY);
+		hidden->mixbuf[1] = (Uint8 *)AllocMem(spec->size, MEMF_ANY);
+	}
+
+	if ((hidden->mixbuf[0] == NULL) || (hidden->mixbuf[1] == NULL))
+	{
+		D(bug("could not alloc audio mixing buffers\n"));
+		SDL_SetError("Unable to allocate audio mixing buffers!\n");
+
+		if (hidden->mixbuf[0])
+			FreeMem(hidden->mixbuf[0], hidden->size);
+
+		if (hidden->mixbuf[1])
+			FreeMem(hidden->mixbuf[1], hidden->size);
+
+		CloseDevice((struct IORequest *)&hidden->ctrl_req);
+		hidden->mixbuf[0] = NULL;
+		hidden->mixbuf[1] = NULL;
+		hidden->have_ahi  = 0;
+		return -1;
+	}
+
+	NEWLIST(&hidden->thread_audio_mp.mp_MsgList);
+	hidden->thread_audio_mp.mp_Node.ln_Pri	= 60;
+	hidden->thread_audio_mp.mp_Node.ln_Type  = NT_MSGPORT;
+	hidden->thread_audio_mp.mp_Flags 		  = PA_SIGNAL;
+
+	hidden->current_buffer =0;
+	hidden->playing = 0;
+
+	D(bug("OpenAudio...OK\n"));
+
+	/* We're ready to rock and roll. :-) */
+
+	return 0;
+}
+
+#if !defined(PROTO_SDL_H)
+static void AHI_ThreadInit(_THIS)
+#else
+static void AHI_ThreadInit(_THIS, struct SDLBase *SDLBase)
+#endif
+{
+	struct SDL_PrivateAudioData *hidden = this->hidden;
+	struct MsgPort 	*mp;
+	struct Task 	*task;
+
+	CopyMem(&hidden->ctrl_req, &hidden->audio_req[0], sizeof(struct AHIRequest));
+	CopyMem(&hidden->ctrl_req, &hidden->audio_req[1], sizeof(struct AHIRequest));
+
+	mp = &hidden->thread_audio_mp;
+
+	hidden->audio_req[0].ahir_Std.io_Message.mn_ReplyPort = mp;
+	hidden->audio_req[1].ahir_Std.io_Message.mn_ReplyPort = mp;
+
+	mp->mp_SigBit  = AllocSignal(-1);
+	mp->mp_SigTask = task = FindTask(NULL);
+
+	SetTaskPri(task, 1);
+}
diff -Naur SDL-1.2.15-orig/src/audio/ahi/SDL_ahiaudio.h SDL-1.2.15/src/audio/ahi/SDL_ahiaudio.h
--- SDL-1.2.15-orig/src/audio/ahi/SDL_ahiaudio.h	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.15/src/audio/ahi/SDL_ahiaudio.h	2015-05-09 15:09:59.753739536 +0200
@@ -0,0 +1,64 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002  Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+
+#ifndef _SDL_ahiaudio_h
+#define _SDL_ahiaudio_h
+
+#include <exec/exec.h>
+#include <dos/dos.h>
+#include <proto/exec.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <devices/ahi.h>
+#include "../../main/aros/mydebug.h"
+
+#include "SDL.h"
+#include "../SDL_audio_c.h"
+#include "../SDL_audiomem.h"
+#include "../SDL_sysaudio.h"
+
+/* Hidden "this" pointer for the audio functions */
+#define _THIS	SDL_AudioDevice *this
+
+struct SDL_PrivateAudioData {
+	/* The handle for the audio device */
+	struct AHIRequest ctrl_req, audio_req[2];
+	struct MsgPort dummy_mp, thread_audio_mp;
+	Sint32 freq,type,bytespersample,size;
+	Uint8 *mixbuf[2];           /* The app mixing buffer */
+	Uint32 current_buffer;
+	Uint8  have_ahi;
+	Uint8  playing;
+	Uint16 convert;
+};
+
+enum
+{
+	AHI_NO_CONVERSION,
+	AHI_CONVERT_8,
+	AHI_CONVERT_16,
+	AHI_CONVERT_U16LSB,
+	AHI_CONVERT_S16LSB
+};
+
+#endif /* _SDL_ahiaudio_h */
diff -Naur SDL-1.2.15-orig/src/audio/disk/SDL_diskaudio.c SDL-1.2.15/src/audio/disk/SDL_diskaudio.c
--- SDL-1.2.15-orig/src/audio/disk/SDL_diskaudio.c	2015-05-09 17:47:54.324774187 +0200
+++ SDL-1.2.15/src/audio/disk/SDL_diskaudio.c	2015-05-09 15:09:59.754739534 +0200
@@ -21,6 +21,11 @@
 
     This file written by Ryan C. Gordon (icculus@icculus.org)
 */
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
 #include "SDL_config.h"
 
 /* Output raw audio data to a file. */
@@ -47,11 +52,19 @@
 #define DISKDEFAULT_WRITEDELAY   150
 
 /* Audio driver functions */
+#if !defined(PROTO_SDL_H)
 static int DISKAUD_OpenAudio(_THIS, SDL_AudioSpec *spec);
 static void DISKAUD_WaitAudio(_THIS);
 static void DISKAUD_PlayAudio(_THIS);
 static Uint8 *DISKAUD_GetAudioBuf(_THIS);
 static void DISKAUD_CloseAudio(_THIS);
+#else
+static int DISKAUD_OpenAudio(_THIS, SDL_AudioSpec *spec, struct SDLBase *SDLBase);
+static void DISKAUD_WaitAudio(_THIS, struct SDLBase *SDLBase);
+static void DISKAUD_PlayAudio(_THIS, struct SDLBase *SDLBase);
+static Uint8 *DISKAUD_GetAudioBuf(_THIS, struct SDLBase *SDLBase);
+static void DISKAUD_CloseAudio(_THIS, struct SDLBase *SDLBase);
+#endif
 
 static const char *DISKAUD_GetOutputFilename(void)
 {
@@ -60,7 +73,11 @@
 }
 
 /* Audio driver bootstrap functions */
+#if !defined(PROTO_SDL_H)
 static int DISKAUD_Available(void)
+#else
+static int DISKAUD_Available(struct SDLBase *SDLBase)
+#endif
 {
 	const char *envr = SDL_getenv("SDL_AUDIODRIVER");
 	if (envr && (SDL_strcmp(envr, DISKAUD_DRIVER_NAME) == 0)) {
@@ -69,13 +86,21 @@
 	return(0);
 }
 
+#if !defined(PROTO_SDL_H)
 static void DISKAUD_DeleteDevice(SDL_AudioDevice *device)
+#else
+static void DISKAUD_DeleteDevice(SDL_AudioDevice *device, struct SDLBase *SDLBase)
+#endif
 {
 	SDL_free(device->hidden);
 	SDL_free(device);
 }
 
+#if !defined(PROTO_SDL_H)
 static SDL_AudioDevice *DISKAUD_CreateDevice(int devindex)
+#else
+static SDL_AudioDevice *DISKAUD_CreateDevice(int devindex, struct SDLBase *SDLBase)
+#endif
 {
 	SDL_AudioDevice *this;
 	const char *envr;
@@ -117,12 +142,20 @@
 };
 
 /* This function waits until it is possible to write a full sound buffer */
+#if !defined(PROTO_SDL_H)
 static void DISKAUD_WaitAudio(_THIS)
+#else
+static void DISKAUD_WaitAudio(_THIS, struct SDLBase *SDLBase)
+#endif
 {
 	SDL_Delay(this->hidden->write_delay);
 }
 
+#if !defined(PROTO_SDL_H)
 static void DISKAUD_PlayAudio(_THIS)
+#else
+static void DISKAUD_PlayAudio(_THIS, struct SDLBase *SDLBase)
+#endif
 {
 	int written;
 
@@ -140,12 +173,20 @@
 #endif
 }
 
+#if !defined(PROTO_SDL_H)
 static Uint8 *DISKAUD_GetAudioBuf(_THIS)
+#else
+static Uint8 *DISKAUD_GetAudioBuf(_THIS, struct SDLBase *SDLBase)
+#endif
 {
 	return(this->hidden->mixbuf);
 }
 
+#if !defined(PROTO_SDL_H)
 static void DISKAUD_CloseAudio(_THIS)
+#else
+static void DISKAUD_CloseAudio(_THIS, struct SDLBase *SDLBase)
+#endif
 {
 	if ( this->hidden->mixbuf != NULL ) {
 		SDL_FreeAudioMem(this->hidden->mixbuf);
@@ -157,7 +198,11 @@
 	}
 }
 
+#if !defined(PROTO_SDL_H)
 static int DISKAUD_OpenAudio(_THIS, SDL_AudioSpec *spec)
+#else
+static int DISKAUD_OpenAudio(_THIS, SDL_AudioSpec *spec, struct SDLBase *SDLBase)
+#endif
 {
 	const char *fname = DISKAUD_GetOutputFilename();
 
diff -Naur SDL-1.2.15-orig/src/audio/dummy/SDL_dummyaudio.c SDL-1.2.15/src/audio/dummy/SDL_dummyaudio.c
--- SDL-1.2.15-orig/src/audio/dummy/SDL_dummyaudio.c	2015-05-09 17:47:54.350774118 +0200
+++ SDL-1.2.15/src/audio/dummy/SDL_dummyaudio.c	2015-05-09 15:09:59.754739534 +0200
@@ -21,6 +21,11 @@
 
     This file written by Ryan C. Gordon (icculus@icculus.org)
 */
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
 #include "SDL_config.h"
 
 /* Output audio to nowhere... */
@@ -37,14 +42,28 @@
 #define DUMMYAUD_DRIVER_NAME         "dummy"
 
 /* Audio driver functions */
+#if !defined(PROTO_SDL_H)
 static int DUMMYAUD_OpenAudio(_THIS, SDL_AudioSpec *spec);
 static void DUMMYAUD_WaitAudio(_THIS);
 static void DUMMYAUD_PlayAudio(_THIS);
 static Uint8 *DUMMYAUD_GetAudioBuf(_THIS);
 static void DUMMYAUD_CloseAudio(_THIS);
+#else
+#include "SDL_intern.h"
+
+static int DUMMYAUD_OpenAudio(_THIS, SDL_AudioSpec *spec, struct SDLBase *SDLBase);
+static void DUMMYAUD_WaitAudio(_THIS, struct SDLBase *SDLBase);
+static void DUMMYAUD_PlayAudio(_THIS, struct SDLBase *SDLBase);
+static Uint8 *DUMMYAUD_GetAudioBuf(_THIS, struct SDLBase *SDLBase);
+static void DUMMYAUD_CloseAudio(_THIS, struct SDLBase *SDLBase);
+#endif
 
 /* Audio driver bootstrap functions */
+#if !defined(PROTO_SDL_H)
 static int DUMMYAUD_Available(void)
+#else
+static int DUMMYAUD_Available(struct SDLBase *SDLBase)
+#endif
 {
 	const char *envr = SDL_getenv("SDL_AUDIODRIVER");
 	if (envr && (SDL_strcmp(envr, DUMMYAUD_DRIVER_NAME) == 0)) {
@@ -53,13 +72,21 @@
 	return(0);
 }
 
+#if !defined(PROTO_SDL_H)
 static void DUMMYAUD_DeleteDevice(SDL_AudioDevice *device)
+#else
+static void DUMMYAUD_DeleteDevice(SDL_AudioDevice *device, struct SDLBase *SDLBase)
+#endif
 {
 	SDL_free(device->hidden);
 	SDL_free(device);
 }
 
+#if !defined(PROTO_SDL_H)
 static SDL_AudioDevice *DUMMYAUD_CreateDevice(int devindex)
+#else
+static SDL_AudioDevice *DUMMYAUD_CreateDevice(int devindex, struct SDLBase *SDLBase)
+#endif
 {
 	SDL_AudioDevice *this;
 
@@ -97,7 +124,11 @@
 };
 
 /* This function waits until it is possible to write a full sound buffer */
+#if !defined(PROTO_SDL_H)
 static void DUMMYAUD_WaitAudio(_THIS)
+#else
+static void DUMMYAUD_WaitAudio(_THIS, struct SDLBase *SDLBase)
+#endif
 {
 	/* Don't block on first calls to simulate initial fragment filling. */
 	if (this->hidden->initial_calls)
@@ -106,17 +137,29 @@
 		SDL_Delay(this->hidden->write_delay);
 }
 
+#if !defined(PROTO_SDL_H)
 static void DUMMYAUD_PlayAudio(_THIS)
+#else
+static void DUMMYAUD_PlayAudio(_THIS, struct SDLBase *SDLBase)
+#endif
 {
 	/* no-op...this is a null driver. */
 }
 
+#if !defined(PROTO_SDL_H)
 static Uint8 *DUMMYAUD_GetAudioBuf(_THIS)
+#else
+static Uint8 *DUMMYAUD_GetAudioBuf(_THIS, struct SDLBase *SDLBase)
+#endif
 {
 	return(this->hidden->mixbuf);
 }
 
+#if !defined(PROTO_SDL_H)
 static void DUMMYAUD_CloseAudio(_THIS)
+#else
+static void DUMMYAUD_CloseAudio(_THIS, struct SDLBase *SDLBase)
+#endif
 {
 	if ( this->hidden->mixbuf != NULL ) {
 		SDL_FreeAudioMem(this->hidden->mixbuf);
@@ -124,7 +167,11 @@
 	}
 }
 
+#if !defined(PROTO_SDL_H)
 static int DUMMYAUD_OpenAudio(_THIS, SDL_AudioSpec *spec)
+#else
+static int DUMMYAUD_OpenAudio(_THIS, SDL_AudioSpec *spec, struct SDLBase *SDLBase)
+#endif
 {
 	float bytes_per_sec = 0.0f;
 
diff -Naur SDL-1.2.15-orig/src/audio/SDL_audio.c SDL-1.2.15/src/audio/SDL_audio.c
--- SDL-1.2.15-orig/src/audio/SDL_audio.c	2015-05-09 17:47:54.352774113 +0200
+++ SDL-1.2.15/src/audio/SDL_audio.c	2015-05-09 15:09:59.754739534 +0200
@@ -19,6 +19,12 @@
     Sam Lantinga
     slouken@libsdl.org
 */
+
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
 #include "SDL_config.h"
 
 /* Allow access to a raw mixing buffer */
@@ -113,27 +119,68 @@
 #if SDL_AUDIO_DRIVER_EPOCAUDIO
 	&EPOCAudio_bootstrap,
 #endif
+#if SDL_AUDIO_DRIVER_AHI
+	&AHI_bootstrap,
+#endif
 	NULL
 };
+#if !defined(PROTO_SDL_H)
 SDL_AudioDevice *current_audio = NULL;
-
+#if SDL_AUDIO_DRIVER_AHI
+Uint32 has_obtained_spec;
+static int format_idx;
+static int format_idx_sub;
+#endif
 /* Various local functions */
 int SDL_AudioInit(const char *driver_name);
 void SDL_AudioQuit(void);
+#else
+#include "SDL_intern.h"
+#define current_audio SDLBase->current_audio
+#define has_obtained_spec SDLBase->has_obtained_spec
+#define format_idx SDLBase->format_idx
+#define format_idx_sub SDLBase->format_idx_sub
+#endif
+
+#define NUM_FORMATS	6
+static Uint16 format_list[NUM_FORMATS][NUM_FORMATS] = {
+ { AUDIO_U8, AUDIO_S8, AUDIO_S16LSB, AUDIO_S16MSB, AUDIO_U16LSB, AUDIO_U16MSB },
+ { AUDIO_S8, AUDIO_U8, AUDIO_S16LSB, AUDIO_S16MSB, AUDIO_U16LSB, AUDIO_U16MSB },
+ { AUDIO_S16LSB, AUDIO_S16MSB, AUDIO_U16LSB, AUDIO_U16MSB, AUDIO_U8, AUDIO_S8 },
+ { AUDIO_S16MSB, AUDIO_S16LSB, AUDIO_U16MSB, AUDIO_U16LSB, AUDIO_U8, AUDIO_S8 },
+ { AUDIO_U16LSB, AUDIO_U16MSB, AUDIO_S16LSB, AUDIO_S16MSB, AUDIO_U8, AUDIO_S8 },
+ { AUDIO_U16MSB, AUDIO_U16LSB, AUDIO_S16MSB, AUDIO_S16LSB, AUDIO_U8, AUDIO_S8 },
+};
 
 /* The general mixing thread function */
+#if !defined(PROTO_SDL_H)
 int SDLCALL SDL_RunAudio(void *audiop)
+#else
+int SDLCALL SDL_RunAudio(struct SDLBase *SDLBase)
+#endif
 {
+#if !defined(PROTO_SDL_H)
 	SDL_AudioDevice *audio = (SDL_AudioDevice *)audiop;
+#else
+        SDL_AudioDevice *audio = current_audio;
+#endif
 	Uint8 *stream;
 	int    stream_len;
 	void  *udata;
+#if !defined(PROTO_SDL_H)
 	void (SDLCALL *fill)(void *userdata,Uint8 *stream, int len);
+#else
+	void (SDLCALL *fill)(void *userdata,Uint8 *stream, int len, struct Library *SDLBase);
+#endif
 	int    silence;
 
 	/* Perform any thread setup */
 	if ( audio->ThreadInit ) {
+#if !defined(PROTO_SDL_H)
 		audio->ThreadInit(audio);
+#else
+		audio->ThreadInit(audio, SDLBase);
+#endif
 	}
 	audio->threadid = SDL_ThreadID();
 
@@ -185,7 +232,11 @@
 				continue;
 			}
 		} else {
+#if !defined(PROTO_SDL_H)
 			stream = audio->GetAudioBuf(audio);
+#else
+			stream = audio->GetAudioBuf(audio, SDLBase);
+#endif
 			if ( stream == NULL ) {
 				stream = audio->fake_stream;
 			}
@@ -195,14 +246,22 @@
 
 		if ( ! audio->paused ) {
 			SDL_mutexP(audio->mixer_lock);
+#if !defined(PROTO_SDL_H)
 			(*fill)(udata, stream, stream_len);
+#else
+			(*fill)(udata, stream, stream_len, (struct Library *)SDLBase);
+#endif
 			SDL_mutexV(audio->mixer_lock);
 		}
 
 		/* Convert the audio if necessary */
 		if ( audio->convert.needed ) {
 			SDL_ConvertAudio(&audio->convert);
+#if !defined(PROTO_SDL_H)
 			stream = audio->GetAudioBuf(audio);
+#else
+			stream = audio->GetAudioBuf(audio, SDLBase);
+#endif
 			if ( stream == NULL ) {
 				stream = audio->fake_stream;
 			}
@@ -212,20 +271,32 @@
 
 		/* Ready current buffer for play and change current buffer */
 		if ( stream != audio->fake_stream ) {
+#if !defined(PROTO_SDL_H)
 			audio->PlayAudio(audio);
+#else
+			audio->PlayAudio(audio, SDLBase);
+#endif
 		}
 
 		/* Wait for an audio buffer to become available */
 		if ( stream == audio->fake_stream ) {
 			SDL_Delay((audio->spec.samples*1000)/audio->spec.freq);
 		} else {
+#if !defined(PROTO_SDL_H)
 			audio->WaitAudio(audio);
+#else
+			audio->WaitAudio(audio, SDLBase);
+#endif
 		}
 	}
 
 	/* Wait for the audio to drain.. */
 	if ( audio->WaitDone ) {
+#if !defined(PROTO_SDL_H)
 		audio->WaitDone(audio);
+#else
+		audio->WaitDone(audio, SDLBase);
+#endif
 	}
 
 #ifdef __OS2__
@@ -236,7 +307,11 @@
 	return(0);
 }
 
+#if !defined(PROTO_SDL_H)
 static void SDL_LockAudio_Default(SDL_AudioDevice *audio)
+#else
+static void SDL_LockAudio_Default(SDL_AudioDevice *audio, struct SDLBase *SDLBase)
+#endif
 {
 	if ( audio->thread && (SDL_ThreadID() == audio->threadid) ) {
 		return;
@@ -244,7 +319,11 @@
 	SDL_mutexP(audio->mixer_lock);
 }
 
+#if !defined(PROTO_SDL_H)
 static void SDL_UnlockAudio_Default(SDL_AudioDevice *audio)
+#else
+static void SDL_UnlockAudio_Default(SDL_AudioDevice *audio, struct SDLBase *SDLBase)
+#endif
 {
 	if ( audio->thread && (SDL_ThreadID() == audio->threadid) ) {
 		return;
@@ -297,8 +376,16 @@
 	return format;
 }
 
+#if !defined(PROTO_SDL_H)
 int SDL_AudioInit(const char *driver_name)
 {
+#else
+AROS_LH1(int, SDL_AudioInit,
+	AROS_LHA(const char *, driver_name, A0),
+	struct SDLBase *, SDLBase, 125, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	SDL_AudioDevice *audio;
 	int i = 0, idx;
 
@@ -349,16 +436,26 @@
 #endif
 			for ( i=0; bootstrap[i]; ++i ) {
 				if (SDL_strcasecmp(bootstrap[i]->name, driver_name) == 0) {
+#if !defined(PROTO_SDL_H)
 					if ( bootstrap[i]->available() ) {
 						audio=bootstrap[i]->create(idx);
+#else
+					if ( bootstrap[i]->available(SDLBase) ) {
+						audio=bootstrap[i]->create(idx, SDLBase);
+#endif
 						break;
 					}
 				}
 			}
 		} else {
 			for ( i=0; bootstrap[i]; ++i ) {
+#if !defined(PROTO_SDL_H)
 				if ( bootstrap[i]->available() ) {
 					audio = bootstrap[i]->create(idx);
+#else
+				if ( bootstrap[i]->available(SDLBase) ) {
+					audio = bootstrap[i]->create(idx, SDLBase);
+#endif
 					if ( audio != NULL ) {
 						break;
 					}
@@ -383,19 +480,43 @@
 		}
 	}
 	return(0);
+#if defined(PROTO_SDL_H)
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 char *SDL_AudioDriverName(char *namebuf, int maxlen)
 {
+#else
+AROS_LH2(char *, SDL_AudioDriverName,
+	AROS_LHA(char *, namebuf, A0),
+	AROS_LHA(int, maxlen, D0),
+	struct SDLBase *, SDLBase, 126, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	if ( current_audio != NULL ) {
 		SDL_strlcpy(namebuf, current_audio->name, maxlen);
 		return(namebuf);
 	}
 	return(NULL);
+#if defined(PROTO_SDL_H)
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 int SDL_OpenAudio(SDL_AudioSpec *desired, SDL_AudioSpec *obtained)
 {
+#else
+AROS_LH2(int, SDL_OpenAudio,
+	AROS_LHA(SDL_AudioSpec *, desired, A0),
+	AROS_LHA(SDL_AudioSpec *, obtained, A1),
+	struct SDLBase *, SDLBase, 128, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	SDL_AudioDevice *audio;
 	const char *env;
 
@@ -494,9 +615,14 @@
 	audio->convert.needed = 0;
 	audio->enabled = 1;
 	audio->paused  = 1;
-
+#ifdef ENABLE_AHI
+	has_obtained_spec = obtained ? 1 : 0;
+#endif
+#if !defined(PROTO_SDL_H)
 	audio->opened = audio->OpenAudio(audio, &audio->spec)+1;
-
+#else
+	audio->opened = audio->OpenAudio(audio, &audio->spec, SDLBase)+1;
+#endif
 	if ( ! audio->opened ) {
 		SDL_CloseAudio();
 		return(-1);
@@ -552,7 +678,11 @@
 #undef SDL_CreateThread
 			audio->thread = SDL_CreateThread(SDL_RunAudio, audio, NULL, NULL);
 #else
+#if !defined(PROTO_SDL_H)
 			audio->thread = SDL_CreateThread(SDL_RunAudio, audio);
+#else
+			audio->thread = SDL_CreateThread(SDL_RunAudio, SDLBase);
+#endif
 #endif
 			if ( audio->thread == NULL ) {
 				SDL_CloseAudio();
@@ -567,10 +697,20 @@
 	}
 
 	return(0);
+#if defined(PROTO_SDL_H)
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 SDL_audiostatus SDL_GetAudioStatus(void)
 {
+#else
+AROS_LH0(SDL_audiostatus, SDL_GetAudioStatus,
+	struct SDLBase *, SDLBase, 129, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	SDL_AudioDevice *audio = current_audio;
 	SDL_audiostatus status;
 
@@ -583,44 +723,103 @@
 		}
 	}
 	return(status);
+#if defined(PROTO_SDL_H)
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 void SDL_PauseAudio (int pause_on)
 {
+#else
+AROS_LH1(void, SDL_PauseAudio,
+	AROS_LHA(int, pause_on, D0),
+	struct SDLBase *, SDLBase, 130, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	SDL_AudioDevice *audio = current_audio;
 
 	if ( audio ) {
 		audio->paused = pause_on;
 	}
+#if defined(PROTO_SDL_H)
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 void SDL_LockAudio (void)
 {
+#else
+AROS_LH0(void, SDL_LockAudio,
+	struct SDLBase *, SDLBase, 137, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	SDL_AudioDevice *audio = current_audio;
 
 	/* Obtain a lock on the mixing buffers */
 	if ( audio && audio->LockAudio ) {
+#if !defined(PROTO_SDL_H)
 		audio->LockAudio(audio);
+#else
+		audio->LockAudio(audio, SDLBase);
+#endif
 	}
+#if defined(PROTO_SDL_H)
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 void SDL_UnlockAudio (void)
 {
+#else
+AROS_LH0(void, SDL_UnlockAudio,
+	struct SDLBase *, SDLBase, 138, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	SDL_AudioDevice *audio = current_audio;
 
 	/* Release lock on the mixing buffers */
 	if ( audio && audio->UnlockAudio ) {
+#if !defined(PROTO_SDL_H)
 		audio->UnlockAudio(audio);
+#else
+		audio->UnlockAudio(audio, SDLBase);
+#endif
 	}
+#if defined(PROTO_SDL_H)
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 void SDL_CloseAudio (void)
 {
+#else
+AROS_LH0(void, SDL_CloseAudio,
+	struct SDLBase *, SDLBase, 139, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	SDL_QuitSubSystem(SDL_INIT_AUDIO);
+#if defined(PROTO_SDL_H)
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 void SDL_AudioQuit(void)
 {
+#else
+AROS_LH0(void, SDL_AudioQuit,
+	struct SDLBase *, SDLBase, 127, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	SDL_AudioDevice *audio = current_audio;
 
 	if ( audio ) {
@@ -639,28 +838,31 @@
 
 		}
 		if ( audio->opened ) {
+#if !defined(PROTO_SDL_H)
 			audio->CloseAudio(audio);
+#else
+			audio->CloseAudio(audio, SDLBase);
+#endif
 			audio->opened = 0;
 		}
 		/* Free the driver data */
+#if !defined(PROTO_SDL_H)
 		audio->free(audio);
+#else
+		audio->free(audio, SDLBase);
+#endif
 		current_audio = NULL;
 	}
+#if defined(PROTO_SDL_H)
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
-#define NUM_FORMATS	6
-static int format_idx;
-static int format_idx_sub;
-static Uint16 format_list[NUM_FORMATS][NUM_FORMATS] = {
- { AUDIO_U8, AUDIO_S8, AUDIO_S16LSB, AUDIO_S16MSB, AUDIO_U16LSB, AUDIO_U16MSB },
- { AUDIO_S8, AUDIO_U8, AUDIO_S16LSB, AUDIO_S16MSB, AUDIO_U16LSB, AUDIO_U16MSB },
- { AUDIO_S16LSB, AUDIO_S16MSB, AUDIO_U16LSB, AUDIO_U16MSB, AUDIO_U8, AUDIO_S8 },
- { AUDIO_S16MSB, AUDIO_S16LSB, AUDIO_U16MSB, AUDIO_U16LSB, AUDIO_U8, AUDIO_S8 },
- { AUDIO_U16LSB, AUDIO_U16MSB, AUDIO_S16LSB, AUDIO_S16MSB, AUDIO_U8, AUDIO_S8 },
- { AUDIO_U16MSB, AUDIO_U16LSB, AUDIO_S16MSB, AUDIO_S16LSB, AUDIO_U8, AUDIO_S8 },
-};
-
+#if !defined(PROTO_SDL_H)
 Uint16 SDL_FirstAudioFormat(Uint16 format)
+#else
+Uint16 SDL_FirstAudioFormatI(Uint16 format, struct SDLBase *SDLBase)
+#endif
 {
 	for ( format_idx=0; format_idx < NUM_FORMATS; ++format_idx ) {
 		if ( format_list[format_idx][0] == format ) {
@@ -671,7 +873,11 @@
 	return(SDL_NextAudioFormat());
 }
 
+#if !defined(PROTO_SDL_H)
 Uint16 SDL_NextAudioFormat(void)
+#else
+Uint16 SDL_NextAudioFormatI(struct SDLBase *SDLBase)
+#endif
 {
 	if ( (format_idx == NUM_FORMATS) || (format_idx_sub == NUM_FORMATS) ) {
 		return(0);
@@ -694,10 +900,25 @@
 	spec->size *= spec->samples;
 }
 
+#if !defined(PROTO_SDL_H)
 void SDL_Audio_SetCaption(const char *caption)
 {
+#else
+AROS_LH1(void, SDL_Audio_SetCaption,
+	AROS_LHA(const char *, caption, A0),
+	struct SDLBase *, SDLBase, 131, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	if ((current_audio) && (current_audio->SetCaption)) {
+#if !defined(PROTO_SDL_H)
 		current_audio->SetCaption(current_audio, caption);
+#else
+		current_audio->SetCaption(current_audio, caption, SDLBase);
+#endif
 	}
+#if defined(PROTO_SDL_H)
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
diff -Naur SDL-1.2.15-orig/src/audio/SDL_audio_c.h SDL-1.2.15/src/audio/SDL_audio_c.h
--- SDL-1.2.15-orig/src/audio/SDL_audio_c.h	2015-05-09 17:47:54.324774187 +0200
+++ SDL-1.2.15/src/audio/SDL_audio_c.h	2015-05-09 15:09:59.754739534 +0200
@@ -23,6 +23,8 @@
 
 /* Functions and variables exported from SDL_audio.c for SDL_sysaudio.c */
 
+/* The actual mixing thread function */
+#if !defined(PROTO_SDL_H)
 /* Functions to get a list of "close" audio formats */
 extern Uint16 SDL_FirstAudioFormat(Uint16 format);
 extern Uint16 SDL_NextAudioFormat(void);
@@ -30,6 +32,16 @@
 /* Function to calculate the size and silence for a SDL_AudioSpec */
 extern void SDL_CalculateAudioSpec(SDL_AudioSpec *spec);
 
-/* The actual mixing thread function */
 extern int SDLCALL SDL_RunAudio(void *audiop);
+#else
+#include "SDL_intern.h"
+extern Uint16 SDL_FirstAudioFormatI(Uint16 format, struct SDLBase *SDLBase);
+extern Uint16 SDL_NextAudioFormatI(struct SDLBase *SDLBase);
+extern void SDL_CalculateAudioSpec(SDL_AudioSpec *spec);
+extern int SDLCALL SDL_RunAudio(struct SDLBase *SDLBase);
+
+#define SDL_FirstAudioFormat(format) SDL_FirstAudioFormatI(format, SDLBase)
+#define SDL_NextAudioFormat() SDL_NextAudioFormatI(SDLBase)
+#endif
+
 
diff -Naur SDL-1.2.15-orig/src/audio/SDL_audiocvt.c SDL-1.2.15/src/audio/SDL_audiocvt.c
--- SDL-1.2.15-orig/src/audio/SDL_audiocvt.c	2015-05-09 17:47:54.352774113 +0200
+++ SDL-1.2.15/src/audio/SDL_audiocvt.c	2015-05-09 15:09:59.755739532 +0200
@@ -19,6 +19,11 @@
     Sam Lantinga
     slouken@libsdl.org
 */
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
 #include "SDL_config.h"
 
 /* Functions for audio drivers to perform runtime conversion of audio format */
@@ -27,7 +32,14 @@
 
 
 /* Effectively mix right and left channels into a single channel */
+#if !defined(PROTO_SDL_H)
 void SDLCALL SDL_ConvertMono(SDL_AudioCVT *cvt, Uint16 format)
+#else
+#include "SDL_intern.h"
+
+#define SDL_ConvertMono SDL_ConvertMonoI
+void SDLCALL SDL_ConvertMonoI(SDL_AudioCVT *cvt, Uint16 format, struct Library *SDLBase)
+#endif
 {
 	int i;
 	Sint32 sample;
@@ -129,12 +141,21 @@
 	}
 	cvt->len_cvt /= 2;
 	if ( cvt->filters[++cvt->filter_index] ) {
+#if !defined(PROTO_SDL_H)
 		cvt->filters[cvt->filter_index](cvt, format);
+#else
+		cvt->filters[cvt->filter_index](cvt, format, SDLBase);
+#endif
 	}
 }
 
 /* Discard top 4 channels */
+#if !defined(PROTO_SDL_H)
 void SDLCALL SDL_ConvertStrip(SDL_AudioCVT *cvt, Uint16 format)
+#else
+#define SDL_ConvertStrip SDL_ConvertStripI
+void SDLCALL SDL_ConvertStripI(SDL_AudioCVT *cvt, Uint16 format, struct Library *SDLBase)
+#endif
 {
 	int i;
 	Sint32 lsample, rsample;
@@ -244,13 +265,22 @@
 	}
 	cvt->len_cvt /= 3;
 	if ( cvt->filters[++cvt->filter_index] ) {
+#if !defined(PROTO_SDL_H)
 		cvt->filters[cvt->filter_index](cvt, format);
+#else
+		cvt->filters[cvt->filter_index](cvt, format, SDLBase);
+#endif
 	}
 }
 
 
 /* Discard top 2 channels of 6 */
+#if !defined(PROTO_SDL_H)
 void SDLCALL SDL_ConvertStrip_2(SDL_AudioCVT *cvt, Uint16 format)
+#else
+#define SDL_ConvertStrip_2 SDL_ConvertStrip_2I
+void SDLCALL SDL_ConvertStrip_2I(SDL_AudioCVT *cvt, Uint16 format, struct Library *SDLBase)
+#endif
 {
 	int i;
 	Sint32 lsample, rsample;
@@ -360,12 +390,21 @@
 	}
 	cvt->len_cvt /= 2;
 	if ( cvt->filters[++cvt->filter_index] ) {
+#if !defined(PROTO_SDL_H)
 		cvt->filters[cvt->filter_index](cvt, format);
+#else
+		cvt->filters[cvt->filter_index](cvt, format, SDLBase);
+#endif
 	}
 }
 
 /* Duplicate a mono channel to both stereo channels */
+#if !defined(PROTO_SDL_H)
 void SDLCALL SDL_ConvertStereo(SDL_AudioCVT *cvt, Uint16 format)
+#else
+#define SDL_ConvertStereo SDL_ConvertStereoI
+void SDLCALL SDL_ConvertStereoI(SDL_AudioCVT *cvt, Uint16 format, struct Library *SDLBase)
+#endif
 {
 	int i;
 
@@ -397,13 +436,22 @@
 	}
 	cvt->len_cvt *= 2;
 	if ( cvt->filters[++cvt->filter_index] ) {
+#if !defined(PROTO_SDL_H)
 		cvt->filters[cvt->filter_index](cvt, format);
+#else
+		cvt->filters[cvt->filter_index](cvt, format, SDLBase);
+#endif
 	}
 }
 
 
 /* Duplicate a stereo channel to a pseudo-5.1 stream */
+#if !defined(PROTO_SDL_H)
 void SDLCALL SDL_ConvertSurround(SDL_AudioCVT *cvt, Uint16 format)
+#else
+#define SDL_ConvertSurround SDL_ConvertSurroundI
+void SDLCALL SDL_ConvertSurroundI(SDL_AudioCVT *cvt, Uint16 format, struct Library *SDLBase)
+#endif
 {
 	int i;
 
@@ -574,13 +622,22 @@
 	}
 	cvt->len_cvt *= 3;
 	if ( cvt->filters[++cvt->filter_index] ) {
+#if !defined(PROTO_SDL_H)
 		cvt->filters[cvt->filter_index](cvt, format);
+#else
+		cvt->filters[cvt->filter_index](cvt, format, SDLBase);
+#endif
 	}
 }
 
 
 /* Duplicate a stereo channel to a pseudo-4.0 stream */
+#if !defined(PROTO_SDL_H)
 void SDLCALL SDL_ConvertSurround_4(SDL_AudioCVT *cvt, Uint16 format)
+#else
+#define SDL_ConvertSurround_4 SDL_ConvertSurround_4I
+void SDLCALL SDL_ConvertSurround_4I(SDL_AudioCVT *cvt, Uint16 format, struct Library *SDLBase)
+#endif
 {
 	int i;
 
@@ -727,13 +784,22 @@
 	}
 	cvt->len_cvt *= 2;
 	if ( cvt->filters[++cvt->filter_index] ) {
+#if !defined(PROTO_SDL_H)
 		cvt->filters[cvt->filter_index](cvt, format);
+#else
+		cvt->filters[cvt->filter_index](cvt, format, SDLBase);
+#endif
 	}
 }
 
 
 /* Convert 8-bit to 16-bit - LSB */
+#if !defined(PROTO_SDL_H)
 void SDLCALL SDL_Convert16LSB(SDL_AudioCVT *cvt, Uint16 format)
+#else
+#define SDL_Convert16LSB SDL_Convert16LSBI
+void SDLCALL SDL_Convert16LSBI(SDL_AudioCVT *cvt, Uint16 format, struct Library *SDLBase)
+#endif
 {
 	int i;
 	Uint8 *src, *dst;
@@ -752,11 +818,20 @@
 	format = ((format & ~0x0008) | AUDIO_U16LSB);
 	cvt->len_cvt *= 2;
 	if ( cvt->filters[++cvt->filter_index] ) {
+#if !defined(PROTO_SDL_H)
 		cvt->filters[cvt->filter_index](cvt, format);
+#else
+		cvt->filters[cvt->filter_index](cvt, format, SDLBase);
+#endif
 	}
 }
 /* Convert 8-bit to 16-bit - MSB */
+#if !defined(PROTO_SDL_H)
 void SDLCALL SDL_Convert16MSB(SDL_AudioCVT *cvt, Uint16 format)
+#else
+#define SDL_Convert16MSB SDL_Convert16MSBI
+void SDLCALL SDL_Convert16MSBI(SDL_AudioCVT *cvt, Uint16 format, struct Library *SDLBase)
+#endif
 {
 	int i;
 	Uint8 *src, *dst;
@@ -775,12 +850,21 @@
 	format = ((format & ~0x0008) | AUDIO_U16MSB);
 	cvt->len_cvt *= 2;
 	if ( cvt->filters[++cvt->filter_index] ) {
+#if !defined(PROTO_SDL_H)
 		cvt->filters[cvt->filter_index](cvt, format);
+#else
+		cvt->filters[cvt->filter_index](cvt, format, SDLBase);
+#endif
 	}
 }
 
 /* Convert 16-bit to 8-bit */
+#if !defined(PROTO_SDL_H)
 void SDLCALL SDL_Convert8(SDL_AudioCVT *cvt, Uint16 format)
+#else
+#define SDL_Convert8 SDL_Convert8I
+void SDLCALL SDL_Convert8I(SDL_AudioCVT *cvt, Uint16 format, struct Library *SDLBase)
+#endif
 {
 	int i;
 	Uint8 *src, *dst;
@@ -801,12 +885,21 @@
 	format = ((format & ~0x9010) | AUDIO_U8);
 	cvt->len_cvt /= 2;
 	if ( cvt->filters[++cvt->filter_index] ) {
+#if !defined(PROTO_SDL_H)
 		cvt->filters[cvt->filter_index](cvt, format);
+#else
+		cvt->filters[cvt->filter_index](cvt, format, SDLBase);
+#endif
 	}
 }
 
 /* Toggle signed/unsigned */
+#if !defined(PROTO_SDL_H)
 void SDLCALL SDL_ConvertSign(SDL_AudioCVT *cvt, Uint16 format)
+#else
+#define SDL_ConvertSign SDL_ConvertSignI
+void SDLCALL SDL_ConvertSignI(SDL_AudioCVT *cvt, Uint16 format, struct Library *SDLBase)
+#endif
 {
 	int i;
 	Uint8 *data;
@@ -830,12 +923,21 @@
 	}
 	format = (format ^ 0x8000);
 	if ( cvt->filters[++cvt->filter_index] ) {
+#if !defined(PROTO_SDL_H)
 		cvt->filters[cvt->filter_index](cvt, format);
+#else
+		cvt->filters[cvt->filter_index](cvt, format, SDLBase);
+#endif
 	}
 }
 
 /* Toggle endianness */
+#if !defined(PROTO_SDL_H)
 void SDLCALL SDL_ConvertEndian(SDL_AudioCVT *cvt, Uint16 format)
+#else
+#define SDL_ConvertEndian SDL_ConvertEndianI
+void SDLCALL SDL_ConvertEndianI(SDL_AudioCVT *cvt, Uint16 format, struct Library *SDLBase)
+#endif
 {
 	int i;
 	Uint8 *data, tmp;
@@ -852,12 +954,21 @@
 	}
 	format = (format ^ 0x1000);
 	if ( cvt->filters[++cvt->filter_index] ) {
+#if !defined(PROTO_SDL_H)
 		cvt->filters[cvt->filter_index](cvt, format);
+#else
+		cvt->filters[cvt->filter_index](cvt, format, SDLBase);
+#endif
 	}
 }
 
 /* Convert rate up by multiple of 2 */
+#if !defined(PROTO_SDL_H)
 void SDLCALL SDL_RateMUL2(SDL_AudioCVT *cvt, Uint16 format)
+#else
+#define SDL_RateMUL2 SDL_RateMUL2I
+void SDLCALL SDL_RateMUL2(SDL_AudioCVT *cvt, Uint16 format, struct Library *SDLBase)
+#endif
 {
 	int i;
 	Uint8 *src, *dst;
@@ -889,13 +1000,22 @@
 	}
 	cvt->len_cvt *= 2;
 	if ( cvt->filters[++cvt->filter_index] ) {
+#if !defined(PROTO_SDL_H)
 		cvt->filters[cvt->filter_index](cvt, format);
+#else
+		cvt->filters[cvt->filter_index](cvt, format, SDLBase);
+#endif
 	}
 }
 
 
 /* Convert rate up by multiple of 2, for stereo */
+#if !defined(PROTO_SDL_H)
 void SDLCALL SDL_RateMUL2_c2(SDL_AudioCVT *cvt, Uint16 format)
+#else
+#define SDL_RateMUL2_c2 SDL_RateMUL2_c2I
+void SDLCALL SDL_RateMUL2_c2I(SDL_AudioCVT *cvt, Uint16 format, struct Library *SDLBase)
+#endif
 {
 	int i;
 	Uint8 *src, *dst;
@@ -933,12 +1053,21 @@
 	}
 	cvt->len_cvt *= 2;
 	if ( cvt->filters[++cvt->filter_index] ) {
+#if !defined(PROTO_SDL_H)
 		cvt->filters[cvt->filter_index](cvt, format);
+#else
+		cvt->filters[cvt->filter_index](cvt, format, SDLBase);
+#endif
 	}
 }
 
 /* Convert rate up by multiple of 2, for quad */
+#if !defined(PROTO_SDL_H)
 void SDLCALL SDL_RateMUL2_c4(SDL_AudioCVT *cvt, Uint16 format)
+#else
+#define SDL_RateMUL2_c4 SDL_RateMUL2_c4I
+void SDLCALL SDL_RateMUL2_c4I(SDL_AudioCVT *cvt, Uint16 format, struct Library *SDLBase)
+#endif
 {
 	int i;
 	Uint8 *src, *dst;
@@ -988,13 +1117,22 @@
 	}
 	cvt->len_cvt *= 2;
 	if ( cvt->filters[++cvt->filter_index] ) {
+#if !defined(PROTO_SDL_H)
 		cvt->filters[cvt->filter_index](cvt, format);
+#else
+		cvt->filters[cvt->filter_index](cvt, format, SDLBase);
+#endif
 	}
 }
 
 
 /* Convert rate up by multiple of 2, for 5.1 */
+#if !defined(PROTO_SDL_H)
 void SDLCALL SDL_RateMUL2_c6(SDL_AudioCVT *cvt, Uint16 format)
+#else
+#define SDL_RateMUL2_c6 SDL_RateMUL2_c6I
+void SDLCALL SDL_RateMUL2_c6I(SDL_AudioCVT *cvt, Uint16 format, struct Library *SDLBase)
+#endif
 {
 	int i;
 	Uint8 *src, *dst;
@@ -1056,12 +1194,21 @@
 	}
 	cvt->len_cvt *= 2;
 	if ( cvt->filters[++cvt->filter_index] ) {
+#if !defined(PROTO_SDL_H)
 		cvt->filters[cvt->filter_index](cvt, format);
+#else
+		cvt->filters[cvt->filter_index](cvt, format, SDLBase);
+#endif
 	}
 }
 
 /* Convert rate down by multiple of 2 */
+#if !defined(PROTO_SDL_H)
 void SDLCALL SDL_RateDIV2(SDL_AudioCVT *cvt, Uint16 format)
+#else
+#define SDL_RateDIV2 SDL_RateDIV2I
+void SDLCALL SDL_RateDIV2I(SDL_AudioCVT *cvt, Uint16 format, struct Library *SDLBase)
+#endif
 {
 	int i;
 	Uint8 *src, *dst;
@@ -1090,13 +1237,22 @@
 	}
 	cvt->len_cvt /= 2;
 	if ( cvt->filters[++cvt->filter_index] ) {
+#if !defined(PROTO_SDL_H)
 		cvt->filters[cvt->filter_index](cvt, format);
+#else
+		cvt->filters[cvt->filter_index](cvt, format, SDLBase);
+#endif
 	}
 }
 
 
 /* Convert rate down by multiple of 2, for stereo */
+#if !defined(PROTO_SDL_H)
 void SDLCALL SDL_RateDIV2_c2(SDL_AudioCVT *cvt, Uint16 format)
+#else
+#define SDL_RateDIV2_c2 SDL_RateDIV2_c2I
+void SDLCALL SDL_RateDIV2_c2I(SDL_AudioCVT *cvt, Uint16 format, struct Library *SDLBase)
+#endif
 {
 	int i;
 	Uint8 *src, *dst;
@@ -1128,13 +1284,22 @@
 	}
 	cvt->len_cvt /= 2;
 	if ( cvt->filters[++cvt->filter_index] ) {
+#if !defined(PROTO_SDL_H)
 		cvt->filters[cvt->filter_index](cvt, format);
+#else
+		cvt->filters[cvt->filter_index](cvt, format, SDLBase);
+#endif
 	}
 }
 
 
 /* Convert rate down by multiple of 2, for quad */
+#if !defined(PROTO_SDL_H)
 void SDLCALL SDL_RateDIV2_c4(SDL_AudioCVT *cvt, Uint16 format)
+#else
+#define SDL_RateDIV2_c4 SDL_RateDIV2_c4I
+void SDLCALL SDL_RateDIV2_c4I(SDL_AudioCVT *cvt, Uint16 format, struct Library *SDLBase)
+#endif
 {
 	int i;
 	Uint8 *src, *dst;
@@ -1172,12 +1337,21 @@
 	}
 	cvt->len_cvt /= 2;
 	if ( cvt->filters[++cvt->filter_index] ) {
+#if !defined(PROTO_SDL_H)
 		cvt->filters[cvt->filter_index](cvt, format);
+#else
+		cvt->filters[cvt->filter_index](cvt, format, SDLBase);
+#endif
 	}
 }
 
 /* Convert rate down by multiple of 2, for 5.1 */
+#if !defined(PROTO_SDL_H)
 void SDLCALL SDL_RateDIV2_c6(SDL_AudioCVT *cvt, Uint16 format)
+#else
+#define SDL_RateDIV2_c6 SDL_RateDIV2_c6I
+void SDLCALL SDL_RateDIV2_c6I(SDL_AudioCVT *cvt, Uint16 format, struct Library *SDLBase)
+#endif
 {
 	int i;
 	Uint8 *src, *dst;
@@ -1221,12 +1395,21 @@
 	}
 	cvt->len_cvt /= 2;
 	if ( cvt->filters[++cvt->filter_index] ) {
+#if !defined(PROTO_SDL_H)
 		cvt->filters[cvt->filter_index](cvt, format);
+#else
+		cvt->filters[cvt->filter_index](cvt, format, SDLBase);
+#endif
 	}
 }
 
 /* Very slow rate conversion routine */
+#if !defined(PROTO_SDL_H)
 void SDLCALL SDL_RateSLOW(SDL_AudioCVT *cvt, Uint16 format)
+#else
+#define SDL_RateSLOW SDL_RateSLOWI
+void SDLCALL SDL_RateSLOWI(SDL_AudioCVT *cvt, Uint16 format, struct Library *SDLBase)
+#endif
 {
 	double ipos;
 	int i, clen;
@@ -1296,12 +1479,24 @@
 	}
 	cvt->len_cvt = clen;
 	if ( cvt->filters[++cvt->filter_index] ) {
+#if !defined(PROTO_SDL_H)
 		cvt->filters[cvt->filter_index](cvt, format);
+#else
+		cvt->filters[cvt->filter_index](cvt, format, SDLBase);
+#endif
 	}
 }
 
+#if !defined(PROTO_SDL_H)
 int SDL_ConvertAudio(SDL_AudioCVT *cvt)
 {
+#else
+AROS_LH1(int, SDL_ConvertAudio,
+	AROS_LHA(SDL_AudioCVT *, cvt, A0),
+	struct Library *, SDLBase, 135, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	/* Make sure there's data to convert */
 	if ( cvt->buf == NULL ) {
 		SDL_SetError("No buffer allocated for conversion");
@@ -1315,8 +1510,15 @@
 
 	/* Set up the conversion and go! */
 	cvt->filter_index = 0;
+#if !defined(PROTO_SDL_H)
 	cvt->filters[0](cvt, cvt->src_format);
+#else
+	cvt->filters[0](cvt, cvt->src_format, SDLBase);
+#endif
 	return(0);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 /* Creates a set of audio filters to convert from one format to another. 
@@ -1324,10 +1526,24 @@
    audio filter is set up.
 */
   
+#if !defined(PROTO_SDL_H)
 int SDL_BuildAudioCVT(SDL_AudioCVT *cvt,
 	Uint16 src_format, Uint8 src_channels, int src_rate,
 	Uint16 dst_format, Uint8 dst_channels, int dst_rate)
 {
+#else
+AROS_LH7(int, SDL_BuildAudioCVT,
+	AROS_LHA(SDL_AudioCVT *, cvt, A0),
+	AROS_LHA(Uint16, src_format, D0),
+	AROS_LHA(Uint8, src_channels, D1),
+	AROS_LHA(int, src_rate, D2),
+	AROS_LHA(Uint16, dst_format, D3),
+	AROS_LHA(Uint8, dst_channels, D4),
+	AROS_LHA(int, dst_rate, D5),
+	struct SDLBase *, SDLBase, 134, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 /*printf("Build format %04x->%04x, channels %u->%u, rate %d->%d\n",
 		src_format, dst_format, src_channels, dst_channels, src_rate, dst_rate);*/
 	/* Start off with no conversion necessary */
@@ -1439,7 +1655,11 @@
 		Uint32 hi_rate, lo_rate;
 		int len_mult;
 		double len_ratio;
+#if !defined(PROTO_SDL_H)
 		void (SDLCALL *rate_cvt)(SDL_AudioCVT *cvt, Uint16 format);
+#else
+		void (SDLCALL *rate_cvt)(SDL_AudioCVT *cvt, Uint16 format, struct Library *SDLBase);
+#endif
 
 		if ( src_rate > dst_rate ) {
 			hi_rate = src_rate;
@@ -1507,4 +1727,7 @@
 		cvt->filters[cvt->filter_index] = NULL;
 	}
 	return(cvt->needed);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
diff -Naur SDL-1.2.15-orig/src/audio/SDL_audiodev.c SDL-1.2.15/src/audio/SDL_audiodev.c
--- SDL-1.2.15-orig/src/audio/SDL_audiodev.c	2015-05-09 17:47:54.324774187 +0200
+++ SDL-1.2.15/src/audio/SDL_audiodev.c	2015-05-09 15:09:59.755739532 +0200
@@ -19,6 +19,11 @@
     Sam Lantinga
     slouken@libsdl.org
 */
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
 #include "SDL_config.h"
 
 /* Get the name of the audio device we use for output */
diff -Naur SDL-1.2.15-orig/src/audio/SDL_mixer.c SDL-1.2.15/src/audio/SDL_mixer.c
--- SDL-1.2.15-orig/src/audio/SDL_mixer.c	2015-05-09 17:47:54.352774113 +0200
+++ SDL-1.2.15/src/audio/SDL_mixer.c	2015-05-09 15:09:59.756739531 +0200
@@ -19,6 +19,11 @@
     Sam Lantinga
     slouken@libsdl.org
 */
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
 #include "SDL_config.h"
 
 /* This provides the default mixing callback for the SDL audio routines */
@@ -31,6 +36,12 @@
 #include "SDL_mixer_MMX_VC.h"
 #include "SDL_mixer_m68k.h"
 
+#if defined(PROTO_SDL_H)        
+#include "SDL_intern.h"
+
+#define current_audio SDLBase->current_audio
+#endif
+
 /* This table is used to add two sound values together and pin
  * the value to avoid overflow.  (used with permission from ARDI)
  * Changed to use 0xFE instead of 0xFF for better sound quality.
@@ -90,8 +101,19 @@
 #define ADJUST_VOLUME(s, v)	(s = (s*v)/SDL_MIX_MAXVOLUME)
 #define ADJUST_VOLUME_U8(s, v)	(s = (((s-128)*v)/SDL_MIX_MAXVOLUME)+128)
 
+#if !defined(PROTO_SDL_H)
 void SDL_MixAudio (Uint8 *dst, const Uint8 *src, Uint32 len, int volume)
 {
+#else
+AROS_LH4(void, SDL_MixAudio,
+	AROS_LHA(Uint8 *, dst, A0),
+	AROS_LHA(Uint8 *, src, A1),
+	AROS_LHA(Uint32, len, D0),
+	AROS_LHA(int, volume, D1),
+	struct SDLBase *, SDLBase, 136, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	Uint16 format;
 
 	if ( volume == 0 ) {
@@ -260,5 +282,8 @@
 			SDL_SetError("SDL_MixAudio(): unknown audio format");
 			return;
 	}
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
diff -Naur SDL-1.2.15-orig/src/audio/SDL_mixer_m68k.c SDL-1.2.15/src/audio/SDL_mixer_m68k.c
--- SDL-1.2.15-orig/src/audio/SDL_mixer_m68k.c	2015-05-09 17:47:54.352774113 +0200
+++ SDL-1.2.15/src/audio/SDL_mixer_m68k.c	2015-05-09 15:09:59.756739531 +0200
@@ -19,6 +19,11 @@
     Sam Lantinga
     slouken@libsdl.org
 */
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
 #include "SDL_config.h"
 
 /*
diff -Naur SDL-1.2.15-orig/src/audio/SDL_mixer_MMX.c SDL-1.2.15/src/audio/SDL_mixer_MMX.c
--- SDL-1.2.15-orig/src/audio/SDL_mixer_MMX.c	2015-05-09 17:47:54.350774118 +0200
+++ SDL-1.2.15/src/audio/SDL_mixer_MMX.c	2015-05-09 15:09:59.756739531 +0200
@@ -19,6 +19,11 @@
     Sam Lantinga
     slouken@libsdl.org
 */
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
 #include "SDL_config.h"
 
 /*
diff -Naur SDL-1.2.15-orig/src/audio/SDL_sysaudio.h SDL-1.2.15/src/audio/SDL_sysaudio.h
--- SDL-1.2.15-orig/src/audio/SDL_sysaudio.h	2015-05-09 17:47:54.324774187 +0200
+++ SDL-1.2.15/src/audio/SDL_sysaudio.h	2015-05-09 15:09:59.756739531 +0200
@@ -27,6 +27,10 @@
 #include "SDL_mutex.h"
 #include "SDL_thread.h"
 
+#if defined(PROTO_SDL_H)
+#include "SDL_intern.h"
+#endif
+
 /* The SDL audio driver */
 typedef struct SDL_AudioDevice SDL_AudioDevice;
 
@@ -46,6 +50,7 @@
 
 	/* * * */
 	/* Public driver functions */
+#if !defined(PROTO_SDL_H)
 	int  (*OpenAudio)(_THIS, SDL_AudioSpec *spec);
 	void (*ThreadInit)(_THIS);	/* Called by audio thread at start */
 	void (*WaitAudio)(_THIS);
@@ -60,7 +65,18 @@
 	void (*UnlockAudio)(_THIS);
 
 	void (*SetCaption)(_THIS, const char *caption);
-
+#else
+	int  (*OpenAudio)(_THIS, SDL_AudioSpec *spec, struct SDLBase *SDLBase);
+	void (*ThreadInit)(_THIS, struct SDLBase *SDLBase);
+	void (*WaitAudio)(_THIS, struct SDLBase *SDLBase);
+	void (*PlayAudio)(_THIS, struct SDLBase *SDLBase);
+	Uint8 *(*GetAudioBuf)(_THIS, struct SDLBase *SDLBase);
+	void (*WaitDone)(_THIS, struct SDLBase *SDLBase);
+	void (*CloseAudio)(_THIS, struct SDLBase *SDLBase);
+	void (*LockAudio)(_THIS, struct SDLBase *SDLBase);
+	void (*UnlockAudio)(_THIS, struct SDLBase *SDLBase);
+	void (*SetCaption)(_THIS, const char *caption, struct SDLBase *SDLBase);
+#endif
 	/* * * */
 	/* Data common to all devices */
 
@@ -91,15 +107,24 @@
 
 	/* * * */
 	/* The function used to dispose of this structure */
+#if !defined(PROTO_SDL_H)
 	void (*free)(_THIS);
+#else
+	void (*free)(_THIS, struct SDLBase *SDLBase);
+#endif
 };
 #undef _THIS
 
 typedef struct AudioBootStrap {
 	const char *name;
 	const char *desc;
+#if !defined(PROTO_SDL_H)
 	int (*available)(void);
-	SDL_AudioDevice *(*create)(int devindex);
+    	SDL_AudioDevice *(*create)(int devindex);
+#else
+	int (*available)(struct SDLBase *SDLBase);
+    	SDL_AudioDevice *(*create)(int devindex, struct SDLBase *SDLBase);
+#endif
 } AudioBootStrap;
 
 #if SDL_AUDIO_DRIVER_BSD
@@ -179,8 +204,13 @@
 #if SDL_AUDIO_DRIVER_EPOCAUDIO
 extern AudioBootStrap EPOCAudio_bootstrap; 
 #endif
+#if SDL_AUDIO_DRIVER_AHI
+extern AudioBootStrap AHI_bootstrap; 
+#endif
 
 /* This is the current audio device */
+#if !defined(PROTO_SDL_H)
 extern SDL_AudioDevice *current_audio;
+#endif
 
 #endif /* _SDL_sysaudio_h */
diff -Naur SDL-1.2.15-orig/src/audio/SDL_wave.c SDL-1.2.15/src/audio/SDL_wave.c
--- SDL-1.2.15-orig/src/audio/SDL_wave.c	2015-05-09 17:47:54.352774113 +0200
+++ SDL-1.2.15/src/audio/SDL_wave.c	2015-05-09 15:09:59.756739531 +0200
@@ -19,6 +19,11 @@
     Sam Lantinga
     slouken@libsdl.org
 */
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
 #include "SDL_config.h"
 
 /* Microsoft WAVE file loading routines */
@@ -26,8 +31,14 @@
 #include "SDL_audio.h"
 #include "SDL_wave.h"
 
-
+#if !defined(PROTO_SDL_H)
 static int ReadChunk(SDL_RWops *src, Chunk *chunk);
+#else
+#include "SDL_intern.h"
+
+static int ReadChunkI(SDL_RWops *src, Chunk *chunk, struct SDLBase *SDLBase);
+#define ReadChunk(src, chunk) ReadChunkI(src, chunk, SDLBase)
+#endif
 
 struct MS_ADPCM_decodestate {
 	Uint8 hPredictor;
@@ -44,7 +55,12 @@
 	struct MS_ADPCM_decodestate state[2];
 } MS_ADPCM_state;
 
+#if !defined(PROTO_SDL_H)
 static int InitMS_ADPCM(WaveFMT *format)
+#else
+#define InitMS_ADPCM(format) InitMS_ADPCMI(format, SDLBase)
+static int InitMS_ADPCMI(WaveFMT *format, struct SDLBase *SDLBase)
+#endif
 {
 	Uint8 *rogue_feel;
 	int i;
@@ -112,7 +128,12 @@
 	return(new_sample);
 }
 
+#if !defined(PROTO_SDL_H)
 static int MS_ADPCM_decode(Uint8 **audio_buf, Uint32 *audio_len)
+#else
+#define MS_ADPCM_decode(audio_buf, audio_len) MS_ADPCM_decodeI(audio_buf, audio_len, SDLBase)
+static int MS_ADPCM_decodeI(Uint8 **audio_buf, Uint32 *audio_len, struct SDLBase *SDLBase)
+#endif
 {
 	struct MS_ADPCM_decodestate *state[2];
 	Uint8 *freeable, *encoded, *decoded;
@@ -320,7 +341,12 @@
 	}
 }
 
+#if !defined(PROTO_SDL_H)
 static int IMA_ADPCM_decode(Uint8 **audio_buf, Uint32 *audio_len)
+#else
+#define IMA_ADPCM_decode(audio_buf, audio_len) IMA_ADPCM_decodeI(audio_buf, audio_len, SDLBase)
+static int IMA_ADPCM_decodeI(Uint8 **audio_buf, Uint32 *audio_len, struct SDLBase *SDLBase)
+#endif
 {
 	struct IMA_ADPCM_decodestate *state;
 	Uint8 *freeable, *encoded, *decoded;
@@ -389,9 +415,21 @@
 	return(0);
 }
 
+#if !defined(PROTO_SDL_H)
 SDL_AudioSpec * SDL_LoadWAV_RW (SDL_RWops *src, int freesrc,
 		SDL_AudioSpec *spec, Uint8 **audio_buf, Uint32 *audio_len)
 {
+#else
+AROS_LH5(SDL_AudioSpec *, SDL_LoadWAV_RW,
+	AROS_LHA(SDL_RWops *, src, A0),
+	AROS_LHA(int, freesrc, D0),
+	AROS_LHA(SDL_AudioSpec *, spec, A1),
+	AROS_LHA(Uint8 **, audio_buf, A2),
+	AROS_LHA(Uint32 *, audio_len, A3),
+	struct SDLBase *, SDLBase, 132, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	int was_error;
 	Chunk chunk;
 	int lenread;
@@ -565,19 +603,38 @@
 		spec = NULL;
 	}
 	return(spec);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 /* Since the WAV memory is allocated in the shared library, it must also
    be freed here.  (Necessary under Win32, VC++)
  */
+#if !defined(PROTO_SDL_H)
 void SDL_FreeWAV(Uint8 *audio_buf)
 {
+#else
+AROS_LH1(void, SDL_FreeWAV,
+	AROS_LHA(Uint8 *, audio_buf, A0),
+	struct SDLBase *, SDLBase, 133, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
+
 	if ( audio_buf != NULL ) {
 		SDL_free(audio_buf);
 	}
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 static int ReadChunk(SDL_RWops *src, Chunk *chunk)
+#else
+static int ReadChunkI(SDL_RWops *src, Chunk *chunk, struct SDLBase *SDLBase)
+#endif
 {
 	chunk->magic	= SDL_ReadLE32(src);
 	chunk->length	= SDL_ReadLE32(src);
diff -Naur SDL-1.2.15-orig/src/cdrom/aros/SDL_syscdrom.c SDL-1.2.15/src/cdrom/aros/SDL_syscdrom.c
--- SDL-1.2.15-orig/src/cdrom/aros/SDL_syscdrom.c	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.15/src/cdrom/aros/SDL_syscdrom.c	2015-05-09 15:09:59.757739529 +0200
@@ -0,0 +1,635 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2004 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+
+#include <proto/exec.h>
+#include <proto/dos.h>
+
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
+/* Stub functions for system-level CD-ROM audio control */
+
+#include	<stdio.h>
+
+#include "SDL_cdrom.h"
+#include "SDL_syscdrom.h"
+
+#include	<dos/dosextens.h>
+#include	<dos/filehandler.h>
+#include	<devices/scsidisk.h>
+
+#include	<aros/macros.h>
+#include 	"../../main/aros/mydebug.h"
+
+/* Just large enought to hold TOC */
+#define	TOC_SIZE				804
+#define	SCSI_INBUF_SIZE	TOC_SIZE
+#define	SCSI_SENSE_SIZE	252
+
+#ifdef __AROS__
+#define AllocTaskPooled(x) AllocVec(x,MEMF_ANY)
+#define FreeTaskPooled(x,y) FreeVec(x)
+#endif
+
+struct MyCDROM
+{
+	char	dosname[20];
+	char	devname[108];
+	ULONG	unit;
+	ULONG	unitflags;
+
+	/* Filled in when this unit is opened	*/
+
+	struct IOStdReq	*req;
+	struct SCSICmd		scsicmd;
+	UWORD	*inbuf;
+	UBYTE	*sensebuf;
+};
+
+struct TrackInfo
+{
+	UBYTE	Pad1, Flags, TrackNumber, Pad2;
+	ULONG	Address;
+};
+
+struct CD_TOC
+{
+	UWORD	Length;
+	UBYTE	FirstTrack;
+	UBYTE	LastTrack;
+	struct TrackInfo	TOCData[100];
+};
+
+#if !defined(PROTO_SDL_H)
+UBYTE                *CDList[MAX_DRIVES];
+#else
+#include "SDL_intern.h"
+
+#define CDList SDLBase->CDList
+#endif
+/**********************************************************************
+	FindDup
+
+	Return 1 if duplicate
+**********************************************************************/
+
+static ULONG FindDup(UBYTE **cdlist, CONST_STRPTR devname, ULONG unit)
+{
+	struct MyCDROM	*entry;
+	ULONG	i;
+
+	D(bug("CDRom : FindDup\n"));
+	
+	for (i = 0; i < MAX_DRIVES; i++)
+	{
+		entry	= (struct MyCDROM *)cdlist[i];
+
+		if (entry == NULL)
+			break;
+
+		if (entry->unit == unit && strcmp(entry->devname, devname) == 0)
+			return 1;
+	}
+
+	return 0;
+}
+
+/**********************************************************************
+	CopyStringBSTRToC
+
+	Convert BCPL string to STRPTR
+**********************************************************************/
+
+LONG CopyStringBSTRToC (BSTR src, STRPTR dst, ULONG dst_size)
+{
+#ifdef __AROS__
+    STRPTR ptr = AROS_BSTR_ADDR(src);
+    ULONG ln = AROS_BSTR_strlen(src);
+#else
+    UBYTE *ptr = BADDR(src);
+    ULONG ln = *ptr++;
+#endif
+    if (ln > (dst_size-1)) ln = dst_size-1;
+    memcpy(dst, ptr, ln);
+    dst[ln] = 0;
+    return ln;
+}
+
+/**********************************************************************
+	SendCMD
+**********************************************************************/
+
+#if !defined(PROTO_SDL_H)
+static LONG SendCMD(SDL_CD *cdrom, const UBYTE *cmd, int cmdlen)
+#else
+#define SendCMD(cdrom, cmd, cmdlen) SendCMDI(cdrom, cmd, cmdlen, SDLBase)
+static LONG SendCMDI(SDL_CD *cdrom, const UBYTE *cmd, int cmdlen, struct SDLBase *SDLBase)
+#endif
+{
+	struct MyCDROM	*entry	= (struct MyCDROM *)CDList[cdrom->id];
+
+	D(bug("CDRom : SendCMD..."));
+	
+	entry->scsicmd.scsi_Data			= entry->inbuf;
+	entry->scsicmd.scsi_Length			= SCSI_INBUF_SIZE;
+	entry->scsicmd.scsi_SenseActual		= 0;
+	entry->scsicmd.scsi_SenseData		= (UBYTE *)entry->sensebuf;
+	entry->scsicmd.scsi_SenseLength		= SCSI_SENSE_SIZE;
+	entry->scsicmd.scsi_CmdActual		= 0;
+	entry->scsicmd.scsi_Command			= (UBYTE *)cmd;
+	entry->scsicmd.scsi_CmdLength		= cmdlen;
+	entry->scsicmd.scsi_Flags			= SCSIF_READ | SCSIF_AUTOSENSE;
+
+	DoIO((struct IORequest *)entry->req);
+	
+	D(bug("%s\n",entry->scsicmd.scsi_Status ? "NOK" : "OK"));
+
+	return (entry->scsicmd.scsi_Status ? -1 : 0);
+}
+
+#if !defined(PROTO_SDL_H)
+static const char *SDL_SYS_CDName(int drive)
+#else
+static const char *SDL_SYS_CDName(int drive, struct SDLBase *SDLBase)
+#endif
+{
+	D(bug("CDRom : SDL_SYS_CDName\n"));
+
+	return(CDList[drive]);
+}
+
+#if !defined(PROTO_SDL_H)
+static void SDL_DisposeCD(struct MyCDROM *entry)
+#else
+#define SDL_DisposeCD(entry) SDL_DisposeCDI(entry, SDLBase)
+static void SDL_DisposeCDI(struct MyCDROM *entry, struct SDLBase *SDLBase)
+#endif
+{
+	D(bug("CDRom : SDL_DisposeCD\n"));
+
+	DeleteIORequest((struct IORequest *)entry->req);
+
+	if (entry->inbuf)
+		FreeTaskPooled(entry->inbuf, SCSI_INBUF_SIZE);
+
+	if (entry->sensebuf)
+		FreeTaskPooled(entry->sensebuf, SCSI_SENSE_SIZE);
+
+	entry->req			= NULL;
+	entry->inbuf		= NULL;
+	entry->sensebuf	= NULL;
+}
+
+#if !defined(PROTO_SDL_H)
+static int SDL_SYS_CDOpen(int drive)
+#else
+static int SDL_SYS_CDOpen(int drive, struct SDLBase *SDLBase)
+#endif
+{
+	struct MyCDROM	*entry;
+	struct MsgPort	*port;
+
+	D(bug("CDRom : SDL_SYS_CDOpen\n"));
+
+        if ((drive >= 0) && (drive < MAX_DRIVES))
+        {
+            /* Yay! Use DOS message port :-) */
+
+            entry	= (struct MyCDROM *)CDList[drive];
+            port	= &((struct Process *)FindTask(NULL))->pr_MsgPort;
+
+            if ((entry->req = CreateIORequest(port, sizeof(struct IOStdReq))) != NULL)
+            {
+                    if ((entry->inbuf		= AllocTaskPooled(SCSI_INBUF_SIZE)) != NULL)
+                    if ((entry->sensebuf	= AllocTaskPooled(SCSI_SENSE_SIZE)) != NULL)
+                    if (OpenDevice(entry->devname, entry->unit, (struct IORequest *)entry->req, entry->unitflags) == 0)
+                    {
+                            entry->req->io_Command	= HD_SCSICMD;
+                            entry->req->io_Data		= (APTR)&entry->scsicmd;
+                            entry->req->io_Length	= sizeof(struct SCSICmd);
+
+                            return drive;
+                    }
+
+                    SDL_DisposeCD(entry);
+            }
+        }
+	return -1;
+}
+
+#if !defined(PROTO_SDL_H)
+static void SDL_SYS_CDClose(SDL_CD *cdrom)
+#else
+static void SDL_SYS_CDClose(SDL_CD *cdrom, struct SDLBase *SDLBase)
+#endif
+{
+	struct MyCDROM	*entry	= (struct MyCDROM *)CDList[cdrom->id];
+
+	D(bug("CDRom : SDL_SYS_CDClose\n"));
+
+	
+	if (entry && entry->req)
+	{
+		CloseDevice((struct IORequest *)entry->req);
+		SDL_DisposeCD(entry);
+	}
+}
+
+#if !defined(PROTO_SDL_H)
+static int SDL_SYS_CDGetTOC(SDL_CD *cdrom)
+#else
+static int SDL_SYS_CDGetTOC(SDL_CD *cdrom, struct SDLBase *SDLBase)
+#endif
+{
+	static const UBYTE	Cmd[10] =
+		{ 0x43, 0, 0, 0, 0, 0, 0, TOC_SIZE >> 8, TOC_SIZE & 0xff, 0 };
+	int	okay;
+
+	D(bug("CDRom : SDL_SYS_CDGetTOC\n"));
+	
+	okay	= 0;
+
+	if (SendCMD(cdrom, Cmd, sizeof(Cmd)) == 0)
+	{
+		struct MyCDROM	*entry	= (struct MyCDROM *)CDList[cdrom->id];
+		struct CD_TOC	*toc;
+		int	i;
+
+		toc	= (struct CD_TOC *)entry->inbuf;
+		
+		D(bug("TOC : length = %d, First Track = %d, Last Track = %d\n",AROS_BE2WORD(toc->Length), toc->FirstTrack, toc->LastTrack));
+
+		cdrom->numtracks = toc->LastTrack - toc->FirstTrack + 1;
+
+		if ( cdrom->numtracks > SDL_MAX_TRACKS ) {
+			cdrom->numtracks = SDL_MAX_TRACKS;
+		}
+		
+		D(bug("Found %d tracks\n",cdrom->numtracks));
+
+		/* Read all the track TOC entries */
+
+		okay	= 1;
+
+		for ( i=0; i<cdrom->numtracks; ++i )
+		{
+			cdrom->track[i].id = i+1;
+
+			D(bug("Track %d :",i));
+			D(bug("%02X, %02X, %02X, %02X\t",toc->TOCData[i].Pad1, toc->TOCData[i].Flags, toc->TOCData[i].TrackNumber, toc->TOCData[i].Pad2));
+
+			if (toc->TOCData[i].Flags & 0x04)
+			{
+				cdrom->track[i].type	= SDL_DATA_TRACK;
+				D(bug("\tDATA\t"));
+			}
+			else
+			{
+				cdrom->track[i].type	= SDL_AUDIO_TRACK;
+				D(bug("\tAUDIO\t"));
+			}
+
+			cdrom->track[i].offset		= AROS_BE2LONG(toc->TOCData[i].Address);
+
+			if (i == cdrom->numtracks)
+			{
+				cdrom->track[i].length	= 0;
+				D(bug("length : %d\n",0));
+			}
+			else
+			{
+				cdrom->track[i].length		= AROS_BE2LONG(toc->TOCData[i+1].Address) - cdrom->track[i].offset;
+				D(bug("length : %d\n",cdrom->track[i].length));
+			}
+		}
+	}
+
+	return(okay ? 0 : -1);
+}
+
+
+#if !defined(PROTO_SDL_H)
+static CDstatus SDL_SYS_CDStatus(SDL_CD *cdrom, int *position)
+#else
+static CDstatus SDL_SYS_CDStatus(SDL_CD *cdrom, int *position, struct SDLBase *SDLBase)
+#endif
+{
+	static const UBYTE	Cmd[10]	=
+		{ 0x42, 0, 0x40, 0x01, 0, 0, 0, SCSI_INBUF_SIZE >> 8, SCSI_INBUF_SIZE & 0xff, 0 };
+	CDstatus	status;
+
+	D(bug("CDRom : SDL_SYS_CDStatus\n"));
+
+	status	= CD_ERROR;
+
+	if (SendCMD(cdrom, Cmd, sizeof(Cmd)) == 0)
+	{
+		struct MyCDROM	*entry	= (struct MyCDROM *)CDList[cdrom->id];
+		UBYTE	*buf;
+		
+		buf	= (UBYTE *)entry->inbuf;
+
+		D(bug("CDRom : Status : %02X,%02X\n", buf[0],buf[1]));
+		
+		switch (buf[1])
+		{
+			case 0x11: 	status	= CD_PLAYING;	break;
+			case 0x12: 	status	= CD_PAUSED;	break;
+			case 0x13: 	status	= CD_STOPPED;	break;
+			case 0x14: 	status	= CD_ERROR;	break;
+			default:	status	= CD_STOPPED;	break;
+		}
+
+	}
+
+	return status;
+}
+
+#if !defined(PROTO_SDL_H)
+static int SDL_SYS_CDPlay(SDL_CD *cdrom, int start, int length)
+#else
+static int SDL_SYS_CDPlay(SDL_CD *cdrom, int start, int length, struct SDLBase *SDLBase)
+#endif
+{
+	UBYTE	Cmd[12]	= { 0xa5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+	UWORD	*tmp		= (UWORD *)Cmd;
+
+	D(bug("CDRom : SDL_SYS_CDPlay\n"));
+
+	tmp[1]	= AROS_BE2WORD(start >> 16);
+	tmp[2]	= AROS_BE2WORD(start);
+	tmp[3]	= AROS_BE2WORD(length >> 16);
+	tmp[4]	= AROS_BE2WORD(length);
+
+	SendCMD(cdrom, Cmd, sizeof(Cmd));
+	return 0;
+}
+
+#if !defined(PROTO_SDL_H)
+static int SDL_SYS_CDPause(SDL_CD *cdrom)
+#else
+static int SDL_SYS_CDPause(SDL_CD *cdrom, struct SDLBase *SDLBase)
+#endif
+{
+	static const UBYTE	Cmd[10] =
+		{ 0x4b, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+
+	D(bug("CDRom : SDL_SYS_CDPause\n"));
+
+	SendCMD(cdrom, Cmd, sizeof(Cmd));
+	return 0;
+}
+
+#if !defined(PROTO_SDL_H)
+static int SDL_SYS_CDResume(SDL_CD *cdrom)
+#else
+static int SDL_SYS_CDResume(SDL_CD *cdrom, struct SDLBase *SDLBase)
+#endif
+{
+	static const UBYTE Cmd[10] = { 0x4b, 0, 0, 0, 0, 0, 0, 0, 1, 0 };
+
+	D(bug("CDRom : SDL_SYS_CDResume\n"));
+
+	SendCMD(cdrom, Cmd, sizeof(Cmd));
+	return 0;
+}
+
+#if !defined(PROTO_SDL_H)
+static int SDL_SYS_CDStop(SDL_CD *cdrom)
+#else
+static int SDL_SYS_CDStop(SDL_CD *cdrom, struct SDLBase *SDLBase)
+#endif
+{
+	static const UBYTE Cmd[10] = { 0x4e, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+
+	D(bug("CDRom : SDL_SYS_CDStop\n"));
+
+	SendCMD(cdrom, Cmd, sizeof(Cmd));
+	return 0;
+}
+
+#if !defined(PROTO_SDL_H)
+static int SDL_SYS_CDEject(SDL_CD *cdrom)
+#else
+static int SDL_SYS_CDEject(SDL_CD *cdrom, struct SDLBase *SDLBase)
+#endif
+{
+	static const UBYTE	Cmd[6] =
+		{ 0x1b, 0, 0, 0, 0x02, 0 };
+
+	D(bug("CDRom : SDL_SYS_CDEject\n"));
+   
+	SendCMD(cdrom, (UBYTE *)Cmd, sizeof(Cmd));
+	return 0;
+}
+
+#if !defined(PROTO_SDL_H)
+int  SDL_SYS_CDInit(void)
+#else
+int  SDL_SYS_CDInitI(struct SDLBase *SDLBase)
+#endif
+{
+	struct DosList	*dlist;
+	ULONG	devices;
+	UBYTE	**cdlist;
+
+	D(bug("CDRom : SDL_SYS_CDInit\n"));
+
+	cdlist	= CDList;
+	devices	= 0;
+	SDL_numcds = 0;
+
+	SDL_CDcaps.Name 	= SDL_SYS_CDName;
+	SDL_CDcaps.Open 	= SDL_SYS_CDOpen;
+	SDL_CDcaps.GetTOC 	= SDL_SYS_CDGetTOC;
+	SDL_CDcaps.Status 	= SDL_SYS_CDStatus;
+	SDL_CDcaps.Play 	= SDL_SYS_CDPlay;
+	SDL_CDcaps.Pause 	= SDL_SYS_CDPause;
+	SDL_CDcaps.Resume 	= SDL_SYS_CDResume;
+	SDL_CDcaps.Stop 	= SDL_SYS_CDStop;
+	SDL_CDcaps.Eject 	= SDL_SYS_CDEject;
+	SDL_CDcaps.Close 	= SDL_SYS_CDClose;
+
+	dlist	= LockDosList(LDF_DEVICES|LDF_READ);
+
+	while ((dlist = NextDosEntry(dlist, LDF_DEVICES|LDF_READ)) != NULL && devices < MAX_DRIVES)
+	{
+		struct FileSysStartupMsg	*startup;
+		CONST_STRPTR	devname;
+		ULONG	devnamelen;
+		
+		startup = BADDR(dlist->dol_misc.dol_handler.dol_Startup);
+		if ((IPTR) startup > 0x400 &&
+		    (startup->fssm_Unit & 0xff000000) == 0 &&
+		     startup->fssm_Device && startup->fssm_Environ)
+		{
+
+			if ((devname = BADDR(startup->fssm_Device)) != NULL)
+			{
+				if ((devnamelen	= CopyStringBSTRToC((BSTR)devname, (STRPTR)devname, 108)) != 0)
+				{
+					if (FindDup(cdlist, devname, startup->fssm_Unit) == 0)
+					{
+						struct MyCDROM	*entry;
+
+						if ((entry =  AllocTaskPooled(sizeof(*entry))) != NULL)
+						{
+							CONST_STRPTR	dosname;
+							ULONG	dosnamelen;
+
+							dosname		= (CONST_STRPTR)BADDR(dlist->dol_Name);
+							dosnamelen	= CopyStringBSTRToC((BSTR)dosname, (STRPTR)dosname, 20);
+
+							entry->unit			= startup->fssm_Unit;
+							entry->unitflags	= startup->fssm_Flags;
+
+							memcpy(entry->dosname, dosname, dosnamelen);
+							memcpy(entry->devname, devname, devnamelen);
+
+							entry->dosname[ dosnamelen ]	= '\0';
+							entry->devname[ devnamelen ]	= '\0';
+
+							D(bug("CDRom : devname : %s, dosname %s\n",entry->devname,entry->dosname));
+
+							entry->req			= NULL;
+							entry->inbuf		= NULL;
+							entry->sensebuf		= NULL;
+
+							cdlist[devices] = (char *)entry;
+							devices++;
+						}
+					}
+				}
+			}
+		}
+	}
+
+	UnLockDosList(LDF_DEVICES|LDF_READ);
+
+	if (devices)
+	{
+		struct IOStdReq	*req;
+		struct SCSICmd		*scsicmd;
+		struct MsgPort	*port;
+		ULONG	i;
+		UBYTE	*inbuf, *sensebuf;
+
+		port	= &((struct Process *)FindTask(NULL))->pr_MsgPort;
+
+		if ((req = CreateIORequest(port, sizeof(struct IOStdReq))) != NULL)
+		{
+			if ((inbuf = AllocTaskPooled(SCSI_INBUF_SIZE)) != NULL)
+			{
+				if ((sensebuf = AllocTaskPooled(SCSI_SENSE_SIZE)) != NULL)
+				{
+					if ((scsicmd = (struct SCSICmd *)AllocTaskPooled(sizeof(*scsicmd))) != NULL)
+					{
+						req->io_Command	= HD_SCSICMD;
+						req->io_Data		= (APTR)scsicmd;
+						req->io_Length	= sizeof(struct SCSICmd);
+
+						for (i = 0; i < MAX_DRIVES; i++)
+						{
+							struct MyCDROM	*entry;
+							ULONG	is_cdrom;
+
+							entry	= (struct MyCDROM *)cdlist[i];
+
+							if (entry == NULL)
+								break;
+
+							is_cdrom	= 0;
+
+							if (OpenDevice(entry->devname, entry->unit, (struct IORequest *)req, entry->unitflags) == 0)
+							{
+								static const UBYTE	Cmd[]	= { 0x12, 0, 0, 0, 252, 0 };
+
+								scsicmd->scsi_Data			= (UWORD *)inbuf;
+								scsicmd->scsi_Length			= SCSI_INBUF_SIZE;
+								scsicmd->scsi_SenseActual	= 0;
+								scsicmd->scsi_SenseData		= sensebuf;
+								scsicmd->scsi_SenseLength	= SCSI_SENSE_SIZE;
+								scsicmd->scsi_CmdActual		= 0;
+								scsicmd->scsi_Command		= (UBYTE *)Cmd;
+								scsicmd->scsi_CmdLength		= sizeof(Cmd);
+								scsicmd->scsi_Flags			= SCSIF_READ | SCSIF_AUTOSENSE;
+
+								DoIO((struct IORequest *)req);
+
+								if (scsicmd->scsi_Status == 0 && req->io_Error == 0)
+								{
+									/* 5 is for CDROM (maybe not proper checking) */
+									/* Must be removable as well*/
+
+									D(
+									{
+										int i;
+										for (i=0;i<2;i++) bug("inbuf[%d] : %04X\n", i, inbuf[i]);
+									}
+									)
+									
+									if (((inbuf[0] & 0x05) == 5) && (inbuf[1] & 0x80))
+										is_cdrom	= 1;
+								}
+								D(else bug("CDRom : DoIO error\n"));
+
+								CloseDevice((struct IORequest *)req);
+							}
+
+							if (is_cdrom == 0)
+							{
+								devices--;
+								cdlist[i]	= cdlist[devices];
+							}
+							else 
+							{
+								SDL_numcds++;
+								D(bug("CDRom detected\n"));
+							}
+						}
+
+						FreeTaskPooled(scsicmd, sizeof(*scsicmd));
+					}
+
+					FreeTaskPooled(sensebuf, SCSI_SENSE_SIZE);
+				}
+
+				FreeTaskPooled(inbuf, SCSI_INBUF_SIZE);
+			}
+
+			DeleteIORequest((struct IORequest *)req);
+		}
+	}
+
+	return(0);
+}
+
+#if !defined(PROTO_SDL_H)
+void SDL_SYS_CDQuit(void)
+#else
+void SDL_SYS_CDQuitI(struct SDLBase *SDLBase)
+#endif
+{
+	D(bug("CDRom : SDL_SYS_CDQuit\n"));
+}
diff -Naur SDL-1.2.15-orig/src/cdrom/aros/SDL_syscdrom.h SDL-1.2.15/src/cdrom/aros/SDL_syscdrom.h
--- SDL-1.2.15-orig/src/cdrom/aros/SDL_syscdrom.h	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.15/src/cdrom/aros/SDL_syscdrom.h	2015-05-09 15:09:59.757739529 +0200
@@ -0,0 +1,107 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2004 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+
+#if defined(PROTO_SDL_H)
+#include "SDL_intern.h"
+#endif
+
+/* This is the system specific header for the SDL CD-ROM API */
+
+#ifndef MAX_DRIVES
+#define	MAX_DRIVES	32
+#endif
+
+/* Structure of CD audio control functions */
+extern struct CDcaps {
+#if !defined(PROTO_SDL_H)
+	/* Get the name of the specified drive */
+	const char *(*Name)(int drive);
+
+	/* Open the specified drive, returning a drive id, or -1 on error */
+	int (*Open)(int drive);
+
+	/* Get table-of-contents (number of tracks + track info) for disk.
+	   The TOC information should be stored in the cdrom structure.
+	   This function should return 0 on success, or -1 on error.
+	 */
+	int (*GetTOC)(SDL_CD *cdrom);
+
+	/* Return the current status and play position, in frames, of the
+	   drive.  'position' may be NULL, and if so, should be ignored.
+	 */
+	CDstatus (*Status)(SDL_CD *cdrom, int *position);
+
+	/* Play from frame 'start' to 'start+len' */
+	int (*Play)(SDL_CD *cdrom, int start, int len); 
+
+	/* Pause play */
+	int (*Pause)(SDL_CD *cdrom);
+
+	/* Resume play */
+	int (*Resume)(SDL_CD *cdrom);
+
+	/* Stop play */
+	int (*Stop)(SDL_CD *cdrom);
+
+	/* Eject the current disk */
+	int (*Eject)(SDL_CD *cdrom);
+
+	/* Close the specified drive */
+	void (*Close)(SDL_CD *cdrom);
+#else
+    	const char *(*Name)(int drive, struct SDLBase *SDLBase);
+	int (*Open)(int drive, struct SDLBase *SDLBase);
+	int (*GetTOC)(SDL_CD *cdrom, struct SDLBase *SDLBase);
+	CDstatus (*Status)(SDL_CD *cdrom, int *position, struct SDLBase *SDLBase);
+	int (*Play)(SDL_CD *cdrom, int start, int len, struct SDLBase *SDLBase); 
+	int (*Pause)(SDL_CD *cdrom, struct SDLBase *SDLBase);
+	int (*Resume)(SDL_CD *cdrom, struct SDLBase *SDLBase);
+	int (*Stop)(SDL_CD *cdrom, struct SDLBase *SDLBase);
+	int (*Eject)(SDL_CD *cdrom, struct SDLBase *SDLBase);
+	void (*Close)(SDL_CD *cdrom, struct SDLBase *SDLBase);
+#endif
+} SDL_CDcaps;
+
+#if !defined(PROTO_SDL_H)
+/* The number of available CD-ROM drives on the system */
+extern int SDL_numcds;
+
+/* Function to scan the system for CD-ROM drives and fill SDL_CDcaps.
+ * This function should set SDL_numcds to the number of available CD
+ * drives.  Drive 0 should be the system default CD-ROM.
+ * It should return 0, or -1 on an unrecoverable fatal error.
+*/
+extern int  SDL_SYS_CDInit(void);
+
+/* Function to perform any system-specific CD-ROM related cleanup */
+extern void SDL_SYS_CDQuit(void);
+#else
+extern int  SDL_SYS_CDInitI(struct SDLBase *SDLBase);
+extern void SDL_SYS_CDQuitI(struct SDLBase *SDLBase);
+
+#define SDL_SYS_CDInit() SDL_SYS_CDInitI(SDLBase)
+#define SDL_SYS_CDQuit() SDL_SYS_CDQuitI(SDLBase)
+
+#ifndef SDL_numcds
+#define SDL_numcds SDLBase->SDL_numcds
+#endif
+#endif
diff -Naur SDL-1.2.15-orig/src/cdrom/SDL_cdrom.c SDL-1.2.15/src/cdrom/SDL_cdrom.c
--- SDL-1.2.15-orig/src/cdrom/SDL_cdrom.c	2015-05-09 17:47:54.311774220 +0200
+++ SDL-1.2.15/src/cdrom/SDL_cdrom.c	2015-05-09 15:09:59.757739529 +0200
@@ -19,6 +19,12 @@
     Sam Lantinga
     slouken@libsdl.org
 */
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#include "SDL_intern.h"
+#endif
+
 #include "SDL_config.h"
 
 /* This is the CD-audio control API for Simple DirectMedia Layer */
@@ -30,9 +36,6 @@
 #define CLIP_FRAMES	10	/* Some CD-ROMs won't go all the way */
 #endif
 
-static int SDL_cdinitted = 0;
-static SDL_CD *default_cdrom;
-
 /* The system level CD-ROM control functions */
 struct CDcaps SDL_CDcaps = {
 	NULL,					/* Name */
@@ -46,9 +49,26 @@
 	NULL,					/* Eject */
 	NULL,					/* Close */
 };
+
+#if !defined(PROTO_SDL_H)
+static int SDL_cdinitted = 0;
+static SDL_CD *default_cdrom;
 int SDL_numcds;
+#else
+#include "SDL_intern.h"
 
+#define SDL_cdinitted SDLBase->SDL_cdinitted
+#define default_cdrom SDLBase->default_cdrom
+#ifndef SDL_numcds
+#define SDL_numcds SDLBase->SDL_numcds
+#endif
+#endif
+
+#if !defined(PROTO_SDL_H)
 int SDL_CDROMInit(void)
+#else
+int SDL_CDROMInitI(struct SDLBase *SDLBase)
+#endif
 {
 	int retval;
 
@@ -62,7 +82,12 @@
 }
 
 /* Check to see if the CD-ROM subsystem has been initialized */
+#if !defined(PROTO_SDL_H)
 static int CheckInit(int check_cdrom, SDL_CD **cdrom)
+#else
+#define CheckInit(check_cdrom, cdrom) CheckInitI(check_cdrom, cdrom, SDLBase)
+static int CheckInitI(int check_cdrom, SDL_CD **cdrom, struct SDLBase *SDLBase)
+#endif
 {
 	int okay;
 
@@ -80,16 +105,34 @@
 	return(okay);
 }
 
+#if !defined(PROTO_SDL_H)
 int SDL_CDNumDrives(void)
 {
+#else
+AROS_LH0(int, SDL_CDNumDrives,
+	struct SDLBase *, SDLBase, 146, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	if ( ! CheckInit(0, NULL) ) {
 		return(-1);
 	}
 	return(SDL_numcds);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 const char *SDL_CDName(int drive)
 {
+#else
+AROS_LH1(const char *, SDL_CDName,
+	AROS_LHA(int, drive, D0),
+	struct SDLBase *, SDLBase, 147, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	if ( ! CheckInit(0, NULL) ) {
 		return(NULL);
 	}
@@ -98,14 +141,29 @@
 		return(NULL);
 	}
 	if ( SDL_CDcaps.Name ) {
+#if !defined(PROTO_SDL_H)
 		return(SDL_CDcaps.Name(drive));
+#else
+		return(SDL_CDcaps.Name(drive, SDLBase));
+#endif
 	} else {
 		return("");
 	}
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 SDL_CD *SDL_CDOpen(int drive)
 {
+#else
+AROS_LH1(SDL_CD *, SDL_CDOpen,
+	AROS_LHA(int, drive, D0),
+	struct SDLBase *, SDLBase, 148, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	struct SDL_CD *cdrom;
 
 	if ( ! CheckInit(0, NULL) ) {
@@ -121,17 +179,32 @@
 		return(NULL);
 	}
 	SDL_memset(cdrom, 0, sizeof(*cdrom));
+#if !defined(PROTO_SDL_H)
 	cdrom->id = SDL_CDcaps.Open(drive);
+#else
+	cdrom->id = SDL_CDcaps.Open(drive, SDLBase);
+#endif
 	if ( cdrom->id < 0 ) {
 		SDL_free(cdrom);
 		return(NULL);
 	}
 	default_cdrom = cdrom;
 	return(cdrom);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 CDstatus SDL_CDStatus(SDL_CD *cdrom)
 {
+#else
+AROS_LH1(CDstatus, SDL_CDStatus,
+	AROS_LHA(SDL_CD *, cdrom, A0),
+	struct SDLBase *, SDLBase, 149, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	CDstatus status;
 	int i;
 	Uint32 position;
@@ -145,13 +218,21 @@
 	cdrom->numtracks = 0;
 	cdrom->cur_track = 0;
 	cdrom->cur_frame = 0;
+#if !defined(PROTO_SDL_H)
 	status = SDL_CDcaps.Status(cdrom, &i);
+#else
+	status = SDL_CDcaps.Status(cdrom, &i, SDLBase);
+#endif
 	position = (Uint32)i;
 	cdrom->status = status;
 
 	/* Get the table of contents, if there's a CD available */
 	if ( CD_INDRIVE(status) ) {
+#if !defined(PROTO_SDL_H)
 		if ( SDL_CDcaps.GetTOC(cdrom) < 0 ) {
+#else
+		if ( SDL_CDcaps.GetTOC(cdrom, SDLBase) < 0 ) {
+#endif
 			status = CD_ERROR;
 		}
 		/* If the drive is playing, get current play position */
@@ -169,11 +250,26 @@
 		}
 	}
 	return(status);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 int SDL_CDPlayTracks(SDL_CD *cdrom,
 			int strack, int sframe, int ntracks, int nframes)
 {
+#else
+AROS_LH5(int, SDL_CDPlayTracks,
+	AROS_LHA(SDL_CD *, cdrom, A0),
+	AROS_LHA(int, strack, D0),
+	AROS_LHA(int, sframe, D1),
+	AROS_LHA(int, ntracks, D2),
+	AROS_LHA(int, nframes, D3),
+	struct SDLBase *, SDLBase, 151, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	int etrack, eframe;
 	int start, length;
 
@@ -236,21 +332,50 @@
 #ifdef DEBUG_CDROM
   fprintf(stderr, "Playing %d frames at offset %d\n", length, start);
 #endif
+#if !defined(PROTO_SDL_H)
 	return(SDL_CDcaps.Play(cdrom, start, length));
+#else
+	return(SDL_CDcaps.Play(cdrom, start, length, SDLBase));
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 int SDL_CDPlay(SDL_CD *cdrom, int sframe, int length)
 {
+#else
+AROS_LH3(int, SDL_CDPlay,
+	AROS_LHA(SDL_CD *, cdrom, A0),
+	AROS_LHA(int, sframe, D0),
+	AROS_LHA(int, length, D1),
+	struct SDLBase *, SDLBase, 150, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	/* Check if the CD-ROM subsystem has been initialized */
 	if ( ! CheckInit(1, &cdrom) ) {
 		return(CD_ERROR);
 	}
 
+#if !defined(PROTO_SDL_H)
 	return(SDL_CDcaps.Play(cdrom, sframe, length));
+#else
+	return(SDL_CDcaps.Play(cdrom, sframe, length, SDLBase));
+
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 int SDL_CDPause(SDL_CD *cdrom)
 {
+#else
+AROS_LH1(int, SDL_CDPause,
+	AROS_LHA(SDL_CD *, cdrom, A0),
+	struct SDLBase *, SDLBase, 152, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	CDstatus status;
 	int retval;
 
@@ -259,20 +384,39 @@
 		return(CD_ERROR);
 	}
 
+#if !defined(PROTO_SDL_H)
 	status = SDL_CDcaps.Status(cdrom, NULL);
+#else
+	status = SDL_CDcaps.Status(cdrom, NULL, SDLBase);
+#endif
 	switch (status) {
 		case CD_PLAYING:
+#if !defined(PROTO_SDL_H)
 			retval = SDL_CDcaps.Pause(cdrom);
+#else
+			retval = SDL_CDcaps.Pause(cdrom, SDLBase);
+#endif
 			break;
 		default:
 			retval = 0;
 			break;
 	}
 	return(retval);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 int SDL_CDResume(SDL_CD *cdrom)
 {
+#else
+AROS_LH1(int, SDL_CDResume,
+	AROS_LHA(SDL_CD *, cdrom, A0),
+	struct SDLBase *, SDLBase, 153, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	CDstatus status;
 	int retval;
 
@@ -281,19 +425,38 @@
 		return(CD_ERROR);
 	}
 
+#if !defined(PROTO_SDL_H)
 	status = SDL_CDcaps.Status(cdrom, NULL);
+#else
+	status = SDL_CDcaps.Status(cdrom, NULL, SDLBase);
+#endif
 	switch (status) {
 		case CD_PAUSED:
+#if !defined(PROTO_SDL_H)
 			retval = SDL_CDcaps.Resume(cdrom);
+#else
+			retval = SDL_CDcaps.Resume(cdrom, SDLBase);
+#endif
 		default:
 			retval = 0;
 			break;
 	}
 	return(retval);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 int SDL_CDStop(SDL_CD *cdrom)
 {
+#else
+AROS_LH1(int, SDL_CDStop,
+	AROS_LHA(SDL_CD *, cdrom, A0),
+	struct SDLBase *, SDLBase, 154, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	CDstatus status;
 	int retval;
 
@@ -302,39 +465,83 @@
 		return(CD_ERROR);
 	}
 
+#if !defined(PROTO_SDL_H)
 	status = SDL_CDcaps.Status(cdrom, NULL);
+#else
+	status = SDL_CDcaps.Status(cdrom, NULL, SDLBase);
+#endif
 	switch (status) {
 		case CD_PLAYING:
 		case CD_PAUSED:
+#if !defined(PROTO_SDL_H)
 			retval = SDL_CDcaps.Stop(cdrom);
+#else
+			retval = SDL_CDcaps.Stop(cdrom, SDLBase);
+#endif
 		default:
 			retval = 0;
 			break;
 	}
 	return(retval);
+#if defined(PROTO_SDL_H)
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 int SDL_CDEject(SDL_CD *cdrom)
 {
+#else
+AROS_LH1(int, SDL_CDEject,
+	AROS_LHA(SDL_CD *, cdrom, A0),
+	struct SDLBase *, SDLBase, 155, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	/* Check if the CD-ROM subsystem has been initialized */
 	if ( ! CheckInit(1, &cdrom) ) {
 		return(CD_ERROR);
 	}
+#if !defined(PROTO_SDL_H)
 	return(SDL_CDcaps.Eject(cdrom));
+#else
+	return(SDL_CDcaps.Eject(cdrom, SDLBase));
+
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 void SDL_CDClose(SDL_CD *cdrom)
 {
+#else
+AROS_LH1(void, SDL_CDClose,
+	AROS_LHA(SDL_CD *, cdrom, A0),
+	struct SDLBase *, SDLBase, 156, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	/* Check if the CD-ROM subsystem has been initialized */
 	if ( ! CheckInit(1, &cdrom) ) {
 		return;
 	}
+#if !defined(PROTO_SDL_H)
 	SDL_CDcaps.Close(cdrom);
+#else
+	SDL_CDcaps.Close(cdrom, SDLBase);
+#endif
 	SDL_free(cdrom);
 	default_cdrom = NULL;
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 void SDL_CDROMQuit(void)
+#else
+void SDL_CDROMQuitI(struct SDLBase *SDLBase)
+#endif
 {
 	SDL_SYS_CDQuit();
 	SDL_cdinitted = 0;
diff -Naur SDL-1.2.15-orig/src/cdrom/SDL_syscdrom.h SDL-1.2.15/src/cdrom/SDL_syscdrom.h
--- SDL-1.2.15-orig/src/cdrom/SDL_syscdrom.h	2015-05-09 17:47:54.311774220 +0200
+++ SDL-1.2.15/src/cdrom/SDL_syscdrom.h	2015-05-09 15:09:59.758739527 +0200
@@ -21,12 +21,17 @@
 */
 #include "SDL_config.h"
 
+#if defined(PROTO_SDL_H)
+#include "SDL_intern.h"
+#endif
+
 /* This is the system specific header for the SDL CD-ROM API */
 
 /* Structure of CD audio control functions */
 extern struct CDcaps {
+#if !defined(PROTO_SDL_H)
 	/* Get the name of the specified drive */
-	const char *(*Name)(int drive);
+    	const char *(*Name)(int drive);
 
 	/* Open the specified drive, returning a drive id, or -1 on error */
 	int (*Open)(int drive);
@@ -59,8 +64,21 @@
 
 	/* Close the specified drive */
 	void (*Close)(SDL_CD *cdrom);
+#else
+    	const char *(*Name)(int drive, struct SDLBase *SDLBase);
+	int (*Open)(int drive, struct SDLBase *SDLBase);
+	int (*GetTOC)(SDL_CD *cdrom, struct SDLBase *SDLBase);
+	CDstatus (*Status)(SDL_CD *cdrom, int *position, struct SDLBase *SDLBase);
+	int (*Play)(SDL_CD *cdrom, int start, int len, struct SDLBase *SDLBase); 
+	int (*Pause)(SDL_CD *cdrom, struct SDLBase *SDLBase);
+	int (*Resume)(SDL_CD *cdrom, struct SDLBase *SDLBase);
+	int (*Stop)(SDL_CD *cdrom, struct SDLBase *SDLBase);
+	int (*Eject)(SDL_CD *cdrom, struct SDLBase *SDLBase);
+	void (*Close)(SDL_CD *cdrom, struct SDLBase *SDLBase);
+#endif
 } SDL_CDcaps;
 
+#if !defined(PROTO_SDL_H)
 /* The number of available CD-ROM drives on the system */
 extern int SDL_numcds;
 
@@ -73,4 +91,13 @@
 
 /* Function to perform any system-specific CD-ROM related cleanup */
 extern void SDL_SYS_CDQuit(void);
+#else
+extern int  SDL_SYS_CDInitI(struct SDLBase *SDLBase);
+extern void SDL_SYS_CDQuitI(struct SDLBase *SDLBase);
+
+#define SDL_SYS_CDInit() SDL_SYS_CDInitI(SDLBase)
+#define SDL_SYS_CDQuit() SDL_SYS_CDQuitI(SDLBase)
+
+#define SDL_numcds SDLBase->SDL_numcds
 
+#endif
diff -Naur SDL-1.2.15-orig/src/cpuinfo/SDL_cpuinfo.c SDL-1.2.15/src/cpuinfo/SDL_cpuinfo.c
--- SDL-1.2.15-orig/src/cpuinfo/SDL_cpuinfo.c	2015-05-09 17:47:54.280774303 +0200
+++ SDL-1.2.15/src/cpuinfo/SDL_cpuinfo.c	2015-05-09 15:09:59.758739527 +0200
@@ -19,6 +19,11 @@
     Sam Lantinga
     slouken@libsdl.org
 */
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
 #include "SDL_config.h"
 
 /* CPU feature detection for SDL */
@@ -33,6 +38,10 @@
 #include <setjmp.h>
 #endif
 
+#if defined(PROTO_SDL_H)
+#include "SDL_intern.h"
+#endif
+
 #define CPU_HAS_RDTSC	0x00000001
 #define CPU_HAS_MMX	0x00000002
 #define CPU_HAS_MMXEXT	0x00000004
@@ -415,68 +424,148 @@
 	return SDL_CPUFeatures;
 }
 
+#if !defined(PROTO_SDL_H)
 SDL_bool SDL_HasRDTSC(void)
 {
+#else
+AROS_LH0(SDL_bool, SDL_HasRDTSC,
+	struct SDLBase *, SDLBase, 188, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	if ( SDL_GetCPUFeatures() & CPU_HAS_RDTSC ) {
 		return SDL_TRUE;
 	}
 	return SDL_FALSE;
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 SDL_bool SDL_HasMMX(void)
 {
+#else
+AROS_LH0(SDL_bool, SDL_HasMMX,
+	struct SDLBase *, SDLBase, 189, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	if ( SDL_GetCPUFeatures() & CPU_HAS_MMX ) {
 		return SDL_TRUE;
 	}
 	return SDL_FALSE;
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 SDL_bool SDL_HasMMXExt(void)
 {
+#else
+AROS_LH0(SDL_bool, SDL_HasMMXExt,
+	struct SDLBase *, SDLBase, 192, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	if ( SDL_GetCPUFeatures() & CPU_HAS_MMXEXT ) {
 		return SDL_TRUE;
 	}
 	return SDL_FALSE;
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 SDL_bool SDL_Has3DNow(void)
 {
+#else
+AROS_LH0(SDL_bool, SDL_Has3DNow,
+	struct SDLBase *, SDLBase, 190, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	if ( SDL_GetCPUFeatures() & CPU_HAS_3DNOW ) {
 		return SDL_TRUE;
 	}
 	return SDL_FALSE;
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 SDL_bool SDL_Has3DNowExt(void)
 {
+#else
+AROS_LH0(SDL_bool, SDL_Has3DNowExt,
+	struct SDLBase *, SDLBase, 193, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	if ( SDL_GetCPUFeatures() & CPU_HAS_3DNOWEXT ) {
 		return SDL_TRUE;
 	}
 	return SDL_FALSE;
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 SDL_bool SDL_HasSSE(void)
 {
+#else
+AROS_LH0(SDL_bool, SDL_HasSSE,
+	struct SDLBase *, SDLBase, 191, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	if ( SDL_GetCPUFeatures() & CPU_HAS_SSE ) {
 		return SDL_TRUE;
 	}
 	return SDL_FALSE;
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 SDL_bool SDL_HasSSE2(void)
 {
+#else
+AROS_LH0(SDL_bool, SDL_HasSSE2,
+	struct SDLBase *, SDLBase, 194, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	if ( SDL_GetCPUFeatures() & CPU_HAS_SSE2 ) {
 		return SDL_TRUE;
 	}
 	return SDL_FALSE;
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 SDL_bool SDL_HasAltiVec(void)
 {
+#else
+AROS_LH0(SDL_bool, SDL_HasAltiVec,
+	struct SDLBase *, SDLBase, 187, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	if ( SDL_GetCPUFeatures() & CPU_HAS_ALTIVEC ) {
 		return SDL_TRUE;
 	}
 	return SDL_FALSE;
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 #ifdef TEST_MAIN
diff -Naur SDL-1.2.15-orig/src/events/SDL_active.c SDL-1.2.15/src/events/SDL_active.c
--- SDL-1.2.15-orig/src/events/SDL_active.c	2015-05-09 17:47:54.280774303 +0200
+++ SDL-1.2.15/src/events/SDL_active.c	2015-05-09 15:09:59.758739527 +0200
@@ -19,6 +19,11 @@
     Sam Lantinga
     slouken@libsdl.org
 */
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
 #include "SDL_config.h"
 
 /* Application focus/iconification handling code for SDL */
@@ -28,10 +33,19 @@
 
 
 /* These are static for our active event handling code */
+#if !defined(PROTO_SDL_H)
 static Uint8 SDL_appstate = 0;
+#else
+#include "SDL_intern.h"
+#define SDL_appstate SDLBase->SDL_appstate
+#endif
 
 /* Public functions */
+#if !defined(PROTO_SDL_H)
 int SDL_AppActiveInit(void)
+#else
+int SDL_AppActiveInitI(struct SDLBase *SDLBase)
+#endif
 {
 	/* Start completely active */
 	SDL_appstate = (SDL_APPACTIVE|SDL_APPINPUTFOCUS|SDL_APPMOUSEFOCUS);
@@ -39,17 +53,35 @@
 	/* That's it! */
 	return(0);
 }
+#if !defined(PROTO_SDL_H)
 void SDL_AppActiveQuit(void)
+#else
+void SDL_AppActiveQuitI(struct SDLBase *SDLBase)
+#endif
 {
 }
 
+#if !defined(PROTO_SDL_H)
 Uint8 SDL_GetAppState(void)
 {
+#else
+AROS_LH0(Uint8, SDL_GetAppState,
+	struct SDLBase *, SDLBase, 121, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	return(SDL_appstate);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 /* This is global for SDL_eventloop.c */
+#if !defined(PROTO_SDL_H)
 int SDL_PrivateAppActive(Uint8 gain, Uint8 state)
+#else
+int SDL_PrivateAppActiveI(Uint8 gain, Uint8 state, struct SDLBase *SDLBase)
+#endif
 {
 	int posted;
 	Uint8 new_state;
diff -Naur SDL-1.2.15-orig/src/events/SDL_events.c SDL-1.2.15/src/events/SDL_events.c
--- SDL-1.2.15-orig/src/events/SDL_events.c	2015-05-09 17:47:54.280774303 +0200
+++ SDL-1.2.15/src/events/SDL_events.c	2015-05-09 15:09:59.758739527 +0200
@@ -19,6 +19,11 @@
     Sam Lantinga
     slouken@libsdl.org
 */
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
 #include "SDL_config.h"
 
 /* General event handling code for SDL */
@@ -33,9 +38,23 @@
 #endif
 
 /* Public data -- the event filter */
+#if !defined(PROTO_SDL_H)
 SDL_EventFilter SDL_EventOK = NULL;
 Uint8 SDL_ProcessEvents[SDL_NUMEVENTS];
 static Uint32 SDL_eventstate = 0;
+/* Thread functions */
+static SDL_Thread *SDL_EventThread = NULL;	/* Thread handle */
+static Uint32 event_thread;			/* The event thread id */
+#else
+#include "SDL_intern.h"
+#define SDL_EventOK SDLBase->SDL_EventOK
+#define SDL_ProcessEvents SDLBase->SDL_ProcessEvents
+#define SDL_eventstate SDLBase->SDL_eventstate
+#define SDL_EventThread SDLBase->SDL_EventThread
+#define event_thread SDLBase->event_thread
+
+#define current_video SDLBase->current_video
+#endif
 
 /* Private data -- event queue */
 #define MAXEVENTS	128
@@ -55,11 +74,11 @@
 	int safe;
 } SDL_EventLock;
 
-/* Thread functions */
-static SDL_Thread *SDL_EventThread = NULL;	/* Thread handle */
-static Uint32 event_thread;			/* The event thread id */
-
+#if !defined(PROTO_SDL_H)
 void SDL_Lock_EventThread(void)
+#else
+void SDL_Lock_EventThreadI(struct SDLBase *SDLBase)
+#endif
 {
 	if ( SDL_EventThread && (SDL_ThreadID() != event_thread) ) {
 		/* Grab lock and spin until we're sure event thread stopped */
@@ -69,7 +88,11 @@
 		}
 	}
 }
+#if !defined(PROTO_SDL_H)
 void SDL_Unlock_EventThread(void)
+#else
+void SDL_Unlock_EventThreadI(struct SDLBase *SDLBase)
+#endif
 {
 	if ( SDL_EventThread && (SDL_ThreadID() != event_thread) ) {
 		SDL_mutexV(SDL_EventLock.lock);
@@ -87,7 +110,11 @@
 #include <time.h>
 #endif
 
+#if !defined(PROTO_SDL_H)
 static int SDLCALL SDL_GobbleEvents(void *unused)
+#else
+static int SDLCALL SDL_GobbleEvents(struct SDLBase *SDLBase)
+#endif
 {
 	event_thread = SDL_ThreadID();
 
@@ -104,7 +131,11 @@
 
 		/* Get events from the video subsystem */
 		if ( video ) {
+#if !defined(PROTO_SDL_H)
 			video->PumpEvents(this);
+#else
+			video->PumpEvents(this, SDLBase);
+#endif
 		}
 
 		/* Queue pending key-repeat events */
@@ -141,7 +172,12 @@
 	return(0);
 }
 
+#if !defined(PROTO_SDL_H)
 static int SDL_StartEventThread(Uint32 flags)
+#else
+#define SDL_StartEventThread(flags) SDL_StartEventThreadI(flags, SDLBase)
+static int SDL_StartEventThreadI(Uint32 flags, struct SDLBase *SDLBase)
+#endif
 {
 	/* Reset everything to zero */
 	SDL_EventThread = NULL;
@@ -173,7 +209,11 @@
 #undef SDL_CreateThread
 		SDL_EventThread = SDL_CreateThread(SDL_GobbleEvents, NULL, NULL, NULL);
 #else
+#if !defined(PROTO_SDL_H)
 		SDL_EventThread = SDL_CreateThread(SDL_GobbleEvents, NULL);
+#else
+		SDL_EventThread = SDL_CreateThread(SDL_GobbleEvents, SDLBase);
+#endif
 #endif
 		if ( SDL_EventThread == NULL ) {
 			return(-1);
@@ -184,7 +224,12 @@
 	return(0);
 }
 
+#if !defined(PROTO_SDL_H)
 static void SDL_StopEventThread(void)
+#else
+#define SDL_StopEventThread() SDL_StopEventThreadI(SDLBase)
+static void SDL_StopEventThreadI(struct SDLBase *SDLBase)
+#endif
 {
 	SDL_EventQ.active = 0;
 	if ( SDL_EventThread ) {
@@ -199,14 +244,21 @@
 #endif
 }
 
+#if !defined(PROTO_SDL_H)
 Uint32 SDL_EventThreadID(void)
+#else
+Uint32 SDL_EventThreadIDI(struct SDLBase *SDLBase)
+#endif
 {
 	return(event_thread);
 }
 
 /* Public functions */
-
+#if !defined(PROTO_SDL_H)
 void SDL_StopEventLoop(void)
+#else
+void SDL_StopEventLoopI(struct SDLBase *SDLBase)
+#endif
 {
 	/* Halt the event thread, if running */
 	SDL_StopEventThread();
@@ -224,7 +276,11 @@
 }
 
 /* This function (and associated calls) may be called more than once */
+#if !defined(PROTO_SDL_H)
 int SDL_StartEventLoop(Uint32 flags)
+#else
+int SDL_StartEventLoopI(Uint32 flags, struct SDLBase *SDLBase)
+#endif
 {
 	int retcode;
 
@@ -262,7 +318,12 @@
 
 
 /* Add an event to the event queue -- called with the queue locked */
+#if !defined(PROTO_SDL_H)
 static int SDL_AddEvent(SDL_Event *event)
+#else
+#define SDL_AddEvent(event) SDL_AddEventI(event, SDLBase)
+static int SDL_AddEventI(SDL_Event *event, struct SDLBase *SDLBase)
+#endif
 {
 	int tail, added;
 
@@ -288,7 +349,12 @@
 
 /* Cut an event, and return the next valid spot, or the tail */
 /*                           -- called with the queue locked */
+#if !defined(PROTO_SDL_H)
 static int SDL_CutEvent(int spot)
+#else
+#define SDL_CutEvent(spot) SDL_CutEventI(spot, SDLBase)
+static int SDL_CutEventI(int spot, struct SDLBase *SDLBase)
+#endif
 {
 	if ( spot == SDL_EventQ.head ) {
 		SDL_EventQ.head = (SDL_EventQ.head+1)%MAXEVENTS;
@@ -316,9 +382,20 @@
 }
 
 /* Lock the event queue, take a peep at it, and unlock it */
+#if !defined(PROTO_SDL_H)
 int SDL_PeepEvents(SDL_Event *events, int numevents, SDL_eventaction action,
 								Uint32 mask)
 {
+#else
+AROS_LH4(int, SDL_PeepEvents,
+	AROS_LHA(SDL_Event *, events, A0),
+	AROS_LHA(int, numevents, D0),
+	AROS_LHA(SDL_eventaction, action, D1),
+	AROS_LHA(Uint32, mask, D2),
+	struct SDLBase *, SDLBase, 86, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	int i, used;
 
 	/* Don't look after we've quit */
@@ -362,18 +439,32 @@
 		used = -1;
 	}
 	return(used);
+#if defined(PROTO_SDL_H)
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 /* Run the system dependent event loops */
+#if !defined(PROTO_SDL_H)
 void SDL_PumpEvents(void)
 {
+#else
+AROS_LH0(void, SDL_PumpEvents,
+	struct SDLBase *, SDLBase, 83, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	if ( !SDL_EventThread ) {
 		SDL_VideoDevice *video = current_video;
 		SDL_VideoDevice *this  = current_video;
 
 		/* Get events from the video subsystem */
 		if ( video ) {
+#if !defined(PROTO_SDL_H)
 			video->PumpEvents(this);
+#else
+			video->PumpEvents(this, SDLBase);
+#endif
 		}
 
 		/* Queue pending key-repeat events */
@@ -386,22 +477,43 @@
 		}
 #endif
 	}
+#if defined(PROTO_SDL_H)
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 /* Public functions */
-
+#if !defined(PROTO_SDL_H)
 int SDL_PollEvent (SDL_Event *event)
 {
+#else
+AROS_LH1(int, SDL_PollEvent,
+	AROS_LHA(SDL_Event *, event, A0),
+	struct SDLBase *, SDLBase, 84, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	SDL_PumpEvents();
 
 	/* We can't return -1, just return 0 (no event) on error */
 	if ( SDL_PeepEvents(event, 1, SDL_GETEVENT, SDL_ALLEVENTS) <= 0 )
 		return 0;
 	return 1;
+#if defined(PROTO_SDL_H)
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 int SDL_WaitEvent (SDL_Event *event)
 {
+#else
+AROS_LH1(int, SDL_WaitEvent,
+	AROS_LHA(SDL_Event *, event, A0),
+	struct SDLBase *, SDLBase, 85, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	while ( 1 ) {
 		SDL_PumpEvents();
 		switch(SDL_PeepEvents(event, 1, SDL_GETEVENT, SDL_ALLEVENTS)) {
@@ -410,32 +522,77 @@
 		    case 0: SDL_Delay(10);
 		}
 	}
+#if defined(PROTO_SDL_H)
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 int SDL_PushEvent(SDL_Event *event)
 {
+#else
+AROS_LH1(int, SDL_PushEvent,
+	AROS_LHA(SDL_Event *, event, A0),
+	struct SDLBase *, SDLBase, 87, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	if ( SDL_PeepEvents(event, 1, SDL_ADDEVENT, 0) <= 0 )
 		return -1;
 	return 0;
+#if defined(PROTO_SDL_H)
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 void SDL_SetEventFilter (SDL_EventFilter filter)
 {
+#else
+AROS_LH1(void, SDL_SetEventFilter,
+	AROS_LHA(SDL_EventFilter, filter, D0),
+	struct SDLBase *, SDLBase, 88, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	SDL_Event bitbucket;
 
 	/* Set filter and discard pending events */
 	SDL_EventOK = filter;
 	while ( SDL_PollEvent(&bitbucket) > 0 )
 		;
+
+#if defined(PROTO_SDL_H)
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 SDL_EventFilter SDL_GetEventFilter(void)
 {
+#else
+AROS_LH0(SDL_EventFilter, SDL_GetEventFilter,
+	struct SDLBase *, SDLBase, 89, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	return(SDL_EventOK);
+#if defined(PROTO_SDL_H)
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 Uint8 SDL_EventState (Uint8 type, int state)
 {
+#else
+AROS_LH2(Uint8, SDL_EventState,
+	AROS_LHA(Uint8, type, D0),
+	AROS_LHA(int, state, D1),
+	struct SDLBase *, SDLBase, 90, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	SDL_Event bitbucket;
 	Uint8 current_state;
 
@@ -478,11 +635,18 @@
 			break;
 	}
 	return(current_state);
+#if defined(PROTO_SDL_H)
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 /* This is a generic event handler.
  */
+#if !defined(PROTO_SDL_H)
 int SDL_PrivateSysWMEvent(SDL_SysWMmsg *message)
+#else
+int SDL_PrivateSysWMEventI(SDL_SysWMmsg *message, struct SDLBase *SDLBase)
+#endif
 {
 	int posted;
 
diff -Naur SDL-1.2.15-orig/src/events/SDL_events_c.h SDL-1.2.15/src/events/SDL_events_c.h
--- SDL-1.2.15-orig/src/events/SDL_events_c.h	2015-05-09 17:47:54.280774303 +0200
+++ SDL-1.2.15/src/events/SDL_events_c.h	2015-05-09 15:09:59.759739525 +0200
@@ -24,6 +24,7 @@
 /* Useful functions and variables from SDL_events.c */
 #include "SDL_events.h"
 
+#if !defined(PROTO_SDL_H)
 /* Start and stop the event processing loop */
 extern int SDL_StartEventLoop(Uint32 flags);
 extern void SDL_StopEventLoop(void);
@@ -76,8 +77,74 @@
 /* Used by the event loop to queue pending keyboard repeat events */
 extern void SDL_CheckKeyRepeat(void);
 
+extern int SDL_TranslateUNICODE;
+#else
+#include "SDL_intern.h"
+extern int SDL_StartEventLoopI(Uint32 flags, struct SDLBase *SDLBase);
+extern void SDL_StopEventLoopI(struct SDLBase *SDLBase);
+
+extern void SDL_Lock_EventThreadI(struct SDLBase *SDLBase);
+extern void SDL_Unlock_EventThreadI(struct SDLBase *SDLBase);
+extern Uint32 SDL_EventThreadIDI(struct SDLBase *SDLBase);
+
+extern int  SDL_AppActiveInitI(struct SDLBase *SDLBase);
+extern int  SDL_KeyboardInitI(struct SDLBase *SDLBase);
+extern int  SDL_MouseInitI(struct SDLBase *SDLBase);
+extern int  SDL_QuitInitI(struct SDLBase *SDLBase);
+
+extern void SDL_AppActiveQuitI(struct SDLBase *SDLBase);
+extern void SDL_KeyboardQuitI(struct SDLBase *SDLBase);
+extern void SDL_MouseQuitI(struct SDLBase *SDLBase);
+extern void SDL_QuitQuitI(struct SDLBase *SDLBase);
+
+extern int SDL_PrivateAppActiveI(Uint8 gain, Uint8 state, struct SDLBase *SDLBase);
+extern int SDL_PrivateMouseMotionI(Uint8 buttonstate, int relative, Sint16 x, Sint16 y, struct SDLBase *SDLBase);
+extern int SDL_PrivateMouseButtonI(Uint8 state, Uint8 button,Sint16 x,Sint16 y, struct SDLBase *SDLBase);
+extern int SDL_PrivateKeyboardI(Uint8 state, SDL_keysym *key, struct SDLBase *SDLBase);
+extern int SDL_PrivateResizeI(int w, int h, struct SDLBase *SDLBase);
+extern int SDL_PrivateExposeI(struct SDLBase *SDLBase);
+extern int SDL_PrivateQuitI(struct SDLBase *SDLBase);
+extern int SDL_PrivateSysWMEventI(SDL_SysWMmsg *message, struct SDLBase *SDLBase);
+
+extern void SDL_SetMouseRangeI(int maxX, int maxY, struct SDLBase *SDLBase);
+extern void SDL_ResetMouseI(struct SDLBase *SDLBase);
+extern void SDL_ResetKeyboardI(struct SDLBase *SDLBase);
+extern void SDL_CheckKeyRepeatI(struct SDLBase *SDLBase);
+
+#define SDL_StartEventLoop(flags) SDL_StartEventLoopI(flags, SDLBase)
+#define SDL_StopEventLoop() SDL_StopEventLoopI(SDLBase)
+
+#define SDL_Lock_EventThread() SDL_Lock_EventThreadI(SDLBase)
+#define SDL_Unlock_EventThread() SDL_Unlock_EventThreadI(SDLBase)
+#define SDL_EventThreadID() SDL_EventThreadIDI(SDLBase)
+
+#define SDL_AppActiveInit() SDL_AppActiveInitI(SDLBase)
+#define SDL_KeyboardInit() SDL_KeyboardInitI(SDLBase)
+#define SDL_MouseInit() SDL_MouseInitI(SDLBase)
+#define SDL_QuitInit() SDL_QuitInitI(SDLBase)
+#define SDL_AppActiveQuit() SDL_AppActiveQuitI(SDLBase)
+#define SDL_KeyboardQuit() SDL_KeyboardQuitI(SDLBase)
+#define SDL_MouseQuit() SDL_MouseQuitI(SDLBase)
+#define SDL_QuitQuit() SDL_QuitQuitI(SDLBase)
+#define SDL_PrivateAppActive(gain, state) SDL_PrivateAppActiveI(gain, state, SDLBase)
+#define SDL_PrivateMouseMotion(buttonstate, relative, x, y) SDL_PrivateMouseMotionI(buttonstate, relative, x, y, SDLBase)
+#define SDL_PrivateMouseButton(state, button, x, y) SDL_PrivateMouseButtonI(state, button, x, y, SDLBase)
+#define SDL_PrivateKeyboard(state, key) SDL_PrivateKeyboardI(state, key, SDLBase)
+#define SDL_PrivateResize(w, h) SDL_PrivateResizeI(w, h, SDLBase)
+#define SDL_PrivateExpose() SDL_PrivateExposeI(SDLBase)
+#define SDL_PrivateQuit() SDL_PrivateQuitI(SDLBase)
+#define SDL_PrivateSysWMEvent(message) SDL_PrivateSysWMEventI(message, SDLBase)
+#define SDL_SetMouseRange(maxX, maxY) SDL_SetMouseRangeI(maxX, maxY, SDLBase)
+#define SDL_ResetMouse() SDL_ResetMouseI(SDLBase)
+#define SDL_ResetKeyboard() SDL_ResetKeyboardI(SDLBase)
+#define SDL_CheckKeyRepeat() SDL_CheckKeyRepeatI(SDLBase)
+
+#define SDL_EventOK SDLBase->SDL_EventOK
+#define SDL_ProcessEvents SDLBase->SDL_ProcessEvents
+#define SDL_TranslateUNICODE SDLBase->SDL_TranslateUNICODE
+#endif
+
 /* Used by the OS keyboard code to detect whether or not to do UNICODE */
 #ifndef DEFAULT_UNICODE_TRANSLATION
 #define DEFAULT_UNICODE_TRANSLATION 0	/* Default off because of overhead */
 #endif
-extern int SDL_TranslateUNICODE;
diff -Naur SDL-1.2.15-orig/src/events/SDL_expose.c SDL-1.2.15/src/events/SDL_expose.c
--- SDL-1.2.15-orig/src/events/SDL_expose.c	2015-05-09 17:47:54.280774303 +0200
+++ SDL-1.2.15/src/events/SDL_expose.c	2015-05-09 15:09:59.759739525 +0200
@@ -19,6 +19,11 @@
     Sam Lantinga
     slouken@libsdl.org
 */
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
 #include "SDL_config.h"
 
 /* Refresh event handling code for SDL */
@@ -28,7 +33,11 @@
 
 
 /* This is global for SDL_eventloop.c */
+#if !defined(PROTO_SDL_H)
 int SDL_PrivateExpose(void)
+#else
+int SDL_PrivateExposeI(struct SDLBase *SDLBase)
+#endif
 {
 	int posted;
 	SDL_Event events[32];
diff -Naur SDL-1.2.15-orig/src/events/SDL_keyboard.c SDL-1.2.15/src/events/SDL_keyboard.c
--- SDL-1.2.15-orig/src/events/SDL_keyboard.c	2015-05-09 17:47:54.280774303 +0200
+++ SDL-1.2.15/src/events/SDL_keyboard.c	2015-05-09 15:09:59.759739525 +0200
@@ -19,6 +19,11 @@
     Sam Lantinga
     slouken@libsdl.org
 */
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
 #include "SDL_config.h"
 
 /* General keyboard handling code for SDL */
@@ -28,13 +33,21 @@
 #include "SDL_events_c.h"
 #include "SDL_sysevents.h"
 
-
+#if !defined(PROTO_SDL_H)
 /* Global keystate information */
 static Uint8  SDL_KeyState[SDLK_LAST];
 static SDLMod SDL_ModState;
 int SDL_TranslateUNICODE = 0;
 
 static const char *keynames[SDLK_LAST];	/* Array of keycode names */
+#else
+#define SDL_KeyState SDLBase->SDL_KeyState
+#define SDL_ModState SDLBase->SDL_ModState
+#define SDL_TranslateUNICODE SDLBase->SDL_TranslateUNICODE
+#define keynames SDLBase->keynames
+
+#define current_video SDLBase->current_video
+#endif
 
 /*
  * jk 991215 - added
@@ -55,7 +68,11 @@
 #define SDL_NLK_NUM  0x02
 
 /* Public functions */
+#if !defined(PROTO_SDL_H)
 int SDL_KeyboardInit(void)
+#else
+int SDL_KeyboardInitI(struct SDLBase *SDLBase)
+#endif
 {
 	const char* env;
 	SDL_VideoDevice *video = current_video;
@@ -68,7 +85,11 @@
 	SDL_ModState = KMOD_NONE;
 	SDL_memset((void*)keynames, 0, sizeof(keynames));
 	SDL_memset(SDL_KeyState, 0, sizeof(SDL_KeyState));
+#if !defined(PROTO_SDL_H)
 	video->InitOSKeymap(this);
+#else
+    	video->InitOSKeymap(this, SDLBase);
+#endif
 
 	SDL_EnableKeyRepeat(0, 0);
 
@@ -334,12 +355,20 @@
 	/* Done.  Whew. */
 	return(0);
 }
+#if !defined(PROTO_SDL_H)
 void SDL_KeyboardQuit(void)
+#else
+void SDL_KeyboardQuitI(struct SDLBase *SDLBase)
+#endif
 {
 }
 
 /* We lost the keyboard, so post key up messages for all pressed keys */
+#if !defined(PROTO_SDL_H)
 void SDL_ResetKeyboard(void)
+#else
+void SDL_ResetKeyboardI(struct SDLBase *SDLBase)
+#endif
 {
 	SDL_keysym keysym;
 	SDLKey key;
@@ -354,8 +383,16 @@
 	SDL_KeyRepeat.timestamp = 0;
 }
 
+#if !defined(PROTO_SDL_H)
 int SDL_EnableUNICODE(int enable)
 {
+#else
+AROS_LH1(int, SDL_EnableUNICODE,
+	AROS_LHA(int, enable, D0),
+	struct SDLBase *, SDLBase, 107, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	int old_mode;
 
 	old_mode = SDL_TranslateUNICODE;
@@ -363,25 +400,68 @@
 		SDL_TranslateUNICODE = enable;
 	}
 	return(old_mode);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 Uint8 * SDL_GetKeyState (int *numkeys)
 {
+#else
+AROS_LH1(Uint8 *, SDL_GetKeyState,
+	AROS_LHA(int *, numkeys, A0),
+	struct SDLBase *, SDLBase, 109, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	if ( numkeys != (int *)0 )
 		*numkeys = SDLK_LAST;
 	return(SDL_KeyState);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
+#if !defined(PROTO_SDL_H)
 SDLMod SDL_GetModState (void)
 {
+#else
+AROS_LH0(SDLMod, SDL_GetModState,
+	struct SDLBase *, SDLBase, 110, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	return(SDL_ModState);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
+#if !defined(PROTO_SDL_H)
 void SDL_SetModState (SDLMod modstate)
 {
+#else
+AROS_LH1(void, SDL_SetModState,
+	AROS_LHA(SDLMod, modstate, D0),
+	struct SDLBase *, SDLBase, 111, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	SDL_ModState = modstate;
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 char *SDL_GetKeyName(SDLKey key)
 {
+#else
+AROS_LH1(char *, SDL_GetKeyName,
+	AROS_LHA(SDLKey, key, D0),
+	struct SDLBase *, SDLBase, 112, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	const char *keyname;
 
 	keyname = NULL;
@@ -393,10 +473,17 @@
 	}
 	/* FIXME: make this function const in 1.3 */
 	return (char *)(keyname);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 /* These are global for SDL_eventloop.c */
+#if !defined(PROTO_SDL_H)
 int SDL_PrivateKeyboard(Uint8 state, SDL_keysym *keysym)
+#else
+int SDL_PrivateKeyboardI(Uint8 state, SDL_keysym *keysym, struct SDLBase *SDLBase)
+#endif
 {
 	SDL_Event event;
 	int posted, repeatable;
@@ -570,7 +657,11 @@
 /*
  * jk 991215 - Added
  */
+#if !defined(PROTO_SDL_H)
 void SDL_CheckKeyRepeat(void)
+#else
+void SDL_CheckKeyRepeatI(struct SDLBase *SDLBase)
+#endif
 {
 	if ( SDL_KeyRepeat.timestamp ) {
 		Uint32 now, interval;
@@ -593,8 +684,17 @@
 	}
 }
 
+#if !defined(PROTO_SDL_H)
 int SDL_EnableKeyRepeat(int delay, int interval)
 {
+#else
+AROS_LH2(int, SDL_EnableKeyRepeat,
+	AROS_LHA(int, delay, D0),
+	AROS_LHA(int, interval, D1),
+	struct SDLBase *, SDLBase, 108, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	if ( (delay < 0) || (interval < 0) ) {
 		SDL_SetError("keyboard repeat value less than zero");
 		return(-1);
@@ -604,6 +704,9 @@
 	SDL_KeyRepeat.interval = interval;
 	SDL_KeyRepeat.timestamp = 0;
 	return(0);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 void SDL_GetKeyRepeat(int *delay, int *interval)
diff -Naur SDL-1.2.15-orig/src/events/SDL_mouse.c SDL-1.2.15/src/events/SDL_mouse.c
--- SDL-1.2.15-orig/src/events/SDL_mouse.c	2015-05-09 17:47:54.280774303 +0200
+++ SDL-1.2.15/src/events/SDL_mouse.c	2015-05-09 15:09:59.759739525 +0200
@@ -19,6 +19,11 @@
     Sam Lantinga
     slouken@libsdl.org
 */
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
 #include "SDL_config.h"
 
 /* General mouse handling code for SDL */
@@ -28,7 +33,7 @@
 #include "../video/SDL_cursor_c.h"
 #include "../video/SDL_sysvideo.h"
 
-
+#if !defined(PROTO_SDL_H)
 /* These are static for our mouse handling code */
 static Sint16 SDL_MouseX = 0;
 static Sint16 SDL_MouseY = 0;
@@ -37,10 +42,24 @@
 static Sint16 SDL_MouseMaxX = 0;
 static Sint16 SDL_MouseMaxY = 0;
 static Uint8  SDL_ButtonState = 0;
+#else
+#define SDL_MouseX SDLBase->SDL_MouseX
+#define SDL_MouseY SDLBase->SDL_MouseY
+#define SDL_DeltaX SDLBase->SDL_DeltaX
+#define SDL_DeltaY SDLBase->SDL_DeltaY
+#define SDL_MouseMaxX SDLBase->SDL_MouseMaxX
+#define SDL_MouseMaxY SDLBase->SDL_MouseMaxY
+#define SDL_ButtonState SDLBase->SDL_ButtonState
 
+#define current_video SDLBase->current_video
+#endif
 
 /* Public functions */
+#if !defined(PROTO_SDL_H)
 int SDL_MouseInit(void)
+#else
+int SDL_MouseInitI(struct SDLBase *SDLBase)
+#endif
 {
 	/* The mouse is at (0,0) */
 	SDL_MouseX = 0;
@@ -54,12 +73,20 @@
 	/* That's it! */
 	return(0);
 }
+#if !defined(PROTO_SDL_H)
 void SDL_MouseQuit(void)
+#else
+void SDL_MouseQuitI(struct SDLBase *SDLBase)
+#endif
 {
 }
 
 /* We lost the mouse, so post button up messages for all pressed buttons */
+#if !defined(PROTO_SDL_H)
 void SDL_ResetMouse(void)
+#else
+void SDL_ResetMouseI(struct SDLBase *SDLBase)
+#endif
 {
 	Uint8 i;
 	for ( i = 0; i < sizeof(SDL_ButtonState)*8; ++i ) {
@@ -69,8 +96,17 @@
 	}
 }
 
+#if !defined(PROTO_SDL_H)
 Uint8 SDL_GetMouseState (int *x, int *y)
 {
+#else
+AROS_LH2(Uint8, SDL_GetMouseState,
+	AROS_LHA(int *, x, A0),
+	AROS_LHA(int *, y, A1),
+	struct SDLBase *, SDLBase, 113, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	if ( x ) {
 		*x = SDL_MouseX;
 	}
@@ -78,10 +114,22 @@
 		*y = SDL_MouseY;
 	}
 	return(SDL_ButtonState);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 Uint8 SDL_GetRelativeMouseState (int *x, int *y)
 {
+#else
+AROS_LH2(Uint8, SDL_GetRelativeMouseState,
+	AROS_LHA(int *, x, A0),
+	AROS_LHA(int *, y, A1),
+	struct SDLBase *, SDLBase, 114, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	if ( x )
 		*x = SDL_DeltaX;
 	if ( y )
@@ -89,9 +137,17 @@
 	SDL_DeltaX = 0;
 	SDL_DeltaY = 0;
 	return(SDL_ButtonState);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 static void ClipOffset(Sint16 *x, Sint16 *y)
+#else
+#define ClipOffset(x, y) ClipOffsetI(x, y, SDLBase)
+static void ClipOffsetI(Sint16 *x, Sint16 *y, struct SDLBase *SDLBase)
+#endif
 {
 	/* This clips absolute mouse coordinates when the apparent
 	   display surface is smaller than the real display surface.
@@ -103,14 +159,22 @@
 	}
 }
 
+#if !defined(PROTO_SDL_H)
 void SDL_SetMouseRange(int maxX, int maxY)
+#else
+void SDL_SetMouseRangeI(int maxX, int maxY, struct SDLBase *SDLBase)
+#endif
 {
 	SDL_MouseMaxX = (Sint16)maxX;
 	SDL_MouseMaxY = (Sint16)maxY;
 }
 
 /* These are global for SDL_eventloop.c */
+#if !defined(PROTO_SDL_H)
 int SDL_PrivateMouseMotion(Uint8 buttonstate, int relative, Sint16 x, Sint16 y)
+#else
+int SDL_PrivateMouseMotionI(Uint8 buttonstate, int relative, Sint16 x, Sint16 y, struct SDLBase *SDLBase)
+#endif
 {
 	int posted;
 	Uint16 X, Y;
@@ -194,7 +258,11 @@
 	return(posted);
 }
 
+#if !defined(PROTO_SDL_H)
 int SDL_PrivateMouseButton(Uint8 state, Uint8 button, Sint16 x, Sint16 y)
+#else
+int SDL_PrivateMouseButtonI(Uint8 state, Uint8 button, Sint16 x, Sint16 y, struct SDLBase *SDLBase)
+#endif
 {
 	SDL_Event event;
 	int posted;
diff -Naur SDL-1.2.15-orig/src/events/SDL_quit.c SDL-1.2.15/src/events/SDL_quit.c
--- SDL-1.2.15-orig/src/events/SDL_quit.c	2015-05-09 17:47:54.280774303 +0200
+++ SDL-1.2.15/src/events/SDL_quit.c	2015-05-09 15:09:59.759739525 +0200
@@ -19,6 +19,11 @@
     Sam Lantinga
     slouken@libsdl.org
 */
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
 #include "SDL_config.h"
 
 /* General quit handling code for SDL */
@@ -38,12 +43,20 @@
 	signal(sig, SDL_HandleSIG);
 
 	/* Signal a quit interrupt */
+#if !defined(PROTO_SDL_H)
 	SDL_PrivateQuit();
+#else
+        // FIXME: Call SDL_PrivateQuit()
+#endif
 }
 #endif /* HAVE_SIGNAL_H */
 
 /* Public functions */
+#if !defined(PROTO_SDL_H)
 int SDL_QuitInit(void)
+#else
+int SDL_QuitInitI(struct SDLBase *SDLBase)
+#endif
 {
 #ifdef HAVE_SIGACTION
 	struct sigaction action;
@@ -80,7 +93,11 @@
 	/* That's it! */
 	return(0);
 }
+#if !defined(PROTO_SDL_H)
 void SDL_QuitQuit(void)
+#else
+void SDL_QuitQuitI(struct SDLBase *SDLBase)
+#endif
 {
 #ifdef HAVE_SIGACTION
 	struct sigaction action;
@@ -107,7 +124,11 @@
 }
 
 /* This function returns 1 if it's okay to close the application window */
+#if !defined(PROTO_SDL_H)
 int SDL_PrivateQuit(void)
+#else
+int SDL_PrivateQuitI(struct SDLBase *SDLBase)
+#endif
 {
 	int posted;
 
diff -Naur SDL-1.2.15-orig/src/events/SDL_resize.c SDL-1.2.15/src/events/SDL_resize.c
--- SDL-1.2.15-orig/src/events/SDL_resize.c	2015-05-09 17:47:54.280774303 +0200
+++ SDL-1.2.15/src/events/SDL_resize.c	2015-05-09 15:09:59.759739525 +0200
@@ -19,6 +19,11 @@
     Sam Lantinga
     slouken@libsdl.org
 */
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
 #include "SDL_config.h"
 
 /* Resize event handling code for SDL */
@@ -27,6 +32,8 @@
 #include "SDL_events_c.h"
 #include "../video/SDL_sysvideo.h"
 
+/* This is global for SDL_eventloop.c */
+#if !defined(PROTO_SDL_H)
 
 /* Keep the last resize event so we don't post duplicates */
 static struct {
@@ -34,8 +41,15 @@
 	int h;
 } last_resize;
 
-/* This is global for SDL_eventloop.c */
 int SDL_PrivateResize(int w, int h)
+#else
+#include "SDL_intern.h"
+
+#define last_resize SDLBase->last_resize
+#define current_video SDLBase->current_video
+
+int SDL_PrivateResizeI(int w, int h, struct SDLBase *SDLBase)
+#endif
 {
 	int posted;
 	SDL_Event events[32];
diff -Naur SDL-1.2.15-orig/src/file/SDL_rwops.c SDL-1.2.15/src/file/SDL_rwops.c
--- SDL-1.2.15-orig/src/file/SDL_rwops.c	2015-05-09 17:47:54.353774110 +0200
+++ SDL-1.2.15/src/file/SDL_rwops.c	2015-05-09 15:09:59.760739523 +0200
@@ -19,6 +19,11 @@
     Sam Lantinga
     slouken@libsdl.org
 */
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
 #include "SDL_config.h"
 
 /* This file provides a general interface for SDL to read and write
@@ -28,6 +33,9 @@
 #include "SDL_endian.h"
 #include "SDL_rwops.h"
 
+#if defined(PROTO_SDL_H)
+#include "SDL_intern.h"
+#endif
 
 #if defined(__WIN32__) && !defined(__SYMBIAN32__)
 
@@ -322,6 +330,9 @@
 
 static int SDLCALL stdio_seek(SDL_RWops *context, int offset, int whence)
 {
+#if defined(PROTO_SDL_H)
+    struct Library __unused *SDLBase = context->SDLLib;
+#endif
 	if ( fseek(context->hidden.stdio.fp, offset, whence) == 0 ) {
 		return(ftell(context->hidden.stdio.fp));
 	} else {
@@ -331,6 +342,9 @@
 }
 static int SDLCALL stdio_read(SDL_RWops *context, void *ptr, int size, int maxnum)
 {
+#if defined(PROTO_SDL_H)
+    struct Library __unused *SDLBase = context->SDLLib;
+#endif
 	size_t nread;
 
 	nread = fread(ptr, size, maxnum, context->hidden.stdio.fp); 
@@ -341,6 +355,9 @@
 }
 static int SDLCALL stdio_write(SDL_RWops *context, const void *ptr, int size, int num)
 {
+#if defined(PROTO_SDL_H)
+    struct Library __unused *SDLBase = context->SDLLib;
+#endif
 	size_t nwrote;
 
 	nwrote = fwrite(ptr, size, num, context->hidden.stdio.fp);
@@ -351,6 +368,9 @@
 }
 static int SDLCALL stdio_close(SDL_RWops *context)
 {
+#if defined(PROTO_SDL_H)
+    struct Library __unused *SDLBase = context->SDLLib;
+#endif
 	if ( context ) {
 		if ( context->hidden.stdio.autoclose ) {
 			/* WARNING:  Check the return value here! */
@@ -360,12 +380,14 @@
 	}
 	return(0);
 }
-#endif /* !HAVE_STDIO_H */
+#endif /* HAVE_STDIO_H */
 
 /* Functions to read/write memory pointers */
-
 static int SDLCALL mem_seek(SDL_RWops *context, int offset, int whence)
 {
+#if defined(PROTO_SDL_H)
+    struct Library __unused *SDLBase = context->SDLLib;
+#endif
 	Uint8 *newpos;
 
 	switch (whence) {
@@ -393,6 +415,9 @@
 }
 static int SDLCALL mem_read(SDL_RWops *context, void *ptr, int size, int maxnum)
 {
+#if defined(PROTO_SDL_H)
+    struct Library __unused *SDLBase = context->SDLLib;
+#endif
 	size_t total_bytes;
 	size_t mem_available;
 
@@ -413,6 +438,9 @@
 }
 static int SDLCALL mem_write(SDL_RWops *context, const void *ptr, int size, int num)
 {
+#if defined(PROTO_SDL_H)
+    struct Library __unused *SDLBase = context->SDLLib;
+#endif
 	if ( (context->hidden.mem.here + (num*size)) > context->hidden.mem.stop ) {
 		num = (context->hidden.mem.stop-context->hidden.mem.here)/size;
 	}
@@ -422,11 +450,17 @@
 }
 static int SDLCALL mem_writeconst(SDL_RWops *context, const void *ptr, int size, int num)
 {
+#if defined(PROTO_SDL_H)
+    struct Library __unused *SDLBase = context->SDLLib;
+#endif
 	SDL_SetError("Can't write to read-only memory");
 	return(-1);
 }
 static int SDLCALL mem_close(SDL_RWops *context)
 {
+#if defined(PROTO_SDL_H)
+    struct Library __unused *SDLBase = context->SDLLib;
+#endif
 	if ( context ) {
 		SDL_FreeRW(context);
 	}
@@ -480,8 +514,17 @@
 }
 #endif /* __MACOS__ */
 
+#if !defined(PROTO_SDL_H)
 SDL_RWops *SDL_RWFromFile(const char *file, const char *mode)
 {
+#else
+AROS_LH2(SDL_RWops *, SDL_RWFromFile,
+	AROS_LHA(const char *, file, A0),
+	AROS_LHA(const char *, mode, A1),
+	struct SDLBase *, SDLBase, 17, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	SDL_RWops *rwops = NULL;
 #ifdef HAVE_STDIO_H
 	FILE *fp = NULL;
@@ -526,11 +569,23 @@
 #endif /* !HAVE_STDIO_H */
 
 	return(rwops);
+#if defined(PROTO_SDL_H)
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 #ifdef HAVE_STDIO_H
+#if !defined(PROTO_SDL_H)
 SDL_RWops *SDL_RWFromFP(FILE *fp, int autoclose)
 {
+#else
+AROS_LH2(SDL_RWops *, SDL_RWFromFP,
+	AROS_LHA(FILE *, fp, A0),
+	AROS_LHA(int, autoclose, D0),
+	struct SDLBase *, SDLBase, 18, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	SDL_RWops *rwops = NULL;
 
 	rwops = SDL_AllocRW();
@@ -543,11 +598,23 @@
 		rwops->hidden.stdio.autoclose = autoclose;
 	}
 	return(rwops);
+#if defined(PROTO_SDL_H)
+    AROS_LIBFUNC_EXIT
+#endif
 }
 #endif /* HAVE_STDIO_H */
 
+#if !defined(PROTO_SDL_H)
 SDL_RWops *SDL_RWFromMem(void *mem, int size)
 {
+#else
+AROS_LH2(SDL_RWops *, SDL_RWFromMem,
+	AROS_LHA(void *, mem, A0),
+	AROS_LHA(int, size, D0),
+	struct SDLBase *, SDLBase, 19, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	SDL_RWops *rwops;
 
 	rwops = SDL_AllocRW();
@@ -561,9 +628,16 @@
 		rwops->hidden.mem.stop = rwops->hidden.mem.base+size;
 	}
 	return(rwops);
+#if defined(PROTO_SDL_H)
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 SDL_RWops *SDL_RWFromConstMem(const void *mem, int size)
+#else
+SDL_RWops *SDL_RWFromConstMem(const void *mem, int size, struct SDLBase *SDLBase)
+#endif
 {
 	SDL_RWops *rwops;
 
@@ -580,94 +654,256 @@
 	return(rwops);
 }
 
+#if !defined(PROTO_SDL_H)
 SDL_RWops *SDL_AllocRW(void)
 {
+#else
+AROS_LH0(SDL_RWops *, SDL_AllocRW,
+	struct Library *, SDLBase, 20, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	SDL_RWops *area;
 
 	area = (SDL_RWops *)SDL_malloc(sizeof *area);
 	if ( area == NULL ) {
 		SDL_OutOfMemory();
 	}
+#if defined(PROTO_SDL_H)
+        area->SDLLib = SDLBase;
+#endif
 	return(area);
+#if defined(PROTO_SDL_H)
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 void SDL_FreeRW(SDL_RWops *area)
 {
+#else
+AROS_LH1(void, SDL_FreeRW,
+	AROS_LHA(SDL_RWops *, area, A0),
+	struct SDLBase *, SDLBase, 21, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	SDL_free(area);
+#if defined(PROTO_SDL_H)
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 /* Functions for dynamically reading and writing endian-specific values */
 
+#if !defined(PROTO_SDL_H)
 Uint16 SDL_ReadLE16 (SDL_RWops *src)
 {
+#else
+AROS_LH1(Uint16, SDL_ReadLE16,
+	AROS_LHA(SDL_RWops *, src, A0),
+	struct SDLBase *, SDLBase, 175, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	Uint16 value;
 
 	SDL_RWread(src, &value, (sizeof value), 1);
 	return(SDL_SwapLE16(value));
+#if defined(PROTO_SDL_H)
+    AROS_LIBFUNC_EXIT
+#endif
 }
+#if !defined(PROTO_SDL_H)
 Uint16 SDL_ReadBE16 (SDL_RWops *src)
 {
+#else
+AROS_LH1(Uint16, SDL_ReadBE16,
+	AROS_LHA(SDL_RWops *, src, A0),
+	struct SDLBase *, SDLBase, 176, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	Uint16 value;
 
 	SDL_RWread(src, &value, (sizeof value), 1);
 	return(SDL_SwapBE16(value));
+#if defined(PROTO_SDL_H)
+    AROS_LIBFUNC_EXIT
+#endif
 }
+#if !defined(PROTO_SDL_H)
 Uint32 SDL_ReadLE32 (SDL_RWops *src)
 {
+#else
+AROS_LH1(Uint32, SDL_ReadLE32,
+	AROS_LHA(SDL_RWops *, src, A0),
+	struct SDLBase *, SDLBase, 177, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	Uint32 value;
 
 	SDL_RWread(src, &value, (sizeof value), 1);
 	return(SDL_SwapLE32(value));
+#if defined(PROTO_SDL_H)
+    AROS_LIBFUNC_EXIT
+#endif
 }
+#if !defined(PROTO_SDL_H)
 Uint32 SDL_ReadBE32 (SDL_RWops *src)
 {
+#else
+AROS_LH1(Uint32, SDL_ReadBE32,
+	AROS_LHA(SDL_RWops *, src, A0),
+	struct SDLBase *, SDLBase, 178, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	Uint32 value;
 
 	SDL_RWread(src, &value, (sizeof value), 1);
 	return(SDL_SwapBE32(value));
+#if defined(PROTO_SDL_H)
+    AROS_LIBFUNC_EXIT
+#endif
 }
+#if !defined(PROTO_SDL_H)
 Uint64 SDL_ReadLE64 (SDL_RWops *src)
 {
+#else
+AROS_LH1(Uint64, SDL_ReadLE64,
+	AROS_LHA(SDL_RWops *, src, A0),
+	struct SDLBase *, SDLBase, 179, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	Uint64 value;
 
 	SDL_RWread(src, &value, (sizeof value), 1);
 	return(SDL_SwapLE64(value));
+#if defined(PROTO_SDL_H)
+    AROS_LIBFUNC_EXIT
+#endif
 }
+#if !defined(PROTO_SDL_H)
 Uint64 SDL_ReadBE64 (SDL_RWops *src)
 {
+#else
+AROS_LH1(Uint64, SDL_ReadBE64,
+	AROS_LHA(SDL_RWops *, src, A0),
+	struct SDLBase *, SDLBase, 180, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	Uint64 value;
 
 	SDL_RWread(src, &value, (sizeof value), 1);
 	return(SDL_SwapBE64(value));
+#if defined(PROTO_SDL_H)
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 int SDL_WriteLE16 (SDL_RWops *dst, Uint16 value)
 {
+#else
+AROS_LH2(int, SDL_WriteLE16,
+	AROS_LHA(SDL_RWops *, dst, A0),
+	AROS_LHA(Uint16, value, D0),
+	struct SDLBase *, SDLBase, 181, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	value = SDL_SwapLE16(value);
 	return(SDL_RWwrite(dst, &value, (sizeof value), 1));
+#if defined(PROTO_SDL_H)
+    AROS_LIBFUNC_EXIT
+#endif
 }
+#if !defined(PROTO_SDL_H)
 int SDL_WriteBE16 (SDL_RWops *dst, Uint16 value)
 {
+#else
+AROS_LH2(int, SDL_WriteBE16,
+	AROS_LHA(SDL_RWops *, dst, A0),
+	AROS_LHA(Uint16, value, D0),
+	struct SDLBase *, SDLBase, 182, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	value = SDL_SwapBE16(value);
 	return(SDL_RWwrite(dst, &value, (sizeof value), 1));
+#if defined(PROTO_SDL_H)
+    AROS_LIBFUNC_EXIT
+#endif
 }
+#if !defined(PROTO_SDL_H)
 int SDL_WriteLE32 (SDL_RWops *dst, Uint32 value)
 {
+#else
+AROS_LH2(int, SDL_WriteLE32,
+	AROS_LHA(SDL_RWops *, dst, A0),
+	AROS_LHA(Uint32, value, D0),
+	struct SDLBase *, SDLBase, 183, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	value = SDL_SwapLE32(value);
 	return(SDL_RWwrite(dst, &value, (sizeof value), 1));
+#if defined(PROTO_SDL_H)
+    AROS_LIBFUNC_EXIT
+#endif
 }
+#if !defined(PROTO_SDL_H)
 int SDL_WriteBE32 (SDL_RWops *dst, Uint32 value)
 {
+#else
+AROS_LH2(int, SDL_WriteBE32,
+	AROS_LHA(SDL_RWops *, dst, A0),
+	AROS_LHA(Uint32, value, D0),
+	struct SDLBase *, SDLBase, 184, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	value = SDL_SwapBE32(value);
 	return(SDL_RWwrite(dst, &value, (sizeof value), 1));
+#if defined(PROTO_SDL_H)
+    AROS_LIBFUNC_EXIT
+#endif
 }
+#if !defined(PROTO_SDL_H)
 int SDL_WriteLE64 (SDL_RWops *dst, Uint64 value)
 {
+#else
+AROS_LH2(int, SDL_WriteLE64,
+	AROS_LHA(SDL_RWops *, dst, A0),
+	AROS_LHA(Uint64, value, D0),
+	struct SDLBase *, SDLBase, 185, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	value = SDL_SwapLE64(value);
 	return(SDL_RWwrite(dst, &value, (sizeof value), 1));
+#if defined(PROTO_SDL_H)
+    AROS_LIBFUNC_EXIT
+#endif
 }
+#if !defined(PROTO_SDL_H)
 int SDL_WriteBE64 (SDL_RWops *dst, Uint64 value)
 {
+#else
+AROS_LH2(int, SDL_WriteBE64,
+	AROS_LHA(SDL_RWops *, dst, A0),
+	AROS_LHA(Uint64, value, D0),
+	struct SDLBase *, SDLBase, 186, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	value = SDL_SwapBE64(value);
 	return(SDL_RWwrite(dst, &value, (sizeof value), 1));
+#if defined(PROTO_SDL_H)
+    AROS_LIBFUNC_EXIT
+#endif
 }
diff -Naur SDL-1.2.15-orig/src/joystick/aros/SDL_sysjoystick.c SDL-1.2.15/src/joystick/aros/SDL_sysjoystick.c
--- SDL-1.2.15-orig/src/joystick/aros/SDL_sysjoystick.c	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.15/src/joystick/aros/SDL_sysjoystick.c	2015-05-09 15:09:59.760739523 +0200
@@ -0,0 +1,506 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2004 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+
+		20040518	SDL_SYS_JoystickOpen() function fixed
+				SetJoyPortAttrs() function added to initialize port
+
+		20040515	SDL_SYS_JoystickInit() function fixed
+				SDL_SYS_JoystickName() function fixed
+				SDL_SYS_JoystickQuit() function fixed
+				joystick max number (2) removed
+				PrivateJoyAxis 2nd parameters inverted!
+
+		20040505	"inline" include replaced with "proto"
+
+		20040501	LowlevelBase static declaration removed
+				Debug lines added
+*/
+
+#if defined (SDL_AROS_SHARED)
+#include <proto/exec.h>
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
+/* This is the system specific header for the SDL joystick API */
+
+#include <stdio.h>		/* For the definition of NULL */
+
+#include <libraries/lowlevel.h>
+//#define NO_LOWLEVEL_EXT
+#ifndef NO_LOWLEVEL_EXT
+#include <libraries/lowlevel_ext.h>
+#endif
+#include <proto/exec.h>
+#include <proto/lowlevel.h>
+#include <proto/graphics.h>
+#include "../../main/aros/mydebug.h"
+
+/*
+extern struct ExecBase *SysBase;
+extern struct GfxBase *GfxBase;
+*/
+
+#include <stdlib.h>
+
+#include "SDL_events.h"
+#include "SDL_error.h"
+#include "SDL_joystick.h"
+#include "../SDL_sysjoystick.h"
+#include "../SDL_joystick_c.h"
+
+/* The maximum number of joysticks we'll detect */
+#define MAX_JOYSTICKS 4 /* lowlevel.library is limited to 4 ports */
+
+/* Directions/Axis differences */
+#define MOS_PLUS  32767 /* was 127, changed by Henes (20040801) */
+#define MOS_MINUS -32768 /* was -127 */
+
+#ifndef JP_TYPE_ANALOGUE
+#define JP_TYPE_ANALOGUE  (14<<28)	  /* port has analogue joystick  */
+#define JP_XAXIS_MASK	(255<<0)	/* horizontal position */
+#define JP_YAXIS_MASK	(255<<8)	/* vertical position */
+#define JP_ANALOGUE_PORT_MAGIC (1<<16) /* port offset to force analogue readout */
+#endif
+
+/* Function to scan the system for joysticks.
+ * This function should set SDL_numjoysticks to the number of available
+ * joysticks.  Joystick 0 should be the system default joystick.
+ * It should return 0, or -1 on an unrecoverable fatal error.
+ */
+
+#if !defined(PROTO_SDL_H)
+struct Library *LowLevelBase = NULL;
+#else
+#include "SDL_intern.h"
+#define LowLevelBase SDLBase->LowLevelBase
+#endif
+
+unsigned long joybut[] =
+{
+	JPF_BUTTON_RED,
+	JPF_BUTTON_BLUE,
+	JPF_BUTTON_YELLOW,
+	JPF_BUTTON_GREEN,
+	JPF_BUTTON_PLAY,
+	JPF_BUTTON_FORWARD,
+	JPF_BUTTON_REVERSE
+/*
+	JPF_JOY_UP,
+	JPF_JOY_DOWN,
+	JPF_JOY_LEFT,
+	JPF_JOY_RIGHT
+*/
+};
+
+struct joystick_hwdata
+{
+	ULONG joystate;
+#ifndef NO_LOWLEVEL_EXT
+	ULONG joystate_ext;
+	ULONG supports_analog;
+#endif
+};
+
+/* lowlevel portNumber 0 <-> 1 */
+static int PortIndex(int index)
+{
+	switch(index)
+	{
+		case 0:
+			return 1;
+			break;
+
+		case 1:
+			return 0;
+			break;
+
+		default:
+			break;
+	}
+
+	return index;
+}
+
+#if !defined(PROTO_SDL_H)
+int SDL_SYS_JoystickInit(void)
+#else
+int SDL_SYS_JoystickInitI(struct SDLBase *SDLBase)
+#endif
+{
+	int numjoysticks = 0;
+	unsigned long joyflag = 0L;
+
+	D(bug("SDL_SYS_JoystickInit()\n"));
+
+	if(!LowLevelBase)
+	{
+		if((LowLevelBase = OpenLibrary("lowlevel.library",37)))
+		{
+			numjoysticks = 0;
+			while(numjoysticks < MAX_JOYSTICKS)
+			{
+				joyflag = ReadJoyPort(PortIndex(numjoysticks));
+
+				if((joyflag&JP_TYPE_MASK) == JP_TYPE_NOTAVAIL)
+				{
+					break;
+				}
+
+				numjoysticks++;
+			}			
+
+			return numjoysticks;
+		}
+		else
+		{
+			/* failed to open lowlevel.library! */
+			SDL_SetError("Unable to open lowlevel.library");
+			return 0;
+		}
+	}
+	else
+	{
+		return SDL_numjoysticks;
+	}
+}
+
+/* Function to get the device-dependent name of a joystick */
+#if !defined(PROTO_SDL_H)
+const char *SDL_SYS_JoystickName(int index)
+#else
+const char *SDL_SYS_JoystickNameI(int index, struct SDLBase *SDLBase)
+#endif
+{
+	static char	name[64];
+	unsigned long joyflag = 0L;
+
+	D(bug("SDL_SYS_JoystickName()\n"));
+
+	if(LowLevelBase)
+	{
+		memset(name, 0, sizeof(name));
+
+		index = PortIndex(index);
+
+		joyflag = ReadJoyPort(index);
+
+		if((joyflag&JP_TYPE_MASK) == JP_TYPE_NOTAVAIL)
+		{
+			SDL_SetError("No joystick available with that index");
+
+			return NULL;
+		}
+
+		if((joyflag&JP_TYPE_MASK) == JP_TYPE_GAMECTLR) sprintf(name, "Port %d is a Game Controller", index);
+		if((joyflag&JP_TYPE_MASK) == JP_TYPE_MOUSE) sprintf(name, "Port %d is a Mouse", index);
+		if((joyflag&JP_TYPE_MASK) == JP_TYPE_JOYSTK) sprintf(name, "Port %d is a Joystick", index);
+		if((joyflag&JP_TYPE_MASK) == JP_TYPE_UNKNOWN) sprintf(name, "Port %d is an unknown device", index);
+		
+		return name;
+	}
+	else
+	{
+		SDL_SetError("No joystick available with that index");
+
+		return NULL;
+	}
+}
+
+/* Function to open a joystick for use.
+   The joystick to open is specified by the index field of the joystick.
+   This should fill the nbuttons and naxes fields of the joystick structure.
+   It returns 0, or -1 if there is an error.
+ */
+#if !defined(PROTO_SDL_H)
+int SDL_SYS_JoystickOpen(SDL_Joystick *joystick)
+#else
+int SDL_SYS_JoystickOpenI(SDL_Joystick *joystick, struct SDLBase *SDLBase)
+#endif
+{
+	unsigned long temp = 0L;
+
+	D(bug("SDL_SYS_JoystickOpen()"));
+	D(bug("Opening joystick %ld\n", joystick->index));
+
+	if(!LowLevelBase)
+	{
+		if(SDL_SYS_JoystickInit() < 1)
+		{
+			SDL_SetError("Initialize Joysticks first!");
+			return -1;
+		}
+	}
+
+	/* if(!(joystick->hwdata=malloc(sizeof(struct joystick_hwdata)))) */
+	joystick->hwdata = (struct joystick_hwdata *) malloc(sizeof(*joystick->hwdata));
+	if ( joystick->hwdata == NULL )
+	{
+		SDL_OutOfMemory();
+
+		return -1;
+	}
+	memset(joystick->hwdata, 0, sizeof(*joystick->hwdata));
+
+	SetJoyPortAttrs(PortIndex(joystick->index), SJA_Type, SJA_TYPE_GAMECTLR, TAG_END);
+
+	temp = ReadJoyPort(PortIndex(joystick->index));
+
+	if((temp & JP_TYPE_MASK)==JP_TYPE_GAMECTLR)
+	{
+		joystick->nbuttons = 7;
+		joystick->nhats = 1;
+	}
+	else if((temp & JP_TYPE_MASK) == JP_TYPE_JOYSTK)
+	{
+		joystick->nbuttons = 3;
+		joystick->nhats = 1;
+	}
+	else if((temp & JP_TYPE_MASK) == JP_TYPE_MOUSE)
+	{
+		joystick->nbuttons = 3;
+		joystick->nhats = 0;
+	}
+	else if((temp & JP_TYPE_MASK) == JP_TYPE_UNKNOWN)
+	{
+		joystick->nbuttons = 3;
+		joystick->nhats = 1;
+	}
+	else if((temp & JP_TYPE_MASK) == JP_TYPE_NOTAVAIL)
+	{
+		joystick->nbuttons = 0;
+		joystick->nhats = 0;
+	}
+
+	joystick->nballs = 0;
+	joystick->naxes = 2; /* FIXME: even for JP_TYPE_NOTAVAIL ? */
+	joystick->hwdata->joystate = 0L;
+#ifndef NO_LOWLEVEL_EXT
+	joystick->hwdata->joystate_ext = 0L;
+
+	if (LowLevelBase->lib_Version > 50 || (LowLevelBase->lib_Version >= 50 && LowLevelBase->lib_Revision >= 17))
+		joystick->hwdata->supports_analog = 1;
+#endif
+
+	return 0;
+}
+
+/* Function to update the state of a joystick - called as a device poll.
+ * This function shouldn't update the joystick structure directly,
+ * but instead should call SDL_PrivateJoystick*() to deliver events
+ * and update joystick device state.
+ */
+#if !defined(PROTO_SDL_H)
+void SDL_SYS_JoystickUpdate(SDL_Joystick *joystick)
+#else
+void SDL_SYS_JoystickUpdateI(SDL_Joystick *joystick, struct SDLBase *SDLBase)
+#endif
+{
+	ULONG data;
+#ifndef NO_LOWLEVEL_EXT
+	ULONG data_ext = 0;
+#endif
+	int	i;
+	
+	D(bug("SDL_SYS_JoystickUpdate()\n"));
+
+	if(!LowLevelBase)
+	{
+		if(SDL_SYS_JoystickInit() < 1)
+		{
+			SDL_SetError("Initialize Joysticks first!");
+
+			return;
+		}
+	}
+
+	data = ReadJoyPort(PortIndex(joystick->index));
+#ifndef NO_LOWLEVEL_EXT
+	if (joystick->hwdata->supports_analog)
+		data_ext = ReadJoyPort(PortIndex(joystick->index) + JP_ANALOGUE_PORT_MAGIC);
+#endif
+
+	/* only send an event when something changed */
+
+	/* hats */
+	if((joystick->hwdata->joystate & JP_DIRECTION_MASK) != (data & JP_DIRECTION_MASK))
+	{
+		if(joystick->nhats)
+		{
+			Uint8 value_hat = SDL_HAT_CENTERED;
+
+			if(data & JPF_JOY_DOWN)
+			{
+				value_hat |= SDL_HAT_DOWN;
+			}
+			else if(data & JPF_JOY_UP)
+			{
+				value_hat |= SDL_HAT_UP;
+			}
+
+			if(data & JPF_JOY_LEFT)
+			{
+				value_hat |= SDL_HAT_LEFT;
+			}
+			else if(data & JPF_JOY_RIGHT)
+			{
+				value_hat |= SDL_HAT_RIGHT;
+			}
+
+			SDL_PrivateJoystickHat(joystick, 0, value_hat);
+		}
+	}
+
+	/* axes */
+#ifndef NO_LOWLEVEL_EXT
+	if (joystick->hwdata->supports_analog && data_ext & JP_TYPE_ANALOGUE)
+	{
+		if((joystick->hwdata->joystate_ext & JP_XAXIS_MASK) != (data_ext & JP_XAXIS_MASK))
+		{
+			Sint16 value;
+
+			value = (data_ext & JP_XAXIS_MASK) * 2*32767 / 255 - 32767;
+			SDL_PrivateJoystickAxis(joystick, 0, value);
+		}
+
+		if((joystick->hwdata->joystate_ext & JP_YAXIS_MASK) != (data_ext & JP_YAXIS_MASK))
+		{
+			Sint16 value;
+
+			value = ((data_ext & JP_YAXIS_MASK)>>8) * 2*32767 / 255 - 32767;
+			SDL_PrivateJoystickAxis(joystick, 1, value);
+		}
+	}
+	else
+#endif
+	{
+		if((joystick->hwdata->joystate & (JPF_JOY_DOWN|JPF_JOY_UP)) != (data & (JPF_JOY_DOWN|JPF_JOY_UP)))
+		{
+			Sint16 value;
+
+			/* UP and DOWN direction */
+			if(data & JPF_JOY_DOWN)
+			{
+				value = MOS_PLUS;
+			}
+			else if(data & JPF_JOY_UP)
+			{
+				value = MOS_MINUS;
+			}
+			else
+			{
+				value = 0;
+			}
+
+			SDL_PrivateJoystickAxis(joystick, 1, value);
+		}
+
+		if((joystick->hwdata->joystate & (JPF_JOY_LEFT|JPF_JOY_RIGHT)) != (data & (JPF_JOY_LEFT|JPF_JOY_RIGHT)))
+		{
+			Sint16 value;
+
+			/* LEFT and RIGHT direction */
+			if(data & JPF_JOY_LEFT)
+			{
+				value = MOS_MINUS;
+			}
+			else if(data & JPF_JOY_RIGHT)
+			{
+				value = MOS_PLUS;
+			}
+			else
+			{
+				value = 0;
+			}
+
+			SDL_PrivateJoystickAxis(joystick, 0, value);
+		}
+	}
+
+	/* Joy buttons */
+	for(i = 0; i < joystick->nbuttons; i++)
+	{
+		if( (data & joybut[i]) )
+		{
+			if(i == 1)
+			{
+				// FIXME: WTF?
+				data &= ~(joybut[2]);
+			}
+
+			if(!(joystick->hwdata->joystate & joybut[i]))
+			{
+				SDL_PrivateJoystickButton(joystick, i, SDL_PRESSED);
+			}
+		}
+		else if(joystick->hwdata->joystate & joybut[i])
+		{
+			SDL_PrivateJoystickButton(joystick, i, SDL_RELEASED);
+		}
+	}
+
+	joystick->hwdata->joystate = data;
+#ifndef NO_LOWLEVEL_EXT
+	joystick->hwdata->joystate_ext = data_ext;
+#endif
+}
+
+/* Function to close a joystick after use */
+#if !defined(PROTO_SDL_H)
+void SDL_SYS_JoystickClose(SDL_Joystick *joystick)
+#else
+void SDL_SYS_JoystickCloseI(SDL_Joystick *joystick, struct SDLBase *SDLBase)
+#endif
+{
+	D(bug("SDL_SYS_JoystickClose()\n"));
+
+	if(LowLevelBase)	/* ne to reinitialize */
+	{
+		SetJoyPortAttrs(PortIndex(joystick->index), SJA_Type, SJA_TYPE_AUTOSENSE, TAG_END);
+	}
+
+	if(joystick->hwdata)
+	{
+		free(joystick->hwdata);
+	}
+
+	return;
+}
+
+/* Function to perform any system-specific joystick related cleanup */
+#if !defined(PROTO_SDL_H)
+void SDL_SYS_JoystickQuit(void)
+#else
+void SDL_SYS_JoystickQuitI(struct SDLBase *SDLBase)
+#endif
+{
+	D(bug("SDL_SYS_JoystickQuit()\n"));
+
+	if(LowLevelBase)
+	{
+		CloseLibrary(LowLevelBase);
+		LowLevelBase = NULL;
+		SDL_numjoysticks = 0;
+	}
+
+	return;
+}
+
diff -Naur SDL-1.2.15-orig/src/joystick/SDL_joystick.c SDL-1.2.15/src/joystick/SDL_joystick.c
--- SDL-1.2.15-orig/src/joystick/SDL_joystick.c	2015-05-09 17:47:54.323774189 +0200
+++ SDL-1.2.15/src/joystick/SDL_joystick.c	2015-05-09 15:09:59.760739523 +0200
@@ -19,6 +19,11 @@
     Sam Lantinga
     slouken@libsdl.org
 */
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
 #include "SDL_config.h"
 
 /* This is the joystick API for Simple DirectMedia Layer */
@@ -40,7 +45,11 @@
 int SDL_allocatedjoysticks = 0;
 SDL_Joystick **SDL_joysticks = NULL;
 
+#if !defined(PROTO_SDL_H)
 int SDL_JoystickInit(void)
+#else
+int SDL_JoystickInitI(struct SDLBase *SDLBase)
+#endif
 {
 	int arraylen;
 	int status;
@@ -66,22 +75,43 @@
 /*
  * Count the number of joysticks attached to the system
  */
+#if !defined(PROTO_SDL_H)
 int SDL_NumJoysticks(void)
 {
+#else
+AROS_LH0(int, SDL_NumJoysticks,
+	struct SDLBase *, SDLBase, 91, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	return SDL_numjoysticks;
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 /*
  * Get the implementation dependent name of a joystick
  */
+#if !defined(PROTO_SDL_H)
 const char *SDL_JoystickName(int device_index)
 {
+#else
+AROS_LH1(const char *, SDL_JoystickName,
+	AROS_LHA(int, device_index, D0),
+	struct SDLBase *, SDLBase, 92, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	if ( (device_index < 0) || (device_index >= SDL_numjoysticks) ) {
 		SDL_SetError("There are %d joysticks available",
 		             SDL_numjoysticks);
 		return(NULL);
 	}
 	return(SDL_SYS_JoystickName(device_index));
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 /*
@@ -91,8 +121,16 @@
  *
  * This function returns a joystick identifier, or NULL if an error occurred.
  */
+#if !defined(PROTO_SDL_H)
 SDL_Joystick *SDL_JoystickOpen(int device_index)
 {
+#else
+AROS_LH1(SDL_Joystick *, SDL_JoystickOpen,
+	AROS_LHA(int, device_index, D0),
+	struct SDLBase *, SDLBase, 93, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	int i;
 	SDL_Joystick *joystick;
 
@@ -176,13 +214,24 @@
 	SDL_Unlock_EventThread();
 
 	return(joystick);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 /*
  * Returns 1 if the joystick has been opened, or 0 if it has not.
  */
+#if !defined(PROTO_SDL_H)
 int SDL_JoystickOpened(int device_index)
 {
+#else
+AROS_LH1(int, SDL_JoystickOpened,
+	AROS_LHA(int, device_index, D0),
+	struct SDLBase *, SDLBase, 94, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	int i, opened;
 
 	opened = 0;
@@ -193,9 +242,17 @@
 		}
 	}
 	return(opened);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 static int ValidJoystick(SDL_Joystick **joystick)
+#else
+#define ValidJoystick(joystick) ValidJoystickI(joystick, SDLBase)
+static int ValidJoystickI(SDL_Joystick **joystick, struct SDLBase *SDLBase)
+#endif
 {
 	int valid;
 
@@ -211,63 +268,127 @@
 /*
  * Get the device index of an opened joystick.
  */
+#if !defined(PROTO_SDL_H)
 int SDL_JoystickIndex(SDL_Joystick *joystick)
 {
+#else
+AROS_LH1(int, SDL_JoystickIndex,
+	AROS_LHA(SDL_Joystick *, joystick, A0),
+	struct SDLBase *, SDLBase, 95, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	if ( ! ValidJoystick(&joystick) ) {
 		return(-1);
 	}
 	return(joystick->index);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 /*
  * Get the number of multi-dimensional axis controls on a joystick
  */
+#if !defined(PROTO_SDL_H)
 int SDL_JoystickNumAxes(SDL_Joystick *joystick)
 {
+#else
+AROS_LH1(int, SDL_JoystickNumAxes,
+	AROS_LHA(SDL_Joystick *, joystick, A0),
+	struct SDLBase *, SDLBase, 96, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	if ( ! ValidJoystick(&joystick) ) {
 		return(-1);
 	}
 	return(joystick->naxes);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 /*
  * Get the number of hats on a joystick
  */
+#if !defined(PROTO_SDL_H)
 int SDL_JoystickNumHats(SDL_Joystick *joystick)
 {
+#else
+AROS_LH1(int, SDL_JoystickNumHats,
+	AROS_LHA(SDL_Joystick *, joystick, A0),
+	struct SDLBase *, SDLBase, 98, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	if ( ! ValidJoystick(&joystick) ) {
 		return(-1);
 	}
 	return(joystick->nhats);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 /*
  * Get the number of trackballs on a joystick
  */
+#if !defined(PROTO_SDL_H)
 int SDL_JoystickNumBalls(SDL_Joystick *joystick)
 {
+#else
+AROS_LH1(int, SDL_JoystickNumBalls,
+	AROS_LHA(SDL_Joystick *, joystick, A0),
+	struct SDLBase *, SDLBase, 97, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	if ( ! ValidJoystick(&joystick) ) {
 		return(-1);
 	}
 	return(joystick->nballs);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 /*
  * Get the number of buttons on a joystick
  */
+#if !defined(PROTO_SDL_H)
 int SDL_JoystickNumButtons(SDL_Joystick *joystick)
 {
+#else
+AROS_LH1(int, SDL_JoystickNumButtons,
+	AROS_LHA(SDL_Joystick *, joystick, A0),
+	struct SDLBase *, SDLBase, 99, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	if ( ! ValidJoystick(&joystick) ) {
 		return(-1);
 	}
 	return(joystick->nbuttons);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 /*
  * Get the current state of an axis control on a joystick
  */
+#if !defined(PROTO_SDL_H)
 Sint16 SDL_JoystickGetAxis(SDL_Joystick *joystick, int axis)
 {
+#else
+AROS_LH2(Sint16, SDL_JoystickGetAxis,
+	AROS_LHA(SDL_Joystick *, joystick, A0),
+	AROS_LHA(int, axis, D0),
+	struct SDLBase *, SDLBase, 102, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	Sint16 state;
 
 	if ( ! ValidJoystick(&joystick) ) {
@@ -280,13 +401,25 @@
 		state = 0;
 	}
 	return(state);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 /*
  * Get the current state of a hat on a joystick
  */
+#if !defined(PROTO_SDL_H)
 Uint8 SDL_JoystickGetHat(SDL_Joystick *joystick, int hat)
 {
+#else
+AROS_LH2(Uint8, SDL_JoystickGetHat,
+	AROS_LHA(SDL_Joystick *, joystick, A0),
+	AROS_LHA(int, hat, D0),
+	struct SDLBase *, SDLBase, 103, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	Uint8 state;
 
 	if ( ! ValidJoystick(&joystick) ) {
@@ -299,13 +432,27 @@
 		state = 0;
 	}
 	return(state);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 /*
  * Get the ball axis change since the last poll
  */
+#if !defined(PROTO_SDL_H)
 int SDL_JoystickGetBall(SDL_Joystick *joystick, int ball, int *dx, int *dy)
 {
+#else
+AROS_LH4(int, SDL_JoystickGetBall,
+	AROS_LHA(SDL_Joystick *, joystick, A0),
+	AROS_LHA(int, ball, D0),
+	AROS_LHA(int *, dx, A1),
+	AROS_LHA(int *, dy, A2),
+	struct SDLBase *, SDLBase, 104, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	int retval;
 
 	if ( ! ValidJoystick(&joystick) ) {
@@ -327,13 +474,25 @@
 		retval = -1;
 	}
 	return(retval);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 /*
  * Get the current state of a button on a joystick
  */
+#if !defined(PROTO_SDL_H)
 Uint8 SDL_JoystickGetButton(SDL_Joystick *joystick, int button)
 {
+#else
+AROS_LH2(Uint8, SDL_JoystickGetButton,
+	AROS_LHA(SDL_Joystick *, joystick, A0),
+	AROS_LHA(int, button, D0),
+	struct SDLBase *, SDLBase, 105, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	Uint8 state;
 
 	if ( ! ValidJoystick(&joystick) ) {
@@ -346,13 +505,24 @@
 		state = 0;
 	}
 	return(state);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 /*
  * Close a joystick previously opened with SDL_JoystickOpen()
  */
+#if !defined(PROTO_SDL_H)
 void SDL_JoystickClose(SDL_Joystick *joystick)
 {
+#else
+AROS_LH1(void, SDL_JoystickClose,
+	AROS_LHA(SDL_Joystick *, joystick, A0),
+	struct SDLBase *, SDLBase, 106, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	int i;
 
 	if ( ! ValidJoystick(&joystick) ) {
@@ -395,9 +565,17 @@
 		SDL_free(joystick->buttons);
 	}
 	SDL_free(joystick);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+
+#if !defined(PROTO_SDL_H)
 void SDL_JoystickQuit(void)
+#else
+void SDL_JoystickQuitI(struct SDLBase *SDLBase)
+#endif
 {
 	const int numsticks = SDL_numjoysticks;
 	int i;
@@ -428,8 +606,11 @@
 
 
 /* These are global for SDL_sysjoystick.c and SDL_events.c */
-
+#if !defined(PROTO_SDL_H)
 int SDL_PrivateJoystickAxis(SDL_Joystick *joystick, Uint8 axis, Sint16 value)
+#else
+int SDL_PrivateJoystickAxisI(SDL_Joystick *joystick, Uint8 axis, Sint16 value, struct SDLBase *SDLBase)
+#endif
 {
 	int posted;
 
@@ -459,7 +640,11 @@
 	return(posted);
 }
 
+#if !defined(PROTO_SDL_H)
 int SDL_PrivateJoystickHat(SDL_Joystick *joystick, Uint8 hat, Uint8 value)
+#else
+int SDL_PrivateJoystickHatI(SDL_Joystick *joystick, Uint8 hat, Uint8 value, struct SDLBase *SDLBase)
+#endif
 {
 	int posted;
 
@@ -489,8 +674,13 @@
 	return(posted);
 }
 
+#if !defined(PROTO_SDL_H)
 int SDL_PrivateJoystickBall(SDL_Joystick *joystick, Uint8 ball,
 					Sint16 xrel, Sint16 yrel)
+#else
+int SDL_PrivateJoystickBallI(SDL_Joystick *joystick, Uint8 ball,
+					Sint16 xrel, Sint16 yrel, struct SDLBase *SDLBase)
+#endif
 {
 	int posted;
 
@@ -522,7 +712,11 @@
 	return(posted);
 }
 
+#if !defined(PROTO_SDL_H)
 int SDL_PrivateJoystickButton(SDL_Joystick *joystick, Uint8 button, Uint8 state)
+#else
+int SDL_PrivateJoystickButtonI(SDL_Joystick *joystick, Uint8 button, Uint8 state, struct SDLBase *SDLBase)
+#endif
 {
 	int posted;
 #if !SDL_EVENTS_DISABLED
@@ -565,17 +759,35 @@
 	return(posted);
 }
 
+#if !defined(PROTO_SDL_H)
 void SDL_JoystickUpdate(void)
 {
+#else
+AROS_LH0(void, SDL_JoystickUpdate,
+	struct SDLBase *, SDLBase, 100, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	int i;
 
 	for ( i=0; SDL_joysticks[i]; ++i ) {
 		SDL_SYS_JoystickUpdate(SDL_joysticks[i]);
 	}
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 int SDL_JoystickEventState(int state)
 {
+#else
+AROS_LH1(int, SDL_JoystickEventState,
+	AROS_LHA(int, state, D0),
+	struct SDLBase *, SDLBase, 101, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 #if SDL_EVENTS_DISABLED
 	return SDL_IGNORE;
 #else
@@ -603,4 +815,7 @@
 	}
 	return(state);
 #endif /* SDL_EVENTS_DISABLED */
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
diff -Naur SDL-1.2.15-orig/src/joystick/SDL_joystick_c.h SDL-1.2.15/src/joystick/SDL_joystick_c.h
--- SDL-1.2.15-orig/src/joystick/SDL_joystick_c.h	2015-05-09 17:47:54.312774218 +0200
+++ SDL-1.2.15/src/joystick/SDL_joystick_c.h	2015-05-09 15:09:59.760739523 +0200
@@ -28,6 +28,7 @@
 extern Uint8 SDL_numjoysticks;
 
 /* Internal event queueing functions */
+#if !defined(PROTO_SDL_H)
 extern int SDL_PrivateJoystickAxis(SDL_Joystick *joystick,
                                    Uint8 axis, Sint16 value);
 extern int SDL_PrivateJoystickBall(SDL_Joystick *joystick,
@@ -36,3 +37,19 @@
                                  Uint8 hat, Uint8 value);
 extern int SDL_PrivateJoystickButton(SDL_Joystick *joystick,
                                      Uint8 button, Uint8 state);
+#else
+#include "SDL_intern.h"
+extern int SDL_PrivateJoystickAxisI(SDL_Joystick *joystick,
+                                   Uint8 axis, Sint16 value, struct SDLBase *SDLBase);
+extern int SDL_PrivateJoystickBallI(SDL_Joystick *joystick,
+                                   Uint8 ball, Sint16 xrel, Sint16 yrel, struct SDLBase *SDLBase);
+extern int SDL_PrivateJoystickHatI(SDL_Joystick *joystick,
+                                 Uint8 hat, Uint8 value, struct SDLBase *SDLBase);
+extern int SDL_PrivateJoystickButtonI(SDL_Joystick *joystick,
+                                     Uint8 button, Uint8 state, struct SDLBase *SDLBase);
+                                     
+#define SDL_PrivateJoystickAxis(joystick, axis, value) SDL_PrivateJoystickAxisI(joystick, axis, value, SDLBase)
+#define SDL_PrivateJoystickBall(joystick, ball, xrel, yrel) SDL_PrivateJoystickBallI(joystick, ball, xrel, yrel, SDLBase)
+#define SDL_PrivateJoystickHat(joystick, hat, value) SDL_PrivateJoystickHatI(joystick, hat, value, SDLBase)
+#define SDL_PrivateJoystickButton(joystick, button, state) SDL_PrivateJoystickButtonI(joystick, button, state, SDLBase)
+#endif
diff -Naur SDL-1.2.15-orig/src/joystick/SDL_sysjoystick.h SDL-1.2.15/src/joystick/SDL_sysjoystick.h
--- SDL-1.2.15-orig/src/joystick/SDL_sysjoystick.h	2015-05-09 17:47:54.312774218 +0200
+++ SDL-1.2.15/src/joystick/SDL_sysjoystick.h	2015-05-09 15:09:59.761739521 +0200
@@ -55,28 +55,39 @@
  * This function should return the number of available joysticks, or -1
  * on an unrecoverable fatal error.
  */
+#if !defined(PROTO_SDL_H)
 extern int SDL_SYS_JoystickInit(void);
-
 /* Function to get the device-dependent name of a joystick */
 extern const char *SDL_SYS_JoystickName(int index);
-
 /* Function to open a joystick for use.
    The joystick to open is specified by the index field of the joystick.
    This should fill the nbuttons and naxes fields of the joystick structure.
    It returns 0, or -1 if there is an error.
  */
 extern int SDL_SYS_JoystickOpen(SDL_Joystick *joystick);
-
 /* Function to update the state of a joystick - called as a device poll.
  * This function shouldn't update the joystick structure directly,
  * but instead should call SDL_PrivateJoystick*() to deliver events
  * and update joystick device state.
  */
 extern void SDL_SYS_JoystickUpdate(SDL_Joystick *joystick);
-
 /* Function to close a joystick after use */
 extern void SDL_SYS_JoystickClose(SDL_Joystick *joystick);
-
 /* Function to perform any system-specific joystick related cleanup */
 extern void SDL_SYS_JoystickQuit(void);
-
+#else
+#include "SDL_intern.h"
+extern int SDL_SYS_JoystickInitI(struct SDLBase *SDLBase);
+extern const char *SDL_SYS_JoystickNameI(int index, struct SDLBase *SDLBase);
+extern int SDL_SYS_JoystickOpenI(SDL_Joystick *joystick, struct SDLBase *SDLBase);
+extern void SDL_SYS_JoystickUpdateI(SDL_Joystick *joystick, struct SDLBase *SDLBase);
+extern void SDL_SYS_JoystickCloseI(SDL_Joystick *joystick, struct SDLBase *SDLBase);
+extern void SDL_SYS_JoystickQuitI(struct SDLBase *SDLBase);
+
+#define SDL_SYS_JoystickInit() SDL_SYS_JoystickInitI(SDLBase)
+#define SDL_SYS_JoystickName(index) SDL_SYS_JoystickNameI(index, SDLBase)
+#define SDL_SYS_JoystickOpen(joystick) SDL_SYS_JoystickOpenI(joystick, SDLBase)
+#define SDL_SYS_JoystickUpdate(joystick) SDL_SYS_JoystickUpdateI(joystick, SDLBase)
+#define SDL_SYS_JoystickClose(joystick) SDL_SYS_JoystickCloseI(joystick, SDLBase)
+#define SDL_SYS_JoystickQuit() SDL_SYS_JoystickQuitI(SDLBase)
+#endif
diff -Naur SDL-1.2.15-orig/src/loadso/dummy/SDL_sysloadso.c SDL-1.2.15/src/loadso/dummy/SDL_sysloadso.c
--- SDL-1.2.15-orig/src/loadso/dummy/SDL_sysloadso.c	2015-05-09 17:47:54.311774220 +0200
+++ SDL-1.2.15/src/loadso/dummy/SDL_sysloadso.c	2015-05-09 15:09:59.761739521 +0200
@@ -19,6 +19,11 @@
     Sam Lantinga
     slouken@libsdl.org
 */
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
 #include "SDL_config.h"
 
 #if defined(SDL_LOADSO_DUMMY) || defined(SDL_LOADSO_DISABLED)
@@ -28,21 +33,33 @@
 
 #include "SDL_loadso.h"
 
+#if !defined(PROTO_SDL_H)
 void *SDL_LoadObject(const char *sofile)
+#else
+void *SDL_LoadObject(const char *sofile, struct Library *SDLBase)
+#endif
 {
 	const char *loaderror = "SDL_LoadObject() not implemented";
 	SDL_SetError("Failed loading %s: %s", sofile, loaderror);
 	return(NULL);
 }
 
+#if !defined(PROTO_SDL_H)
 void *SDL_LoadFunction(void *handle, const char *name)
+#else
+void *SDL_LoadFunction(void *handle, const char *name, struct Library *SDLBase)
+#endif
 {
 	const char *loaderror = "SDL_LoadFunction() not implemented";
 	SDL_SetError("Failed loading %s: %s", name, loaderror);
 	return(NULL);
 }
 
+#if !defined(PROTO_SDL_H)
 void SDL_UnloadObject(void *handle)
+#else
+void SDL_UnloadObject(void *handle, struct Library *SDLBase)
+#endif
 {
     /* no-op. */
 }
diff -Naur SDL-1.2.15-orig/src/main/aros/mydebug.h SDL-1.2.15/src/main/aros/mydebug.h
--- SDL-1.2.15-orig/src/main/aros/mydebug.h	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.15/src/main/aros/mydebug.h	2015-05-09 15:09:59.761739521 +0200
@@ -0,0 +1,8 @@
+#ifndef MYDEBUG
+#define MYDEBUG
+#ifndef AROS_DEBUG_H
+#include <aros/debug.h>
+#endif
+#define MAKE_HIT() {char *a=NULL,b;b=*a;}
+
+#endif
diff -Naur SDL-1.2.15-orig/src/SDL.c SDL-1.2.15/src/SDL.c
--- SDL-1.2.15-orig/src/SDL.c	2015-05-09 17:47:54.323774189 +0200
+++ SDL-1.2.15/src/SDL.c	2015-05-09 15:09:59.761739521 +0200
@@ -19,6 +19,11 @@
     Sam Lantinga
     slouken@libsdl.org
 */
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
 #include "SDL_config.h"
 
 /* Initialization code for SDL */
@@ -33,6 +38,7 @@
 #include <pth.h>
 #endif
 
+#if !defined(PROTO_SDL_H)
 /* Initialization/Cleanup routines */
 #if !SDL_JOYSTICK_DISABLED
 extern int  SDL_JoystickInit(void);
@@ -47,23 +53,57 @@
 extern int  SDL_TimerInit(void);
 extern void SDL_TimerQuit(void);
 #endif
-
-/* The current SDL version */
-static SDL_version version = 
-	{ SDL_MAJOR_VERSION, SDL_MINOR_VERSION, SDL_PATCHLEVEL };
-
 /* The initialized subsystems */
 static Uint32 SDL_initialized = 0;
 #if !SDL_TIMERS_DISABLED
 static Uint32 ticks_started = 0;
 #endif
-
 #ifdef CHECK_LEAKS
 int surfaces_allocated = 0;
 #endif
+#else
+#include "SDL_intern.h"
+
+#if !SDL_JOYSTICK_DISABLED
+extern int  SDL_JoystickInitI(struct SDLBase *SDLBase);
+extern void SDL_JoystickQuitI(struct SDLBase *SDLBase);
+#define SDL_JoystickInit() SDL_JoystickInitI(SDLBase)
+#define SDL_JoystickQuit() SDL_JoystickQuitI(SDLBase)
+#endif
+#if !SDL_CDROM_DISABLED
+extern int  SDL_CDROMInitI(struct SDLBase *SDLBase);
+extern void SDL_CDROMQuitI(struct SDLBase *SDLBase);
+#define SDL_CDROMInit() SDL_CDROMInitI(SDLBase)
+#define SDL_CDROMQuit() SDL_CDROMQuitI(SDLBase)
+#endif
+#if !SDL_TIMERS_DISABLED
+extern void SDL_StartTicksI(struct SDLBase *SDLBase);
+extern int  SDL_TimerInitI(struct SDLBase *SDLBase);
+extern void SDL_TimerQuitI(struct SDLBase *SDLBase);
+#define SDL_StartTicks() SDL_StartTicksI(SDLBase)
+#define SDL_TimerInit() SDL_TimerInitI(SDLBase)
+#define SDL_TimerQuit() SDL_TimerQuitI(SDLBase)
+#endif
+
+#define SDL_initialized SDLBase->SDL_initialized
+#define ticks_started SDLBase->ticks_started
+#define surfaces_allocated SDLBase->surfaces_allocated
+#endif
 
+/* The current SDL version */
+static SDL_version version = 
+	{ SDL_MAJOR_VERSION, SDL_MINOR_VERSION, SDL_PATCHLEVEL };
+
+#if !defined(PROTO_SDL_H)
 int SDL_InitSubSystem(Uint32 flags)
 {
+#else
+AROS_LH1(int, SDL_InitSubSystem,
+	AROS_LHA(Uint32, flags, D0),
+	struct SDLBase *, SDLBase, 15, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 #if !SDL_TIMERS_DISABLED
 	/* Initialize the timer subsystem */
 	if ( ! ticks_started ) {
@@ -145,10 +185,22 @@
 	}
 #endif
 	return(0);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 int SDL_Init(Uint32 flags)
 {
+#else
+
+AROS_LH1(int, SDL_Init,
+	AROS_LHA(Uint32, flags, D0),
+	struct SDLBase *, SDLBase, 11, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 #if !SDL_THREADS_DISABLED && SDL_THREAD_PTH
 	if (!pth_init()) {
 		return -1;
@@ -168,10 +220,21 @@
 		SDL_InstallParachute();
 	}
 	return(0);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 void SDL_QuitSubSystem(Uint32 flags)
 {
+#else
+AROS_LH1(void, SDL_QuitSubSystem,
+	AROS_LHA(Uint32, flags, D0),
+	struct SDLBase *, SDLBase, 16, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	/* Shut down requested initialized subsystems */
 #if !SDL_CDROM_DISABLED
 	if ( (flags & SDL_initialized & SDL_INIT_CDROM) ) {
@@ -203,18 +266,39 @@
 		SDL_initialized &= ~SDL_INIT_TIMER;
 	}
 #endif
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 Uint32 SDL_WasInit(Uint32 flags)
 {
+#else
+AROS_LH1(Uint32, SDL_WasInit,
+	AROS_LHA(Uint32, flags, D0),
+	struct SDLBase *, SDLBase, 13, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	if ( ! flags ) {
 		flags = SDL_INIT_EVERYTHING;
 	}
 	return (SDL_initialized&flags);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 void SDL_Quit(void)
 {
+#else
+AROS_LH0(void, SDL_Quit,
+	struct SDLBase *, SDLBase, 14, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	/* Quit all subsystems */
 #ifdef DEBUG_BUILD
   printf("[SDL_Quit] : Enter! Calling QuitSubSystem()\n"); fflush(stdout);
@@ -245,13 +329,26 @@
 #ifdef DEBUG_BUILD
   printf("[SDL_Quit] : Returning!\n"); fflush(stdout);
 #endif
-
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 /* Return the library version number */
+#if !defined(PROTO_SDL_H)
 const SDL_version * SDL_Linked_Version(void)
 {
+#else
+AROS_LH0(const SDL_version *, SDL_Linked_Version,
+	struct SDLBase *, SDLBase, 12, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	return(&version);
+    
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 #if defined(__OS2__)
diff -Naur SDL-1.2.15-orig/src/SDL_error.c SDL-1.2.15/src/SDL_error.c
--- SDL-1.2.15-orig/src/SDL_error.c	2015-05-09 17:47:54.280774303 +0200
+++ SDL-1.2.15/src/SDL_error.c	2015-05-09 15:09:59.761739521 +0200
@@ -19,6 +19,13 @@
     Sam Lantinga
     slouken@libsdl.org
 */
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
+#define DEBUG_ERROR
+
 #include "SDL_config.h"
 
 /* Simple error handling in SDL */
@@ -27,6 +34,7 @@
 #include "SDL_error_c.h"
 
 /* Routine to get the thread-specific error variable */
+#if !defined(PROTO_SDL_H)
 #if SDL_THREADS_DISABLED
 /* The  SDL_arraysize(The ),default (non-thread-safe) global error variable */
 static SDL_error SDL_global_error;
@@ -34,6 +42,12 @@
 #else
 extern SDL_error *SDL_GetErrBuf(void);
 #endif /* SDL_THREADS_DISABLED */
+#else
+#include "SDL_intern.h"
+#define SDL_global_error SDLBase->SDL_global_error
+extern SDL_error *SDL_GetErrBufI(struct SDLBase *SDLBase);
+#define SDL_GetErrBuf() SDL_GetErrBufI(SDLBase)
+#endif
 
 #define SDL_ERRBUFIZE	1024
 
@@ -46,18 +60,30 @@
 }
 
 /* Public functions */
+#define fetch_arg(ap, type) ((type)(*(ap++)))
+
+#if !defined(PROTO_SDL_H)
+
+void SDL_SetErrorA (const char *fmt, CONST IPTR *params)
+{
+#else
 
-void SDL_SetError (const char *fmt, ...)
+AROS_LH2(void, SDL_SetErrorA,
+	AROS_LHA(const char *, fmt, A0),
+	AROS_LHA(CONST IPTR *, params, A1),
+	struct SDLBase *, SDLBase, 122, SDL)
 {
-	va_list ap;
+    AROS_LIBFUNC_INIT
+#endif
 	SDL_error *error;
 
+        CONST IPTR *ap = params;
+
 	/* Copy in the key, mark error as valid */
 	error = SDL_GetErrBuf();
 	error->error = 1;
 	SDL_strlcpy((char *)error->key, fmt, sizeof(error->key));
 
-	va_start(ap, fmt);
 	error->argc = 0;
 	while ( *fmt ) {
 		if ( *fmt++ == '%' ) {
@@ -76,20 +102,20 @@
 			    case 'x':
 			    case 'X':
 				error->args[error->argc++].value_i =
-							va_arg(ap, int);
+							fetch_arg(ap, int);
 				break;
 			    case 'f':
 				error->args[error->argc++].value_f =
-							va_arg(ap, double);
+							fetch_arg(ap, double);
 				break;
 			    case 'p':
 				error->args[error->argc++].value_ptr =
-							va_arg(ap, void *);
+							fetch_arg(ap, void *);
 				break;
 			    case 's':
 				{
 				  int i = error->argc;
-				  const char *str = va_arg(ap, const char *);
+				  const char *str = fetch_arg(ap, const char *);
 				  if (str == NULL)
 				      str = "(null)";
 				  SDL_strlcpy((char *)error->args[i].buf, str, ERR_MAX_STRLEN);
@@ -104,18 +130,24 @@
 			}
 		}
 	}
-	va_end(ap);
-
 	/* If we are in debug mode, print out an error message */
 #ifdef DEBUG_ERROR
 	fprintf(stderr, "SDL_SetError: %s\n", SDL_GetError());
 #endif
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 /* This function has a bit more overhead than most error functions
    so that it supports internationalization and thread-safe errors.
 */
+#if !defined(PROTO_SDL_H)
 char *SDL_GetErrorMsg(char *errstr, unsigned int maxlen)
+#else
+#define SDL_GetErrorMsg(errstr, maxlen) SDL_GetErrorMsgI(errstr, maxlen, SDLBase)
+char *SDL_GetErrorMsgI(char *errstr, unsigned int maxlen, struct SDLBase *SDLBase)
+#endif
 {
 	SDL_error *error;
 
@@ -184,24 +216,52 @@
 }
 
 /* Available for backwards compatibility */
+#if !defined(PROTO_SDL_H)
 char *SDL_GetError (void)
 {
+#else
+AROS_LH0(char *, SDL_GetError,
+	struct SDLBase *, SDLBase, 123, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	static char errmsg[SDL_ERRBUFIZE];
 
 	return((char *)SDL_GetErrorMsg(errmsg, SDL_ERRBUFIZE));
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 void SDL_ClearError(void)
 {
+#else
+AROS_LH0(void, SDL_ClearError,
+	struct SDLBase *, SDLBase, 124, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	SDL_error *error;
 
 	error = SDL_GetErrBuf();
 	error->error = 0;
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 /* Very common errors go here */
+#if !defined(PROTO_SDL_H)
 void SDL_Error(SDL_errorcode code)
 {
+#else
+AROS_LH1(void, SDL_Error,
+	AROS_LHA(SDL_errorcode, code, D0),
+	struct SDLBase *, SDLBase, 168, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	switch (code) {
 		case SDL_ENOMEM:
 			SDL_SetError("Out of memory");
@@ -219,6 +279,9 @@
 			SDL_SetError("Unknown SDL error");
 			break;
 	}
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 #ifdef TEST_ERROR
diff -Naur SDL-1.2.15-orig/src/SDL_fatal.c SDL-1.2.15/src/SDL_fatal.c
--- SDL-1.2.15-orig/src/SDL_fatal.c	2015-05-09 17:47:54.323774189 +0200
+++ SDL-1.2.15/src/SDL_fatal.c	2015-05-09 15:09:59.761739521 +0200
@@ -19,6 +19,11 @@
     Sam Lantinga
     slouken@libsdl.org
 */
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
 #include "SDL_config.h"
 
 /* General fatal signal handling code for SDL */
@@ -38,7 +43,11 @@
 static void SDL_Parachute(int sig)
 {
 	signal(sig, SIG_DFL);
+#if !defined(PROTO_SDL_H)
 	SDL_Quit();
+#else
+	// FIXME: Call SDL_Quit()
+#endif
 	raise(sig);
 }
 
diff -Naur SDL-1.2.15-orig/src/stdlib/SDL_getenv.c SDL-1.2.15/src/stdlib/SDL_getenv.c
--- SDL-1.2.15-orig/src/stdlib/SDL_getenv.c	2015-05-09 17:47:54.353774110 +0200
+++ SDL-1.2.15/src/stdlib/SDL_getenv.c	2015-05-09 15:09:59.762739519 +0200
@@ -19,6 +19,11 @@
     Sam Lantinga
     slouken@libsdl.org
 */
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
 #include "SDL_config.h"
 
 #include "SDL_stdinc.h"
diff -Naur SDL-1.2.15-orig/src/stdlib/SDL_iconv.c SDL-1.2.15/src/stdlib/SDL_iconv.c
--- SDL-1.2.15-orig/src/stdlib/SDL_iconv.c	2015-05-09 17:47:54.353774110 +0200
+++ SDL-1.2.15/src/stdlib/SDL_iconv.c	2015-05-09 15:09:59.762739519 +0200
@@ -19,6 +19,11 @@
     Sam Lantinga
     slouken@libsdl.org
 */
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
 #include "SDL_config.h"
 
 /* This file contains portable iconv functions for SDL */
@@ -39,12 +44,14 @@
 
 #include <errno.h>
 
+struct SDLBase;
+
 size_t SDL_iconv(SDL_iconv_t cd,
                  const char **inbuf, size_t *inbytesleft,
                  char **outbuf, size_t *outbytesleft)
 {
 	size_t retCode;
-#ifdef ICONV_INBUF_NONCONST
+#if defined(ICONV_INBUF_NONCONST) || defined(__AROS__)
 	retCode = iconv(cd, (char **)inbuf, inbytesleft, outbuf, outbytesleft);
 #else
 	retCode = iconv(cd, inbuf, inbytesleft, outbuf, outbytesleft);
@@ -812,8 +819,19 @@
 
 #endif /* !HAVE_ICONV */
 
+#if !defined(PROTO_SDL_H)
 char *SDL_iconv_string(const char *tocode, const char *fromcode, const char *inbuf, size_t inbytesleft)
 {
+#else
+AROS_LH4(char *, SDL_iconv_string,
+	AROS_LHA(const char *, tocode, A0),
+	AROS_LHA(const char *, fromcode, A1),
+	AROS_LHA(const char *, inbuf, A2),
+	AROS_LHA(size_t, inbytesleft, D0),
+	struct SDLBase *, SDLBase, 195, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	SDL_iconv_t cd;
 	char *string;
 	size_t stringsize;
@@ -878,4 +896,7 @@
 	SDL_iconv_close(cd);
 
 	return string;
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
diff -Naur SDL-1.2.15-orig/src/stdlib/SDL_malloc.c SDL-1.2.15/src/stdlib/SDL_malloc.c
--- SDL-1.2.15-orig/src/stdlib/SDL_malloc.c	2015-05-09 17:47:54.353774110 +0200
+++ SDL-1.2.15/src/stdlib/SDL_malloc.c	2015-05-09 15:09:59.762739519 +0200
@@ -19,6 +19,11 @@
     Sam Lantinga
     slouken@libsdl.org
 */
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
 #include "SDL_config.h"
 
 /* This file contains portable memory management functions for SDL */
diff -Naur SDL-1.2.15-orig/src/stdlib/SDL_qsort.c SDL-1.2.15/src/stdlib/SDL_qsort.c
--- SDL-1.2.15-orig/src/stdlib/SDL_qsort.c	2015-05-09 17:47:54.353774110 +0200
+++ SDL-1.2.15/src/stdlib/SDL_qsort.c	2015-05-09 15:09:59.763739517 +0200
@@ -41,6 +41,11 @@
  *
  * Gareth McCaughan   Peterhouse   Cambridge   1998
  */
+ #if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
 #include "SDL_config.h"
 
 /*
diff -Naur SDL-1.2.15-orig/src/stdlib/SDL_stdlib.c SDL-1.2.15/src/stdlib/SDL_stdlib.c
--- SDL-1.2.15-orig/src/stdlib/SDL_stdlib.c	2015-05-09 17:47:54.353774110 +0200
+++ SDL-1.2.15/src/stdlib/SDL_stdlib.c	2015-05-09 15:09:59.763739517 +0200
@@ -19,6 +19,11 @@
     Sam Lantinga
     slouken@libsdl.org
 */
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
 #include "SDL_config.h"
 
 /* This file contains portable stdlib functions for SDL */
diff -Naur SDL-1.2.15-orig/src/stdlib/SDL_string.c SDL-1.2.15/src/stdlib/SDL_string.c
--- SDL-1.2.15-orig/src/stdlib/SDL_string.c	2015-05-09 17:47:54.353774110 +0200
+++ SDL-1.2.15/src/stdlib/SDL_string.c	2015-05-09 15:09:59.763739517 +0200
@@ -19,6 +19,11 @@
     Sam Lantinga
     slouken@libsdl.org
 */
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
 #include "SDL_config.h"
 
 /* This file contains portable string manipulation functions for SDL */
diff -Naur SDL-1.2.15-orig/src/thread/aros/SDL_syscond.c SDL-1.2.15/src/thread/aros/SDL_syscond.c
--- SDL-1.2.15-orig/src/thread/aros/SDL_syscond.c	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.15/src/thread/aros/SDL_syscond.c	2015-05-09 15:09:59.763739517 +0200
@@ -0,0 +1,297 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002  Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+
+   An implementation of condition variables using semaphores and mutexes
+
+   This implementation borrows heavily from the BeOS condition variable
+   implementation, written by Christopher Tate and Owen Smith.  Thanks!
+   
+ 	Yannick Erb
+	yannick.erb@free.fr
+	
+		20110326	Adapted for AROS
+
+ */
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "SDL_error.h"
+#include "SDL_thread.h"
+
+struct SDLBase;
+
+struct SDL_cond
+{
+	SDL_mutex *lock;
+	int waiting;
+	int signals;
+	SDL_sem *wait_sem;
+	SDL_sem *wait_done;
+};
+
+/* Create a condition variable */
+#if !defined(PROTO_SDL_H)
+SDL_cond * SDL_CreateCond(void)
+{
+#else
+AROS_LH0(SDL_cond *, SDL_CreateCond,
+	struct SDLBase *, SDLBase, 169, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
+	SDL_cond *cond;
+
+	cond = (SDL_cond *) malloc(sizeof(SDL_cond));
+	if ( cond ) {
+		cond->lock = SDL_CreateMutex();
+		cond->wait_sem = SDL_CreateSemaphore(0);
+		cond->wait_done = SDL_CreateSemaphore(0);
+		cond->waiting = cond->signals = 0;
+		if ( ! cond->lock || ! cond->wait_sem || ! cond->wait_done ) {
+			SDL_DestroyCond(cond);
+			cond = NULL;
+		}
+	} else {
+		SDL_OutOfMemory();
+	}
+	return(cond);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
+}
+
+/* Destroy a condition variable */
+#if !defined(PROTO_SDL_H)
+void SDL_DestroyCond(SDL_cond *cond)
+{
+#else
+AROS_LH1(void, SDL_DestroyCond,
+	AROS_LHA(SDL_cond *, cond, A0),
+	struct SDLBase *, SDLBase, 170, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
+	if ( cond ) {
+		if ( cond->wait_sem ) {
+			SDL_DestroySemaphore(cond->wait_sem);
+		}
+		if ( cond->wait_done ) {
+			SDL_DestroySemaphore(cond->wait_done);
+		}
+		if ( cond->lock ) {
+			SDL_DestroyMutex(cond->lock);
+		}
+		free(cond);
+	}
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
+}
+
+/* Restart one of the threads that are waiting on the condition variable */
+#if !defined(PROTO_SDL_H)
+int SDL_CondSignal(SDL_cond *cond)
+{
+#else
+AROS_LH1(int, SDL_CondSignal,
+	AROS_LHA(SDL_cond *, cond, A0),
+	struct SDLBase *, SDLBase, 171, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
+	if ( ! cond ) {
+		SDL_SetError("Passed a NULL condition variable");
+		return -1;
+	}
+
+	/* If there are waiting threads not already signalled, then
+	   signal the condition and wait for the thread to respond.
+	*/
+	SDL_LockMutex(cond->lock);
+	if ( cond->waiting > cond->signals ) {
+		++cond->signals;
+		SDL_SemPost(cond->wait_sem);
+		SDL_UnlockMutex(cond->lock);
+		SDL_SemWait(cond->wait_done);
+	} else {
+		SDL_UnlockMutex(cond->lock);
+	}
+
+	return 0;
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
+}
+
+/* Restart all threads that are waiting on the condition variable */
+#if !defined(PROTO_SDL_H)
+int SDL_CondBroadcast(SDL_cond *cond)
+{
+#else
+AROS_LH1(int, SDL_CondBroadcast,
+	AROS_LHA(SDL_cond *, cond, A0),
+	struct SDLBase *, SDLBase, 172, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
+	if ( ! cond ) {
+		SDL_SetError("Passed a NULL condition variable");
+		return -1;
+	}
+
+	/* If there are waiting threads not already signalled, then
+	   signal the condition and wait for the thread to respond.
+	*/
+	SDL_LockMutex(cond->lock);
+	if ( cond->waiting > cond->signals ) {
+		int i, num_waiting;
+
+		num_waiting = (cond->waiting - cond->signals);
+		cond->signals = cond->waiting;
+		for ( i=0; i<num_waiting; ++i ) {
+			SDL_SemPost(cond->wait_sem);
+		}
+		/* Now all released threads are blocked here, waiting for us.
+		   Collect them all (and win fabulous prizes!) :-)
+		 */
+		SDL_UnlockMutex(cond->lock);
+		for ( i=0; i<num_waiting; ++i ) {
+			SDL_SemWait(cond->wait_done);
+		}
+	} else {
+		SDL_UnlockMutex(cond->lock);
+	}
+
+	return 0;
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
+}
+
+/* Wait on the condition variable for at most 'ms' milliseconds.
+   The mutex must be locked before entering this function!
+   The mutex is unlocked during the wait, and locked again after the wait.
+
+Typical use:
+
+Thread A:
+	SDL_LockMutex(lock);
+	while ( ! condition ) {
+		SDL_CondWait(cond);
+	}
+	SDL_UnlockMutex(lock);
+
+Thread B:
+	SDL_LockMutex(lock);
+	...
+	condition = true;
+	...
+	SDL_UnlockMutex(lock);
+ */
+#if !defined(PROTO_SDL_H)
+int SDL_CondWaitTimeout(SDL_cond *cond, SDL_mutex *mutex, Uint32 ms)
+{
+#else
+AROS_LH3(int, SDL_CondWaitTimeout,
+	AROS_LHA(SDL_cond *, cond, A0),
+	AROS_LHA(SDL_mutex *, mutex, A1),
+	AROS_LHA(Uint32, ms, D0),
+	struct SDLBase *, SDLBase, 173, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
+	int retval;
+
+	if ( ! cond ) {
+		SDL_SetError("Passed a NULL condition variable");
+		return -1;
+	}
+
+	/* Obtain the protection mutex, and increment the number of waiters.
+	   This allows the signal mechanism to only perform a signal if there
+	   are waiting threads.
+	 */
+	SDL_LockMutex(cond->lock);
+	++cond->waiting;
+	SDL_UnlockMutex(cond->lock);
+
+	/* Unlock the mutex, as is required by condition variable semantics */
+	SDL_UnlockMutex(mutex);
+
+	/* Wait for a signal */
+	if ( ms == SDL_MUTEX_MAXWAIT ) {
+		retval = SDL_SemWait(cond->wait_sem);
+	} else {
+		retval = SDL_SemWaitTimeout(cond->wait_sem, ms);
+	}
+
+	/* Let the signaler know we have completed the wait, otherwise
+           the signaler can race ahead and get the condition semaphore
+           if we are stopped between the mutex unlock and semaphore wait,
+           giving a deadlock.  See the following URL for details:
+        http://www-classic.be.com/aboutbe/benewsletter/volume_III/Issue40.html
+	*/
+	SDL_LockMutex(cond->lock);
+	if ( cond->signals > 0 ) {
+		/* If we timed out, we need to eat a condition signal */
+		if ( retval > 0 ) {
+			SDL_SemWait(cond->wait_sem);
+		}
+		/* We always notify the signal thread that we are done */
+		SDL_SemPost(cond->wait_done);
+
+		/* Signal handshake complete */
+		--cond->signals;
+	}
+	--cond->waiting;
+	SDL_UnlockMutex(cond->lock);
+
+	/* Lock the mutex, as is required by condition variable semantics */
+	SDL_LockMutex(mutex);
+
+	return retval;
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
+}
+
+/* Wait on the condition variable forever */
+#if !defined(PROTO_SDL_H)
+int SDL_CondWait(SDL_cond *cond, SDL_mutex *mutex)
+{
+#else
+AROS_LH2(int, SDL_CondWait,
+	AROS_LHA(SDL_cond *, cond, A0),
+	AROS_LHA(SDL_mutex *, mutex, A1),
+	struct SDLBase *, SDLBase, 174, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
+	return SDL_CondWaitTimeout(cond, mutex, SDL_MUTEX_MAXWAIT);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
+}
diff -Naur SDL-1.2.15-orig/src/thread/aros/SDL_sysmutex.c SDL-1.2.15/src/thread/aros/SDL_sysmutex.c
--- SDL-1.2.15-orig/src/thread/aros/SDL_sysmutex.c	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.15/src/thread/aros/SDL_sysmutex.c	2015-05-09 15:09:59.763739517 +0200
@@ -0,0 +1,179 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is SDL_free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
+#include "SDL_config.h"
+
+/* An implementation of mutexes using semaphores */
+
+#include "SDL_error.h"
+#include "SDL_thread.h"
+#include "SDL_systhread_c.h"
+
+struct SDLBase;
+
+struct SDL_mutex {
+	int recursive;
+	Uint32 owner;
+	SDL_sem *sem;
+};
+
+/* Create a mutex */
+#if !defined(PROTO_SDL_H)
+SDL_mutex *SDL_CreateMutex(void)
+{
+#else
+AROS_LH0(SDL_mutex *, SDL_CreateMutex,
+	struct SDLBase *, SDLBase, 157, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
+	SDL_mutex *mutex;
+
+	/* Allocate mutex memory */
+	mutex = (SDL_mutex *)SDL_malloc(sizeof(*mutex));
+	if ( mutex ) {
+		/* Create the mutex semaphore, with initial value 1 */
+		mutex->sem = SDL_CreateSemaphore(1);
+		mutex->recursive = 0;
+		mutex->owner = 0;
+		if ( ! mutex->sem ) {
+			SDL_free(mutex);
+			mutex = NULL;
+		}
+	} else {
+		SDL_OutOfMemory();
+	}
+	return mutex;
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
+}
+
+/* Free the mutex */
+#if !defined(PROTO_SDL_H)
+void SDL_DestroyMutex(SDL_mutex *mutex)
+{
+#else
+AROS_LH1(void, SDL_DestroyMutex,
+	AROS_LHA(SDL_mutex *, mutex, A0),
+	struct SDLBase *, SDLBase, 158, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
+	if ( mutex ) {
+		if ( mutex->sem ) {
+			SDL_DestroySemaphore(mutex->sem);
+		}
+		SDL_free(mutex);
+	}
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
+}
+
+/* Lock the semaphore */
+#if !defined(PROTO_SDL_H)
+int SDL_mutexP(SDL_mutex *mutex)
+{
+#else
+AROS_LH1(int, SDL_mutexP,
+	AROS_LHA(SDL_mutex *, mutex, A0),
+	struct SDLBase *, SDLBase, 159, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
+#ifdef DISABLE_THREADS
+	return 0;
+#else
+	Uint32 this_thread;
+
+	if ( mutex == NULL ) {
+		SDL_SetError("Passed a NULL mutex");
+		return -1;
+	}
+
+	this_thread = SDL_ThreadID();
+	if ( mutex->owner == this_thread ) {
+		++mutex->recursive;
+	} else {
+		/* The order of operations is important.
+		   We set the locking thread id after we obtain the lock
+		   so unlocks from other threads will fail.
+		*/
+		SDL_SemWait(mutex->sem);
+		mutex->owner = this_thread;
+		mutex->recursive = 0;
+	}
+
+	return 0;
+#endif /* DISABLE_THREADS */
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
+}
+
+/* Unlock the mutex */
+#if !defined(PROTO_SDL_H)
+int SDL_mutexV(SDL_mutex *mutex)
+{
+#else
+AROS_LH1(int, SDL_mutexV,
+	AROS_LHA(SDL_mutex *, mutex, A0),
+	struct SDLBase *, SDLBase, 160, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
+#ifdef DISABLE_THREADS
+	return 0;
+#else
+	if ( mutex == NULL ) {
+		SDL_SetError("Passed a NULL mutex");
+		return -1;
+	}
+
+	/* If we don't own the mutex, we can't unlock it */
+	if ( SDL_ThreadID() != mutex->owner ) {
+		SDL_SetError("mutex not owned by this thread");
+		return -1;
+	}
+
+	if ( mutex->recursive ) {
+		--mutex->recursive;
+	} else {
+		/* The order of operations is important.
+		   First reset the owner so another thread doesn't lock
+		   the mutex and set the ownership before we reset it,
+		   then release the lock semaphore.
+		 */
+		mutex->owner = 0;
+		SDL_SemPost(mutex->sem);
+	}
+	return 0;
+#endif /* DISABLE_THREADS */
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
+}
diff -Naur SDL-1.2.15-orig/src/thread/aros/SDL_syssem.c SDL-1.2.15/src/thread/aros/SDL_syssem.c
--- SDL-1.2.15-orig/src/thread/aros/SDL_syssem.c	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.15/src/thread/aros/SDL_syssem.c	2015-05-09 15:09:59.764739515 +0200
@@ -0,0 +1,658 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002  Sam Lantinga
+    Copyright (C) 2004  Harry Sintonen
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+
+    Harry Sintonen
+    sintonen@iki.fi
+
+		20040824	Non-polling SDL_SemWaitTimeout
+				Optimized
+
+		20040822	Reimplementation. Improvements:
+				- initial_value != 1 works properly
+				- wait can be aborted via CTRL-C
+				- doesn't nest per task
+
+		20040513	SDL_SemTryWait() function return value fixed
+
+		20040510	ObtainSemaphore inserted in SDL_SemWaitTimeout
+
+		20040504	Debug lines added
+				WarpOS code removed
+				
+	Yannick Erb
+	yannick.erb@free.fr
+	
+		20110326	Adapted for AROS
+
+*/
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
+#include <stdlib.h> /* for malloc/free */
+
+#include "SDL_error.h"
+#include "SDL_thread.h"
+#include "SDL_systhread_c.h"
+#include "../../timer/SDL_systimer.h"
+
+#include <exec/semaphores.h>
+#include <devices/timer.h>
+#include <dos/dos.h>
+
+#include "../../main/aros/mydebug.h"
+
+#if !defined(PROTO_SDL_H)
+extern struct timerequest	*TimerIO;
+#else
+#include "SDL_intern.h"
+
+#define TimerIO SDLBase->TimerIO
+#endif
+
+struct waitnode
+{
+	struct MinNode node;
+	struct Task   *task;
+	ULONG          sigmask;
+};
+
+struct SDL_semaphore
+{
+	struct SignalSemaphore sem;
+	struct MinList         waitlist;
+	int                    sem_value;
+};
+
+struct mywaitdata
+{
+	struct MsgPort      port;
+	struct timerequest  timereq;
+	ULONG               extramask;
+	BOOL                pending;
+};
+
+#define FALLBACKSIGNAL SIGBREAKB_CTRL_E
+
+static
+void mywaitdone(struct mywaitdata *data)
+{
+	if (data->pending)
+	{
+		data->pending = FALSE;
+		AbortIO((struct IORequest *) &data->timereq);
+		WaitIO((struct IORequest *) &data->timereq);
+	}
+
+	if ((BYTE) data->port.mp_SigBit != -1)
+	{
+		FreeSignal(data->port.mp_SigBit);
+		data->port.mp_SigBit = (UBYTE) -1;
+	}
+}
+
+#if !defined(PROTO_SDL_H)
+static
+int mywaitinit(struct mywaitdata *data, Uint32 timeout)
+#else
+#define mywaitinit(data, timeout) mywaitinitI(data, timeout, SDLBase)
+static int mywaitinitI(struct mywaitdata *data, Uint32 timeout, struct SDLBase *SDLBase)
+#endif
+{
+	data->extramask = 0;
+	data->pending   = FALSE;
+	data->port.mp_SigBit = -1;
+
+	if (TimerIO && ((BYTE) (data->port.mp_SigBit = AllocSignal(-1)) != -1))
+	{
+		struct timerequest *req = TimerIO;
+
+		data->port.mp_Node.ln_Type = NT_MSGPORT;
+		data->port.mp_Flags        = PA_SIGNAL;
+		data->port.mp_SigTask      = FindTask(NULL);
+		NEWLIST(&data->port.mp_MsgList);
+
+		data->timereq.tr_node.io_Message.mn_Node.ln_Type = NT_REPLYMSG;
+		data->timereq.tr_node.io_Message.mn_ReplyPort    = &data->port;
+		data->timereq.tr_node.io_Message.mn_Length       = sizeof(data->timereq);
+		data->timereq.tr_node.io_Device                  = req->tr_node.io_Device;
+		data->timereq.tr_node.io_Unit                    = req->tr_node.io_Unit;
+
+		return 0;
+	}
+
+	mywaitdone(data);
+
+	return -1;
+}
+
+static
+int mywait(struct mywaitdata *data, Uint32 timeout)
+{
+	ULONG wsig, sigs;
+
+	wsig = 1 << data->timereq.tr_node.io_Message.mn_ReplyPort->mp_SigBit;
+
+	if (!data->pending)
+	{
+		data->pending = TRUE;
+		data->timereq.tr_node.io_Command = TR_ADDREQUEST;
+		data->timereq.tr_time.tv_secs  = timeout / 1000;
+		data->timereq.tr_time.tv_micro = (timeout % 1000) * 1000;
+		SendIO((struct IORequest *) &data->timereq);
+	}
+
+	sigs = Wait(wsig | data->extramask | SIGBREAKF_CTRL_C);
+
+	if (sigs & wsig)
+	{
+		data->pending = FALSE;
+		WaitIO((struct IORequest *) &data->timereq);
+	}
+	else
+	{
+		if (data->pending && data->extramask == 0)
+		{
+			data->pending = FALSE;
+			AbortIO((struct IORequest *) &data->timereq);
+			WaitIO((struct IORequest *) &data->timereq);
+		}
+	}
+
+	data->extramask &= sigs;
+
+	if (sigs & SIGBREAKF_CTRL_C)
+	{
+		return -1;
+	}
+
+	return 0;
+}
+
+/* Create a semaphore, initialized with value */
+#if !defined(PROTO_SDL_H)
+SDL_sem *SDL_CreateSemaphore(Uint32 initial_value)
+{
+#else
+AROS_LH1(SDL_sem *, SDL_CreateSemaphore,
+	AROS_LHA(Uint32, initial_value, D0),
+	struct SDLBase *, SDLBase, 161, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
+	SDL_sem *sem;
+
+	D(bug("[SDL] SDL_CreateSemaphore(%ld)\n", initial_value));
+
+	sem = malloc(sizeof(*sem));
+	if (sem)
+	{
+		memset(&sem->sem, 0, sizeof(sem->sem));
+		InitSemaphore(&sem->sem);
+
+		NEWLIST(&sem->waitlist);
+
+		sem->sem_value = initial_value;
+	}
+	else
+	{
+		SDL_OutOfMemory();
+	}
+
+	return sem;
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
+}
+
+#if !defined(PROTO_SDL_H)
+void SDL_DestroySemaphore(SDL_sem *sem)
+{
+#else
+AROS_LH1(void, SDL_DestroySemaphore,
+	AROS_LHA(SDL_sem *, sem, A0),
+	struct SDLBase *, SDLBase, 162, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
+	D(bug("[SDL] SDL_DestroySemaphore()\n"));
+	D(bug("Destroying semaphore %lx...\n",sem));
+
+	if (sem)
+	{
+		#if 1
+
+		struct mywaitdata data;
+
+		if (mywaitinit(&data, 10) == 0)
+		{
+			ObtainSemaphore(&sem->sem);
+
+			sem->sem_value = -1;
+
+			while (!IsListEmpty(&sem->waitlist))
+			{
+				struct waitnode *wn;
+				int res;
+
+				D(bug("[SDL] bug, semaphore %lx busy!\n", sem));
+
+				for (wn = (struct waitnode *) sem->waitlist.mlh_Head;
+				     wn->node.mln_Succ;
+				     wn = (struct waitnode *) wn->node.mln_Succ)
+				{
+					Signal(wn->task, wn->sigmask);
+				}
+
+				ReleaseSemaphore(&sem->sem);
+
+				res = mywait(&data, 10);
+
+				ObtainSemaphore(&sem->sem);
+
+				if (res < 0)
+				{
+					break;
+				}
+			}
+
+			ReleaseSemaphore(&sem->sem);
+		}
+
+		mywaitdone(&data);
+
+		#endif
+
+		free(sem);
+	}
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
+}
+
+#if !defined(PROTO_SDL_H)
+int SDL_SemTryWait(SDL_sem *sem)
+{
+#else
+AROS_LH1(int, SDL_SemTryWait,
+	AROS_LHA(SDL_sem *, sem, A0),
+	struct SDLBase *, SDLBase, 163, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
+	int retval;
+
+	D(bug("[SDL] SDL_SemTryWait()\n"));
+
+	if (!sem)
+	{
+		SDL_SetError("Passed a NULL semaphore");
+		return -1;
+	}
+
+	ObtainSemaphore(&sem->sem);
+
+	if (sem->sem_value > 0)
+	{
+		--sem->sem_value;
+		retval = 0;
+	}
+	else
+	{
+		retval = SDL_MUTEX_TIMEDOUT;
+	}
+
+	ReleaseSemaphore(&sem->sem);
+
+	return retval;
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
+}
+
+#if !defined(PROTO_SDL_H)
+int SDL_SemWait(SDL_sem *sem)
+{
+#else
+AROS_LH1(int, SDL_SemWait,
+	AROS_LHA(SDL_sem *, sem, A0),
+	struct SDLBase *, SDLBase, 165, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
+	int retval;
+	struct waitnode wn;
+	LONG signal;
+
+	D(bug("[SDL] SDL_SemWait(0x%08.8lx) from thread 0x%08.8lx\n", (IPTR)sem, (IPTR)FindTask(NULL)));
+
+	if (!sem)
+	{
+		SDL_SetError("Passed a NULL semaphore");
+		return -1;
+	}
+
+	retval = 0;
+	signal = -1;
+
+	ObtainSemaphore(&sem->sem);
+
+	D(bug("[SDL] SDL_SemWait(): from thread 0x%08.8lx initial sem_value: %ld\n", (IPTR)FindTask(NULL), sem->sem_value));
+
+	while (sem->sem_value <= 0)
+	{
+		ULONG sigmask;
+
+		if (signal == -1)
+		{
+			wn.task = FindTask(NULL);
+			signal = AllocSignal(-1);
+			if (signal == -1)
+			{
+				signal = FALLBACKSIGNAL;
+				SetSignal(1 << FALLBACKSIGNAL, 0);
+			}
+			wn.sigmask = 1 << signal;
+
+			ADDTAIL(&sem->waitlist, &wn);
+		}
+
+		D(bug("[SDL] SDL_SemWait(): waiting for semaphore... \n"));
+
+		ReleaseSemaphore(&sem->sem);
+
+		sigmask = Wait(wn.sigmask | SIGBREAKF_CTRL_C);
+
+		ObtainSemaphore(&sem->sem);
+
+		if (sigmask & SIGBREAKF_CTRL_C)
+		{
+			D(bug("[SDL] SDL_SemWait(): was aborted...\n"));
+			retval = -1;
+			break;
+		}
+	}
+
+	if (signal != -1)
+	{
+		REMOVE(&wn);
+
+		if (signal != FALLBACKSIGNAL)
+		{
+			FreeSignal(signal);
+		}
+	}
+
+	if (retval == 0)
+	{
+		--sem->sem_value;
+
+		D(bug("[SDL] SDL_SemWait(): final sem_value: %ld\n", sem->sem_value));
+	}
+
+	ReleaseSemaphore(&sem->sem);
+	D(bug("done...\n"));
+
+	return retval;
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
+}
+
+#if !defined(PROTO_SDL_H)
+int SDL_SemWaitTimeout(SDL_sem *sem, Uint32 timeout)
+{
+#else
+AROS_LH2(int, SDL_SemWaitTimeout,
+	AROS_LHA(SDL_sem *, sem, A0),
+	AROS_LHA(Uint32, timeout, D0),
+	struct SDLBase *, SDLBase, 164, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
+	struct mywaitdata data;
+	int retval;
+
+	D(bug("[SDL] SDL_SemWaitTimeout()\n"));
+
+	if (!sem)
+	{
+		SDL_SetError("Passed a NULL semaphore");
+		return -1;
+	}
+
+	/* Try the easy cases first */
+	if (timeout == 0)
+	{
+		return SDL_SemTryWait(sem);
+	}
+	if (timeout == SDL_MUTEX_MAXWAIT)
+	{
+		return SDL_SemWait(sem);
+	}
+
+	#if 1
+
+	if (mywaitinit(&data, timeout) == 0)
+	{
+		struct waitnode wn;
+		LONG signal;
+
+		retval = 0;
+		signal = -1;
+
+		ObtainSemaphore(&sem->sem);
+
+		while (sem->sem_value <= 0)
+		{
+			if (signal == -1)
+			{
+				wn.task = FindTask(NULL);
+				signal = AllocSignal(-1);
+				if (signal == -1)
+				{
+					signal = FALLBACKSIGNAL;
+					SetSignal(1 << FALLBACKSIGNAL, 0);
+				}
+				wn.sigmask = 1 << signal;
+
+				ADDTAIL(&sem->waitlist, &wn);
+			}
+
+			ReleaseSemaphore(&sem->sem);
+
+			data.extramask = wn.sigmask;
+			retval = mywait(&data, timeout);
+
+			ObtainSemaphore(&sem->sem);
+
+			/* CTRL-C? */
+			if (retval < 0)
+			{
+				break;
+			}
+
+			/* Timed out? (== no 'semaphore released'-signal) */
+			if (data.extramask == 0)
+			{
+				retval = SDL_MUTEX_TIMEDOUT;
+
+				break;
+			}
+
+			/*
+			 * Not timed out, someone released the semaphore.
+			 * See if we can get it. If we can't, continue waiting.
+			 */
+		}
+
+		if (signal != -1)
+		{
+			REMOVE(&wn);
+
+			if (signal != FALLBACKSIGNAL)
+			{
+				FreeSignal(signal);
+			}
+		}
+
+		/* If can obtain (no timeout, no break), obtain it */
+		if (retval == 0)
+		{
+			--sem->sem_value;
+
+			D(bug("[SDL] SDL_SemWaitTimeout(): final sem_value: %ld\n", sem->sem_value));
+		}
+
+		ReleaseSemaphore(&sem->sem);
+	}
+	else retval = -1;
+
+	mywaitdone(&data);
+
+	#else
+
+	/* Ack!  We have to busy wait... */
+	timeout += SDL_GetTicks();
+
+	if (mywaitinit(&data, 1) == 0)
+	{
+		do
+		{
+			retval = SDL_SemTryWait(sem);
+			if (retval == 0)
+			{
+				break;
+			}
+
+			if (mywait(&data, 1) < 0)
+			{
+				retval = -1;
+				break;
+			}
+
+		} while (SDL_GetTicks() < timeout);
+	}
+	else retval = -1;
+
+	mywaitdone(&data);
+
+	#endif
+
+	return retval;
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
+}
+
+#if !defined(PROTO_SDL_H)
+Uint32 SDL_SemValue(SDL_sem *sem)
+{
+#else
+AROS_LH1(Uint32, SDL_SemValue,
+	AROS_LHA(SDL_sem *, sem, A0),
+	struct SDLBase *, SDLBase, 166, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
+    int retval;
+
+	D(bug("[SDL] SDL_SemValue()\n"));
+
+	if (!sem)
+	{
+		SDL_SetError("Passed a NULL semaphore");
+		return 0;
+	}
+
+	ObtainSemaphoreShared(&sem->sem);
+
+	retval = sem->sem_value;
+
+	ReleaseSemaphore(&sem->sem);
+
+	if (retval < 0)
+	{
+		retval = 0;
+	}
+
+	return (Uint32) retval;
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
+}
+
+#if !defined(PROTO_SDL_H)
+int SDL_SemPost(SDL_sem *sem)
+{
+#else
+AROS_LH1(int, SDL_SemPost,
+	AROS_LHA(SDL_sem *, sem, A0),
+	struct SDLBase *, SDLBase, 167, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
+	struct waitnode *wn;
+
+	if (!sem)
+	{
+		SDL_SetError("Passed a NULL semaphore");
+		return -1;
+	}
+
+	ObtainSemaphore(&sem->sem);
+
+	D(bug("[SDL] SDL_SemPost(0x%08.8lx): initial sem_value: %ld\n", (IPTR)sem, sem->sem_value));
+
+	#if 1
+
+	/* Wake whatever task happens to be first in the waitlist */
+	wn = (struct waitnode *) sem->waitlist.mlh_Head;
+	if (wn->node.mln_Succ)
+	{
+		Signal(wn->task, wn->sigmask);
+	}
+
+	#else
+
+	for (wn = (struct waitnode *) sem->waitlist.mlh_Head;
+	     wn->node.mln_Succ;
+	     wn = (struct waitnode *) wn->node.mln_Succ)
+	{
+		Signal(wn->task, wn->sigmask);
+	}
+
+	#endif
+
+	++sem->sem_value;
+
+	D(bug("[SDL] SDL_SemPost(): final sem_value: %ld\n", sem->sem_value));
+
+	ReleaseSemaphore(&sem->sem);
+
+	return 0;
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
+}
+
diff -Naur SDL-1.2.15-orig/src/thread/aros/SDL_systhread.c SDL-1.2.15/src/thread/aros/SDL_systhread.c
--- SDL-1.2.15-orig/src/thread/aros/SDL_systhread.c	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.15/src/thread/aros/SDL_systhread.c	2015-05-09 15:09:59.764739515 +0200
@@ -0,0 +1,173 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
+#include "SDL_config.h"
+
+/* BeOS thread management routines for SDL */
+
+#include "SDL_mutex.h"
+#include "SDL_thread.h"
+#include "../SDL_thread_c.h"
+#include "../SDL_systhread.h"
+#include "../../main/aros/mydebug.h"
+
+struct SDLBase;
+
+typedef struct {
+	int (*func)(void *);
+	void *data;
+	SDL_Thread *info;
+	struct Task *wait;
+#if defined(PROTO_SDL_H)
+        struct SDLBase *base;
+#endif
+} thread_args;
+
+#if !defined(PROTO_SDL_H)
+extern int SDL_numthreads;
+#else
+#include "SDL_intern.h"
+
+#define SDL_numthreads SDLBase->SDL_numthreads
+void __aros_setoffsettable(void *base);
+#endif
+
+Uint32 RunThread(char *args)
+{
+	thread_args *data=FindTask(NULL)->tc_UserData;
+#if defined(PROTO_SDL_H)
+	/* Have child use parent library base */
+	__aros_setoffsettable(data->base);
+#endif
+	struct Task *Father;
+
+	D(bug("Received data: %lx\n",data));
+	Father=data->wait;
+
+	SDL_RunThread(data);
+
+	Signal(Father,SIGBREAKF_CTRL_F);
+	D(bug("Thread with data %lx ended\n",data));
+	return(0);
+}
+
+#if !defined(PROTO_SDL_H)
+int SDL_SYS_CreateThread(SDL_Thread *thread, void *args)
+#else
+int SDL_SYS_CreateThreadI(SDL_Thread *thread, void *args, struct SDLBase *SDLBase)
+#endif
+{
+	/* Create the thread and go! */
+	char buffer[20];
+
+	D(bug("Sending %lx to the new thread...\n",args));
+
+	if(args)
+		SDL_snprintf(buffer, SDL_arraysize(buffer),"%ld",(unsigned long)args);
+
+#if defined(__AROS__)
+        char tasknmtmp[1024];
+        struct Task *thisTask = FindTask(NULL);
+        
+        if ((thread->threadno = (SDL_numthreads - 1)) > 0)
+        {
+            sprintf(tasknmtmp, "%s SDL subtask #%u", ((struct Node *)thisTask)->ln_Name, (unsigned int)thread->threadno);
+        }
+        else
+        {
+            sprintf(tasknmtmp, "%s SDL subtask", ((struct Node *)thisTask)->ln_Name);
+        }
+        char *subtaskname = AllocVec(strlen(tasknmtmp) + 1, MEMF_CLEAR);
+        CopyMem(tasknmtmp, subtaskname, strlen(tasknmtmp));
+#endif
+	thread->handle=(struct Task *)CreateNewProcTags(NP_Output,Output(),
+#if !defined(__AROS__)
+					NP_Name,(ULONG)"SDL subtask",
+					NP_StackSize, 98304,
+					NP_Entry,(ULONG)RunThread,
+					args ? NP_Arguments : TAG_IGNORE,(ULONG)buffer,
+#else
+					NP_Name, (IPTR)subtaskname,
+					NP_StackSize, (IPTR)(thisTask->tc_SPUpper - thisTask->tc_SPLower),
+					NP_Entry, (IPTR)RunThread,
+					args ? NP_Arguments : TAG_IGNORE, (IPTR)buffer,
+					NP_UserData, args,
+#endif
+					NP_CloseOutput, FALSE,
+					TAG_DONE);
+
+	if(!thread->handle)
+	{
+		SDL_SetError("Not enough resources to create thread");
+		return(-1);
+	}
+
+	return(0);
+}
+
+#if !defined(PROTO_SDL_H)
+void SDL_SYS_SetupThread(void)
+#else
+void SDL_SYS_SetupThreadI(struct SDLBase *SDLBase)
+#endif
+{
+}
+
+#if !defined(PROTO_SDL_H)
+Uint32 SDL_ThreadID(void)
+{
+#else
+AROS_LH0(Uint32, SDL_ThreadID,
+	struct SDLBase *, SDLBase, 141, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
+        /* FIXME: ThreadID may be NON-UNIQUE on 64-bit architectures! */
+	return((Uint32)(IPTR)FindTask(NULL));
+#if defined(PROTO_SDL_H)
+    AROS_LIBFUNC_EXIT
+#endif
+}
+
+#if !defined(PROTO_SDL_H)
+void SDL_SYS_WaitThread(SDL_Thread *thread)
+#else
+void SDL_SYS_WaitThreadI(SDL_Thread *thread, struct SDLBase *SDLBase)
+#endif
+{
+	SetSignal(0L,SIGBREAKF_CTRL_F|SIGBREAKF_CTRL_C);
+	Wait(SIGBREAKF_CTRL_F|SIGBREAKF_CTRL_C);
+}
+
+#if !defined(PROTO_SDL_H)
+void SDL_SYS_KillThread(SDL_Thread *thread)
+#else
+void SDL_SYS_KillThreadI(SDL_Thread *thread, struct SDLBase *SDLBase)
+#endif
+{
+	Signal((struct Task *)thread->handle,SIGBREAKF_CTRL_C);
+}
diff -Naur SDL-1.2.15-orig/src/thread/aros/SDL_systhread_c.h SDL-1.2.15/src/thread/aros/SDL_systhread_c.h
--- SDL-1.2.15-orig/src/thread/aros/SDL_systhread_c.h	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.15/src/thread/aros/SDL_systhread_c.h	2015-05-09 15:09:59.764739515 +0200
@@ -0,0 +1,36 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#include <exec/exec.h>
+#include <dos/dos.h>
+#include <dos/dostags.h>
+#include <proto/dos.h>
+#include <proto/exec.h>
+
+#include "../../main/aros/mydebug.h"
+
+extern struct ExecBase *SysBase;
+extern struct DosLibrary *DOSBase;
+
+#define SYS_ThreadHandle struct Task *
+
diff -Naur SDL-1.2.15-orig/src/thread/aros/SDL_thread.c SDL-1.2.15/src/thread/aros/SDL_thread.c
--- SDL-1.2.15-orig/src/thread/aros/SDL_thread.c	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.15/src/thread/aros/SDL_thread.c	2015-05-09 15:09:59.764739515 +0200
@@ -0,0 +1,408 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+
+/*
+	This file is from an older SDL library version
+	In order for threads to work on AROS port it has to be used
+	in place of SDL_thread.c from parent directory
+	
+	AROS SDL threads implementation should be updated
+	in order to work with current SDL version of threads
+*/
+
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
+#include "SDL_config.h"
+
+/* System independent thread management routines for SDL */
+
+#include "SDL_mutex.h"
+#include "SDL_thread.h"
+#include "../SDL_thread_c.h"
+#include "../SDL_systhread.h"
+
+#include "../../main/aros/mydebug.h"
+
+#define ARRAY_CHUNKSIZE	32
+/* The array of threads currently active in the application
+   (except the main thread)
+   The manipulation of an array here is safer than using a linked list.
+*/
+#if !defined(PROTO_SDL_H)
+static int SDL_maxthreads = 0;
+int SDL_numthreads = 0;
+static SDL_Thread **SDL_Threads = NULL;
+static struct SignalSemaphore thread_lock;
+int thread_lock_created = 0;
+/* The default (non-thread-safe) global error variable */
+static SDL_error SDL_global_error;
+static struct SignalSemaphore *threadlock_ptr = &thread_lock;
+#else
+#include "SDL_intern.h"
+#define SDL_maxthreads SDLBase->SDL_maxthreads
+#define SDL_numthreads SDLBase->SDL_numthreads
+#define SDL_Threads SDLBase->SDL_Threads
+#define threadlock_ptr SDLBase->SDL_ThreadLock
+#define thread_lock SDLBase->SDL_ThreadLock
+#define thread_lock_created SDLBase->SDL_ThreadLockCreated
+#define SDL_global_error SDLBase->SDL_global_error
+#endif
+
+/* Arguments and callback to setup and run the user thread function */
+typedef struct {
+	int (*func)(void *);
+	void *data;
+	SDL_Thread *info;
+	struct Task *wait;
+#if defined(PROTO_SDL_H)
+        struct SDLBase *base;
+#endif
+} thread_args;
+
+#if !defined(PROTO_SDL_H)
+int SDL_ThreadsInit(void)
+#else
+#define SDL_ThreadsInit() SDL_ThreadsInitI(SDLBase)
+int SDL_ThreadsInitI(struct SDLBase *SDLBase)
+#endif
+{
+#if defined(PROTO_SDL_H)
+        if ((thread_lock = AllocVec(sizeof(struct SignalSemaphore), MEMF_CLEAR)) != NULL)
+        {
+        D(bug("ThreadLock created @ 0x%p\n", thread_lock));
+#endif
+	InitSemaphore(threadlock_ptr);
+	thread_lock_created=1;
+#if defined(PROTO_SDL_H)
+        }
+        else
+            return -1;
+#endif
+	return 0;
+}
+
+/* This should never be called...
+   If this is called by SDL_Quit(), we don't know whether or not we should
+   clean up threads here.  If any threads are still running after this call,
+   they will no longer have access to any per-thread data.
+ */
+#if !defined(PROTO_SDL_H)
+void SDL_ThreadsQuit()
+#else
+#define SDL_ThreadsQuit() SDL_ThreadsQuitI(SDLBase)
+void SDL_ThreadsQuitI(struct SDLBase *SDLBase)
+#endif
+{
+	thread_lock_created=0;
+}
+
+/* Routines for manipulating the thread list */
+#if !defined(PROTO_SDL_H)
+static void SDL_AddThread(SDL_Thread *thread)
+#else
+#define SDL_AddThread(thread) SDL_AddThreadI(thread, SDLBase)
+static void SDL_AddThreadI(SDL_Thread *thread, struct SDLBase *SDLBase)
+#endif
+{
+	SDL_Thread **threads;
+
+	/* WARNING:
+	   If the very first threads are created simultaneously, then
+	   there could be a race condition causing memory corruption.
+	   In practice, this isn't a problem because by definition there
+	   is only one thread running the first time this is called.
+	*/
+	if ( !thread_lock_created ) {
+		if ( SDL_ThreadsInit() < 0 ) {
+			return;
+		}
+	}
+        if ( !threadlock_ptr )
+        {
+            return;
+        }
+
+	ObtainSemaphore(threadlock_ptr);
+
+	/* Expand the list of threads, if necessary */
+#ifdef DEBUG_THREADS
+	printf("Adding thread (%d already - %d max)\n",
+			SDL_numthreads, SDL_maxthreads);
+#endif
+	if ( SDL_numthreads == SDL_maxthreads ) {
+		threads=(SDL_Thread **)SDL_malloc((SDL_maxthreads+ARRAY_CHUNKSIZE)*
+		                              (sizeof *threads));
+		if ( threads == NULL ) {
+			SDL_OutOfMemory();
+			goto done;
+		}
+		SDL_memcpy(threads, SDL_Threads, SDL_numthreads*(sizeof *threads));
+		SDL_maxthreads += ARRAY_CHUNKSIZE;
+		if ( SDL_Threads ) {
+			SDL_free(SDL_Threads);
+		}
+		SDL_Threads = threads;
+	}
+	SDL_Threads[SDL_numthreads++] = thread;
+done:
+	ReleaseSemaphore(threadlock_ptr);
+}
+
+#if !defined(PROTO_SDL_H)
+static void SDL_DelThread(SDL_Thread *thread)
+#else
+#define SDL_DelThread(thread) SDL_DelThreadI(thread, SDLBase)
+static void SDL_DelThreadI(SDL_Thread *thread, struct SDLBase *SDLBase)
+#endif
+{
+	int i;
+
+        if ( !threadlock_ptr )
+        {
+            return;
+        }
+	if ( thread_lock_created ) {
+		ObtainSemaphore(threadlock_ptr);
+		for ( i=0; i<SDL_numthreads; ++i ) {
+			if ( thread == SDL_Threads[i] ) {
+				break;
+			}
+		}
+		if ( i < SDL_numthreads ) {
+			--SDL_numthreads;
+			while ( i < SDL_numthreads ) {
+				SDL_Threads[i] = SDL_Threads[i+1];
+				++i;
+			}
+#ifdef DEBUG_THREADS
+			printf("Deleting thread (%d left - %d max)\n",
+					SDL_numthreads, SDL_maxthreads);
+#endif
+		}
+		ReleaseSemaphore(threadlock_ptr);
+	}
+}
+
+/* Routine to get the thread-specific error variable */
+#if !defined(PROTO_SDL_H)
+SDL_error *SDL_GetErrBuf(void)
+#else
+SDL_error *SDL_GetErrBufI(struct SDLBase *SDLBase)
+#endif
+{
+	SDL_error *errbuf = NULL;
+
+	errbuf = &SDL_global_error;
+	if ( SDL_Threads ) {
+		int i;
+		Uint32 this_thread;
+
+		this_thread = SDL_ThreadID();
+                if (threadlock_ptr)
+                {
+                    ObtainSemaphore(threadlock_ptr);
+                    for ( i=0; i<SDL_numthreads; ++i ) {
+                            if ( this_thread == SDL_Threads[i]->threadid ) {
+                                    errbuf = &SDL_Threads[i]->errbuf;
+                                    break;
+                            }
+                    }
+                    ReleaseSemaphore(threadlock_ptr);
+                }
+	}
+	return(errbuf);
+}
+
+void SDL_RunThread(void *data)
+{
+	thread_args *args;
+	int (*userfunc)(void *);
+	void *userdata;
+	int *statusloc;
+
+	/* Get the thread id */
+	args = (thread_args *)data;
+#if defined(PROTO_SDL_H)
+        struct SDLBase *SDLBase = (struct SDLBase *)__aros_getbase_SDLBase();
+#endif
+	/* Perform any system-dependent setup
+	   - this function cannot fail, and cannot use SDL_SetError()
+	 */
+	SDL_SYS_SetupThread();
+    
+	args->info->threadid = SDL_ThreadID();
+
+	/* Figure out what function to run */
+	userfunc = args->func;
+	userdata = args->data;
+	statusloc = &args->info->status;
+
+	/* Wake up the parent thread */
+	Signal(args->wait,SIGBREAKF_CTRL_E);
+
+	/* Run the function */
+	*statusloc = userfunc(userdata);
+}
+
+#if !defined(PROTO_SDL_H)
+SDL_Thread *SDL_CreateThread(int (*fn)(void *), void *data)
+{
+#else
+AROS_LH2(SDL_Thread *, SDL_CreateThread,
+	AROS_LHA(void *, fn, A0),
+	AROS_LHA(void *, data, A1),
+	struct SDLBase *, SDLBase, 140, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
+
+	SDL_Thread *thread;
+	thread_args *args;
+	int ret;
+
+	/* Allocate memory for the thread info structure */
+	thread = (SDL_Thread *)SDL_malloc(sizeof(*thread));
+	if ( thread == NULL ) {
+		SDL_OutOfMemory();
+		return(NULL);
+	}
+	SDL_memset(thread, 0, (sizeof *thread));
+	thread->status = -1;
+
+	/* Set up the arguments for the thread */
+	args = (thread_args *)SDL_malloc(sizeof(*args));
+	if ( args == NULL ) {
+		SDL_OutOfMemory();
+		SDL_free(thread);
+		return(NULL);
+	}
+#if defined(PROTO_SDL_H)
+        args->base = SDLBase;
+#endif
+	args->func = fn;
+	args->data = data;
+	args->info = thread;
+	args->wait = FindTask(NULL);
+
+	if ( args->wait == NULL ) {
+		SDL_free(thread);
+		SDL_free(args);
+		SDL_OutOfMemory();
+		return(NULL);
+	}
+
+	/* Add the thread to the list of available threads */
+	SDL_AddThread(thread);
+
+	D(bug("Starting thread...\n"));
+
+	/* Create the thread and go! */
+	ret = SDL_SYS_CreateThread(thread, args);
+	if ( ret >= 0 ) {
+		D(bug("Waiting for thread CTRL_E...\n"));
+		/* Wait for the thread function to use arguments */
+		Wait(SIGBREAKF_CTRL_E);
+		D(bug("  Arrived."));
+	} else {
+		/* Oops, failed.  Gotta free everything */
+		SDL_DelThread(thread);
+		SDL_free(thread);
+		thread = NULL;
+	}
+	SDL_free(args);
+
+	/* Everything is running now */
+	return(thread);
+#if defined(PROTO_SDL_H)
+    AROS_LIBFUNC_EXIT
+#endif
+}
+
+#if !defined(PROTO_SDL_H)
+void SDL_WaitThread(SDL_Thread *thread, int *status)
+{
+#else
+AROS_LH2(void, SDL_WaitThread,
+	AROS_LHA(SDL_Thread *, thread, A0),
+	AROS_LHA(int *, status, A1),
+	struct SDLBase *, SDLBase, 143, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
+	if ( thread ) {
+		SDL_SYS_WaitThread(thread);
+		if ( status ) {
+			*status = thread->status;
+		}
+		SDL_DelThread(thread);
+		SDL_free(thread);
+	}
+#if defined(PROTO_SDL_H)
+    AROS_LIBFUNC_EXIT
+#endif
+}
+
+#if !defined(PROTO_SDL_H)
+Uint32 SDL_GetThreadID(SDL_Thread *thread)
+{
+#else
+AROS_LH1(Uint32, SDL_GetThreadID,
+	AROS_LHA(SDL_Thread *, thread, A0),
+	struct SDLBase *, SDLBase, 142, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
+	Uint32 id;
+
+	if ( thread ) {
+		id = thread->threadid;
+	} else {
+		id = SDL_ThreadID();
+	}
+	return(id);
+#if defined(PROTO_SDL_H)
+    AROS_LIBFUNC_EXIT
+#endif
+}
+
+#if !defined(PROTO_SDL_H)
+void SDL_KillThread(SDL_Thread *thread)
+{
+#else
+AROS_LH1(void, SDL_KillThread,
+	AROS_LHA(SDL_Thread *, thread, A0),
+	struct SDLBase *, SDLBase, 144, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
+	if ( thread ) {
+		SDL_SYS_KillThread(thread);
+		SDL_WaitThread(thread, NULL);
+	}
+#if defined(PROTO_SDL_H)
+    AROS_LIBFUNC_EXIT
+#endif
+}
+
diff -Naur SDL-1.2.15-orig/src/thread/SDL_systhread.h SDL-1.2.15/src/thread/SDL_systhread.h
--- SDL-1.2.15-orig/src/thread/SDL_systhread.h	2015-05-09 17:47:54.280774303 +0200
+++ SDL-1.2.15/src/thread/SDL_systhread.h	2015-05-09 15:09:59.764739515 +0200
@@ -32,6 +32,7 @@
    saves a system-dependent thread id in thread->id, and returns 0
    on success.
 */
+#if !defined(PROTO_SDL_H)
 #ifdef SDL_PASSED_BEGINTHREAD_ENDTHREAD
 extern int SDL_SYS_CreateThread(SDL_Thread *thread, void *args, pfnSDL_CurrentBeginThread pfnBeginThread, pfnSDL_CurrentEndThread pfnEndThread);
 #else
@@ -48,5 +49,17 @@
 
 /* This function kills the thread and returns */
 extern void SDL_SYS_KillThread(SDL_Thread *thread);
+#else
+#include "SDL_intern.h"
+
+extern int SDL_SYS_CreateThreadI(SDL_Thread *thread, void *args, struct SDLBase *SDLBase);
+extern void SDL_SYS_SetupThreadI(struct SDLBase *SDLBase);
+extern void SDL_SYS_WaitThreadI(SDL_Thread *thread, struct SDLBase *SDLBase);
+extern void SDL_SYS_KillThreadI(SDL_Thread *thread, struct SDLBase *SDLBase);
 
+#define SDL_SYS_CreateThread(thread, args) SDL_SYS_CreateThreadI(thread, args, SDLBase)
+#define SDL_SYS_SetupThread() SDL_SYS_SetupThreadI(SDLBase)
+#define SDL_SYS_WaitThread(thread) SDL_SYS_WaitThreadI(thread, SDLBase)
+#define SDL_SYS_KillThread(thread) SDL_SYS_KillThreadI(thread, SDLBase)
+#endif
 #endif /* _SDL_systhread_h */
diff -Naur SDL-1.2.15-orig/src/thread/SDL_thread.c SDL-1.2.15/src/thread/SDL_thread.c
--- SDL-1.2.15-orig/src/thread/SDL_thread.c	2015-05-09 17:47:54.280774303 +0200
+++ SDL-1.2.15/src/thread/SDL_thread.c	2015-05-09 15:09:59.764739515 +0200
@@ -19,6 +19,11 @@
     Sam Lantinga
     slouken@libsdl.org
 */
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
 #include "SDL_config.h"
 
 /* System independent thread management routines for SDL */
@@ -33,12 +38,27 @@
    (except the main thread)
    The manipulation of an array here is safer than using a linked list.
 */
+#if !defined(PROTO_SDL_H)
 static int SDL_maxthreads = 0;
 static int SDL_numthreads = 0;
 static SDL_Thread **SDL_Threads = NULL;
 static SDL_mutex *thread_lock = NULL;
+/* The default (non-thread-safe) global error variable */
+static SDL_error SDL_global_error;
+#else
+#include "SDL_intern.h"
+#define SDL_maxthreads SDLBase->SDL_maxthreads
+#define SDL_numthreads SDLBase->SDL_numthreads
+#define SDL_Threads SDLBase->SDL_Threads
+#define thread_lock SDLBase->thread_lock
+#define SDL_global_error SDLBase->SDL_global_error
+#endif
 
+#if !defined(PROTO_SDL_H)
 int SDL_ThreadsInit(void)
+#else
+int SDL_ThreadsInit(struct SDLBase *SDLBase)
+#endif
 {
 	int retval;
 
@@ -55,7 +75,11 @@
    clean up threads here.  If any threads are still running after this call,
    they will no longer have access to any per-thread data.
  */
+#if !defined(PROTO_SDL_H)
 void SDL_ThreadsQuit(void)
+#else
+void SDL_ThreadsQuit(struct SDLBase *SDLBase)
+#endif
 {
 	SDL_mutex *mutex;
 
@@ -67,7 +91,11 @@
 }
 
 /* Routines for manipulating the thread list */
+#if !defined(PROTO_SDL_H)
 static void SDL_AddThread(SDL_Thread *thread)
+#else
+static void SDL_AddThread(SDL_Thread *thread, struct SDLBase *SDLBase)
+#endif
 {
 	/* WARNING:
 	   If the very first threads are created simultaneously, then
@@ -103,7 +131,11 @@
 	SDL_mutexV(thread_lock);
 }
 
+#if !defined(PROTO_SDL_H)
 static void SDL_DelThread(SDL_Thread *thread)
+#else
+static void SDL_DelThread(SDL_Thread *thread, struct SDLBase *SDLBase)
+#endif
 {
 	int i;
 
@@ -141,9 +173,6 @@
 #endif
 }
 
-/* The default (non-thread-safe) global error variable */
-static SDL_error SDL_global_error;
-
 /* Routine to get the thread-specific error variable */
 SDL_error *SDL_GetErrBuf(void)
 {
diff -Naur SDL-1.2.15-orig/src/thread/SDL_thread_c.h SDL-1.2.15/src/thread/SDL_thread_c.h
--- SDL-1.2.15-orig/src/thread/SDL_thread_c.h	2015-05-09 17:47:54.280774303 +0200
+++ SDL-1.2.15/src/thread/SDL_thread_c.h	2015-05-09 15:09:59.765739514 +0200
@@ -43,6 +43,8 @@
 #include "win32/SDL_systhread_c.h"
 #elif SDL_THREAD_SYMBIAN
 #include "symbian/SDL_systhread_c.h"
+#elif SDL_THREAD_AROS
+#include "aros/SDL_systhread_c.h"
 #else
 #error Need thread implementation for this platform
 #include "generic/SDL_systhread_c.h"
@@ -52,6 +54,7 @@
 /* This is the system-independent thread info structure */
 struct SDL_Thread {
 	Uint32 threadid;
+        Uint32 threadno;
 	SYS_ThreadHandle handle;
 	int status;
 	SDL_error errbuf;
@@ -60,5 +63,4 @@
 
 /* This is the function called to run a thread */
 extern void SDL_RunThread(void *data);
-
 #endif /* _SDL_thread_c_h */
diff -Naur SDL-1.2.15-orig/src/timer/aros/SDL_systimer.c SDL-1.2.15/src/timer/aros/SDL_systimer.c
--- SDL-1.2.15-orig/src/timer/aros/SDL_systimer.c	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.15/src/timer/aros/SDL_systimer.c	2015-05-09 17:41:01.929187319 +0200
@@ -0,0 +1,337 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include <proto/dos.h>
+#include <proto/exec.h>
+
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
+#include "SDL_config.h"
+
+#ifdef SDL_TIMER_AROS
+
+#define __TIMER_NOLIBBASE__          
+
+#include <stdio.h>
+#include <time.h>
+#include <signal.h>
+#include <unistd.h>
+#include <string.h>
+#include <errno.h>
+#include <exec/types.h>
+#include <devices/timer.h>
+#include <proto/timer.h>
+#include "../../main/aros/mydebug.h"
+
+#include "SDL_thread.h"
+#include "SDL_timer.h"
+#include "../SDL_timer_c.h"
+
+#if !defined(PROTO_SDL_H)
+extern struct DosLibrary *DOSBase;
+extern struct ExecBase *SysBase;
+struct timerequest *TimerIO;
+clock_t start;
+struct Device *TimerBase;
+struct timeval basetime;
+struct MsgPort *TimerMP;
+struct Task *OwnerTask;
+int fallback;
+#else
+#include "SDL_intern.h"
+#define timer_alive SDLBase->timer_alive
+#define timer_thread SDLBase->timer_thread
+#define TimerIO SDLBase->TimerIO
+#define start SDLBase->start
+#define TimerBase SDLBase->TimerBase
+#define basetime SDLBase->basetime
+#define TimerMP SDLBase->TimerMP
+#define OwnerTask SDLBase->OwnerTask
+#define fallback SDLBase->fallback
+#endif
+
+/* The first ticks value of the application */
+#if !defined(PROTO_SDL_H)
+static void close_timer(void)
+#else
+#define close_timer() close_timerI(SDLBase)
+void close_timerI(struct SDLBase *SDLBase)
+#endif
+{
+    D(bug("freeing timer resources..."));
+    if(TimerIO) {
+        CloseDevice((struct IORequest *)TimerIO);
+        DeleteIORequest((struct IORequest *)TimerIO);
+        TimerIO = NULL;
+    }
+    if(TimerMP) {
+        DeleteMsgPort(TimerMP);
+        TimerMP = NULL;
+    }
+    D(bug("OK\n"));
+}
+
+#if !defined(PROTO_SDL_H)
+static BOOL open_timer(void)
+#else
+#define open_timer() open_timerI(SDLBase)
+static BOOL open_timerI(struct SDLBase *SDLBase)
+#endif
+{
+  if (TimerBase || fallback) {
+     return FALSE;
+  }
+
+  if (!(TimerMP = CreateMsgPort())) {
+ 	 start=clock();
+     fallback = 1;
+     return FALSE;
+  }
+
+  if (!(TimerIO = (struct timerequest *)
+              CreateIORequest(TimerMP, sizeof(struct timerequest)))) {
+     DeleteMsgPort(TimerMP);
+	 start=clock();
+     fallback = 1;
+     return FALSE;
+  }
+  // Under AROS we use UNIT_MICROHZ to be more accurate for short delays
+  // Delays under SDL are mainly used to synchronise frame updates
+  // and therefore are usually less than 1/50 or 1/60 seconds
+  if (OpenDevice("timer.device", UNIT_MICROHZ, &TimerIO->tr_node, 0)) {
+	  DeleteMsgPort(TimerMP);
+      DeleteIORequest((struct IORequest *)TimerIO);
+ 	  start=clock();
+      fallback = 1;
+      return FALSE;
+  }
+  
+  OwnerTask = TimerMP->mp_SigTask;
+  TimerBase = TimerIO->tr_node.io_Device;
+  D(bug("Timer resource allocated.\n"));
+
+  GetSysTime(&basetime);
+  D(bug("Basetime: %lusecs %lumicro\n", basetime.tv_secs, basetime.tv_micro));
+
+#if !defined(PROTO_SDL_H) && !defined(SHARED_LIB)
+  atexit(close_timer);
+#endif
+
+  return TRUE;
+}
+
+#if !defined(PROTO_SDL_H)
+void SDL_StartTicks(void)
+#else
+void SDL_StartTicksI(struct SDLBase *SDLBase)
+#endif
+{
+  open_timer();  
+}
+
+#if !defined(PROTO_SDL_H)
+Uint32 SDL_GetTicks (void)
+{
+#else
+AROS_LH0(Uint32, SDL_GetTicks,
+	struct SDLBase *, SDLBase, 78, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
+    open_timer(); // TimerBase must be set for GetSysTime()
+    if (fallback) {
+        clock_t ticks;
+        
+        ticks=clock()-start;
+
+#if CLOCKS_PER_SEC == 1000
+        return(ticks);
+#else
+        return ticks*(1000/CLOCKS_PER_SEC);
+#endif  
+    }
+    else {
+        struct timeval tv;
+        Uint32 tics;
+        
+        GetSysTime(&tv);
+
+        if(basetime.tv_micro > tv.tv_micro) {           
+           tv.tv_secs --;
+          
+           tv.tv_micro += 1000000;
+        }
+        tics = ((tv.tv_secs - basetime.tv_secs) * 1000) + 
+            ((tv.tv_micro - basetime.tv_micro)/1000);
+
+        return tics;
+    }
+#if defined(PROTO_SDL_H)
+    AROS_LIBFUNC_EXIT
+#endif
+}
+
+#if !defined(PROTO_SDL_H)
+void SDL_Delay (Uint32 ms)
+{
+#else
+AROS_LH1(void, SDL_Delay,
+	AROS_LHA(Uint32, ms, D0),
+	struct SDLBase *, SDLBase, 79, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
+/*
+We should try to be more clever under AROS to avoid any busy looping
+Busy looping causes the system to slow down, while an SDL application
+is waiting to sync screen update, those delays are usually less than 
+1/50 seconds, i.e. 20ms
+*/
+	if (OwnerTask == FindTask(NULL)) //SysBase->ThisTask)
+	{
+		TimerIO->tr_node.io_Command	= TR_ADDREQUEST;
+		TimerIO->tr_time.tv_secs	= ms / 1000;
+		TimerIO->tr_time.tv_micro	= (ms % 1000) * 1000;
+
+		DoIO((struct IORequest *) TimerIO);
+	}
+	else
+	{
+		struct MsgPort port;
+
+		if ((BYTE) (port.mp_SigBit = AllocSignal(-1)) != -1)
+		{
+			struct timerequest ioreq;
+
+			port.mp_Node.ln_Type = NT_MSGPORT;
+			port.mp_Flags        = PA_SIGNAL;
+			port.mp_SigTask      = FindTask(NULL);
+			NEWLIST(&port.mp_MsgList);
+
+			ioreq.tr_node.io_Message.mn_Node.ln_Type = NT_REPLYMSG;
+			ioreq.tr_node.io_Message.mn_ReplyPort    = &port;
+			ioreq.tr_node.io_Message.mn_Length       = sizeof(struct timerequest);
+			ioreq.tr_node.io_Device                  = TimerIO->tr_node.io_Device;
+			ioreq.tr_node.io_Unit                    = TimerIO->tr_node.io_Unit;
+			ioreq.tr_node.io_Command                 = TR_ADDREQUEST;
+			ioreq.tr_time.tv_secs                    = ms / 1000;
+			ioreq.tr_time.tv_micro                   = (ms % 1000) * 1000;
+
+			DoIO((struct IORequest *) &ioreq);
+
+			FreeSignal(port.mp_SigBit);
+		}
+	}
+#if defined(PROTO_SDL_H)
+    AROS_LIBFUNC_EXIT
+#endif
+}
+
+
+/* Data to handle a single periodic alarm */
+#if !defined(PROTO_SDL_H)
+static int timer_alive = 0;
+static SDL_Thread *timer_thread = NULL;
+
+static int RunTimer(void *unused)
+#else
+#define timer_alive SDLBase->timer_alive
+#define timer_thread SDLBase->timer_thread
+
+static int RunTimer(struct SDLBase *SDLBase)
+#endif
+{
+	D(bug("SYSTimer: Entering RunTimer loop..."));
+
+	while ( timer_alive ) {
+		if ( SDL_timer_running ) {
+			SDL_ThreadedTimerCheck();
+		}
+		SDL_Delay(1); // Might use new SDL_Delay implementation but has to be thread safe before!
+	}
+	D(bug("SYSTimer: EXITING RunTimer loop..."));
+	return(0);
+}
+
+/* This is only called if the event thread is not running */
+#if !defined(PROTO_SDL_H)
+int SDL_SYS_TimerInit(void)
+#else
+int SDL_SYS_TimerInitI(struct SDLBase *SDLBase)
+#endif
+{
+	D(bug("Creating thread for the timer (NOITIMER)...\n"));
+
+	timer_alive = 1;
+#if !defined(PROTO_SDL_H)
+	timer_thread = SDL_CreateThread(RunTimer, NULL);
+#else
+	timer_thread = SDL_CreateThread(RunTimer, SDLBase);
+#endif
+	if ( timer_thread == NULL )
+	{
+		D(bug("Creazione del thread fallita...\n"));
+
+		return(-1);
+	}
+	return(SDL_SetTimerThreaded(1));
+}
+
+#if !defined(PROTO_SDL_H)
+void SDL_SYS_TimerQuit(void)
+#else
+void SDL_SYS_TimerQuitI(struct SDLBase *SDLBase)
+#endif
+{
+	timer_alive = 0;
+	if ( timer_thread ) {
+		SDL_WaitThread(timer_thread, NULL);
+		timer_thread = NULL;
+	}
+}
+
+#if !defined(PROTO_SDL_H)
+int SDL_SYS_StartTimer(void)
+#else
+int SDL_SYS_StartTimerI(struct SDLBase *SDLBase)
+#endif
+{
+	SDL_SetError("Internal logic error: AmigaOS uses threaded timer");
+	return(-1);
+}
+
+#if !defined(PROTO_SDL_H)
+void SDL_SYS_StopTimer(void)
+#else
+void SDL_SYS_StopTimerI(struct SDLBase *SDLBase)
+#endif
+{
+	return;
+}
+
+#if defined(PROTO_SDL_H)
+ADD2CLOSELIB(close_timerI, -5);
+#endif
+
+#endif /* SDL_TIMER_AROS */
diff -Naur SDL-1.2.15-orig/src/timer/SDL_systimer.h SDL-1.2.15/src/timer/SDL_systimer.h
--- SDL-1.2.15-orig/src/timer/SDL_systimer.h	2015-05-09 17:47:54.323774189 +0200
+++ SDL-1.2.15/src/timer/SDL_systimer.h	2015-05-09 15:09:59.765739514 +0200
@@ -26,7 +26,7 @@
 #include "SDL_timer.h"
 #include "SDL_timer_c.h"
 
-
+#if !defined(PROTO_SDL_H)
 /* Initialize the system dependent timer subsystem */
 extern int SDL_SYS_TimerInit(void);
 
@@ -38,3 +38,14 @@
 
 /* Stop a previously started timer */
 extern void SDL_SYS_StopTimer(void);
+#else
+extern int SDL_SYS_TimerInitI(struct SDLBase *SDLBase);
+extern void SDL_SYS_TimerQuitI(struct SDLBase *SDLBase);
+extern int SDL_SYS_StartTimerI(struct SDLBase *SDLBase);
+extern void SDL_SYS_StopTimerI(struct SDLBase *SDLBase);
+
+#define SDL_SYS_TimerInit() SDL_SYS_TimerInitI(SDLBase)
+#define SDL_SYS_TimerQuit() SDL_SYS_TimerQuitI(SDLBase)
+#define SDL_SYS_StartTimer() SDL_SYS_StartTimerI(SDLBase)
+#define SDL_SYS_StopTimer() SDL_SYS_StopTimerI(SDLBase)
+#endif
\ No newline at end of file
diff -Naur SDL-1.2.15-orig/src/timer/SDL_timer.c SDL-1.2.15/src/timer/SDL_timer.c
--- SDL-1.2.15-orig/src/timer/SDL_timer.c	2015-05-09 17:47:54.323774189 +0200
+++ SDL-1.2.15/src/timer/SDL_timer.c	2015-05-09 15:09:59.765739514 +0200
@@ -19,6 +19,11 @@
     Sam Lantinga
     slouken@libsdl.org
 */
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
 #include "SDL_config.h"
 
 #include "SDL_timer.h"
@@ -28,6 +33,15 @@
 
 /* #define DEBUG_TIMERS */
 
+struct _SDL_TimerID {
+	Uint32 interval;
+	SDL_NewTimerCallback cb;
+	void *param;
+	Uint32 last_alarm;
+	struct _SDL_TimerID *next;
+};
+
+#if !defined(PROTO_SDL_H)
 int SDL_timer_started = 0;
 int SDL_timer_running = 0;
 
@@ -38,22 +52,29 @@
 /* Data used for a thread-based timer */
 static int SDL_timer_threaded = 0;
 
-struct _SDL_TimerID {
-	Uint32 interval;
-	SDL_NewTimerCallback cb;
-	void *param;
-	Uint32 last_alarm;
-	struct _SDL_TimerID *next;
-};
-
 static SDL_TimerID SDL_timers = NULL;
 static SDL_mutex *SDL_timer_mutex;
 static volatile SDL_bool list_changed = SDL_FALSE;
+#else
+#include "SDL_intern.h"
+#define SDL_timers SDLBase->SDL_timers
+#define SDL_timer_started SDLBase->SDL_timer_started
+#define SDL_timer_running SDLBase->SDL_timer_running
+#define SDL_alarm_interval SDLBase->SDL_alarm_interval
+#define SDL_alarm_callback SDLBase->SDL_alarm_callback
+#define SDL_timer_threaded SDLBase->SDL_timer_threaded
+#define SDL_timer_mutex SDLBase->SDL_timer_mutex
+#define list_changed SDLBase->list_changed
+#endif
 
 /* Set whether or not the timer should use a thread.
    This should not be called while the timer subsystem is running.
 */
+#if !defined(PROTO_SDL_H)
 int SDL_SetTimerThreaded(int value)
+#else
+int SDL_SetTimerThreadedI(int value, struct SDLBase *SDLBase)
+#endif
 {
 	int retval;
 
@@ -67,7 +88,11 @@
 	return retval;
 }
 
+#if !defined(PROTO_SDL_H)
 int SDL_TimerInit(void)
+#else
+int SDL_TimerInitI(struct SDLBase *SDLBase)
+#endif
 {
 	int retval;
 
@@ -87,7 +112,11 @@
 	return(retval);
 }
 
+#if !defined(PROTO_SDL_H)
 void SDL_TimerQuit(void)
+#else
+void SDL_TimerQuitI(struct SDLBase *SDLBase)
+#endif
 {
 	SDL_SetTimer(0, NULL);
 	if ( SDL_timer_threaded < 2 ) {
@@ -101,7 +130,11 @@
 	SDL_timer_threaded = 0;
 }
 
+#if !defined(PROTO_SDL_H)
 void SDL_ThreadedTimerCheck(void)
+#else
+void SDL_ThreadedTimerCheckI(struct SDLBase *SDLBase)
+#endif
 {
 	Uint32 now, ms;
 	SDL_TimerID t, prev, next;
@@ -162,7 +195,12 @@
 	SDL_mutexV(SDL_timer_mutex);
 }
 
+#if !defined(PROTO_SDL_H)
 static SDL_TimerID SDL_AddTimerInternal(Uint32 interval, SDL_NewTimerCallback callback, void *param)
+#else
+#define SDL_AddTimerInternal(interval, callback, param) SDL_AddTimerInternalI(interval, callback, param, SDLBase)
+static SDL_TimerID SDL_AddTimerInternalI(Uint32 interval, SDL_NewTimerCallback callback, void *param, struct SDLBase *SDLBase)
+#endif
 {
 	SDL_TimerID t;
 	t = (SDL_TimerID) SDL_malloc(sizeof(struct _SDL_TimerID));
@@ -182,8 +220,18 @@
 	return t;
 }
 
+#if !defined(PROTO_SDL_H)
 SDL_TimerID SDL_AddTimer(Uint32 interval, SDL_NewTimerCallback callback, void *param)
 {
+#else
+AROS_LH3(SDL_TimerID, SDL_AddTimer,
+	AROS_LHA(Uint32, interval, D0),
+	AROS_LHA(SDL_NewTimerCallback, callback, A0),
+	AROS_LHA(void *, param, A1),
+	struct SDLBase *, SDLBase, 81, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	SDL_TimerID t;
 	if ( ! SDL_timer_mutex ) {
 		if ( SDL_timer_started ) {
@@ -201,10 +249,21 @@
 	t = SDL_AddTimerInternal(interval, callback, param);
 	SDL_mutexV(SDL_timer_mutex);
 	return t;
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 SDL_bool SDL_RemoveTimer(SDL_TimerID id)
 {
+#else
+AROS_LH1(SDL_bool, SDL_RemoveTimer,
+	AROS_LHA(SDL_TimerID, id, D0),
+	struct SDLBase *, SDLBase, 82, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	SDL_TimerID t, prev = NULL;
 	SDL_bool removed;
 
@@ -230,6 +289,9 @@
 #endif
 	SDL_mutexV(SDL_timer_mutex);
 	return removed;
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 /* Old style callback functions are wrapped through this */
@@ -239,8 +301,17 @@
 	return (*func)(ms);
 }
 
+#if !defined(PROTO_SDL_H)
 int SDL_SetTimer(Uint32 ms, SDL_TimerCallback callback)
 {
+#else
+AROS_LH2(int, SDL_SetTimer,
+	AROS_LHA(Uint32, ms, D0),
+	AROS_LHA(SDL_TimerCallback, callback, A0),
+	struct SDLBase *, SDLBase, 80, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	int retval;
 
 #ifdef DEBUG_TIMERS
@@ -282,4 +353,7 @@
 	}
 
 	return retval;
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
diff -Naur SDL-1.2.15-orig/src/timer/SDL_timer_c.h SDL-1.2.15/src/timer/SDL_timer_c.h
--- SDL-1.2.15-orig/src/timer/SDL_timer_c.h	2015-05-09 17:47:54.323774189 +0200
+++ SDL-1.2.15/src/timer/SDL_timer_c.h	2015-05-09 15:09:59.765739514 +0200
@@ -27,6 +27,7 @@
 #define ROUND_RESOLUTION(X)	\
 	(((X+TIMER_RESOLUTION-1)/TIMER_RESOLUTION)*TIMER_RESOLUTION)
 
+#if !defined(PROTO_SDL_H)
 extern int SDL_timer_started;
 extern int SDL_timer_running;
 
@@ -44,3 +45,20 @@
 
 /* This function is called from the SDL event thread if it is available */
 extern void SDL_ThreadedTimerCheck(void);
+#else
+#include "SDL_intern.h"
+extern int SDL_SetTimerThreadedI(int value, struct SDLBase *SDLBase);
+extern int SDL_TimerInitI(struct SDLBase *SDLBase);
+extern void SDL_TimerQuitI(struct SDLBase *SDLBase);
+extern void SDL_ThreadedTimerCheckI(struct SDLBase *SDLBase);
+
+#define SDL_SetTimerThreaded(value) SDL_SetTimerThreadedI(value, SDLBase)
+#define SDL_TimerInit() SDL_TimerInitI(SDLBase)
+#define SDL_TimerQuit() SDL_TimerQuitI(SDLBase)
+#define SDL_ThreadedTimerCheck() SDL_ThreadedTimerCheckI(SDLBase)
+
+#define SDL_timer_started SDLBase->SDL_timer_started
+#define SDL_timer_running SDLBase->SDL_timer_running
+#define SDL_alarm_interval SDLBase->SDL_alarm_interval
+#define SDL_alarm_callback SDLBase->SDL_alarm_callback
+#endif
\ No newline at end of file
diff -Naur SDL-1.2.15-orig/src/video/cgx/SDL_cgxaccel.c SDL-1.2.15/src/video/cgx/SDL_cgxaccel.c
--- SDL-1.2.15-orig/src/video/cgx/SDL_cgxaccel.c	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.15/src/video/cgx/SDL_cgxaccel.c	2015-05-09 15:09:59.766739512 +0200
@@ -0,0 +1,701 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
+#include "SDL_config.h"
+
+#include "SDL_endian.h"
+#include "SDL_cgxaccel_c.h"
+#include "SDL_cgxvideo.h"
+#include "../SDL_blit.h"
+
+#if defined(PROTO_SDL_H)
+#include "SDL_intern.h"
+#define current_video SDLBase->current_video
+#endif
+
+#include <aros/macros.h>
+
+/* HW bliting functions */
+static int CGX_HWtoHWBlit(	SDL_Surface *src, SDL_Rect *srcrect,
+							SDL_Surface *dst, SDL_Rect *dstrect);
+static int CGX_HWtoHWBlitA(	SDL_Surface *src, SDL_Rect *srcrect,
+							SDL_Surface *dst, SDL_Rect *dstrect);
+static int CGX_HWtoHWBlitCC(SDL_Surface *src, SDL_Rect *srcrect,
+							SDL_Surface *dst, SDL_Rect *dstrect);
+static int CGX_SWtoHWBlit(	SDL_Surface *src, SDL_Rect *srcrect,
+							SDL_Surface *dst, SDL_Rect *dstrect);
+static int CGX_SWtoHWBlitA(	SDL_Surface *src, SDL_Rect *srcrect,
+							SDL_Surface *dst, SDL_Rect *dstrect);
+static int CGX_SWtoHWBlitCC(SDL_Surface *src, SDL_Rect *srcrect,
+							SDL_Surface *dst, SDL_Rect *dstrect);
+
+#if !defined(PROTO_SDL_H)
+int CGX_AllocHWSurface(_THIS, SDL_Surface *surface)
+#else
+int CGX_AllocHWSurfaceI(_THIS, SDL_Surface *surface, struct SDLBase *SDLBase)
+#endif
+{
+#ifndef NO_AMIGAHWSURF
+	D(bug("Alloc HW surface...%ld x %ld x %ld!\n",surface->w,surface->h,this->hidden->depth));
+
+	if(surface==SDL_VideoSurface)
+	{
+		D(bug("Allocation skipped, it's system one!\n"));
+		return 0;
+	}
+
+	if(!surface->hwdata)
+	{
+		if(!(surface->hwdata=SDL_malloc(sizeof(struct private_hwdata))))
+			return -1;
+	}
+
+	surface->hwdata->mask=NULL;
+	surface->hwdata->pixarrayalpha=NULL;
+	surface->hwdata->lock=NULL;
+	surface->hwdata->videodata=this;
+	surface->hwdata->allocated=0;
+
+	if((surface->hwdata->bmap=AllocBitMap(surface->w,surface->h,this->hidden->depth,BMF_MINPLANES,SDL_Display->RastPort.BitMap)))
+	{
+		surface->hwdata->allocated=1;
+		surface->hwdata->pixfmt = GetCyberMapAttr(surface->hwdata->bmap,CYBRMATTR_PIXFMT);
+		surface->flags|=SDL_HWSURFACE;
+		
+		D(bug("PIXFMT = 0x%08X\t",surface->hwdata->pixfmt));
+		D(bug("...OK\n"));
+		return 0;
+	}
+	else
+	{
+		SDL_free(surface->hwdata);
+		surface->hwdata=NULL;
+	}
+#endif
+	return(-1);
+}
+
+#if !defined(PROTO_SDL_H)
+void CGX_FreeHWSurface(_THIS, SDL_Surface *surface)
+#else
+void CGX_FreeHWSurfaceI(_THIS, SDL_Surface *surface, struct SDLBase *SDLBase)
+#endif
+{
+#ifndef NO_AMIGAHWSURF
+	if(surface && surface!=SDL_VideoSurface && surface->hwdata)
+	{
+		D(bug("Free hw surface.\n"));
+
+		if(surface->hwdata->mask)
+			SDL_free(surface->hwdata->mask);
+
+		if(surface->hwdata->pixarrayalpha)
+			SDL_free(surface->hwdata->pixarrayalpha);			
+
+		if(surface->hwdata->bmap&&surface->hwdata->allocated)
+			FreeBitMap(surface->hwdata->bmap);
+
+		SDL_free(surface->hwdata);
+		surface->hwdata=NULL;
+		surface->pixels=NULL;
+		D(bug("end of free hw surface\n"));
+	}
+#endif
+	return;
+}
+
+#if !defined(PROTO_SDL_H)
+int CGX_LockHWSurface(_THIS, SDL_Surface *surface)
+#else
+int CGX_LockHWSurfaceI(_THIS, SDL_Surface *surface, struct SDLBase *SDLBase)
+#endif
+{
+#ifndef NO_AMIGAHWSURF
+	if (surface->hwdata)
+	{
+		D(bug("Locking a bitmap..."));
+		if(!surface->hwdata->lock)
+		{	
+			Uint32 pitch;
+
+			if((surface->hwdata->lock = LockBitMapTags(surface->hwdata->bmap,
+					LBMI_BASEADDRESS,(IPTR)&surface->pixels,
+					LBMI_BYTESPERROW,(IPTR)&pitch,TAG_DONE)) != NULL)
+			{
+				D(bug("Done...\n"));
+				surface->pitch=pitch;
+			}
+			else
+			{
+				D(bug("Couldn't lock surface!\n"));
+				return -1;
+			}
+		}
+		D(else bug("Already locked!!!\n"));
+	}
+#endif
+	return(0);
+}
+
+#if !defined(PROTO_SDL_H)
+void CGX_UnlockHWSurface(_THIS, SDL_Surface *surface)
+#else
+void CGX_UnlockHWSurfaceI(_THIS, SDL_Surface *surface, struct SDLBase *SDLBase)
+#endif
+{
+#ifndef NO_AMIGAHWSURF
+	if((surface->hwdata) && (surface->hwdata->lock))
+	{
+		D(bug("Unlocking a bitmap...\n"));
+		UnLockBitMap(surface->hwdata->lock);
+		surface->hwdata->lock = NULL;
+	
+		/* refresh display if pending */
+		if ((surface->hwdata->bmap == this->hidden->BlitBitMap) && surface->hwdata->update)
+		{
+			surface->hwdata->update = 0;
+			BltBitMapRastPort(	this->hidden->BlitBitMap,
+								0,
+								0,
+								SDL_RastPort,
+								SDL_Window->BorderLeft,
+								SDL_Window->BorderTop,
+								surface->w,
+								surface->h,
+								0xc0);
+		}
+	}
+#endif
+}
+
+#if !defined(PROTO_SDL_H)
+int CGX_FlipHWSurface(_THIS, SDL_Surface *surface)
+#else
+int CGX_FlipHWSurfaceI(_THIS, SDL_Surface *surface, struct SDLBase *SDLBase)
+#endif
+{
+	static int current=0;
+	static BOOL SafeDisp=TRUE;
+	static BOOL SafeChange=TRUE;
+	
+	if(this->hidden->dbuffer)
+	{
+		D(bug("Double Buffering Flip to surface %d\n", current^1));
+	
+		if(!SafeChange)
+		{
+			Wait(this->hidden->disp_sigbit);
+			while(GetMsg(this->hidden->dispport)!=NULL);
+			SafeChange=TRUE;
+		}
+
+		if(ChangeScreenBuffer(SDL_Display,this->hidden->SB[current^1]))
+		{
+			surface->hwdata->bmap=SDL_RastPort->BitMap=this->hidden->SB[current]->sb_BitMap;
+			SafeChange=FALSE;
+			SafeDisp=FALSE;
+			current^=1;
+		}
+
+		if(!SafeDisp)
+		{
+			Wait(this->hidden->safe_sigbit);
+			while(GetMsg(this->hidden->safeport)!=NULL);
+			SafeDisp=TRUE;
+		}
+
+	}
+	else if (this->hidden->BlitBitMap)
+	{
+		D(bug("[SDL] CGX_FakeFlipSurface - blit offscreen bitmap\n"));
+
+		if (this->screen->hwdata->lock)
+			this->screen->hwdata->update = 1;
+		else
+			BltBitMapRastPort(	this->hidden->BlitBitMap,
+								0,
+								0,
+								SDL_RastPort,
+								SDL_Window->BorderLeft,
+								SDL_Window->BorderTop,
+								this->screen->w,
+								this->screen->h,
+								0xc0);
+	}
+	return(0);
+}
+
+
+#if !defined(PROTO_SDL_H)
+int CGX_FillHWRect(_THIS, SDL_Surface *dst, SDL_Rect *dstrect, Uint32 color)
+#else
+int CGX_FillHWRectI(_THIS, SDL_Surface *dst, SDL_Rect *dstrect, Uint32 color, struct SDLBase *SDLBase)
+#endif
+{
+	ULONG col;
+	
+	D(bug("CGX_FillHWRect\n"));
+
+	if(dst->hwdata)
+	{
+		if (dst->format->BitsPerPixel > 8)
+			col =     (((color & dst->format->Amask) >> dst->format->Ashift) << (dst->format->Aloss + 24))
+					| (((color & dst->format->Rmask) >> dst->format->Rshift) << (dst->format->Rloss + 16))
+					| (((color & dst->format->Gmask) >> dst->format->Gshift) << (dst->format->Gloss + 8))
+					| (((color & dst->format->Bmask) >> dst->format->Bshift) <<  dst->format->Bloss);
+		else
+			col = color;
+	
+		if(!SDL_temprp) SDL_temprp = CreateRastPort();
+		SDL_temprp->BitMap=(struct BitMap *)dst->hwdata->bmap;
+
+		FillPixelArray(SDL_temprp,dstrect->x,dstrect->y,dstrect->w,dstrect->h,col);
+	}
+	return 0;
+}
+
+#ifndef NO_AMIGAHWSURF
+#if !defined(PROTO_SDL_H)
+int CGX_CheckHWBlit(_THIS,SDL_Surface *src,SDL_Surface *dst)
+#else
+int CGX_CheckHWBlitI(_THIS, SDL_Surface *src, SDL_Surface *dst, struct SDLBase *SDLBase)
+#endif
+{
+	int result = 0;
+	
+	if (dst->hwdata)
+	{
+		if(src->hwdata) 
+		{
+			// SOURCE is a HW Bitmap
+			switch (src->flags & (SDL_SRCALPHA|SDL_SRCCOLORKEY))
+			{
+				case (SDL_SRCALPHA|SDL_SRCCOLORKEY):
+					if ( CGX_SetHWColorKey(this, src, src->format->colorkey) < 0 ) 
+					{
+						D(bug("CheckHW blit : HW to HW CC+ALPHA... NOK!\n"));
+						src->flags &= ~SDL_HWACCEL;
+					}
+					else
+					{
+						D(bug("CheckHW blit : HW to HW CC+ALPHA... OK!\n"));
+						src->flags |= SDL_HWACCEL;
+						src->map->hw_blit = CGX_HWtoHWBlitA;
+						result = 1;
+					}
+					break;
+				
+				case (SDL_SRCCOLORKEY):
+					if ( CGX_SetHWColorKey(this, src, src->format->colorkey) < 0 ) 
+					{
+						D(bug("CheckHW blit : HW to HW CC... NOK!\n"));
+						src->flags &= ~SDL_HWACCEL;
+					}
+					else
+					{
+						D(bug("CheckHW blit : HW to HW CC... OK!\n"));
+						src->flags |= SDL_HWACCEL;
+						src->map->hw_blit = CGX_HWtoHWBlitCC;
+						result = 1;
+					}
+					break;
+					
+				case (SDL_SRCALPHA):
+					if ( CGX_CreateAlphaPixMap(this, src) < 0 ) 
+					{
+						D(bug("CheckHW blit : HW to HW ALPHA... NOK!\n"));
+						src->flags &= ~SDL_HWACCEL;
+					}
+					else
+					{
+						D(bug("CheckHW blit : HW to HW ALPHA... OK!\n"));
+						src->flags |= SDL_HWACCEL;
+						src->map->hw_blit = CGX_HWtoHWBlitA;
+						result = 1;
+					}
+					break;
+	
+				default:
+					D(bug("CheckHW blit : HW to HW OK!\n"));
+					src->flags |= SDL_HWACCEL;
+					src->map->hw_blit = CGX_HWtoHWBlit;
+					result = 1;
+					break;
+			}
+		}
+		else
+		{
+			// SOURCE is a SW pixel array
+			switch (src->flags & (SDL_SRCALPHA|SDL_SRCCOLORKEY))
+			{
+				case (SDL_SRCALPHA|SDL_SRCCOLORKEY):
+					if (CGX_ColorKeyToAlpha( this, src, src->format->colorkey) < 0)
+					{
+						D(bug("CheckHW blit : SW to HW CC+ALPHA... NOK!\n"));
+						src->flags &= ~SDL_HWACCEL;
+					}
+					else
+					{
+						D(bug("CheckHW blit : SW to HW CC+ALPHA... OK!\n"));
+						src->flags |= SDL_HWACCEL;
+						src->map->hw_blit = CGX_SWtoHWBlitA;
+						result = 1;
+					}
+					break;
+				
+				case (SDL_SRCCOLORKEY):
+					if (CGX_ColorKeyToAlpha( this, src, src->format->colorkey) < 0)
+					{
+						D(bug("CheckHW blit : SW to HW CC... NOK!\n"));
+						src->flags &= ~SDL_HWACCEL;
+					}
+					else
+					{
+						D(bug("CheckHW blit : SW to HW CC... OK!\n"));
+						src->flags |= SDL_HWACCEL;
+						src->map->hw_blit = CGX_SWtoHWBlitCC;
+						result = 1;
+					}
+					break;
+			
+				case (SDL_SRCALPHA):
+					D(bug("CheckHW blit : SW to HW ALPHA... OK!\n"));
+					src->flags |= SDL_HWACCEL;
+					src->map->hw_blit = CGX_SWtoHWBlitA;
+					result = 1;
+					break;
+					
+				default:
+					D(bug("CheckHW blit : SW to HW... OK!\n"));
+					src->flags |= SDL_HWACCEL;
+					src->map->hw_blit = CGX_SWtoHWBlit;
+					result = 1;
+					break;
+			}
+		}
+	}
+	else
+	{
+		src->flags &= ~SDL_HWACCEL;
+		D(bug("HW blitting not available\n"));
+	}
+
+	return result;
+}
+
+#if !defined(PROTO_SDL_H)
+int CGX_CreateAlphaPixMap(_THIS,SDL_Surface *surface)
+#else
+int CGX_CreateAlphaPixMapI(_THIS, SDL_Surface *surface, struct SDLBase *SDLBase)
+#endif
+{
+	/*
+		We are creating a pixmap in system memory with alpha channel (RGBA format)
+		Doesn't work yet for 8 bits per pixel format!
+	*/
+	int result = -1;
+	int i;
+	ULONG *pix;
+	
+	D(bug("CGX_CreateAlphaPixMap\n"));
+	
+	if   ( (surface->hwdata)
+		&& (surface->format->BytesPerPixel > 1))
+	{
+		if (surface->hwdata->pixarrayalpha) SDL_free(surface->hwdata->pixarrayalpha);
+		if ((surface->hwdata->pixarrayalpha = SDL_malloc(surface->w * surface->h * 4)) != NULL)
+		{
+			if(!SDL_temprp) SDL_temprp = CreateRastPort();
+			SDL_temprp->BitMap=(struct BitMap *)surface->hwdata->bmap;
+		
+			ReadPixelArray(	surface->hwdata->pixarrayalpha,
+							0,
+							0,
+							surface->w * 4,
+							SDL_temprp,
+							0,
+							0,
+							surface->w,
+							surface->h,
+							RECTFMT_ARGB32);
+
+			if (surface->hwdata->pixarrayalpha)
+			{
+				/* if source data is without alpha channel it has to be set manually to 255 */
+				if (  (surface->hwdata->pixfmt != PIXFMT_ARGB32)
+				   || (surface->hwdata->pixfmt != PIXFMT_BGRA32)
+				   || (surface->hwdata->pixfmt != PIXFMT_RGBA32))
+				{
+					pix = (ULONG *)surface->hwdata->pixarrayalpha;
+					for (i = 0; i < surface->w * surface->h; i++) pix[i] |= AROS_BE2LONG(0xFF000000);
+				}
+				result = 0;
+			}
+		}
+	}
+	
+	return result;
+}
+
+
+#if !defined(PROTO_SDL_H)
+int CGX_SetHWColorKey(_THIS,SDL_Surface *surface, Uint32 key)
+#else
+int CGX_SetHWColorKeyI(_THIS, SDL_Surface *surface, Uint32 key, struct SDLBase *SDLBase)
+#endif
+{
+	/*
+		We are creating a pixmap in system memory with alpha channel (RGBA format)
+		The ColorKey is encoded in the Alpha channel
+		Doesn't work yet for 8 bits per pixel format!
+	*/
+	int result = -1;
+	ULONG ARGBKey = 0x00000000;
+	ULONG *currentpix;
+	int pixnum=0;
+	
+	D(bug("CGX_SetHWColorKey\n"));
+	
+	result = CGX_CreateAlphaPixMap(this,surface);
+	
+	if (result == 0)
+	{
+		/* Convert ColorKey to ARGB format (Do not take Alpha channel into account)*/
+		ARGBKey = (((key & surface->format->Rmask) >> surface->format->Rshift) << (surface->format->Rloss + 16))
+				| (((key & surface->format->Gmask) >> surface->format->Gshift) << (surface->format->Gloss + 8))
+				| (((key & surface->format->Bmask) >> surface->format->Bshift) << (surface->format->Bloss + 0));
+				
+		currentpix = (ULONG *)surface->hwdata->pixarrayalpha;
+		for (pixnum = 0; pixnum<surface->w*surface->h; pixnum++)
+		{
+			if ((currentpix[pixnum] & AROS_BE2LONG(0x00FFFFFF)) == AROS_BE2LONG(ARGBKey))
+			{
+				/* Keep color but put alpha channel to fully transparent (0 : TBC)*/
+				 currentpix[pixnum] = (currentpix[pixnum] & AROS_BE2LONG(0x00FFFFFF));
+			}
+		}
+	}
+	return result;
+}
+
+#if !defined(PROTO_SDL_H)
+int CGX_ColorKeyToAlpha(_THIS,SDL_Surface *surface, Uint32 key)
+#else
+int CGX_ColorKeyToAlphaI(_THIS, SDL_Surface *surface, Uint32 key, struct SDLBase *SDLBase)
+#endif
+{
+	/* Includes the ColorKey in the Alpha Channel of a SW surface */
+	int result = -1;
+	ULONG ARGBKey = 0x00000000;
+	ULONG *currentpix;
+	int pixnum=0;
+	
+	D(bug("CGX_ColorKeyToAlpha\n"));
+	// FIXME: Potential endianess issue here!
+	
+	/* Only works for 32bits surfaces in ARGB format */
+	if	(  (surface->format->BytesPerPixel == 4)
+		&& (surface->format->Rmask == AROS_BE2LONG(0x00FF0000))
+		&& (surface->format->Gmask == AROS_BE2LONG(0x0000FF00))
+		&& (surface->format->Bmask == AROS_BE2LONG(0x000000FF)) )
+	{
+		/* Convert ColorKey to ARGB format (Do not take Alpha channel into account)*/
+		ARGBKey = (((key & surface->format->Rmask) >> surface->format->Rshift) << (surface->format->Rloss + 16))
+				| (((key & surface->format->Gmask) >> surface->format->Gshift) << (surface->format->Gloss + 8))
+				| (((key & surface->format->Bmask) >> surface->format->Bshift) << (surface->format->Bloss + 0));
+				
+				
+		currentpix = (ULONG *)surface->pixels;
+		for (pixnum = 0; pixnum<surface->w*surface->h; pixnum++)
+		{
+			if ((currentpix[pixnum] & AROS_BE2LONG(0x00FFFFFF)) == AROS_BE2LONG(ARGBKey))
+			{
+				/* Keep color but put alpha channel to fully transparent (0 : TBC)*/
+				currentpix[pixnum] = (currentpix[pixnum] & AROS_BE2LONG(0x00FFFFFF));
+			}
+		}
+		result = 0;
+	}
+	return result;
+}
+
+static int CGX_HWtoHWBlit(	SDL_Surface *src, SDL_Rect *srcrect,
+							SDL_Surface *dst, SDL_Rect *dstrect)
+{
+	D(bug("Accelerated HW to HW blit\n"));
+
+	BltBitMap(	src->hwdata->bmap,
+				srcrect->x,
+				srcrect->y,
+				dst->hwdata->bmap,
+				dstrect->x,
+				dstrect->y,
+				srcrect->w,
+				srcrect->h,
+				(ABC|ABNC),
+				0xff,
+				NULL);
+
+	return 0;
+}
+
+static int CGX_HWtoHWBlitA(	SDL_Surface *src, SDL_Rect *srcrect,
+							SDL_Surface *dst, SDL_Rect *dstrect)
+{
+	struct SDL_VideoDevice 	*this = dst->hwdata->videodata;
+
+	D(bug("Accelerated HW to HW blit with Alpha channel\n"));
+
+	if (src->hwdata->pixarrayalpha)
+	{
+		if(!SDL_temprp) SDL_temprp = CreateRastPort();
+		SDL_temprp->BitMap=(struct BitMap *)dst->hwdata->bmap;
+		
+		WritePixelArrayAlpha(	src->hwdata->pixarrayalpha, 
+								srcrect->x, 
+								srcrect->y, 
+								src->w * 4, 
+								SDL_temprp,
+								dstrect->x,
+								dstrect->y,
+								srcrect->w,
+								srcrect->h,
+								0x01010101 * src->format->alpha );
+	}
+	return 0;
+}
+
+static int CGX_HWtoHWBlitCC(SDL_Surface *src, SDL_Rect *srcrect,
+							SDL_Surface *dst, SDL_Rect *dstrect)
+{
+	struct SDL_VideoDevice 	*this = dst->hwdata->videodata;
+
+	D(bug("Accelerated HW to HW blit with ColorKey\n"));
+	
+	if (src->hwdata->pixarrayalpha)
+	{
+		if(!SDL_temprp) SDL_temprp = CreateRastPort();
+		SDL_temprp->BitMap=(struct BitMap *)dst->hwdata->bmap;
+		
+		WritePixelArrayAlpha(	src->hwdata->pixarrayalpha, 
+								srcrect->x, 
+								srcrect->y, 
+								src->w * 4, 
+								SDL_temprp,
+								dstrect->x,
+								dstrect->y,
+								srcrect->w,
+								srcrect->h,
+								0xFFFFFFFF);
+	}
+	return 0;
+}
+
+static int CGX_SWtoHWBlit(	SDL_Surface *src, SDL_Rect *srcrect,
+							SDL_Surface *dst, SDL_Rect *dstrect)
+{
+	ULONG format;
+	struct SDL_VideoDevice 	*this = dst->hwdata->videodata;
+	
+	D(bug("Accelerated SW to HW blit\n"));
+	
+	format=CGX_MaskToRECTFMT(	src->format->Amask,
+								src->format->Rmask,
+								src->format->Gmask,
+								src->format->Bmask);
+
+	if(!SDL_temprp) SDL_temprp = CreateRastPort();
+	SDL_temprp->BitMap=(struct BitMap *)dst->hwdata->bmap;
+	
+	WritePixelArray(	src->pixels, 
+						srcrect->x, 
+						srcrect->y, 
+						src->pitch, 
+						SDL_temprp,
+						dstrect->x,
+						dstrect->y,
+						srcrect->w,
+						srcrect->h,
+						format);
+
+	return 0;
+}
+
+static int CGX_SWtoHWBlitA(	SDL_Surface *src, SDL_Rect *srcrect,
+							SDL_Surface *dst, SDL_Rect *dstrect)
+{
+	/*
+	WritePixelArrayAlpha only works with pixels array in ARGB format
+	That's why we've forced the use of this format when 32 bit surface is requested
+	This however will have to be checked if really working or not
+	*/	
+	struct SDL_VideoDevice 	*this = dst->hwdata->videodata;
+
+	D(bug("Accelerated SW to HW blit with ALPHA\n"));
+	
+	return 0;
+	
+	if(!SDL_temprp) SDL_temprp = CreateRastPort();
+	SDL_temprp->BitMap=(struct BitMap *)dst->hwdata->bmap;
+	
+	WritePixelArrayAlpha(	src->pixels, 
+							srcrect->x, 
+							srcrect->y, 
+							src->pitch, 
+							SDL_temprp,
+							dstrect->x,
+							dstrect->y,
+							srcrect->w,
+							srcrect->h,
+							0x01010101 * src->format->alpha );
+
+	return 0;
+}
+
+static int CGX_SWtoHWBlitCC(SDL_Surface *src, SDL_Rect *srcrect,
+							SDL_Surface *dst, SDL_Rect *dstrect)
+{
+	struct SDL_VideoDevice 	*this = dst->hwdata->videodata;
+
+	D(bug("Accelerated SW to HW blit with CC\n"));
+
+	if(!SDL_temprp) SDL_temprp = CreateRastPort();
+	SDL_temprp->BitMap=(struct BitMap *)dst->hwdata->bmap;
+	
+	WritePixelArrayAlpha(	src->pixels, 
+							srcrect->x, 
+							srcrect->y, 
+							src->pitch, 
+							SDL_temprp,
+							dstrect->x,
+							dstrect->y,
+							srcrect->w,
+							srcrect->h,
+							0xFFFFFFFF );
+	return 0;
+}
+
+#endif
diff -Naur SDL-1.2.15-orig/src/video/cgx/SDL_cgxaccel_c.h SDL-1.2.15/src/video/cgx/SDL_cgxaccel_c.h
--- SDL-1.2.15-orig/src/video/cgx/SDL_cgxaccel_c.h	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.15/src/video/cgx/SDL_cgxaccel_c.h	2015-05-09 15:09:59.766739512 +0200
@@ -0,0 +1,64 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#include "SDL_cgxvideo.h"
+#include "SDL_cgximage_c.h"
+
+#if !defined(PROTO_SDL_H)
+extern int 	CGX_AllocHWSurface(_THIS, SDL_Surface *surface);
+extern void CGX_FreeHWSurface(_THIS, SDL_Surface *surface);
+extern int 	CGX_LockHWSurface(_THIS, SDL_Surface *surface);
+extern void CGX_UnlockHWSurface(_THIS, SDL_Surface *surface);
+extern int 	CGX_FlipHWSurface(_THIS, SDL_Surface *surface);
+extern int 	CGX_FillHWRect(_THIS,SDL_Surface *dst,SDL_Rect *dstrect,Uint32 color);
+#ifndef NO_AMIGAHWSURF
+extern int 	CGX_CheckHWBlit(_THIS,SDL_Surface *src,SDL_Surface *dst);
+extern int 	CGX_SetHWColorKey(_THIS,SDL_Surface *surface, Uint32 key);
+extern int 	CGX_CreateAlphaPixMap(_THIS,SDL_Surface *surface);
+extern int 	CGX_ColorKeyToAlpha(_THIS,SDL_Surface *surface, Uint32 key);
+#endif
+#else
+extern int 	CGX_AllocHWSurfaceI(_THIS, SDL_Surface *surface, struct SDLBase *SDLBase);
+extern void CGX_FreeHWSurfaceI(_THIS, SDL_Surface *surface, struct SDLBase *SDLBase);
+extern int 	CGX_LockHWSurfaceI(_THIS, SDL_Surface *surface, struct SDLBase *SDLBase);
+extern void CGX_UnlockHWSurfaceI(_THIS, SDL_Surface *surface, struct SDLBase *SDLBase);
+extern int 	CGX_FlipHWSurfaceI(_THIS, SDL_Surface *surface, struct SDLBase *SDLBase);
+extern int 	CGX_FillHWRectI(_THIS, SDL_Surface *dst, SDL_Rect *dstrect, Uint32 colo, struct SDLBase *SDLBase);
+#ifndef NO_AMIGAHWSURF
+extern int 	CGX_CheckHWBlitI(_THIS, SDL_Surface *src, SDL_Surface *dst, struct SDLBase *SDLBase);
+extern int 	CGX_SetHWColorKeyI(_THIS, SDL_Surface *surface, Uint32 key, struct SDLBase *SDLBase);
+extern int 	CGX_CreateAlphaPixMapI(_THIS, SDL_Surface *surface, struct SDLBase *SDLBase);
+extern int 	CGX_ColorKeyToAlphaI(_THIS, SDL_Surface *surface, Uint32 key, struct SDLBase *SDLBase);
+
+#define CGX_CheckHWBlit(this, src, dst) CGX_CheckHWBlitI(this, src, dst, SDLBase)
+#define CGX_SetHWColorKey(this, surface, key) CGX_SetHWColorKeyI(this, surface, key, SDLBase)
+#define CGX_CreateAlphaPixMap(this, surface) CGX_CreateAlphaPixMapI(this, surface, SDLBase)
+#define CGX_ColorKeyToAlpha(this, surface, key) CGX_ColorKeyToAlphaI(this, surface, key, SDLBase)
+#endif
+#define CGX_AllocHWSurface(this, surface) CGX_AllocHWSurfaceI(this, surface, SDLBase)
+#define CGX_FreeHWSurface(this, surface) CGX_FreeHWSurfaceI(this, surface, SDLBase)
+#define CGX_LockHWSurface(this, surface) CGX_LockHWSurfaceI(this, surface, SDLBase)
+#define CGX_UnlockHWSurface(this, surface) CGX_UnlockHWSurfaceI(this, surface, SDLBase)
+#define CGX_FlipHWSurface(this, surface) CGX_FlipHWSurfaceI(this, surface, SDLBase)
+#define CGX_FillHWRect(this, dst, dstrect, colo) CGX_FillHWRectI(this, dst, dstrect, colo, SDLBase)
+#endif
diff -Naur SDL-1.2.15-orig/src/video/cgx/SDL_cgxevents.c SDL-1.2.15/src/video/cgx/SDL_cgxevents.c
--- SDL-1.2.15-orig/src/video/cgx/SDL_cgxevents.c	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.15/src/video/cgx/SDL_cgxevents.c	2015-05-09 15:09:59.766739512 +0200
@@ -0,0 +1,491 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
+#include "SDL_config.h"
+
+/* Handle the event stream, converting Amiga events into SDL events */
+#include "SDL.h"
+
+#include "SDL_syswm.h"
+#include "../SDL_sysvideo.h"
+#include "../../events/SDL_sysevents.h"
+#include "../../events/SDL_events_c.h"
+#include "SDL_cgxvideo.h"
+#include "SDL_cgxmodes_c.h"
+#include "SDL_cgximage_c.h"
+#include "SDL_cgxwm_c.h"
+#include "SDL_cgxmouse_c.h"
+#include "SDL_cgxevents_c.h"
+
+#if defined(PROTO_SDL_H)
+#include "SDL_intern.h"
+#define current_video SDLBase->current_video
+#endif
+
+/* The translation tables from an Amiga keysym to a SDL keysym */
+static SDLKey 		MISC_keymap[256];
+
+struct IOStdReq*	SDL_ConReq=NULL;
+struct MsgPort*		SDL_ConPort=NULL;
+
+#if !defined(PROTO_SDL_H)
+SDL_keysym *CGX_TranslateKey(int code, UWORD qualifier, SDL_keysym *keysym)
+#else
+#define CGX_TranslateKey(code, qualifier, keysym) CGX_TranslateKeyI(code, qualifier, keysym, SDLBase)
+SDL_keysym *CGX_TranslateKeyI(int code, UWORD qualifier, SDL_keysym *keysym, struct SDLBase *SDLBase)
+#endif
+{
+	struct InputEvent event;
+	long actual;
+	char buffer[5];
+
+	static struct Device *ConsoleDevice=NULL;
+
+	/* Get the raw keyboard scancode */
+	keysym->scancode = code;
+	keysym->sym = MISC_keymap[code];
+
+	if(!ConsoleDevice)
+	{
+		if((SDL_ConPort=CreateMsgPort()))
+		{
+			if((SDL_ConReq=CreateIORequest(SDL_ConPort,sizeof(struct IOStdReq))))
+			{
+				if(!OpenDevice("console.device",-1,(struct IORequest *)SDL_ConReq,0))
+					ConsoleDevice=(struct Device *)SDL_ConReq->io_Device;
+				else
+				{
+					DeleteIORequest(SDL_ConReq);
+					SDL_ConReq=NULL;
+				}
+			}
+			else
+			{
+				DeleteMsgPort(SDL_ConPort);
+				SDL_ConPort=NULL;
+			}
+		}
+	}
+	/* Get the translated SDL virtual keysym */
+	if ( keysym->sym==SDLK_UNKNOWN )
+	{
+		if(ConsoleDevice)
+		{
+			event.ie_Qualifier=0;
+			event.ie_Class=IECLASS_RAWKEY;
+			event.ie_SubClass=0L;
+			event.ie_Code=code & ~(IECODE_UP_PREFIX);
+			event.ie_X=event.ie_Y=0;
+			event.ie_EventAddress=NULL;
+			event.ie_NextEvent=NULL;
+			event.ie_Prev1DownCode=event.ie_Prev1DownQual=event.ie_Prev2DownCode=event.ie_Prev2DownQual=0;
+
+			if( (actual=RawKeyConvert(&event,buffer,5,NULL))==1)
+			{
+				keysym->sym = (buffer[0] & 0xFF);
+				D(bug("Converted rawcode %ld to <%lc>\n",code,*buffer));
+				// Buffering for successive calls
+				MISC_keymap[code]= (buffer[0] & 0xFF);
+			}
+			else D(bug("Warning (%ld) character conversion!\n",actual));
+		}
+
+	}
+	keysym->mod = KMOD_NONE;
+
+	/* If UNICODE is on, get the UNICODE value for the key */
+	/*Bad hack, only ascii values are returned, RawKeyConvert doesn't return unicode or? */
+	keysym->unicode = 0;
+	if ( SDL_TranslateUNICODE )
+	{
+		if(ConsoleDevice)
+		{
+			event.ie_Class = IECLASS_RAWKEY;
+			event.ie_SubClass = 0;
+			event.ie_Code  = code & ~(IECODE_UP_PREFIX);
+			event.ie_Qualifier = qualifier;
+			event.ie_EventAddress = NULL;
+
+			actual = RawKeyConvert(&event, buffer, 5, 0);
+			
+			if ((actual == 1) && (keysym->sym!=SDLK_UNKNOWN)) keysym->unicode = (buffer[0] & 0xFF);
+		}
+	}
+	return(keysym);
+}
+
+static int CGX_GetButton(int code)
+{
+	switch(code)
+	{
+		case IECODE_MBUTTON:
+			return SDL_BUTTON_MIDDLE;
+		case IECODE_RBUTTON:
+			return SDL_BUTTON_RIGHT;
+		default:
+			return SDL_BUTTON_LEFT;
+	}
+}
+
+#if !defined(PROTO_SDL_H)
+static int CGX_FocusActivate(_THIS, BOOL activate)
+#else
+#define CGX_FocusActivate(this, activate) CGX_FocusActivateI(this, activate, SDLBase)
+static int CGX_FocusActivateI(_THIS, BOOL activate, struct SDLBase *SDLBase)
+#endif
+{
+	int posted = 0;
+	int val = activate ? 1 : 0;
+
+	posted = SDL_PrivateAppActive(val, SDL_APPMOUSEFOCUS);
+	posted |= SDL_PrivateAppActive(val, SDL_APPINPUTFOCUS);
+	this->hidden->FocusActive = val;
+
+	return posted;
+}
+
+static int CGX_IsMouseInsideDrawArea(int mouseX, int mouseY, struct Window * wnd)
+{
+	if ((mouseX < (wnd->BorderLeft)) ||
+		(mouseX > (wnd->Width - wnd->BorderRight)))
+		return 0;
+	if ((mouseY < (wnd->BorderTop)) ||
+		(mouseY > (wnd->Height - wnd->BorderBottom)))
+		return 0;
+		
+	return 1;
+}
+
+/* 
+ * FocusActive handling:
+ *   How to loose focus:
+ *     - If !GrabMouse and WindowActive and Exit window drawing area
+ *     - ALT + TAB = IDCMP_IACTIVEWINDOW
+ *   How to gain focus:
+ *     - If WindowActive and Enter window drawing area and !ExplicitFocusActivation
+ *     - Open SDL_FULLSCREEN mode (indirect via clearing ExplicitFocusFlag)
+ *     - If ExplicitFocusActivation and Click in window drawing area
+ */
+#if !defined(PROTO_SDL_H)
+static int CGX_DispatchEvent(_THIS, struct IntuiMessage *msg)
+#else
+#define CGX_DispatchEvent(this, msg) CGX_DispatchEventI(this, msg, SDLBase)
+static int CGX_DispatchEventI(_THIS, struct IntuiMessage *msg, struct SDLBase *SDLBase)
+#endif
+{
+	int class=msg->Class,code=msg->Code;
+	int posted;
+
+	posted = 0;
+	switch (class) {
+	    /* Gaining app & mouse focus */
+	    case IDCMP_ACTIVEWINDOW:
+			this->hidden->WindowActive = 1;
+			break;
+
+	    /* Loosing app & mouse focus */
+	    case IDCMP_INACTIVEWINDOW:
+			/* If mouse is grabbed, request explicit activation */
+			if (this->hidden->GrabMouse)
+				this->hidden->ExplicitFocusActivation = 1;
+			posted = CGX_FocusActivate(this, FALSE);
+			this->hidden->WindowActive = 0;
+			break;
+
+	    /* Mouse motion */
+	    case IDCMP_MOUSEMOVE:
+			if ( SDL_VideoSurface )
+			{
+				int new_x, new_y, dx = 0, dy = 0;
+				
+				if (currently_fullscreen)
+				{
+					/* Center display on screen */
+					dx = (SDL_Display->Width - this->screen->w)/2;
+					dy = (SDL_Display->Height - this->screen->h)/2;
+				}
+				
+				/* Check for activation/deactivation of App */
+				if (this->hidden->WindowActive)
+				{
+					/* Exit only if not grabbed */
+					if (this->hidden->FocusActive && !this->hidden->GrabMouse &&
+						!CGX_IsMouseInsideDrawArea(msg->MouseX, msg->MouseY, SDL_Window))
+						posted |= CGX_FocusActivate(this, FALSE);
+
+					/* Enter only if not explicit focus activation needed */
+					if (!this->hidden->FocusActive && !this->hidden->ExplicitFocusActivation &&
+						CGX_IsMouseInsideDrawArea(msg->MouseX, msg->MouseY, SDL_Window))
+						posted |= CGX_FocusActivate(this, TRUE);
+				}
+
+				/* These are coords "inside" AROS window (without borders) */
+				new_x = msg->MouseX - SDL_Window->BorderLeft;
+				new_y = msg->MouseY - SDL_Window->BorderTop;
+
+				if (this->hidden->FocusActive && this->hidden->GrabMouse)
+				{
+					if (!this->hidden->CursorVisible)
+					{
+						/* This is a special case in SDL documentation. When
+						   GrabMouse and !CursonVisible, always post relative
+						   move events. Always warp to center of screen. */
+						int center_x = this->screen->w / 2;
+						int center_y = this->screen->h / 2;
+
+						if ((new_x == center_x) && (new_y == center_y))
+						{
+							/* Do nothing - this is a signal generated by warp call. */
+						}
+						else
+						{
+							int rel_x = msg->MouseX - this->hidden->LastMouseX;
+							int rel_y = msg->MouseY - this->hidden->LastMouseY;
+
+							/* 	Workaround:
+							 * 	Send "recall" event only when cursor leaves 1/2 of inner area
+							 	of window. Sending the event each mouse event casues an increasing
+							 	stall with DoIO call. The root cause of this stall is unknown.
+							 	The workaround seems to avoid the stall. */
+							if ((new_x < center_x / 2) || (new_x > (center_x * 3 / 2)) ||
+								(new_y < center_y / 2) || (new_y > (center_y * 3 / 2)))
+								CGX_WarpWMCursor(this, center_x, center_y);
+							posted |= SDL_PrivateMouseMotion(0, 1, rel_x, rel_y);
+						}
+					}
+					else
+					{
+						BOOL dowarp = FALSE;
+									
+						if (new_x - dx  < 0)
+						{
+							dowarp = TRUE;
+							new_x = dx;
+						}
+						else if (new_x - dx > this->screen->w - 1)
+						{
+							dowarp = TRUE;
+							new_x = dx + this->screen->w - 1;
+						}
+					
+						if (new_y - dy < 0)
+						{
+							dowarp = TRUE;
+							new_y = 0;
+						}
+						else if (new_y - dy > this->screen->h - 1)
+						{
+							dowarp = TRUE;
+							new_y = dy + this->screen->h - 1;
+						}
+
+						if (dowarp) CGX_WarpWMCursor(this, new_x, new_y);
+						posted |= SDL_PrivateMouseMotion(0, 0, new_x - dx, new_y - dy);
+					}
+				}
+				else
+					posted |= SDL_PrivateMouseMotion(0, 0, new_x - dx, new_y - dy);
+
+				this->hidden->LastMouseX = msg->MouseX;
+				this->hidden->LastMouseY = msg->MouseY;
+			}
+	    	break;
+
+	    
+		case IDCMP_MOUSEBUTTONS:
+			/* Mouse button press? */
+			if(!(code&IECODE_UP_PREFIX))
+			{
+				/* Explicit focus activation case */
+				if (this->hidden->ExplicitFocusActivation && 
+					CGX_IsMouseInsideDrawArea(msg->MouseX, msg->MouseY, SDL_Window))
+				{
+					this->hidden->ExplicitFocusActivation = 0;
+					posted |= CGX_FocusActivate(this, TRUE);
+				}
+				else
+				{
+					posted |= SDL_PrivateMouseButton(SDL_PRESSED, 
+							CGX_GetButton(code), 0, 0);
+				}
+			}
+			/* Mouse button release? */
+			else
+			{
+				code&=~IECODE_UP_PREFIX;
+				posted = SDL_PrivateMouseButton(SDL_RELEASED,
+						CGX_GetButton(code), 0, 0);
+			}
+			break;
+
+	    case IDCMP_RAWKEY:
+			/* Mouse wheel support */
+			if (code == RAWKEY_NM_WHEEL_UP)
+			{
+				posted = SDL_PrivateMouseButton(SDL_PRESSED,
+							SDL_BUTTON_WHEELUP, 0, 0);
+				posted |= SDL_PrivateMouseButton(SDL_RELEASED,
+							SDL_BUTTON_WHEELUP, 0, 0);
+				break;
+			}
+			
+			if (code == RAWKEY_NM_WHEEL_DOWN)
+			{
+				posted = SDL_PrivateMouseButton(SDL_PRESSED,
+							SDL_BUTTON_WHEELDOWN, 0, 0);
+				posted |= SDL_PrivateMouseButton(SDL_RELEASED,
+							SDL_BUTTON_WHEELDOWN, 0, 0);
+				break;
+			}
+
+		    if( !(code&IECODE_UP_PREFIX) )
+		    {
+				/* Key press */
+				SDL_keysym keysym;
+				posted = SDL_PrivateKeyboard(SDL_PRESSED,
+					CGX_TranslateKey(code, msg->Qualifier, &keysym));
+		    }
+		    else
+		    {
+				/* Key release */
+				SDL_keysym keysym;
+				code&=~IECODE_UP_PREFIX;
+				posted = SDL_PrivateKeyboard(SDL_RELEASED,
+					CGX_TranslateKey(code, msg->Qualifier, &keysym));
+		    }
+		    break;
+
+	    /* Have we been resized? */
+	    case IDCMP_NEWSIZE:
+			SDL_PrivateResize(SDL_Window->Width-SDL_Window->BorderLeft-SDL_Window->BorderRight,
+		                  SDL_Window->Height-SDL_Window->BorderTop-SDL_Window->BorderBottom);
+
+			break;
+
+	    /* Have we been requested to quit? */
+	    case IDCMP_CLOSEWINDOW:
+			posted = SDL_PrivateQuit();
+			break;
+
+	    /* Do we need to refresh ourselves? */
+
+	    default: {
+			/* Only post the event if we're watching for it */
+			if ( SDL_ProcessEvents[SDL_SYSWMEVENT] == SDL_ENABLE ) {
+				SDL_SysWMmsg wmmsg;
+
+				SDL_VERSION(&wmmsg.version);
+
+				posted = SDL_PrivateSysWMEvent(&wmmsg);
+			}
+			}
+			break;
+	}
+	ReplyMsg((struct Message *)msg);
+
+	return(posted);
+}
+
+#if !defined(PROTO_SDL_H)
+void CGX_PumpEvents(_THIS)
+#else
+void CGX_PumpEvents(_THIS, struct SDLBase *SDLBase)
+#endif
+{
+	struct IntuiMessage *m;
+	
+	if (SDL_Window)
+		while (( m=(struct IntuiMessage *)GetMsg(SDL_Window->UserPort) )) 
+		{
+			CGX_DispatchEvent(this, m );
+		}
+}
+
+#if !defined(PROTO_SDL_H)
+void CGX_InitOSKeymap(_THIS)
+#else
+void CGX_InitOSKeymap(_THIS, struct SDLBase *SDLBase)
+#endif
+{
+	int i;
+
+	/* Map the miscellaneous keys */
+	for ( i=0; i<SDL_arraysize(MISC_keymap); ++i )
+		MISC_keymap[i] = SDLK_UNKNOWN;
+
+	MISC_keymap[RAWKEY_BACKSPACE	] = SDLK_BACKSPACE;
+	MISC_keymap[RAWKEY_TAB			] = SDLK_TAB;
+	MISC_keymap[RAWKEY_DELETE		] = SDLK_DELETE;
+	MISC_keymap[RAWKEY_RETURN		] = SDLK_RETURN;
+	MISC_keymap[RAWKEY_ESCAPE		] = SDLK_ESCAPE;
+	MISC_keymap[RAWKEY_KP_0			] = SDLK_KP0;		/* Keypad 0-9 */
+	MISC_keymap[RAWKEY_KP_1			] = SDLK_KP1;
+	MISC_keymap[RAWKEY_KP_2			] = SDLK_KP2;
+	MISC_keymap[RAWKEY_KP_3			] = SDLK_KP3;
+	MISC_keymap[RAWKEY_KP_4			] = SDLK_KP4;
+	MISC_keymap[RAWKEY_KP_5			] = SDLK_KP5;
+	MISC_keymap[RAWKEY_KP_6			] = SDLK_KP6;
+	MISC_keymap[RAWKEY_KP_7			] = SDLK_KP7;
+	MISC_keymap[RAWKEY_KP_8			] = SDLK_KP8;
+	MISC_keymap[RAWKEY_KP_9			] = SDLK_KP9;
+	MISC_keymap[RAWKEY_KP_DECIMAL	] = SDLK_KP_PERIOD;
+	MISC_keymap[0x5A				] = SDLK_NUMLOCK;
+	MISC_keymap[0x5B				] = SDLK_KP_DIVIDE;
+	MISC_keymap[0x5C				] = SDLK_KP_MULTIPLY;
+	MISC_keymap[0x5D				] = SDLK_KP_MINUS;
+	MISC_keymap[RAWKEY_KP_PLUS		] = SDLK_KP_PLUS;
+	MISC_keymap[RAWKEY_KP_ENTER		] = SDLK_KP_ENTER;
+	MISC_keymap[RAWKEY_UP			] = SDLK_UP;
+	MISC_keymap[RAWKEY_DOWN			] = SDLK_DOWN;
+	MISC_keymap[RAWKEY_RIGHT		] = SDLK_RIGHT;
+	MISC_keymap[RAWKEY_LEFT			] = SDLK_LEFT;
+	MISC_keymap[RAWKEY_PAGEUP		] = SDLK_PAGEUP;
+	MISC_keymap[RAWKEY_PAGEDOWN		] = SDLK_PAGEDOWN;
+	MISC_keymap[RAWKEY_F1			] = SDLK_F1;
+	MISC_keymap[RAWKEY_F2			] = SDLK_F2;
+	MISC_keymap[RAWKEY_F3			] = SDLK_F3;
+	MISC_keymap[RAWKEY_F4			] = SDLK_F4;
+	MISC_keymap[RAWKEY_F5			] = SDLK_F5;
+	MISC_keymap[RAWKEY_F6			] = SDLK_F6;
+	MISC_keymap[RAWKEY_F7			] = SDLK_F7;
+	MISC_keymap[RAWKEY_F8			] = SDLK_F8;
+	MISC_keymap[RAWKEY_F9			] = SDLK_F9;
+	MISC_keymap[RAWKEY_F10			] = SDLK_F10;
+	MISC_keymap[RAWKEY_F11			] = SDLK_F11;		/* F11 is hard mapped to HELP	on AROS */
+	MISC_keymap[RAWKEY_F12			] = SDLK_F12;		/* F12 is hard mapped to RSUPER	on AROS */
+	MISC_keymap[RAWKEY_CAPSLOCK		] = SDLK_CAPSLOCK;
+	MISC_keymap[RAWKEY_RSHIFT		] = SDLK_RSHIFT;
+	MISC_keymap[RAWKEY_LSHIFT		] = SDLK_LSHIFT;
+	MISC_keymap[RAWKEY_CONTROL		] = SDLK_LCTRL;  	/* There is only one control key on an amiga keyboard! */
+	MISC_keymap[RAWKEY_RALT			] = SDLK_RALT;
+	MISC_keymap[RAWKEY_LALT			] = SDLK_LALT;
+	MISC_keymap[RAWKEY_LAMIGA		] = SDLK_LSUPER; 	/* Left "Windows" i.e "Amiga"*/
+	MISC_keymap[RAWKEY_RAMIGA		] = SDLK_RSUPER; 	/* Right "Windows i.e "Amiga"*/
+	MISC_keymap[RAWKEY_HELP			] = SDLK_HELP;
+	MISC_keymap[RAWKEY_INSERT		] = SDLK_INSERT;
+	MISC_keymap[RAWKEY_HOME			] = SDLK_HOME;
+	MISC_keymap[RAWKEY_END			] = SDLK_END;
+}
diff -Naur SDL-1.2.15-orig/src/video/cgx/SDL_cgxevents_c.h SDL-1.2.15/src/video/cgx/SDL_cgxevents_c.h
--- SDL-1.2.15-orig/src/video/cgx/SDL_cgxevents_c.h	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.15/src/video/cgx/SDL_cgxevents_c.h	2015-05-09 15:09:59.766739512 +0200
@@ -0,0 +1,35 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#include "SDL_cgxvideo.h"
+
+/* Functions to be exported */
+#if !defined(PROTO_SDL_H)
+extern void CGX_InitOSKeymap(_THIS);
+extern void CGX_PumpEvents(_THIS);
+#else
+extern void CGX_InitOSKeymap(_THIS, struct SDLBase *SDLBase);
+extern void CGX_PumpEvents(_THIS, struct SDLBase *SDLBase);
+#endif
+
+
diff -Naur SDL-1.2.15-orig/src/video/cgx/SDL_cgxgl_c.h SDL-1.2.15/src/video/cgx/SDL_cgxgl_c.h
--- SDL-1.2.15-orig/src/video/cgx/SDL_cgxgl_c.h	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.15/src/video/cgx/SDL_cgxgl_c.h	2015-05-09 15:09:59.766739512 +0200
@@ -0,0 +1,77 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#include "../SDL_sysvideo.h"
+
+#if SDL_VIDEO_OPENGL
+#include <proto/exec.h>
+#include <GL/gla.h>
+#endif
+
+#define _THIS   SDL_VideoDevice *_this
+
+struct SDL_PrivateGLData {
+#if SDL_VIDEO_OPENGL
+	GLAContext glctx;
+#endif
+};
+
+#if !defined(PROTO_SDL_H)
+/* OpenGL functions */
+extern int CGX_GL_CreateContext(_THIS);
+extern void CGX_GL_DestroyContext(_THIS);
+extern void CGX_GL_Quit(_THIS);
+extern int CGX_GL_UpdateContext(_THIS);
+#if SDL_VIDEO_OPENGL
+extern int CGX_GL_MakeCurrent(_THIS);
+extern int CGX_GL_GetAttribute(_THIS, SDL_GLattr attrib, int* value);
+extern void CGX_GL_SwapBuffers(_THIS);
+extern void *CGX_GL_GetProcAddress(_THIS, const char *proc);
+extern int CGX_GL_LoadLibrary(_THIS, const char *path);
+#endif
+#else
+/* OpenGL functions */
+extern int CGX_GL_CreateContextI(_THIS, struct SDLBase *SDLBase);
+extern void CGX_GL_DestroyContextI(_THIS, struct SDLBase *SDLBase);
+extern void CGX_GL_QuitI(_THIS, struct SDLBase *SDLBase);
+extern int CGX_GL_UpdateContextI(_THIS, struct SDLBase *SDLBase);
+#if SDL_VIDEO_OPENGL
+extern int CGX_GL_MakeCurrentI(_THIS, struct SDLBase *SDLBase);
+extern int CGX_GL_GetAttributeI(_THIS, SDL_GLattr attrib, int* value, struct SDLBase *SDLBase);
+extern void CGX_GL_SwapBuffersI(_THIS, struct SDLBase *SDLBase);
+extern void *CGX_GL_GetProcAddressI(_THIS, const char *proc, struct SDLBase *SDLBase);
+extern int CGX_GL_LoadLibraryI(_THIS, const char *path, struct SDLBase *SDLBase);
+
+#define CGX_GL_MakeCurrent(this) CGX_GL_MakeCurrentI(this, SDLBase)
+#define CGX_GL_GetAttribute(this, attrib, value) CGX_GL_GetAttributeI(this, attrib, value, SDLBase)
+#define CGX_GL_SwapBuffers(this) CGX_GL_SwapBuffersI(this, SDLBase)
+#define CGX_GL_GetProcAddress(this, proc) CGX_GL_GetProcAddressI(this, proc, SDLBase)
+#define CGX_GL_LoadLibrary(this, path) CGX_GL_LoadLibraryI(this, path, SDLBase)
+#endif
+#define CGX_GL_CreateContext(this) CGX_GL_CreateContextI(this, SDLBase)
+#define CGX_GL_DestroyContext(this) CGX_GL_DestroyContextI(this, SDLBase)
+#define CGX_GL_Quit(this) CGX_GL_QuitI(this, SDLBase)
+#define CGX_GL_UpdateContext(this) CGX_GL_UpdateContextI(this, SDLBase)
+#endif
+
+#undef _THIS
diff -Naur SDL-1.2.15-orig/src/video/cgx/SDL_cgxgl_CreateContext.c SDL-1.2.15/src/video/cgx/SDL_cgxgl_CreateContext.c
--- SDL-1.2.15-orig/src/video/cgx/SDL_cgxgl_CreateContext.c	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.15/src/video/cgx/SDL_cgxgl_CreateContext.c	2015-05-09 15:09:59.766739512 +0200
@@ -0,0 +1,119 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
+#include <aros/system.h>
+
+#include "SDL_config.h"
+
+/* GLA implementation of SDL OpenGL support */
+
+#include "SDL_cgxgl_c.h"
+#include "SDL_cgxvideo.h"
+
+#if defined(PROTO_SDL_H) && SDL_VIDEO_OPENGL
+#include "SDL_intern.h"
+#define GLBase_ptr SDLBase->GLBase_ptr
+#define GLBase *GLBase_ptr
+#else
+extern struct Library *GLBase;
+#define GLBase_ptr &GLBase
+#endif
+
+/* Create OpenGL context */
+#if !defined(PROTO_SDL_H)
+int CGX_GL_CreateContext(_THIS)
+#else
+int CGX_GL_CreateContextI(_THIS, struct SDLBase *SDLBase)
+#endif
+{
+#if SDL_VIDEO_OPENGL
+    LONG i = 0;
+    struct TagItem attributes [10];
+    struct Window *win = (struct Window *)SDL_Window;
+
+    if ( this->gl_config.red_size   == 0 &&
+            this->gl_config.blue_size  == 0 &&
+            this->gl_config.green_size == 0 ) {
+        SDL_SetError("gl.library does not work with indexed color");
+        return(-1);
+    }
+
+    if( this->gl_config.stereo ) {
+        SDL_SetError("gl.library does not support stereo buffer");
+        return(-1);		
+    }
+    
+    if ( ! this->gl_config.driver_loaded ) {
+        if ( CGX_GL_LoadLibrary(this, NULL) < 0 ) {
+            return(-1);
+        }
+    }
+
+    /* Required window pointer  */
+    attributes[i].ti_Tag = GLA_Window;	attributes[i++].ti_Data = (IPTR)win;
+
+    /* this->gl_config.double_buffer - skipped, GLA always double-buffer */
+    /* this->gl_config.multisamplebuffers - currently not supported */
+    /* this->gl_config.multisamplesample - currently not supported */
+
+    /* no depth buffer ? */
+    if ( this->gl_config.depth_size == 0 ) 
+    {
+        attributes[i].ti_Tag = GLA_NoDepth;
+        attributes[i++].ti_Data = GL_TRUE;
+    }
+    /* no stencil buffer ? */
+    if ( this->gl_config.stencil_size == 0 )
+    {
+        attributes[i].ti_Tag = GLA_NoStencil;
+        attributes[i++].ti_Data = GL_TRUE;
+    }
+    /* no accum buffer ? */
+    if ( this->gl_config.accum_red_size   == 0 && 
+        this->gl_config.accum_blue_size  == 0 &&
+        this->gl_config.accum_green_size == 0 )
+    {
+        attributes[i].ti_Tag = GLA_NoAccum;
+        attributes[i++].ti_Data = GL_TRUE;
+    }
+
+    /* done */
+    attributes[i].ti_Tag = TAG_DONE;
+
+    this->gl_data->glctx = glACreateContext(attributes);
+
+    if ( this->gl_data->glctx == NULL ) {
+        SDL_SetError("Couldn't create OpenGL context");
+        return(-1);
+    }
+
+    return(0);
+
+#else
+    SDL_SetError("OpenGL support not configured");
+    return(-1);
+#endif
+}
diff -Naur SDL-1.2.15-orig/src/video/cgx/SDL_cgxgl_DestroyContext.c SDL-1.2.15/src/video/cgx/SDL_cgxgl_DestroyContext.c
--- SDL-1.2.15-orig/src/video/cgx/SDL_cgxgl_DestroyContext.c	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.15/src/video/cgx/SDL_cgxgl_DestroyContext.c	2015-05-09 15:09:59.766739512 +0200
@@ -0,0 +1,57 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
+#include <aros/system.h>
+
+#include "SDL_config.h"
+
+/* GLA implementation of SDL OpenGL support */
+
+#include "SDL_cgxgl_c.h"
+#include "SDL_cgxvideo.h"
+
+#if defined(PROTO_SDL_H) && SDL_VIDEO_OPENGL
+#include "SDL_intern.h"
+#define GLBase SDLBase->GLBase
+#else
+extern struct Library *GLBase;
+#endif
+
+/* Destroy OpenGL context */
+#if !defined(PROTO_SDL_H)
+void CGX_GL_DestroyContext(_THIS)
+#else
+void CGX_GL_DestroyContextI(_THIS, struct SDLBase *SDLBase)
+#endif
+{
+#if SDL_VIDEO_OPENGL
+    if (GLBase && (this->gl_data->glctx != NULL)) {
+        glAMakeCurrent(NULL);
+        glADestroyContext(this->gl_data->glctx);
+        this->gl_data->glctx = NULL;
+    }
+#endif
+}
diff -Naur SDL-1.2.15-orig/src/video/cgx/SDL_cgxgl_GetAttribute.c SDL-1.2.15/src/video/cgx/SDL_cgxgl_GetAttribute.c
--- SDL-1.2.15-orig/src/video/cgx/SDL_cgxgl_GetAttribute.c	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.15/src/video/cgx/SDL_cgxgl_GetAttribute.c	2015-05-09 15:09:59.767739510 +0200
@@ -0,0 +1,103 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
+#include <aros/system.h>
+
+#include "SDL_config.h"
+
+/* GLA implementation of SDL OpenGL support */
+
+#include "SDL_cgxgl_c.h"
+#include "SDL_cgxvideo.h"
+
+#if defined(PROTO_SDL_H) && SDL_VIDEO_OPENGL
+#include "SDL_intern.h"
+#define GLBase SDLBase->GLBase
+#else
+extern struct Library *GLBase;
+#endif
+
+#if SDL_VIDEO_OPENGL
+#if !defined(PROTO_SDL_H)
+int CGX_GL_GetAttribute(_THIS, SDL_GLattr attrib, int* value)
+#else
+int CGX_GL_GetAttributeI(_THIS, SDL_GLattr attrib, int* value, struct SDLBase *SDLBase)
+#endif
+{
+    GLenum mesa_attrib;
+
+    if (!GLBase)
+        return -1;
+
+    switch(attrib) {
+        case SDL_GL_RED_SIZE:
+            mesa_attrib = GL_RED_BITS;
+            break;
+        case SDL_GL_GREEN_SIZE:
+            mesa_attrib = GL_GREEN_BITS;
+            break;
+        case SDL_GL_BLUE_SIZE:
+            mesa_attrib = GL_BLUE_BITS;
+            break;
+        case SDL_GL_ALPHA_SIZE:
+            mesa_attrib = GL_ALPHA_BITS;
+            break;
+        case SDL_GL_DOUBLEBUFFER:
+            mesa_attrib = GL_DOUBLEBUFFER;
+            break;
+        case SDL_GL_DEPTH_SIZE:
+            mesa_attrib = GL_DEPTH_BITS;
+            break;
+        case SDL_GL_STENCIL_SIZE:
+            mesa_attrib = GL_STENCIL_BITS;
+            break;
+        case SDL_GL_ACCUM_RED_SIZE:
+            mesa_attrib = GL_ACCUM_RED_BITS;
+            break;
+        case SDL_GL_ACCUM_GREEN_SIZE:
+            mesa_attrib = GL_ACCUM_GREEN_BITS;
+            break;
+        case SDL_GL_ACCUM_BLUE_SIZE:
+            mesa_attrib = GL_ACCUM_BLUE_BITS;
+            break;
+        case SDL_GL_ACCUM_ALPHA_SIZE:
+            mesa_attrib = GL_ACCUM_ALPHA_BITS;
+            break;
+        case SDL_GL_STEREO:
+            mesa_attrib = GL_STEREO;
+            break;
+        case SDL_GL_MULTISAMPLEBUFFERS:
+            return 0;
+        case SDL_GL_MULTISAMPLESAMPLES:
+            return 0;
+        default:
+            return -1;
+    }
+
+    glAGetConfig(this->gl_data->glctx, mesa_attrib, value);
+    return 0;
+}
+#endif /* SDL_VIDEO_OPENGL */
diff -Naur SDL-1.2.15-orig/src/video/cgx/SDL_cgxgl_GetProcAddress.c SDL-1.2.15/src/video/cgx/SDL_cgxgl_GetProcAddress.c
--- SDL-1.2.15-orig/src/video/cgx/SDL_cgxgl_GetProcAddress.c	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.15/src/video/cgx/SDL_cgxgl_GetProcAddress.c	2015-05-09 15:09:59.767739510 +0200
@@ -0,0 +1,59 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
+#include <aros/system.h>
+
+#include "SDL_config.h"
+
+/* GLA implementation of SDL OpenGL support */
+
+#include "SDL_cgxgl_c.h"
+#include "SDL_cgxvideo.h"
+
+#if defined(PROTO_SDL_H) && SDL_VIDEO_OPENGL
+#include "SDL_intern.h"
+#define GLBase SDLBase->GLBase
+#else
+extern struct Library *GLBase;
+#endif
+
+#if SDL_VIDEO_OPENGL
+#if !defined(PROTO_SDL_H)
+void *CGX_GL_GetProcAddress(_THIS, const char *proc) 
+#else
+void *CGX_GL_GetProcAddressI(_THIS, const char *proc, struct SDLBase *SDLBase)
+#endif
+{
+    void *func = NULL;
+
+    if (GLBase)
+    {
+        func = glAGetProcAddress(proc);
+    }
+
+    return func;
+}
+#endif /* SDL_VIDEO_OPENGL */
diff -Naur SDL-1.2.15-orig/src/video/cgx/SDL_cgxgl_LoadLibrary.c SDL-1.2.15/src/video/cgx/SDL_cgxgl_LoadLibrary.c
--- SDL-1.2.15-orig/src/video/cgx/SDL_cgxgl_LoadLibrary.c	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.15/src/video/cgx/SDL_cgxgl_LoadLibrary.c	2015-05-09 15:09:59.767739510 +0200
@@ -0,0 +1,70 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
+#include <aros/system.h>
+
+#include "SDL_config.h"
+
+#include <aros/debug.h>
+
+/* GLA implementation of SDL OpenGL support */
+
+#include "SDL_cgxgl_c.h"
+#include "SDL_cgxvideo.h"
+
+#if SDL_VIDEO_OPENGL
+#if !defined(PROTO_SDL_H)
+struct Library *GLBase;
+#else
+#define GLBase SDLBase->GLBase
+#endif
+
+#if !defined(PROTO_SDL_H)
+int CGX_GL_LoadLibrary(_THIS, const char *path)
+#else
+int CGX_GL_LoadLibraryI(_THIS, const char *path, struct SDLBase *SDLBase)
+#endif
+{
+    D(bug("CGX_GL_LoadLibrary('%s')\n", path));
+
+    if (GLBase == NULL)
+    {
+        if ((GLBase = OpenLibrary("gl.library", 20)) != NULL)
+        {
+            this->gl_config.driver_loaded = 1;
+        }
+        else
+        {
+            this->gl_config.driver_loaded = 0;
+            SDL_SetError("Could not open gl.library");
+            return(-1);
+        }
+        this->gl_data->glctx = NULL;
+    }
+
+    return 0;
+}
+#endif /* SDL_VIDEO_OPENGL */
diff -Naur SDL-1.2.15-orig/src/video/cgx/SDL_cgxgl_MakeCurrent.c SDL-1.2.15/src/video/cgx/SDL_cgxgl_MakeCurrent.c
--- SDL-1.2.15-orig/src/video/cgx/SDL_cgxgl_MakeCurrent.c	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.15/src/video/cgx/SDL_cgxgl_MakeCurrent.c	2015-05-09 15:09:59.767739510 +0200
@@ -0,0 +1,57 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
+#include <aros/system.h>
+
+#include "SDL_config.h"
+
+/* GLA implementation of SDL OpenGL support */
+
+#include "SDL_cgxgl_c.h"
+#include "SDL_cgxvideo.h"
+
+#if defined(PROTO_SDL_H) && SDL_VIDEO_OPENGL
+#include "SDL_intern.h"
+#define GLBase SDLBase->GLBase
+#else
+extern struct Library *GLBase;
+#endif
+
+#if SDL_VIDEO_OPENGL
+/* Make the current context active */
+#if !defined(PROTO_SDL_H)
+int CGX_GL_MakeCurrent(_THIS)
+#else
+int CGX_GL_MakeCurrentI(_THIS, struct SDLBase *SDLBase)
+#endif
+{
+    if( !GLBase || this->gl_data->glctx == NULL)
+        return -1;
+
+    glAMakeCurrent(this->gl_data->glctx);
+    return 0;
+}
+#endif /* SDL_VIDEO_OPENGL */
diff -Naur SDL-1.2.15-orig/src/video/cgx/SDL_cgxgl_Quit.c SDL-1.2.15/src/video/cgx/SDL_cgxgl_Quit.c
--- SDL-1.2.15-orig/src/video/cgx/SDL_cgxgl_Quit.c	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.15/src/video/cgx/SDL_cgxgl_Quit.c	2015-05-09 15:09:59.767739510 +0200
@@ -0,0 +1,58 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
+#include <aros/system.h>
+
+#include "SDL_config.h"
+
+/* GLA implementation of SDL OpenGL support */
+
+#include "SDL_cgxgl_c.h"
+#include "SDL_cgxvideo.h"
+
+#if defined(PROTO_SDL_H) && SDL_VIDEO_OPENGL
+#include "SDL_intern.h"
+#define GLBase SDLBase->GLBase
+#else
+extern struct Library *GLBase;
+#endif
+
+/* Quit OpenGL */
+#if !defined(PROTO_SDL_H)
+void CGX_GL_Quit(_THIS)
+#else
+void CGX_GL_QuitI(_THIS, struct SDLBase *SDLBase)
+#endif
+{
+#if SDL_VIDEO_OPENGL
+    CGX_GL_DestroyContext(this);
+    if ( GLBase != NULL ) {
+        CloseLibrary(GLBase);
+        this->gl_config.driver_loaded = 0;
+        GLBase = NULL;
+    }
+#endif
+}
diff -Naur SDL-1.2.15-orig/src/video/cgx/SDL_cgxgl_SwapBuffers.c SDL-1.2.15/src/video/cgx/SDL_cgxgl_SwapBuffers.c
--- SDL-1.2.15-orig/src/video/cgx/SDL_cgxgl_SwapBuffers.c	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.15/src/video/cgx/SDL_cgxgl_SwapBuffers.c	2015-05-09 15:09:59.767739510 +0200
@@ -0,0 +1,55 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
+#include <aros/system.h>
+
+#include "SDL_config.h"
+
+/* GLA implementation of SDL OpenGL support */
+
+#include "SDL_cgxgl_c.h"
+#include "SDL_cgxvideo.h"
+
+#if defined(PROTO_SDL_H) && SDL_VIDEO_OPENGL
+#include "SDL_intern.h"
+#define GLBase SDLBase->GLBase
+#else
+extern struct Library *GLBase;
+#endif
+
+#if SDL_VIDEO_OPENGL
+#if !defined(PROTO_SDL_H)
+void CGX_GL_SwapBuffers(_THIS)
+#else
+void CGX_GL_SwapBuffersI(_THIS, struct SDLBase *SDLBase)
+#endif
+{
+    if (!GLBase)
+        return;
+
+    glASwapBuffers(this->gl_data->glctx);
+}
+#endif /* SDL_VIDEO_OPENGL */
diff -Naur SDL-1.2.15-orig/src/video/cgx/SDL_cgxgl_UpdateContext.c SDL-1.2.15/src/video/cgx/SDL_cgxgl_UpdateContext.c
--- SDL-1.2.15-orig/src/video/cgx/SDL_cgxgl_UpdateContext.c	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.15/src/video/cgx/SDL_cgxgl_UpdateContext.c	2015-05-09 15:09:59.767739510 +0200
@@ -0,0 +1,67 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
+#include <aros/system.h>
+
+#include "SDL_config.h"
+
+/* GLA implementation of SDL OpenGL support */
+
+#include "SDL_cgxgl_c.h"
+#include "SDL_cgxvideo.h"
+
+#if defined(PROTO_SDL_H) && SDL_VIDEO_OPENGL
+#include "SDL_intern.h"
+#define GLBase SDLBase->GLBase
+#else
+extern struct Library *GLBase;
+#endif
+
+/* Attach context to another window */
+#if !defined(PROTO_SDL_H)
+int CGX_GL_UpdateContext(_THIS)
+#else
+int CGX_GL_UpdateContextI(_THIS, struct SDLBase *SDLBase)
+#endif
+{
+#if SDL_VIDEO_OPENGL
+    struct TagItem tags[2];
+    struct Window *win = (struct Window*)SDL_Window;
+    if( !GLBase || this->gl_data->glctx == NULL ) {
+            return -1; //should never happen
+    }
+    tags[0].ti_Tag = GLA_Window;
+    tags[0].ti_Data = (IPTR)win;
+    tags[1].ti_Tag = TAG_DONE;
+
+    glASetRast(this->gl_data->glctx, tags);
+
+    return 0;
+#else
+    SDL_SetError("OpenGL support not configured");
+    return -1;
+#endif
+}
diff -Naur SDL-1.2.15-orig/src/video/cgx/SDL_cgximage.c SDL-1.2.15/src/video/cgx/SDL_cgximage.c
--- SDL-1.2.15-orig/src/video/cgx/SDL_cgximage.c	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.15/src/video/cgx/SDL_cgximage.c	2015-05-09 15:09:59.767739510 +0200
@@ -0,0 +1,306 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
+#include "SDL_config.h"
+
+#include "SDL_endian.h"
+#include "SDL_cgximage_c.h"
+#include "SDL_cgxaccel_c.h"
+#include "../../main/aros/mydebug.h"
+
+#if !defined(PROTO_SDL_H)
+/* Various screen update functions available */
+static void CGX_SWScreenUpdate(_THIS, int numrects, SDL_Rect *rects);
+static void CGX_HWScreenUpdate(_THIS, int numrects, SDL_Rect *rects);
+#else
+#include "SDL_intern.h"
+
+static void CGX_SWScreenUpdate(_THIS, int numrects, SDL_Rect *rects, struct SDLBase *SDLBase);
+static void CGX_HWScreenUpdate(_THIS, int numrects, SDL_Rect *rects, struct SDLBase *SDLBase);
+#endif
+
+ULONG CGX_MaskToRECTFMT(ULONG A, ULONG R, ULONG G, ULONG B)
+{
+	ULONG GlobMask = AROS_BE2LONG((A & 0x11111111) | (R & 0x22222222) | (G & 0x44444444) | (B & 0x88888888));
+	ULONG rectfmt = 0;
+	
+	switch (GlobMask)
+	{
+		case 0x22448811: rectfmt = RECTFMT_RGBA; 	break;
+		case 0x11224488: rectfmt = RECTFMT_ARGB; 	break;
+		case 0x00000000: rectfmt = RECTFMT_LUT8; 	break;
+		case 0x00002048: rectfmt = RECTFMT_RGB15; 	break;
+		case 0x00000842: rectfmt = RECTFMT_BGR15; 	break;
+		case 0x00004820: rectfmt = RECTFMT_RGB15PC; break;
+		case 0x00004208: rectfmt = RECTFMT_BGR15PC; break;
+		case 0x00002448: rectfmt = RECTFMT_RGB16; 	break;
+		case 0x00008C42: rectfmt = RECTFMT_BGR16; 	break;
+		case 0x00004824: rectfmt = RECTFMT_RGB16PC; break;
+		case 0x0000428C: rectfmt = RECTFMT_BGR16PC; break;
+		case 0x88442211: rectfmt = RECTFMT_BGRA32; 	break;
+		case 0x11884422: rectfmt = RECTFMT_ABGR32; 	break;
+		case 0x00224488: rectfmt = RECTFMT_0RGB32; 	break;
+		case 0x88442200: rectfmt = RECTFMT_BGR032; 	break;
+		case 0x22448800: rectfmt = RECTFMT_RGB032; 	break;
+		case 0x00884422: rectfmt = RECTFMT_0BGR32; 	break;
+		default:         rectfmt = RECTFMT_RAW; 	break;
+//		case 0x00224488: rectfmt = RECTFMT_RGB; 	break;
+//		case 0x00884422: rectfmt = RECTFMT_BGR24; 	break;
+	}
+	
+	return(rectfmt);
+}
+
+#if !defined(PROTO_SDL_H)
+int CGX_SetupImage(_THIS, SDL_Surface *screen)
+#else
+int CGX_SetupImageI(_THIS, SDL_Surface *screen, struct SDLBase *SDLBase)
+#endif
+{
+    SDL_Image = NULL;
+
+	D(bug("CGX_SetupImage\n"));
+	D(bug("BitsPerPixel: %d\n",screen->format->BitsPerPixel));
+	D(bug("BytesPerPixel: %d\n",screen->format->BytesPerPixel));
+	D(bug("Rmask: 0x%08X\n",screen->format->Rmask));
+	D(bug("Gmask: 0x%08X\n",screen->format->Gmask));
+	D(bug("Bmask: 0x%08X\n",screen->format->Bmask));
+	D(bug("Amask: 0x%08X\n",screen->format->Amask));	
+	
+    if(screen->flags & SDL_HWSURFACE)
+	{
+#ifndef NO_AMIGAHWSURF
+        ULONG pitch;
+        APTR pixels;
+        APTR lock;
+
+		if (this->hidden->dbuffer)
+			lock = LockBitMapTags(
+					SDL_RastPort->BitMap,
+					LBMI_BASEADDRESS, (IPTR)&pixels,
+					LBMI_BYTESPERROW, (IPTR)&pitch,
+					TAG_DONE);
+		else
+			lock = LockBitMapTags(
+					this->hidden->BlitBitMap,
+					LBMI_BASEADDRESS, (IPTR)&pixels,
+					LBMI_BYTESPERROW, (IPTR)&pitch,
+					TAG_DONE);
+
+        if (lock)
+		{
+            UnLockBitMap(lock);		
+            if (!screen->hwdata)
+                screen->hwdata = SDL_malloc(sizeof(struct private_hwdata));
+
+            if (screen->hwdata)
+			{
+                screen->hwdata->lock      	= NULL;
+                screen->hwdata->allocated 	= 0;
+                screen->hwdata->mask      	= NULL;
+                screen->hwdata->bmap      	= this->hidden->dbuffer ? SDL_RastPort->BitMap : this->hidden->BlitBitMap;
+				screen->hwdata->update 		= 0;
+                screen->hwdata->videodata 	= this;			
+                screen->pixels 				= pixels; 
+                screen->pitch  				= GetCyberMapAttr(screen->hwdata->bmap, CYBRMATTR_XMOD);;
+				screen->hwdata->pixfmt		= GetCyberMapAttr(screen->hwdata->bmap, CYBRMATTR_PIXFMT);
+				
+				this->UpdateRects			= CGX_HWScreenUpdate;
+				
+                D(bug("HW video image configured (%lx, pitch %ld, pixfmt 0x%08X).\n", screen->pixels, screen->pitch, screen->hwdata->pixfmt));
+				D(bug("Bitmap : %s\n",this->hidden->dbuffer ?"RastPort->BitMap":"BlitBitMap"));
+				
+                return 0;
+            }
+            D(bug("Creating system accel struct FAILED.\n"));
+        }
+#endif
+        D(bug("HW surface not available, falling back to SW surface.\n"));
+
+        screen->flags &= ~SDL_HWSURFACE;
+	}
+
+    screen->hwdata=NULL;
+
+    D(bug("h = %d, pitch = %d\n", screen->h, screen->pitch));
+
+    screen->pixels = SDL_malloc(screen->h*screen->pitch);
+
+    if ( screen->pixels == NULL )
+    {
+        SDL_OutOfMemory();
+        return -1;
+    }
+
+    SDL_Image = screen->pixels;
+
+    if ( SDL_Image == NULL )
+    {
+        SDL_SetError("Couldn't create XImage");
+        return -1;
+    }
+
+    this->UpdateRects = CGX_SWScreenUpdate;
+
+    return 0;
+}
+
+#if !defined(PROTO_SDL_H)
+void CGX_DestroyImage(_THIS, SDL_Surface *screen)
+#else
+void CGX_DestroyImageI(_THIS, SDL_Surface *screen, struct SDLBase *SDLBase)
+#endif
+{
+	if ( SDL_Image ) 
+	{
+		SDL_free(SDL_Image);
+		SDL_Image = NULL;
+	}
+	if ( screen ) 
+	{
+		screen->pixels = NULL;
+
+		if(screen->hwdata) 
+		{
+			SDL_free(screen->hwdata);
+			screen->hwdata=NULL;
+		}
+	}
+}
+
+#if !defined(PROTO_SDL_H)
+int CGX_ResizeImage(_THIS, SDL_Surface *screen, Uint32 flags)
+#else
+int CGX_ResizeImageI(_THIS, SDL_Surface *screen, Uint32 flags, struct SDLBase *SDLBase)
+#endif
+{
+	int retval;
+
+	D(bug("CGX_ResizeImage(%lx,%lx)\n",this,screen));
+
+	CGX_DestroyImage(this, screen);
+
+	if ( flags & SDL_OPENGL ) 
+        retval = 0;			/* No image when using GL */
+	else
+		retval = CGX_SetupImage(this, screen);
+
+	return(retval);
+}
+
+#if !defined(PROTO_SDL_H)
+static void CGX_HWScreenUpdate(_THIS, int numrects, SDL_Rect *rects)
+#else
+static void CGX_HWScreenUpdate(_THIS, int numrects, SDL_Rect *rects, struct SDLBase *SDLBase)
+#endif
+{
+	D(bug("CGX_HWScreenUpdate\n"));
+	CGX_FlipHWSurface(this, this->screen);
+}
+
+#if !defined(PROTO_SDL_H)
+static void CGX_SWScreenUpdate(_THIS, int numrects, SDL_Rect *rects)
+#else
+static void CGX_SWScreenUpdate(_THIS, int numrects, SDL_Rect *rects, struct SDLBase *SDLBase)
+#endif
+{
+	int i,format, dx = 0, dy = 0;
+
+	D(bug("CGX_SWScreenUpdate:\t"));
+	
+	format=CGX_MaskToRECTFMT(	this->screen->format->Amask,
+								this->screen->format->Rmask,
+								this->screen->format->Gmask,
+								this->screen->format->Bmask);
+	D(bug("format = 0x%08X\n", format));
+	
+	if (currently_fullscreen)
+	{
+		// center display on screen
+		dx = (SDL_Display->Width - this->screen->w)/2;
+		dy = (SDL_Display->Height - this->screen->h)/2;
+	}
+	
+	if (format==RECTFMT_LUT8)
+	{
+		for ( i=0; i<numrects; ++i ) {
+			if ( ! rects[i].w ) { /* Clipped? */
+				continue;
+			}
+			WriteLUTPixelArray(	this->screen->pixels,
+								rects[i].x, 
+								rects[i].y,
+								this->screen->pitch,
+								SDL_RastPort,
+								SDL_Pens,
+								SDL_Window->BorderLeft+rects[i].x + dx,
+								SDL_Window->BorderTop+rects[i].y + dy,
+								rects[i].w,
+								rects[i].h,
+								CTABFMT_XRGB8);
+		}
+	}
+	else
+	{
+		for ( i=0; i<numrects; ++i ) {
+			if ( ! rects[i].w ) { /* Clipped? */
+				continue;
+			}
+			WritePixelArray(	this->screen->pixels,
+								rects[i].x,
+								rects[i].y,
+								this->screen->pitch,
+								SDL_RastPort,
+								SDL_Window->BorderLeft+rects[i].x + dx,
+								SDL_Window->BorderTop+rects[i].y + dy,
+								rects[i].w,
+								rects[i].h,
+								format);
+		}
+	}
+}
+
+#if !defined(PROTO_SDL_H)
+void CGX_RefreshDisplay(_THIS)
+#else
+void CGX_RefreshDisplayI(_THIS, struct SDLBase *SDLBase)
+#endif
+{
+	SDL_Rect screenrect;
+	
+	/* Don't refresh a display that doesn't have an image (like GL) */
+	if ( ! SDL_Image ) return;
+
+	screenrect.x = 0;
+	screenrect.y = 0;
+	screenrect.w = this->screen->w;
+	screenrect.h = this->screen->h;
+#if !defined(PROTO_SDL_H)
+	this->UpdateRects(this, 1, &screenrect);
+#else
+	this->UpdateRects(this, 1, &screenrect, SDLBase);
+#endif
+}
diff -Naur SDL-1.2.15-orig/src/video/cgx/SDL_cgximage_c.h SDL-1.2.15/src/video/cgx/SDL_cgximage_c.h
--- SDL-1.2.15-orig/src/video/cgx/SDL_cgximage_c.h	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.15/src/video/cgx/SDL_cgximage_c.h	2015-05-09 15:09:59.767739510 +0200
@@ -0,0 +1,45 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#include "SDL_cgxvideo.h"
+
+extern ULONG CGX_MaskToRECTFMT(ULONG A, ULONG R, ULONG G, ULONG B);
+
+#if !defined(PROTO_SDL_H)
+extern int CGX_SetupImage(_THIS, SDL_Surface *screen);
+extern int CGX_ResizeImage(_THIS, SDL_Surface *screen, Uint32 flags);
+extern void CGX_DestroyImage(_THIS, SDL_Surface *screen);
+extern void CGX_RefreshDisplay(_THIS);
+#else
+#include "SDL_intern.h"
+
+extern int CGX_SetupImageI(_THIS, SDL_Surface *screen, struct SDLBase *SDLBase);
+extern int CGX_ResizeImageI(_THIS, SDL_Surface *screen, Uint32 flags, struct SDLBase *SDLBase);
+extern void CGX_DestroyImageI(_THIS, SDL_Surface *screen, struct SDLBase *SDLBase);
+extern void CGX_RefreshDisplayI(_THIS, struct SDLBase *SDLBase);
+
+#define CGX_SetupImage(this, screen) CGX_SetupImageI(this, screen, SDLBase)
+#define CGX_ResizeImage(this, screen, flags) CGX_ResizeImageI(this, screen, flags, SDLBase)
+#define CGX_DestroyImage(this, screen) CGX_DestroyImageI(this, screen, SDLBase)
+#define CGX_RefreshDisplay(this) CGX_RefreshDisplayI(this, SDLBase)
+#endif
diff -Naur SDL-1.2.15-orig/src/video/cgx/SDL_cgxmodes.c SDL-1.2.15/src/video/cgx/SDL_cgxmodes.c
--- SDL-1.2.15-orig/src/video/cgx/SDL_cgxmodes.c	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.15/src/video/cgx/SDL_cgxmodes.c	2015-05-09 15:09:59.768739508 +0200
@@ -0,0 +1,236 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
+#include "SDL_config.h"
+
+#define DEBUG 1
+#include <aros/debug.h>
+
+#include "SDL_timer.h"
+#include "SDL_events.h"
+#include "../../events/SDL_events_c.h"
+#include "SDL_cgxvideo.h"
+#include "SDL_cgxwm_c.h"
+#include "SDL_cgxmouse_c.h"
+#include "SDL_cgxmodes_c.h"
+
+#if defined(PROTO_SDL_H)
+#include "SDL_intern.h"
+#endif
+
+static void add_visual(_THIS, int depth, int class)
+{
+	Uint32 tID;
+
+	tID=BestCModeIDTags(CYBRBIDTG_Depth,depth,
+						CYBRBIDTG_NominalWidth,640,
+						CYBRBIDTG_NominalHeight,480,
+						TAG_DONE);
+
+	if(tID!=INVALID_ID)
+	{
+		int n = this->hidden->nvisuals;
+
+		this->hidden->visuals[n].depth = depth;
+		this->hidden->visuals[n].visual = tID;
+		this->hidden->visuals[n].bpp = GetCyberIDAttr(CYBRIDATTR_BPPIX,tID) * 8;
+		this->hidden->nvisuals++;
+	}
+}
+
+#define TrueColor 1
+#define PseudoColor 2
+
+#if !defined(PROTO_SDL_H)
+int CGX_GetVideoModes(_THIS)
+#else
+int CGX_GetVideoModesI(_THIS, struct SDLBase *SDLBase)
+#endif
+{
+    int i;
+	ULONG nextid;
+	int nmodes=0;
+
+	D(bug("CGX_GetVideoModes()\n"));
+
+	SDL_modelist=NULL;
+
+	nextid=NextDisplayInfo(INVALID_ID);
+
+	while(nextid!=INVALID_ID)
+	{
+		if(IsCyberModeID(nextid))
+		{
+			DisplayInfoHandle h;
+
+			if((h = FindDisplayInfo(nextid)) != 0)
+			{
+				struct DimensionInfo info;
+
+				/* ULONG GetDisplayInfoData( CONST DisplayInfoHandle handle, APTR buf, ULONG size, ULONG tagID, ULONG displayID ); */
+				if(GetDisplayInfoData(h,(char *)&info,(ULONG)sizeof(struct DimensionInfo),(ULONG)DTAG_DIMS,(IPTR)NULL))
+				{
+					int ok=0;
+
+					for(i=0;i<nmodes;i++)
+					{
+						if(	SDL_modelist[i]->w == (info.Nominal.MaxX+1) &&
+							SDL_modelist[i]->h == (info.Nominal.MaxY+1) )
+							ok=1;
+					}
+
+					if(!ok)
+					{
+						nmodes++;
+
+						SDL_modelist = (SDL_Rect **)SDL_realloc(SDL_modelist,(nmodes+1)*sizeof(SDL_Rect *));
+						SDL_modelist[nmodes]=NULL;
+
+						if ( SDL_modelist )
+						{
+							SDL_modelist[nmodes-1] = (SDL_Rect *)SDL_malloc(sizeof(SDL_Rect));
+
+							if ( SDL_modelist[nmodes-1] == NULL )
+								break;
+
+							SDL_modelist[nmodes-1]->x = 0;
+							SDL_modelist[nmodes-1]->y = 0;
+							SDL_modelist[nmodes-1]->w = info.Nominal.MaxX+1;
+							SDL_modelist[nmodes-1]->h = info.Nominal.MaxY+1;
+						}
+					}
+				}
+			}
+		}
+		nextid=NextDisplayInfo(nextid);
+	}
+
+
+	this->hidden->nvisuals = 0;
+	/* Search for the visuals in deepest-first order, so that the first
+	   will be the richest one */
+	add_visual(this, 32, TrueColor);
+	add_visual(this, 24, TrueColor);
+	add_visual(this, 16, TrueColor);
+	add_visual(this, 15, TrueColor);
+	add_visual(this, 8, PseudoColor);
+
+	if(this->hidden->nvisuals == 0) 
+	{
+	    SDL_SetError("Found no sufficiently capable CGX visuals");
+		return -1;
+	}
+
+    if ( SDL_modelist == NULL ) 
+	{
+        SDL_modelist = (SDL_Rect **)SDL_malloc((1+1)*sizeof(SDL_Rect *));
+        i = 0;
+        if ( SDL_modelist ) 
+		{
+            SDL_modelist[i] = (SDL_Rect *)SDL_malloc(sizeof(SDL_Rect));
+            if ( SDL_modelist[i] ) 
+			{
+                SDL_modelist[i]->x = 0;
+                SDL_modelist[i]->y = 0;
+                SDL_modelist[i]->w = SDL_Display->Width;
+                SDL_modelist[i]->h = SDL_Display->Height;
+                ++i;
+            }
+            SDL_modelist[i] = NULL;
+        }
+    }
+
+    D( 
+		if ( SDL_modelist ) 
+		{
+			bug("CGX video mode list: (%ld)\n",nmodes);
+			for ( i=0; SDL_modelist[i]; ++i )
+			{
+				bug( "\t%ld x %ld\n",
+					SDL_modelist[i]->w, SDL_modelist[i]->h);
+			}
+		}
+
+		bug("CGX visuals list: (%ld)\n",this->hidden->nvisuals);
+
+		for(i=0;i<this->hidden->nvisuals;i++)
+			bug("\t%lx - depth: %ld bpp: %ld\n",this->hidden->visuals[i].visual,this->hidden->visuals[i].depth,this->hidden->visuals[i].bpp);
+    );
+	
+    return 0;
+}
+
+#if !defined(PROTO_SDL_H)
+static int CGX_SupportedVisual(_THIS, SDL_PixelFormat *format)
+#else
+#define CGX_SupportedVisual(this, format) CGX_SupportedVisualI(this, format, SDLBase)
+static int CGX_SupportedVisualI(_THIS, SDL_PixelFormat *format, struct SDLBase *SDLBase)
+#endif
+{
+    int i;
+    for(i = 0; i < this->hidden->nvisuals; i++)
+	{
+		if(this->hidden->visuals[i].depth == format->BitsPerPixel || this->hidden->visuals[i].bpp == format->BitsPerPixel) // Era bpp
+		    return 1;
+	}
+    return 0;
+}
+
+#if !defined(PROTO_SDL_H)
+SDL_Rect **CGX_ListModes(_THIS, SDL_PixelFormat *format, Uint32 flags)
+#else
+SDL_Rect **CGX_ListModesI(_THIS, SDL_PixelFormat *format, Uint32 flags, struct SDLBase *SDLBase)
+#endif
+{
+    if ( CGX_SupportedVisual(this, format) )
+	{
+        if ( flags & SDL_FULLSCREEN )
+            return(SDL_modelist);
+        else
+            return((SDL_Rect **)-1);
+    } 
+	else
+        return((SDL_Rect **)0);
+}
+
+#if !defined(PROTO_SDL_H)
+void CGX_FreeVideoModes(_THIS)
+#else
+void CGX_FreeVideoModesI(_THIS, struct SDLBase *SDLBase)
+#endif
+{
+    int i;
+
+    if ( SDL_modelist )
+	{
+        for ( i=0; SDL_modelist[i]; ++i )
+		{
+            SDL_free(SDL_modelist[i]);
+        }
+        SDL_free(SDL_modelist);
+        SDL_modelist = NULL;
+    }
+}
diff -Naur SDL-1.2.15-orig/src/video/cgx/SDL_cgxmodes_c.h SDL-1.2.15/src/video/cgx/SDL_cgxmodes_c.h
--- SDL-1.2.15-orig/src/video/cgx/SDL_cgxmodes_c.h	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.15/src/video/cgx/SDL_cgxmodes_c.h	2015-05-09 15:09:59.768739508 +0200
@@ -0,0 +1,47 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+/* Utilities for getting and setting the X display mode */
+
+#include "SDL_cgxvideo.h"
+
+#if !defined(PROTO_SDL_H)
+extern int CGX_GetVideoModes(_THIS);
+extern SDL_Rect **CGX_ListModes(_THIS, SDL_PixelFormat *format, Uint32 flags);
+extern void CGX_FreeVideoModes(_THIS);
+/*
+extern void CGX_WaitMapped(_THIS, Window win);
+extern void CGX_WaitUnmapped(_THIS, Window win);
+extern void CGX_QueueEnterFullScreen(_THIS);
+*/
+#else
+#include "SDL_intern.h"
+
+extern int CGX_GetVideoModesI(_THIS, struct SDLBase *SDLBase);
+extern SDL_Rect **CGX_ListModesI(_THIS, SDL_PixelFormat *format, Uint32 flags, struct SDLBase *SDLBase);
+extern void CGX_FreeVideoModesI(_THIS, struct SDLBase *SDLBase);
+
+#define CGX_GetVideoModes(this) CGX_GetVideoModesI(this, SDLBase)
+#define CGX_ListModes(this, format, flags) CGX_ListModesI(this, format, flags, SDLBase)
+#define CGX_FreeVideoModes(this) CGX_FreeVideoModesI(this, SDLBase)
+#endif
diff -Naur SDL-1.2.15-orig/src/video/cgx/SDL_cgxmouse.c SDL-1.2.15/src/video/cgx/SDL_cgxmouse.c
--- SDL-1.2.15-orig/src/video/cgx/SDL_cgxmouse.c	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.15/src/video/cgx/SDL_cgxmouse.c	2015-05-09 15:09:59.768739508 +0200
@@ -0,0 +1,266 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
+#include "SDL_config.h"
+
+#include <devices/input.h>
+#include <intuition/pointerclass.h>
+
+#include "SDL_mouse.h"
+#include "../../events/SDL_events_c.h"
+#include "../SDL_pixels_c.h"
+#include "../SDL_cursor_c.h"
+#include "SDL_cgxmouse_c.h"
+
+struct WMcursor
+{
+	struct	BitMap *CursorBM;
+	Object	*PointerObj;
+};
+
+#if !defined(PROTO_SDL_H)
+void CGX_FreeWMCursor(_THIS, WMcursor *cursor)
+#else
+void CGX_FreeWMCursor(_THIS, WMcursor *cursor, struct SDLBase *SDLBase)
+#endif
+{
+	D(bug("[SDL] CGX_FreeWMCursor()\n"));
+
+	if (cursor)
+	{
+		if (SDL_Window)
+			ClearPointer(SDL_Window);
+
+		if (cursor->CursorBM)
+			FreeBitMap(cursor->CursorBM);
+
+		if(cursor->PointerObj) 
+			DisposeObject(cursor->PointerObj);
+			
+		free(cursor);
+	}
+}
+
+#if !defined(PROTO_SDL_H)
+WMcursor *CGX_CreateWMCursor(_THIS, Uint8 *data, Uint8 *mask, int w, int h, int hot_x, int hot_y)
+#else
+WMcursor *CGX_CreateWMCursor(_THIS, Uint8 *data, Uint8 *mask, int w, int h, int hot_x, int hot_y, struct SDLBase *SDLBase)
+#endif
+{
+	struct WMcursor *cursor = NULL;
+	struct RastPort *CursorRP = NULL;
+	ULONG  *pixarray = NULL;
+	ULONG  pixel_cnt;
+	char   currentbit = 7, currentdata, currentmask;
+	
+	cursor = malloc(sizeof(*cursor));
+	CursorRP = CreateRastPort();
+	pixarray = AllocVec(w*h*4,MEMF_ANY);
+	
+	if (cursor && CursorRP && pixarray)
+	{
+		// Allocate Cursor BitMap
+		// TODO: check if it's OK to use NULL for friend bitmap in case SDL_Window is NULL
+		cursor->CursorBM = AllocBitMap(w,h,32,BMF_MINPLANES | BMF_SPECIALFMT | (PIXFMT_RGBA32 << 24),
+					       SDL_Window ? SDL_Window->RPort->BitMap : NULL);
+		
+		if (cursor->CursorBM)
+		{
+			// Create pixarray from data and mask
+			for (pixel_cnt = 0; pixel_cnt < w*h; pixel_cnt++)
+			{
+				currentdata = ((*data >> currentbit) & 0x01);
+				currentmask = ((*mask >> currentbit) & 0x01);
+				if (currentbit == 0)
+				{
+					data++;
+					mask++;
+					currentbit = 7;
+				}
+				else
+				{
+					currentbit--;
+				}
+				
+				switch(currentdata * 2 + currentmask)
+				{
+					case 0: //(0,0) => Transparent
+						pixarray[pixel_cnt] = AROS_BE2LONG(0x00000000);
+						break;
+					case 1: //(0,1) => White
+						pixarray[pixel_cnt] = AROS_BE2LONG(0xFFFFFFFF);
+						break;
+					case 2: //(1,0) => Inverted color if possible, black if not (Semi transparent here AROS)
+						pixarray[pixel_cnt] = AROS_BE2LONG(0x0000007F);
+						break;
+					case 3: //(1,1) => Black
+						pixarray[pixel_cnt] = AROS_BE2LONG(0x000000FF);
+						break;
+				}
+			}
+			
+			// Copy pixel array into bitmap
+			CursorRP->BitMap = cursor->CursorBM;
+			WritePixelArray( pixarray,
+							 0, 0, w * 4,
+							 CursorRP,
+							 0, 0, w, h,
+							 RECTFMT_RGBA32 );
+			
+			// Create Pointer Object
+			cursor->PointerObj = (Object *)NewObject(NULL,	
+													(STRPTR)"pointerclass",
+													POINTERA_BitMap,      (IPTR)cursor->CursorBM,
+													POINTERA_XOffset,     (IPTR)(-hot_x),
+													POINTERA_YOffset,     (IPTR)(-hot_y),
+													TAG_DONE);
+													
+			if (!cursor->PointerObj)
+			{
+				FreeBitMap(cursor->CursorBM);
+				free(cursor);
+				cursor = NULL;
+			}
+		}
+		else
+		{
+			free(cursor);
+			cursor = NULL;
+		}
+	}
+	
+	if (pixarray) FreeVec(pixarray);
+	if (CursorRP) FreeRastPort(CursorRP);
+
+	D(bug("[SDL] CGX_CreateWMCursor() (size %ld/%ld) -> 0x%08.8lx\n", w, h, (IPTR)cursor));
+
+	return cursor;
+}
+
+#if !defined(PROTO_SDL_H)
+int CGX_ShowWMCursor(_THIS, WMcursor *cursor)
+#else
+int CGX_ShowWMCursorI(_THIS, WMcursor *cursor, struct SDLBase *SDLBase)
+#endif
+{
+	/* Don't do anything if the display is gone */
+	if ( SDL_Display == NULL)
+	{
+		this->hidden->CursorVisible = 0;
+		return(0);
+	}
+
+	/* Set the cursor, or blank if cursor is NULL */
+	if ( SDL_Window )
+	{
+		SDL_Lock_EventThread();
+		if ( cursor == NULL )
+		{
+			if ( SDL_BlankCursor != NULL )
+			{
+				// Hide cursor HERE
+				SetPointer(SDL_Window,(UWORD *)SDL_BlankCursor,1,1,0,0);
+			}
+			this->hidden->CursorVisible = 0;
+		}
+		else
+		{
+			// Show cursor
+			SetWindowPointer( SDL_Window,
+							  WA_Pointer, (APTR)cursor->PointerObj,
+							  TAG_DONE );
+			this->hidden->CursorVisible = 1;
+        }
+		SDL_Unlock_EventThread();
+	}
+	return(1);
+}
+
+#if !defined(PROTO_SDL_H)
+void CGX_WarpWMCursor(_THIS, Uint16 x, Uint16 y)
+#else
+void CGX_WarpWMCursorI(_THIS, Uint16 x, Uint16 y, struct SDLBase *SDLBase)
+#endif
+{
+	struct IOStdReq *req;
+	struct MsgPort *port;
+
+	D(bug("[SDL] CGX_WarpWMCursor(%ld, %ld)\n", x, y));
+
+	SDL_Lock_EventThread();
+
+	port = CreateMsgPort();
+	req  = (struct IOStdReq *)CreateIORequest(port, sizeof(*req));
+
+	if (req)
+	{
+		if (OpenDevice("input.device", 0, (struct IORequest *)req, 0) == 0)
+		{
+			struct InputEvent *ie;
+			struct IEPointerPixel *newpos;
+
+			if ((ie = malloc(sizeof(*ie) + sizeof(*newpos))))
+			{
+				newpos = (struct IEPointerPixel *)(ie + 1);
+
+				newpos->iepp_Screen = SDL_Display;
+				newpos->iepp_Position.X = x + SDL_Window->BorderLeft + SDL_Window->LeftEdge;
+				newpos->iepp_Position.Y = y + SDL_Window->BorderTop + SDL_Window->TopEdge;
+
+				ie->ie_EventAddress = newpos;
+				ie->ie_NextEvent    = NULL;
+				ie->ie_Class        = IECLASS_NEWPOINTERPOS;
+				ie->ie_SubClass     = IESUBCLASS_PIXEL;
+				ie->ie_Code         = IECODE_NOBUTTON;
+				ie->ie_Qualifier    = 0;
+
+				req->io_Data    = ie;
+				req->io_Length  = sizeof(*ie);
+				req->io_Command = IND_WRITEEVENT;
+
+				DoIO((struct IORequest *)req);
+				free(ie);
+			}
+			CloseDevice((struct IORequest *)req);
+		}
+	}
+	DeleteIORequest((struct IORequest *)req);
+	DeleteMsgPort(port);
+	
+	SDL_Unlock_EventThread();
+
+}
+
+
+#if !defined(PROTO_SDL_H)
+void CGX_CheckMouseMode(_THIS)
+#else
+void CGX_CheckMouseMode(_THIS, struct SDLBase *SDLBase)
+#endif
+{
+	/* Check to see if we need to enter or leave mouse relative mode */
+	/* under AROS the mouse mode is always absolute => nothing to be done*/
+}
diff -Naur SDL-1.2.15-orig/src/video/cgx/SDL_cgxmouse_c.h SDL-1.2.15/src/video/cgx/SDL_cgxmouse_c.h
--- SDL-1.2.15-orig/src/video/cgx/SDL_cgxmouse_c.h	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.15/src/video/cgx/SDL_cgxmouse_c.h	2015-05-09 15:09:59.768739508 +0200
@@ -0,0 +1,44 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#include "SDL_cgxvideo.h"
+
+/* Functions to be exported */
+#if !defined(PROTO_SDL_H)
+extern void 		CGX_FreeWMCursor(_THIS, WMcursor *cursor);
+extern WMcursor*	CGX_CreateWMCursor(_THIS, Uint8 *data, Uint8 *mask, int w, int h, int hot_x, int hot_y);
+extern void 		CGX_CheckMouseMode(_THIS);
+
+extern int 			CGX_ShowWMCursor(_THIS, WMcursor *cursor);
+extern void 		CGX_WarpWMCursor(_THIS, Uint16 x, Uint16 y);
+#else
+extern void 		CGX_FreeWMCursor(_THIS, WMcursor *cursor, struct SDLBase *SDLBase);
+extern WMcursor*	CGX_CreateWMCursor(_THIS, Uint8 *data, Uint8 *mask, int w, int h, int hot_x, int hot_y, struct SDLBase *SDLBase);
+extern void 		CGX_CheckMouseMode(_THIS, struct SDLBase *SDLBase);
+
+extern int 			CGX_ShowWMCursorI(_THIS, WMcursor *cursor, struct SDLBase *SDLBase);
+extern void 		CGX_WarpWMCursorI(_THIS, Uint16 x, Uint16 y, struct SDLBase *SDLBase);
+
+#define CGX_ShowWMCursor(this, cursor) CGX_ShowWMCursorI(this, cursor, SDLBase)
+#define CGX_WarpWMCursor(this, x, y) CGX_WarpWMCursorI(this, x, y, SDLBase)
+#endif
diff -Naur SDL-1.2.15-orig/src/video/cgx/SDL_cgxvideo.c SDL-1.2.15/src/video/cgx/SDL_cgxvideo.c
--- SDL-1.2.15-orig/src/video/cgx/SDL_cgxvideo.c	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.15/src/video/cgx/SDL_cgxvideo.c	2015-05-09 15:09:59.769739506 +0200
@@ -0,0 +1,1518 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+    Copyright (C) 2011-2016 AROS Development Team
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#define DEBUG 1
+#include <aros/debug.h>
+
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
+#include "SDL_config.h"
+
+/*
+ * CGX based SDL video driver implementation by Gabriele Greco
+ * gabriele.greco@aruba.it
+ */
+
+#include "SDL_endian.h"
+#include "SDL_timer.h"
+#include "SDL_thread.h"
+#include "SDL_video.h"
+#include "SDL_mouse.h"
+#include "../SDL_sysvideo.h"
+#include "../SDL_pixels_c.h"
+#include "../../events/SDL_events_c.h"
+#include "SDL_cgxgl_c.h"
+#include "SDL_cgxvideo.h"
+#include "SDL_cgxwm_c.h"
+#include "SDL_cgxmouse_c.h"
+#include "SDL_cgxevents_c.h"
+#include "SDL_cgxmodes_c.h"
+#include "SDL_cgximage_c.h"
+#include "SDL_cgxaccel_c.h"
+
+#if defined(PROTO_SDL_H)
+#include "SDL_intern.h"
+
+#define current_video SDLBase->current_video
+#endif
+
+/* This is a special flag that tells video mode change code to not to drop existing
+	GL context. */
+#define SDL_KEEP_GL_CONTEXT	0x00100000
+
+#if !defined(PROTO_SDL_H)
+static SDL_VideoDevice *CGX_CreateDevice(int devindex);
+static SDL_Surface *CGX_SetVideoMode(_THIS, SDL_Surface *current, int width, int height, int bpp, Uint32 flags);
+static int CGX_ToggleFullScreen(_THIS, int on);
+static void CGX_UpdateMouse(_THIS);
+/* Initialization/Query functions */
+static int 			CGX_VideoInit(_THIS, SDL_PixelFormat *vformat);
+static int 			CGX_SetColors(_THIS, int firstcolor, int ncolors, SDL_Color *colors);
+static void 		CGX_VideoQuit(_THIS);
+
+/* Gamma correction functions */
+static int CGX_SetGamma(_THIS, float red, float green, float blue);
+static int CGX_GetGamma(_THIS, float *red, float *green, float *blue);
+static int CGX_SetGammaRamp(_THIS, Uint16 *ramp);
+static int CGX_GetGammaRamp(_THIS, Uint16 *ramp);
+
+/* CGX driver bootstrap functions */
+static int 				CGX_Available(void);
+static void 			CGX_DeleteDevice(SDL_VideoDevice *device);
+#else
+static SDL_VideoDevice *CGX_CreateDeviceI(int devindex, struct SDLBase *SDLBase);
+static SDL_Surface *CGX_SetVideoModeI(_THIS, SDL_Surface *current, int width, int height, int bpp, Uint32 flags, struct SDLBase *SDLBase);
+static int CGX_ToggleFullScreenI(_THIS, int on, struct SDLBase *SDLBase);
+static void CGX_UpdateMouseI(_THIS, struct SDLBase *SDLBase);
+static int CGX_VideoInitI(_THIS, SDL_PixelFormat *vformat, struct SDLBase *SDLBase);
+static int CGX_SetColorsI(_THIS, int firstcolor, int ncolors, SDL_Color *colors, struct SDLBase *SDLBase);
+static void CGX_VideoQuitI(_THIS, struct SDLBase *SDLBase);
+static int CGX_SetGammaI(_THIS, float red, float green, float blue, struct SDLBase *SDLBase);
+static int CGX_GetGammaI(_THIS, float *red, float *green, float *blue, struct SDLBase *SDLBase);
+static int CGX_SetGammaRampI(_THIS, Uint16 *ramp, struct SDLBase *SDLBase);
+static int CGX_GetGammaRampI(_THIS, Uint16 *ramp, struct SDLBase *SDLBase);
+static int CGX_AvailableI(struct SDLBase *SDLBase);
+static void CGX_DeleteDeviceI(SDL_VideoDevice *device, struct SDLBase *SDLBase);
+
+#ifdef CGX_ShowWMCursor
+#undef CGX_ShowWMCursor
+#endif
+#define CGX_ShowWMCursor CGX_ShowWMCursorI
+#ifdef CGX_WarpWMCursor
+#undef CGX_WarpWMCursor
+#endif
+#define CGX_WarpWMCursor CGX_WarpWMCursorI
+
+#ifdef CGX_SetIcon
+#undef CGX_SetIcon
+#endif
+#define CGX_SetIcon CGX_SetIconI
+#ifdef CGX_SetCaption
+#undef CGX_SetCaption
+#endif
+#define CGX_SetCaption CGX_SetCaptionI
+#ifdef CGX_IconifyWindow
+#undef CGX_IconifyWindow
+#endif
+#define CGX_IconifyWindow CGX_IconifyWindowI
+#ifdef CGX_GrabWMInput
+#undef CGX_GrabWMInput
+#endif
+#define CGX_GrabWMInput CGX_GrabWMInputI
+#ifdef CGX_GetWMInfo
+#undef CGX_GetWMInfo
+#endif
+#define CGX_GetWMInfo CGX_GetWMInfoI
+
+#ifdef CGX_ListModes
+#undef CGX_ListModes
+#endif
+#define CGX_ListModes CGX_ListModesI
+#ifdef CGX_AllocHWSurface
+#undef CGX_AllocHWSurface
+#endif
+#define CGX_AllocHWSurface CGX_AllocHWSurfaceI
+#ifdef CGX_CheckHWBlit
+#undef CGX_CheckHWBlit
+#endif
+#define CGX_CheckHWBlit CGX_CheckHWBlitI
+#ifdef CGX_SetHWColorKey
+#undef CGX_SetHWColorKey
+#endif
+#define CGX_SetHWColorKey CGX_SetHWColorKeyI
+#ifdef CGX_FillHWRect
+#undef CGX_FillHWRect
+#endif
+#define CGX_FillHWRect CGX_FillHWRectI
+#ifdef CGX_LockHWSurface
+#undef CGX_LockHWSurface
+#endif
+#define CGX_LockHWSurface CGX_LockHWSurfaceI
+#ifdef CGX_UnlockHWSurface
+#undef CGX_UnlockHWSurface
+#endif
+#define CGX_UnlockHWSurface CGX_UnlockHWSurfaceI
+#ifdef CGX_FlipHWSurface
+#undef CGX_FlipHWSurface
+#endif
+#define CGX_FlipHWSurface CGX_FlipHWSurfaceI
+#ifdef CGX_FreeHWSurface
+#undef CGX_FreeHWSurface
+#endif
+#define CGX_FreeHWSurface CGX_FreeHWSurfaceI
+#ifdef CGX_GL_LoadLibrary
+#undef CGX_GL_LoadLibrary
+#endif
+#define CGX_GL_LoadLibrary CGX_GL_LoadLibraryI
+#ifdef CGX_GL_GetProcAddress
+#undef CGX_GL_GetProcAddress
+#endif
+#define CGX_GL_GetProcAddress CGX_GL_GetProcAddressI
+#ifdef CGX_GL_GetAttribute
+#undef CGX_GL_GetAttribute
+#endif
+#define CGX_GL_GetAttribute CGX_GL_GetAttributeI
+#ifdef CGX_GL_MakeCurrent
+#undef CGX_GL_MakeCurrent
+#endif
+#define CGX_GL_MakeCurrent CGX_GL_MakeCurrentI
+#ifdef CGX_GL_SwapBuffers
+#undef CGX_GL_SwapBuffers
+#endif
+#define CGX_GL_SwapBuffers CGX_GL_SwapBuffersI
+
+#define CGX_CreateDevice CGX_CreateDeviceI
+#define CGX_SetVideoMode CGX_SetVideoModeI
+#define CGX_ToggleFullScreen CGX_ToggleFullScreenI
+#define CGX_UpdateMouse CGX_UpdateMouseI
+#define CGX_VideoInit CGX_VideoInitI
+#define CGX_SetColors CGX_SetColorsI
+#define CGX_VideoQuit CGX_VideoQuitI
+#define CGX_SetGamma CGX_SetGammaI
+#define CGX_GetGamma CGX_GetGammaI
+#define CGX_SetGammaRamp CGX_SetGammaRampI
+#define CGX_GetGammaRamp CGX_GetGammaRampI
+#define CGX_Available CGX_AvailableI
+#define CGX_DeleteDevice(device) CGX_DeleteDeviceI(device, SDLBase)
+#endif
+
+static const char cgxVidName[] = "CGX";
+
+/* Bootstrap */
+VideoBootStrap CGX_bootstrap = {
+    cgxVidName, "AROS CyberGraphics",
+    CGX_Available, CGX_CreateDevice
+};
+
+
+#if !defined(PROTO_SDL_H)
+static SDL_VideoDevice *CGX_CreateDevice(int devindex)
+#else
+
+#ifdef CGX_CreateDevice
+#undef CGX_CreateDevice
+#endif
+#ifdef CGX_Available
+#undef CGX_Available
+#endif
+#define CGX_CreateDevice(devindex) CGX_CreateDeviceI(devindex, SDLBase)
+#define CGX_Available() CGX_AvailableI(SDLBase)
+
+static SDL_VideoDevice *CGX_CreateDeviceI(int devindex, struct SDLBase *SDLBase)
+#endif
+{
+	SDL_VideoDevice *device;
+
+	/* Initialize all variables that we clean on shutdown */
+	device = (SDL_VideoDevice *)SDL_malloc(sizeof(SDL_VideoDevice));
+	
+	if ( device )
+	{
+		SDL_memset(device, 0, (sizeof *device));
+		device->hidden = (struct SDL_PrivateVideoData *)SDL_malloc((sizeof *device->hidden));
+		device->gl_data = (struct SDL_PrivateGLData *)SDL_malloc((sizeof *device->gl_data));
+	}
+	
+	if ( (device == NULL) || (device->hidden == NULL) || (device->gl_data == NULL) )
+	{
+		D(bug("Unable to create video device!\n"));
+		SDL_OutOfMemory();
+		CGX_DeleteDevice(device);
+		return(0);
+	}
+	
+	SDL_memset(device->hidden, 0, sizeof(*device->hidden));
+	SDL_memset(device->gl_data, 0, sizeof(*device->gl_data));
+
+	/* Set the driver flags */
+	device->handles_any_size	= 1;
+
+#if defined(PROTO_SDL_H)
+#ifdef CGX_DeleteDevice
+#undef CGX_DeleteDevice
+#endif
+#define CGX_DeleteDevice CGX_DeleteDeviceI
+#endif
+
+	/* Set the function pointers */
+	/* SDL_cgxvideo.c */
+	device->VideoInit			= CGX_VideoInit;
+	device->ListModes			= CGX_ListModes;
+	device->SetVideoMode 		= CGX_SetVideoMode;
+	device->ToggleFullScreen 	= CGX_ToggleFullScreen;
+	device->UpdateMouse 		= CGX_UpdateMouse;
+	device->SetColors 			= CGX_SetColors;
+	device->UpdateRects 		= NULL;
+	device->VideoQuit 			= CGX_VideoQuit;
+	device->free 				= CGX_DeleteDevice;
+	device->SetGamma 			= CGX_SetGamma;
+	device->GetGamma 			= CGX_GetGamma;
+	device->SetGammaRamp 		= CGX_SetGammaRamp;
+	device->GetGammaRamp 		= CGX_GetGammaRamp;
+	/* SDL_cgxaccel.c */
+	device->AllocHWSurface 		= CGX_AllocHWSurface;
+#ifndef NO_AMIGAHWSURF
+	device->CheckHWBlit 		= CGX_CheckHWBlit;
+	device->SetHWColorKey 		= CGX_SetHWColorKey;
+#else
+	device->CheckHWBlit 		= NULL;
+	device->SetHWColorKey 		= NULL;
+#endif
+	device->FillHWRect 			= CGX_FillHWRect;
+	device->SetHWAlpha 			= NULL;
+	device->LockHWSurface 		= CGX_LockHWSurface;
+	device->UnlockHWSurface 	= CGX_UnlockHWSurface;
+	device->FlipHWSurface 		= CGX_FlipHWSurface;
+	device->FreeHWSurface 		= CGX_FreeHWSurface;
+	/* SDL_cgxwm.c */
+	device->SetIcon 			= CGX_SetIcon;
+	device->SetCaption 			= CGX_SetCaption;
+	device->IconifyWindow 		= CGX_IconifyWindow;
+	device->GrabInput 			= CGX_GrabWMInput;
+	device->GetWMInfo 			= CGX_GetWMInfo;
+	device->FreeWMCursor 		= CGX_FreeWMCursor;
+	device->CreateWMCursor 		= CGX_CreateWMCursor;
+	device->ShowWMCursor 		= CGX_ShowWMCursor;
+	device->WarpWMCursor 		= CGX_WarpWMCursor;
+	device->CheckMouseMode 		= CGX_CheckMouseMode;
+	/* SDL_cgxevents.c */
+	device->InitOSKeymap 		= CGX_InitOSKeymap;
+	device->PumpEvents 			= CGX_PumpEvents;
+#if SDL_VIDEO_OPENGL
+	/* SDL_cgxgl.c */
+	device->GL_LoadLibrary 		= CGX_GL_LoadLibrary;
+	device->GL_GetProcAddress 	= CGX_GL_GetProcAddress;
+	device->GL_GetAttribute 	= CGX_GL_GetAttribute;
+	device->GL_MakeCurrent 		= CGX_GL_MakeCurrent;
+	device->GL_SwapBuffers 		= CGX_GL_SwapBuffers;
+#endif
+
+	return device;
+}
+
+/*
+
+#define CGX_VideoInit(this, vformat) CGX_VideoInitI(this, vformat, SDLBase)
+#define CGX_SetColors(this, firstcolor, ncolors, colors) CGX_SetColorsI(this, firstcolor, ncolors, colors, SDLBase)
+#define CGX_VideoQuit(this) CGX_VideoQuitI(this, SDLBase)
+#define CGX_SetGamma(this, red, green, blue) CGX_SetGammaI(this, red, green, blue, SDLBase)
+#define CGX_GetGamma(this, red, green, blue) CGX_GetGammaI(this, red, green, blue, SDLBase)
+#define CGX_SetGammaRamp(this, ramp) CGX_SetGammaRampI(this, ramp, SDLBase)
+#define CGX_GetGammaRamp(this, ramp) CGX_GetGammaRampI(this, ramp, SDLBase)
+#define CGX_DeleteDevice(device) CGX_DeleteDeviceI(device, SDLBase)
+
+*/
+#if !defined(PROTO_SDL_H)
+static Uint32 CGX_OpenCustomScreen(_THIS, SDL_Surface *screen, int width, int height, int bpp, Uint32 flags)
+#else
+#define CGX_OpenCustomScreen(this, screen, width, height, bpp, flags) CGX_OpenCustomScreenI(this, screen, width, height, bpp, flags, SDLBase)
+static Uint32 CGX_OpenCustomScreenI(_THIS, SDL_Surface *screen, int width, int height, int bpp, Uint32 flags, struct SDLBase *SDLBase)
+#endif
+{
+	Uint32 okid;
+
+	this->hidden->dbuffer = 0;
+	
+	/* This function expects that GFX_Display is not set */
+	if (GFX_Display) {
+		D(bug("CGX_OpenCustomScreen called with GFX_Display still set\n"));
+		SDL_SetError("CGX_OpenCustomScreen called with GFX_Display still set");
+		flags &= ~SDL_FULLSCREEN;
+		flags &= ~SDL_DOUBLEBUF;
+		return flags;
+	}
+
+	okid = BestCModeIDTags(CYBRBIDTG_NominalWidth, width,
+								CYBRBIDTG_NominalHeight, height,
+								CYBRBIDTG_Depth, bpp,
+								TAG_DONE);
+								
+	if ((okid == INVALID_ID) && (bpp == 32))
+	{
+		D(bug("Failed to open a 32bits screen trying 24bits instead\n"));
+		bpp = 24;
+		okid = BestCModeIDTags(CYBRBIDTG_NominalWidth, width,
+									CYBRBIDTG_NominalHeight, height,
+									CYBRBIDTG_Depth, bpp,
+									TAG_DONE);				
+	}
+
+	D(bug("Opening screen %dx%d/%d (id:%lx)...\n", width, height, bpp, okid));
+
+	if(okid != INVALID_ID)
+		GFX_Display = OpenScreenTags(NULL,
+									SA_Width,width,
+									SA_Height,height,
+									SA_Quiet,TRUE,
+									SA_ShowTitle,FALSE,
+									SA_Depth,bpp,
+									SA_DisplayID,okid,
+									TAG_DONE);
+
+	if (!GFX_Display)
+	{
+		D(bug("OpenScreenTags failed!\n"));
+		flags &= ~SDL_FULLSCREEN;
+		flags &= ~SDL_DOUBLEBUF;
+	}
+	else
+	{
+		SDL_Display = GFX_Display;
+
+		D(bug("Screen opened: %d x %d.\n", GFX_Display->Width, GFX_Display->Height));
+
+		if(flags & SDL_DOUBLEBUF)
+		{
+#ifndef NO_AMIGAHWSURF
+			APTR lock = NULL;
+			/* check if surface can be locked, if not => Surface is SW and there is no double buffering!*/
+			lock = LockBitMapTags(	SDL_Display->RastPort.BitMap,
+									TAG_DONE);
+									
+			if (lock)
+			{
+				UnLockBitMap(lock);
+
+				D(bug("Start of DBuffering allocations...\n"));
+				
+				this->hidden->safeport=CreateMsgPort();
+				this->hidden->dispport=CreateMsgPort();
+						
+				this->hidden->SB[0]=AllocScreenBuffer(SDL_Display,NULL,SB_SCREEN_BITMAP);
+				this->hidden->SB[1]=AllocScreenBuffer(SDL_Display,NULL,SB_COPY_BITMAP);
+				
+				if (	this->hidden->safeport
+					&&	this->hidden->dispport
+					&&	this->hidden->SB[0]
+					&&	this->hidden->SB[1])
+				{
+					D(bug("Screen buffers Allocated...\n"));
+					
+					this->hidden->safe_sigbit=1L<< this->hidden->safeport->mp_SigBit;
+					this->hidden->disp_sigbit=1L<< this->hidden->dispport->mp_SigBit;
+
+					this->hidden->SB[0]->sb_DBufInfo->dbi_SafeMessage.mn_ReplyPort=this->hidden->safeport;
+					this->hidden->SB[0]->sb_DBufInfo->dbi_DispMessage.mn_ReplyPort=this->hidden->dispport;
+					this->hidden->SB[1]->sb_DBufInfo->dbi_SafeMessage.mn_ReplyPort=this->hidden->safeport;
+					this->hidden->SB[1]->sb_DBufInfo->dbi_DispMessage.mn_ReplyPort=this->hidden->dispport;
+					
+					this->hidden->dbuffer = 1;
+					if (screen) screen->flags |= SDL_DOUBLEBUF;
+					D(bug("Dbuffering enabled!\n"));
+				}
+				else
+				{
+					if (this->hidden->SB[0]) FreeScreenBuffer(SDL_Display,this->hidden->SB[0]);
+					if (this->hidden->SB[1]) FreeScreenBuffer(SDL_Display,this->hidden->SB[1]);
+					if (this->hidden->safeport) DeleteMsgPort (this->hidden->safeport);
+					if (this->hidden->dispport) DeleteMsgPort (this->hidden->dispport);
+					this->hidden->SB[0] = NULL;
+					this->hidden->SB[1] = NULL;
+					this->hidden->safeport = NULL;
+					this->hidden->dispport = NULL;
+					
+					flags &= ~SDL_DOUBLEBUF;
+					this->hidden->dbuffer = 0;
+					D(bug("Dbuffering failed!\n"));
+				}
+			}
+			else
+			{
+				flags &= ~SDL_DOUBLEBUF;
+				this->hidden->dbuffer = 0;
+				D(bug("Dbuffering failed!\n"));
+			}
+#else
+			flags &= ~SDL_DOUBLEBUF;
+#endif
+		}
+	}
+
+	D(bug("Screen bitmap: %ld (%ld), bpp %ld\n",
+			GetCyberMapAttr(SDL_Display->RastPort.BitMap,CYBRMATTR_BPPIX),
+			GetCyberMapAttr(SDL_Display->RastPort.BitMap,CYBRMATTR_DEPTH),
+			bpp));
+
+	return flags;
+
+}
+
+static void CGX_CloseCustomScreen(_THIS, SDL_Surface *screen)
+{
+	if(this->hidden->dbuffer)
+	{
+		D(bug("Freeing double buffering stuff..."));
+
+		this->hidden->dbuffer = 0;
+		if (screen) screen->flags &= ~SDL_DOUBLEBUF;
+		if(this->hidden->SB[1]) FreeScreenBuffer(SDL_Display,this->hidden->SB[1]);
+		if(this->hidden->SB[0]) FreeScreenBuffer(SDL_Display,this->hidden->SB[0]);
+
+		D(bug("Screen buffers OK..."));			
+		
+		if(this->hidden->safeport)
+		{
+			while(GetMsg(this->hidden->safeport) != NULL);
+				DeleteMsgPort(this->hidden->safeport);
+		}
+		D(bug("safeport OK..."));			
+		if(this->hidden->dispport)
+		{
+			while(GetMsg(this->hidden->dispport) != NULL);
+				DeleteMsgPort(this->hidden->dispport);
+		}
+		D(bug("dispport OK..."));			
+
+		this->hidden->SB[0]=this->hidden->SB[1] = NULL;
+
+		if(SDL_RastPort && SDL_RastPort != &SDL_Display->RastPort) FreeRastPort(SDL_RastPort);
+		SDL_RastPort=NULL;
+		D(bug("Rastport OK..."));			
+	}
+
+	D(bug("Closing screen..."));
+	CloseScreen(GFX_Display);
+	GFX_Display = NULL; SDL_Display = NULL;
+	currently_fullscreen = 0;
+	if (screen) screen->flags &= ~SDL_FULLSCREEN;
+}
+
+static void CGX_CloseUnlockScreen(_THIS, SDL_Surface *screen)
+{
+  	if(currently_fullscreen) {
+		CGX_CloseCustomScreen(this, screen);
+	}
+	else if(GFX_Display) {
+		UnlockPubScreen(NULL, GFX_Display);
+		GFX_Display = NULL; SDL_Display = NULL;
+	}
+
+	D(bug("Ok\n"));
+}
+
+#if !defined(PROTO_SDL_H)
+static int CGX_Available(void)
+#else
+static int CGX_AvailableI(struct SDLBase *SDLBase)
+#endif
+{
+	if ( CyberGfxBase != NULL ) {
+		D(bug("CGX video device AVAILABLE\n"));
+	}
+	D(else bug("**CGX video device UNAVAILABLE\n"));
+
+	return(CyberGfxBase != NULL);
+}
+
+#if !defined(PROTO_SDL_H)
+static void CGX_DeleteDevice(SDL_VideoDevice *device)
+#else
+static void CGX_DeleteDeviceI(SDL_VideoDevice *device, struct SDLBase *SDLBase)
+#endif
+{
+	if ( device ) {
+		if ( device->hidden ) {
+			SDL_free(device->hidden);
+		}
+		if ( device->gl_data ) {
+			SDL_free(device->gl_data);
+		}
+		SDL_free(device);
+	}
+}
+
+static void MakeBitMask(_THIS, int format,int *bpp, Uint32 *Rmask, Uint32 *Gmask, Uint32 *Bmask, Uint32 *Amask)
+{
+	if (this->hidden->depth==*bpp)
+	{
+		D(bug("REAL pixel format: "));
+
+		switch(format) 
+		{
+			case PIXFMT_LUT8:
+				D(bug("PIXFMT_LUT8\n"));
+				*Rmask = 0;
+				*Gmask = 0;
+				*Bmask = 0;
+				*Amask = 0;
+				break;
+			case PIXFMT_BGR15:
+				D(bug("PIXFMT_BGR15\n"));
+				*Rmask = AROS_BE2WORD(0x001f);
+				*Gmask = AROS_BE2WORD(0x03e0);
+				*Bmask = AROS_BE2WORD(0x7c00);
+				*Amask = 0;
+				break;
+			case PIXFMT_RGB15:
+				D(bug("PIXFMT_RGB15\n"));
+				*Rmask = AROS_BE2WORD(0x7c00);
+				*Gmask = AROS_BE2WORD(0x03e0);
+				*Bmask = AROS_BE2WORD(0x001f);
+				*Amask = 0;
+				break;
+			case PIXFMT_RGB15PC:
+				D(bug("PIXFMT_RGB15PC\n"));
+				*Rmask = AROS_BE2WORD(0x007c);
+				*Gmask = AROS_BE2WORD(0xe003);
+				*Bmask = AROS_BE2WORD(0x1f00);
+				*Amask = 0;
+				break;
+			case PIXFMT_BGR15PC:
+				D(bug("PIXFMT_BGR15PC\n"));
+				*Rmask = AROS_BE2WORD(0x1f00);
+				*Gmask = AROS_BE2WORD(0xe003);
+				*Bmask = AROS_BE2WORD(0x007c);
+				*Amask = 0;
+				break;
+			case PIXFMT_RGB16:
+				D(bug("PIXFMT_RGB16\n"));
+				*Rmask = AROS_BE2WORD(0xf800);
+				*Gmask = AROS_BE2WORD(0x07e0);
+				*Bmask = AROS_BE2WORD(0x001f);
+				*Amask = 0;
+				break;
+			case PIXFMT_BGR16:
+				D(bug("PIXFMT_BGR16\n"));
+				*Rmask = AROS_BE2WORD(0x001f);
+				*Gmask = AROS_BE2WORD(0x07e0);
+				*Bmask = AROS_BE2WORD(0xf800);
+				*Amask = 0;
+				break;
+			case PIXFMT_RGB16PC:
+				D(bug("PIXFMT_RGB16PC\n"));
+				*Rmask = AROS_BE2WORD(0x00f8);
+				*Gmask = AROS_BE2WORD(0xe007);
+				*Bmask = AROS_BE2WORD(0x1f00);
+				*Amask = 0;
+				break;
+			case PIXFMT_BGR16PC:
+				D(bug("PIXFMT_BGR16PC\n"));
+				*Rmask = AROS_BE2WORD(0x1f00);
+				*Gmask = AROS_BE2WORD(0xe007);
+				*Bmask = AROS_BE2WORD(0x00f8);
+				*Amask = 0;
+				break;
+			case PIXFMT_RGB24:
+				D(bug("PIXFMT_RGB24\n"));
+				*Rmask = AROS_BE2LONG(0x00ff0000);
+				*Gmask = AROS_BE2LONG(0x0000ff00);
+				*Bmask = AROS_BE2LONG(0x000000ff);
+				*Amask = 0;
+				break;
+			case PIXFMT_BGR24:
+				D(bug("PIXFMT_BGR24\n"));
+				*Rmask = AROS_BE2LONG(0x000000ff);
+				*Gmask = AROS_BE2LONG(0x0000ff00);
+				*Bmask = AROS_BE2LONG(0x00ff0000);
+				*Amask = 0;
+				break;
+			case PIXFMT_ARGB32:
+				D(bug("PIXFMT_ARGB32\n"));
+				*Rmask = AROS_BE2LONG(0x00ff0000);
+				*Gmask = AROS_BE2LONG(0x0000ff00);
+				*Bmask = AROS_BE2LONG(0x000000ff);
+				*Amask = AROS_BE2LONG(0xff000000);
+				break;
+			case PIXFMT_BGRA32:
+				D(bug("PIXFMT_BGRA32\n"));
+				*Rmask = AROS_BE2LONG(0x0000ff00);
+				*Gmask = AROS_BE2LONG(0x00ff0000);
+				*Bmask = AROS_BE2LONG(0xff000000);
+				*Amask = AROS_BE2LONG(0x000000ff);
+				break;
+			case PIXFMT_RGBA32:
+				D(bug("PIXFMT_RGBA32\n"));
+				*Rmask = AROS_BE2LONG(0xff000000);
+				*Gmask = AROS_BE2LONG(0x00ff0000);
+				*Bmask = AROS_BE2LONG(0x0000ff00);
+				*Amask = AROS_BE2LONG(0x000000ff);
+				break;
+			default:
+				D(bug("Unknown pixel format! Default to RGB24\n"));
+				*Rmask = AROS_BE2LONG(0x00ff0000);
+				*Gmask = AROS_BE2LONG(0x0000ff00);
+				*Bmask = AROS_BE2LONG(0x000000ff);
+				*Amask = 0;
+				break;
+		}
+	} 
+	else 
+	{
+		D(bug("DIFFERENT from screen.\nAllocated screen format: "));
+
+		switch(*bpp)
+		{
+			case 32:
+				D(bug("ARGB32\n"));
+				*Rmask = AROS_BE2LONG(0x00ff0000);
+				*Gmask = AROS_BE2LONG(0x0000ff00);
+				*Bmask = AROS_BE2LONG(0x000000ff);
+				*Amask = AROS_BE2LONG(0xff000000);
+				break;
+			case 24:
+				D(bug("0RGB32\n"));
+				*Rmask = AROS_BE2LONG(0x00ff0000);
+				*Gmask = AROS_BE2LONG(0x0000ff00);
+				*Bmask = AROS_BE2LONG(0x000000ff);
+				*Amask = 0;
+				break;
+			case 16:
+			case 15:
+				D(bug("Not supported, switching to 24bit!\n"));
+				*bpp=24;
+				MakeBitMask(this, format, bpp, Rmask, Gmask, Bmask, Amask);
+				break;
+			default:
+				D(bug("This is a chunky display\n"));
+				*Rmask = 0;
+				*Gmask = 0;
+				*Bmask = 0;
+				*Amask = 0;
+				break;
+		}
+	}
+	D(bug("Mask created :\n R = 0x%08X; G = 0x%08X; B = 0x%08X; A = 0x%08X\n", *Rmask, *Gmask, *Bmask, *Amask));
+	
+}
+
+#if !defined(PROTO_SDL_H)
+static int CGX_VideoInit(_THIS, SDL_PixelFormat *vformat)
+#else
+static int CGX_VideoInitI(_THIS, SDL_PixelFormat *vformat, struct SDLBase *SDLBase)
+#endif
+{
+	int i;
+	int form;
+
+	D(bug("VideoInit... Opening libraries\n"));
+
+	if(!IntuitionBase) 
+	{
+		SDL_SetError("Couldn't open intuition V39+");
+		return -1;
+	}
+
+	if(!GfxBase)
+	{
+		SDL_SetError("Couldn't open graphics V39+");
+		return -1;
+	}
+
+	if(!CyberGfxBase)
+	{
+		SDL_SetError("Couldn't open cybergraphics.");
+		return(-1);
+	}
+
+	D(bug("Library intialized, locking screen...\n"));
+
+	SDL_Display = LockPubScreen(NULL);
+
+	if ( SDL_Display == NULL ) {
+		D(bug("Cannot lock display...\n"));
+		SDL_SetError("Couldn't lock the display");
+		return(-1);
+	}
+	this->info.current_w = SDL_Display->Width;
+	this->info.current_h = SDL_Display->Height;
+
+	D(bug("Checking if we are using a CGX native display...\n"));
+	if(!IsCyberModeID(GetVPModeID(&SDL_Display->ViewPort)))
+	{
+		Uint32 okid=BestCModeIDTags(CYBRBIDTG_NominalWidth,	SDL_Display->Width,
+									CYBRBIDTG_NominalHeight, SDL_Display->Height,
+									CYBRBIDTG_Depth, 8,
+									TAG_DONE);
+
+		D(bug("Default visual is not CGX native!\n"));
+
+		UnlockPubScreen(NULL,SDL_Display);
+
+		GFX_Display=NULL;
+
+		if(okid!=INVALID_ID)
+		{
+			GFX_Display=OpenScreenTags(	NULL,
+										SA_Width,SDL_Display->Width,
+										SA_Height,SDL_Display->Height,
+										SA_Depth,8,
+										SA_Quiet,TRUE,
+										SA_ShowTitle,FALSE,
+										SA_DisplayID,okid,
+										TAG_DONE);
+		}
+
+		if(!GFX_Display)
+		{
+			SDL_SetError("Unable to open a suited CGX display");
+			return -1;
+		}
+		else SDL_Display=GFX_Display;
+
+	}
+	else GFX_Display = SDL_Display;
+
+	D(bug("Before GetVideoModes....\n"));
+	/* Get the available video modes */
+	if(CGX_GetVideoModes(this) < 0) return -1;
+
+	/* Determine the default screen depth: Use the default visual (or at least one with the same depth) */
+	for(i = 0; i < this->hidden->nvisuals; i++)
+		if(this->hidden->visuals[i].depth == GetCyberMapAttr(SDL_Display->RastPort.BitMap,CYBRMATTR_DEPTH)) break;
+
+	/* default visual was useless, take the deepest one instead */
+	if(i == this->hidden->nvisuals) i = 0;
+
+	D(bug("Init: Setting screen depth to: %ld\n",this->hidden->visuals[i].depth));
+	
+	SDL_Visual 				= this->hidden->visuals[i].visual;
+	this->hidden->depth 	= this->hidden->visuals[i].depth;
+	vformat->BitsPerPixel 	= this->hidden->visuals[i].depth;
+	vformat->BytesPerPixel 	= this->hidden->visuals[i].bpp / 8;
+
+	// In this case I use makebitmask in a way that I'm sure I'll get PIXFMT pixel mask
+	form = GetCyberIDAttr(CYBRIDATTR_PIXFMT,SDL_Visual);
+	if ( vformat->BitsPerPixel > 8 )
+	{
+		MakeBitMask(this,form,&this->hidden->depth, &vformat->Rmask, &vformat->Gmask, &vformat->Bmask, &vformat->Amask);
+		vformat->Amask = 0;
+	}
+
+	/* Create the blank cursor */
+	SDL_BlankCursor = AllocMem(16,MEMF_CHIP|MEMF_CLEAR);
+
+	/* Fill in some window manager capabilities */
+	this->info.wm_available = 1;
+	this->info.blit_fill	= 1;
+#ifndef NO_AMIGAHWSURF
+	this->info.hw_available = 1;
+	this->info.blit_hw		= 1;
+	this->info.blit_hw_CC	= 1;
+	this->info.blit_hw_A	= 1;
+	this->info.blit_sw		= 1;
+	this->info.blit_sw_CC	= 0;
+	this->info.blit_sw_A	= 1;
+#endif
+	this->info.video_mem	= AvailMem(MEMF_FAST) / 4096000 * 1000; /* how to get Video Memory size? */
+	
+	SDL_RastPort = &SDL_Display->RastPort;
+	
+	/* We're done! */
+	D(bug("End of CGX_VideoInit\n"));
+
+	return(0);
+}
+
+#if !defined(PROTO_SDL_H)
+static void CGX_DestroyWindow(_THIS, SDL_Surface *screen, Uint32 flags)
+#else
+#define CGX_DestroyWindow(this, screen, flags) CGX_DestroyWindowI(this, screen, flags, SDLBase)
+static void CGX_DestroyWindowI(_THIS, SDL_Surface *screen, Uint32 flags, struct SDLBase *SDLBase)
+#endif
+{
+	D(bug("Destroy Window...\n"));
+
+	/* Mark activation flags */
+	this->hidden->WindowActive = 0;
+	this->hidden->FocusActive = 0;
+
+	/* Clean up OpenGL */
+	if ( screen && ( screen->flags & SDL_OPENGL ) && ! (flags & SDL_KEEP_GL_CONTEXT)) {
+		CGX_GL_DestroyContext(this);
+		screen->flags &= ~(SDL_OPENGL|SDL_OPENGLBLIT);
+	}
+
+	/* Free the colormap entries */
+	if ( SDL_Pens )	{
+		if (	this->screen
+			&& 	this->hidden
+			&&	GFX_Display
+			&&	this->screen->format
+			&&	this->hidden->depth == 8
+			&&	! ( screen && (screen->flags & SDL_FULLSCREEN) ) ) {
+			int numcolors = 1 << this->screen->format->BitsPerPixel;
+			unsigned long pen;
+
+			if(numcolors > 256) numcolors = 256;
+
+			D(bug("Releasing %d pens...\n", numcolors));
+			for ( pen=0; pen < numcolors; pen++ )
+				if(SDL_Pens[pen] >= 0) ReleasePen(GFX_Display->ViewPort.ColorMap,SDL_Pens[pen]);
+		}
+		SDL_free(SDL_Pens);
+		SDL_Pens = NULL;
+	}
+
+	/* Destroy the output window */
+	if ( SDL_Window ) {
+#ifndef NO_AMIGAHWSURF
+		if (this->hidden->temprp) FreeRastPort(this->hidden->temprp);
+		this->hidden->temprp = NULL;
+		if (this->hidden->BlitBitMap) FreeBitMap(this->hidden->BlitBitMap);
+		this->hidden->BlitBitMap = NULL;
+#endif
+		CloseWindow(SDL_Window);
+		SDL_Window = NULL;
+	}
+}
+
+static void CGX_SetSizeHints(_THIS, int w, int h, Uint32 flags)
+{
+	if ( flags & SDL_RESIZABLE )
+		WindowLimits(SDL_Window, 32, 32,4096,4096);
+	else
+		WindowLimits(SDL_Window, w,h,w,h);
+
+	if ( flags & SDL_FULLSCREEN ) 
+		flags &= ~SDL_RESIZABLE;
+	else if ( SDL_getenv("SDL_VIDEO_CENTERED") )
+		ChangeWindowBox(SDL_Window,
+						(SDL_Display->Width - w - SDL_Window->BorderLeft-SDL_Window->BorderRight)/2,
+						(SDL_Display->Height - h - SDL_Window->BorderTop-SDL_Window->BorderBottom)/2,
+						w+SDL_Window->BorderLeft+SDL_Window->BorderRight,
+						h+SDL_Window->BorderTop+SDL_Window->BorderBottom);
+}
+
+#if !defined(PROTO_SDL_H)
+static int CGX_CreateWindow(_THIS, SDL_Surface *screen, int w, int h, int bpp, Uint32 flags)
+#else
+#define CGX_CreateWindow(this, screen, w, h, bpp, flags) CGX_CreateWindowI(this, screen, w, h, bpp, flags, SDLBase)
+static int CGX_CreateWindowI(_THIS, SDL_Surface *screen, int w, int h, int bpp, Uint32 flags, struct SDLBase *SDLBase)
+#endif
+{
+	Uint32 form, rb, gb, bb, ab;
+
+	D(bug("CGX_CreateWindow %dx%d/%d flags:%lx\n", w, h, bpp, flags));
+
+	/* This function assumes any existing window has already been closed */
+	if (SDL_Window != 0) {
+		D(bug("CGX_CreateWindow called when window still open\n"));
+		SDL_SetError("CGX_CreateWindow called when window still open");
+		return (-1);
+	}
+	/* This function assumes any existing GL context has already been freed up */
+	if (!(flags & SDL_KEEP_GL_CONTEXT) && (this->gl_data->glctx != NULL)) {
+		D(bug("CGX_CreateWindow called when GL context still active\n"));
+		SDL_SetError("CGX_CreateWindow called when GL context still active");
+		return (-1);
+	}
+
+	/* Allocate the new pixel format for this video mode */
+	form = GetCyberIDAttr(CYBRIDATTR_PIXFMT,SDL_Visual);
+
+	if((flags & SDL_HWSURFACE) && (bpp!=this->hidden->depth))
+	{
+			bpp = this->hidden->depth;
+			D(bug("Accel forces bpp to be equal (%ld)\n",bpp));
+	}
+
+	/* 
+		With this call if needed I'll revert the wanted bpp to a bpp best suited for the display, actually occurs
+		only with requested format 15/16bit and display format != 15/16bit
+	 */
+	D(bug("BEFORE screen allocation: bpp:%ld (real:%ld)\n",bpp,this->hidden->depth));
+ 
+	MakeBitMask(this,form,&bpp, &rb, &gb, &bb, &ab);
+
+	if ( ! SDL_ReallocFormat(screen, 8 * GetCyberMapAttr(SDL_Display->RastPort.BitMap, CYBRMATTR_BPPIX), rb, gb, bb, 0) )
+		return -1;
+
+	D(bug("AFTER screen allocation: bpp:%ld (real:%ld)\n",bpp,this->hidden->depth));
+
+	/* Create the appropriate colormap */
+	if ( GetCyberMapAttr(SDL_Display->RastPort.BitMap,CYBRMATTR_PIXFMT)==PIXFMT_LUT8 || bpp==8 )
+	{
+		int ncolors,i;
+		D(bug("Pens palette allocation...\n"));
+
+		/* Allocate the pixel flags */
+		if(bpp>=8)
+			ncolors=256;
+		else
+			ncolors = 1 << screen->format->BitsPerPixel;
+
+		SDL_Pens = (Sint32 *)SDL_malloc(ncolors * sizeof(Sint32));
+
+		if(SDL_Pens == NULL)
+		{
+			SDL_OutOfMemory();
+			return -1;
+		}
+
+		for(i=0;i<ncolors;i++) SDL_Pens[i]=-1;
+
+		/* always allocate a private colormap on non-default visuals */
+		if(bpp==8) flags |= SDL_HWPALETTE;
+
+		if ( flags & SDL_HWPALETTE ) screen->flags |= SDL_HWPALETTE;
+	} 
+
+	if( flags & SDL_FULLSCREEN )
+	{
+		SDL_Window = OpenWindowTags(NULL,
+									WA_Width,SDL_Display->Width,
+									WA_Height,SDL_Display->Height,
+									WA_Flags,WFLG_ACTIVATE|WFLG_RMBTRAP|WFLG_BORDERLESS|WFLG_BACKDROP|WFLG_REPORTMOUSE,
+									WA_IDCMP,IDCMP_RAWKEY|IDCMP_MOUSEBUTTONS|IDCMP_MOUSEMOVE,
+									WA_BackFill, (IPTR)LAYERS_NOBACKFILL,
+									WA_CustomScreen,(IPTR)SDL_Display,
+									TAG_DONE);
+		FillPixelArray(SDL_Window->RPort,SDL_Window->BorderLeft,SDL_Window->BorderTop,SDL_Display->Width,SDL_Display->Height,0x00000000);
+		D(bug("Opening backdrop window %ldx%ld on display %lx!\n",SDL_Display->Width,SDL_Display->Height,SDL_Display));
+	}
+	else
+	{
+		ULONG left, top;
+		
+		left = (SDL_Display->Width - w) / 2;
+		top  = (SDL_Display->Height - h) / 2;
+		
+		SDL_Window = OpenWindowTags(NULL,
+									WA_InnerWidth,w,
+									WA_InnerHeight,h,
+									WA_Left, left,
+									WA_Top, top,
+									WA_Title, this->hidden->WindowName,
+									WA_Flags,	WFLG_REPORTMOUSE|WFLG_ACTIVATE|WFLG_RMBTRAP |
+												((flags&SDL_NOFRAME) ? 0 : (WFLG_DEPTHGADGET|WFLG_CLOSEGADGET|WFLG_DRAGBAR | 
+												((flags&SDL_RESIZABLE) ? WFLG_SIZEGADGET|WFLG_SIZEBBOTTOM : 0))),
+									WA_IDCMP,	IDCMP_RAWKEY|IDCMP_CLOSEWINDOW|IDCMP_MOUSEBUTTONS|IDCMP_NEWSIZE|
+												IDCMP_MOUSEMOVE|IDCMP_ACTIVEWINDOW|IDCMP_INACTIVEWINDOW,
+									WA_BackFill, (IPTR)LAYERS_NOBACKFILL,
+									WA_PubScreen,(IPTR)SDL_Display,
+									TAG_DONE);
+		FillPixelArray(SDL_Window->RPort,SDL_Window->BorderLeft,SDL_Window->BorderTop,w,h,0x00000000);
+		D(bug("Opening WB window of size: %ldx%ld!\n",w,h));
+	}
+
+#ifndef NO_AMIGAHWSURF
+	if (	(flags & SDL_DOUBLEBUF)
+		&&	(flags & SDL_FULLSCREEN)
+		&&	(this->hidden->dbuffer) )
+	{
+		D(bug("Double Buffering in use\n",w,h));
+		if((SDL_RastPort = CreateRastPort()) != NULL)
+		{
+			SDL_RastPort->BitMap=this->hidden->SB[1]->sb_BitMap;
+			screen->flags |= SDL_DOUBLEBUF;
+		}
+		else
+			return -1;
+	}
+	else
+	{
+		// If there is no double buffering we create a Bitmap to fake double buffering.
+		D(bug("No Double Buffering : Using BlitBitMap hack\n",w,h));
+		this->hidden->BlitBitMap = AllocBitMap(	w, 
+												h,
+												GetBitMapAttr(SDL_Window->RPort->BitMap, BMA_DEPTH),
+												flags & SDL_FULLSCREEN ? BMF_CLEAR| BMF_MINPLANES : BMF_CLEAR | BMF_MINPLANES | BMF_DISPLAYABLE,
+												SDL_Window->RPort->BitMap);
+												
+		if (!this->hidden->BlitBitMap) return -1;
+		
+		screen->flags &= ~SDL_DOUBLEBUF;
+		SDL_RastPort=SDL_Window->RPort;
+	}
+#else
+	screen->flags &= ~SDL_DOUBLEBUF;
+	SDL_RastPort=SDL_Window->RPort;
+#endif
+	
+	if (flags & SDL_HWSURFACE)
+		screen->flags |= SDL_HWSURFACE;
+	else
+		screen->flags &= ~SDL_HWSURFACE;
+
+	CGX_SetSizeHints(this, w, h, flags);
+	this->info.current_w = w;
+	this->info.current_h = h;
+	
+	if ( flags & SDL_FULLSCREEN )
+	{
+		screen->flags |= SDL_FULLSCREEN;
+		/* IDCMP_ACTIVEWINDOW does not seem to be sent to windows opened on
+		   new screen, so we set activity status here */
+		this->hidden->WindowActive = 1;
+		/* Reset explicit focus activation - alway capture in full screen mode */
+		this->hidden->ExplicitFocusActivation = 0;
+
+		currently_fullscreen=1;
+	}
+	else
+		screen->flags &= ~SDL_FULLSCREEN;
+
+	screen->w = w;
+	screen->h = h;
+	screen->pitch = SDL_CalculatePitch(screen);
+	CGX_ResizeImage(this, screen, flags);
+
+	/* Make OpenGL Context if needed*/
+	if(flags & SDL_OPENGL) {
+		if (flags & SDL_KEEP_GL_CONTEXT) {
+			/* Context was not destroyed, update it here */
+			if (CGX_GL_UpdateContext(this) < 0) {
+				SDL_SetError("Failed to update GL context");
+				return -1;
+			}
+		} else {
+			if(CGX_GL_CreateContext(this) < 0) {
+				SDL_SetError("Failed to create GL context");
+				return -1;
+			}
+			else
+				screen->flags |= SDL_OPENGL;
+		}
+	}
+	
+	return 0;
+}
+
+#if !defined(PROTO_SDL_H)
+static int CGX_ResizeWindow(_THIS, SDL_Surface *screen, int width, int height, Uint32 flags)
+#else
+#define CGX_ResizeWindow(this, screen, width, height, flags) CGX_ResizeWindowI(this, screen, width, height, flags, SDLBase)
+static int CGX_ResizeWindowI(_THIS, SDL_Surface *screen, int width, int height, Uint32 flags, struct SDLBase *SDLBase)
+#endif
+{
+	D(bug("CGX_ResizeWindow\n"));
+	
+	/* Resize the window manager window */
+	CGX_SetSizeHints(this, width, height, flags);
+	this->info.current_w = width;
+	this->info.current_h = height;
+
+	ChangeWindowBox(	SDL_Window,
+						SDL_Window->LeftEdge,
+						SDL_Window->TopEdge,
+						width+SDL_Window->BorderLeft+SDL_Window->BorderRight,
+						height+SDL_Window->BorderTop+SDL_Window->BorderBottom);
+	screen->w = width;
+	screen->h = height;
+	screen->pitch = SDL_CalculatePitch(screen);
+#ifndef NO_AMIGAHWSURF
+	if (this->hidden->BlitBitMap)
+	{
+		FreeBitMap(this->hidden->BlitBitMap);
+		this->hidden->BlitBitMap = AllocBitMap(	width, 
+												height,
+												GetBitMapAttr(SDL_Window->RPort->BitMap, BMA_DEPTH),
+												flags & SDL_FULLSCREEN ? BMF_CLEAR | BMF_MINPLANES : BMF_CLEAR |BMF_MINPLANES | BMF_DISPLAYABLE,
+												SDL_Window->RPort->BitMap);
+	}
+#endif
+	CGX_ResizeImage(this, screen, flags);
+
+	return 0;
+}
+
+/*  There are several combinations of existing and request parameters that this
+	function needs to support.
+	
+	Explanation of parameters:
+		FS - full screen
+		WND - windowned on Workbench window
+		sizeA, sizeB, sizeAny - some different sizes (width/height) of surfaces
+		bppA, bppB, bppAny - some different bits per pixel of surfaces
+		bppWB - bits per pixel of Workbench
+		OGL - surface uses OpenGL
+		NOGL - surface does not use OpenGL
+
+	Explanation of actions:
+		wndR		- resize window
+		wndC, wndD	- create, destroy window
+		scrC, scrD	- create, destroy screen
+		oglC, oglD	- create, destroy OpenGL context
+		oglU		- update OpenGL context with new window
+
+	Cases:
+	
+	| Current                 | Requested                  | Actions                                                    |
+	| bppWB, sizeA, WND, OGL  | bppB, sizeAny, WND, OGL    | Not possible to change bpp of window on Workbench          |
+	| bppWB, sizeA, WND, OGL  | bppWB, sizeB, WND, OGL     | wndR(sizeB)                                                |
+	| bppWB, sizeA, WND, NOGL | bppWB, sizeB, WND, NOGL    | wndR(sizeB)                                                |
+	| bppWB, sizeA, WND, OGL  | bppWB, sizeB, WND, NOGL    | oglD, wndD, wndC(sizeB)                                    |
+	| bppWB, sizeA, WND, NOGL | bppWB, sizeB, WND, OGL     | wndD, wndC(sizeB), oglC                                    |
+	| bppWB, sizeA, WND, OGL  | bppAny, sizeAny, FS, OGL   | wndD, scrC(sizeAny, bppAny), wndC(sizeAny), oglU           |
+	| bppWB, sizeA, WND, OGL  | bppAny, sizeAny, FS, NOGL  | oglD, wndD, scrC(sizeAny, bppAny), wndC(sizeAny), oglC     |
+	| bppA, sizeA, FS, OGL    | bppB, sizeAny, FS, OGL     | wndD, scrD, scrC(sizeAny, bppB), wndC(sizeAny), oglU       |
+	| bppA, sizeA, FS, OGL    | bppAny, sizeB, FS, OGL     | wndD, scrD, scrC(sizeB, bppAny), wndC(sizeB), oglU         |
+	| bppA, sizeA, FS, OGL    | bppB, sizeAny, FS, NOGL    | oglD, wndD, scrD, scrC(sizeAny, bppB), wndC(sizeAny)       |
+	| bppA, sizeA, FS, OGL    | bppAny, sizeB, FS, NOGL    | oglD, wndD, scrD, scrC(sizeB, bppAny), wndC(sizeB)         |
+	| bppA, sizeA, FS, OGL    | bppWB, sizeAny, WND, OGL   | wndD, scrD, wndC(sizeAny), oglU                            |
+	| bppA, sizeA, FS, OGL    | bppWB, sizeAny, WND, NOGL  | oglD, wndD, scrD, wndC(sizeAny)                            |
+
+	Rules:
+
+	(+)if ( curr->WND && req->WND && sizediff && ! ogldiff ) resize_window
+	(+)if ( ! resize_window ) destroy_window
+	(+)if ( curr->FS && ( sizediff || bppdiff || req->WND ) ) destroy_screen
+	(+)if ( req->FS && ( sizediff || bppdiff || curr->WND ) ) create_screen
+	(+)if ( ! resize_window ) create_window
+
+	(+)if ( ! ogldiff) req->SDL_KEEP_GL_CONTEXT
+	(+)if ( destroy_window && curr->SDL_OPENGL && ! req->SDL_KEEP_GL_CONTEXT ) destroy_context
+	(+)if ( create_window && req->SDL_OPENGL && ! req->SDL_KEEP_GL_CONTEXT ) create_context
+	(+)if ( create_window && req->SDL_OPENGL && req->SDL_KEEP_GL_CONTEXT ) update_context
+*/
+
+#if !defined(PROTO_SDL_H)
+static SDL_Surface *CGX_SetVideoMode(_THIS, SDL_Surface *current, int width, int height, int bpp, Uint32 flags)
+#else
+#ifdef CGX_SetVideoMode
+#undef CGX_SetVideoMode
+#endif
+#define CGX_SetVideoMode(this, current, width, height, bpp, flags) CGX_SetVideoModeI(this, current, width, height, bpp, flags, SDLBase)
+static SDL_Surface *CGX_SetVideoModeI(_THIS, SDL_Surface *current, int width, int height, int bpp, Uint32 flags, struct SDLBase *SDLBase)
+#endif
+{
+	int sizediff = 0, bppdiff = 0, ogldiff = 0, i;
+	
+	sizediff = (current != NULL) ? ((current->w != width) || (current->h != height)) : 1;
+	bppdiff = (this->hidden != NULL) ? (this->hidden->depth != bpp) : 1;
+	ogldiff = (current != NULL) ? ((current->flags & SDL_OPENGL) != (flags & SDL_OPENGL)) : 1;
+	if (!ogldiff) flags |= SDL_KEEP_GL_CONTEXT;
+	
+	D(bug("CGX_SetVideoMode to %dx%dx%d, sizediff %d bppdiff %d\n", width, height, bpp, sizediff, bppdiff));
+
+	/* Lock the event thread, in multi-threading environments */
+	SDL_Lock_EventThread();
+
+	/* Decide early on if we are resizing or rebuilding window */
+	if ((SDL_Window && current && !(current->flags & SDL_FULLSCREEN)) && !(flags & SDL_FULLSCREEN) 
+		&& (sizediff) && (!ogldiff)) {
+		if (bppdiff) {
+			/* Not possible in windowned mode. Use previous depth. */
+			D(bug("Bringing bpp back from %d to %d\n", bpp, this->hidden->depth));
+			bpp = this->hidden->depth;
+		}
+		/* Resize */
+		if (CGX_ResizeWindow(this, current, width, height, flags) < 0)
+			current = NULL;
+		else
+			current->flags |= (flags & SDL_RESIZABLE); /* Resizable only if the user asked it */
+
+		/* Release the event thread */
+		SDL_Unlock_EventThread();
+	
+		/* We're done! */
+		return(current);
+	}
+	
+	/* Destroy existing window */
+	CGX_DestroyImage(this, current);
+	CGX_DestroyWindow(this, current, flags);
+	
+	/* Destroy existing screen if needed */
+	if ((current && (current->flags & SDL_FULLSCREEN)) &&
+		((!(flags & SDL_FULLSCREEN)) || (sizediff) || (bppdiff))) {
+		CGX_CloseCustomScreen(this, current);
+	}
+	
+	/* Create new screen if needed */
+	if ((flags & SDL_FULLSCREEN) &&
+		((current && !(current->flags & SDL_FULLSCREEN))
+		|| (sizediff) || (bppdiff))) {
+		
+		/* Release hold on Workbench screen first */
+		if (current && !(current->flags & SDL_FULLSCREEN)) {
+			UnlockPubScreen(NULL, GFX_Display);
+			GFX_Display = NULL; SDL_Display = NULL;
+		}
+
+		flags = CGX_OpenCustomScreen(this, current, width, height, bpp, flags);
+	}
+	
+	if (!GFX_Display) {
+		/*  Attach SDL to Workbench screen if screen opening failed on running 
+			in windowed mode. */
+		GFX_Display = SDL_Display = LockPubScreen(NULL);
+	}
+
+	/* Select visual before creating a window */
+	bpp = this->hidden->depth = GetCyberMapAttr(SDL_Display->RastPort.BitMap,CYBRMATTR_DEPTH);
+	D(bug("Setting screen depth to: %ld\n", this->hidden->depth));
+
+	for (i = 0; i < this->hidden->nvisuals; i++)
+		if (this->hidden->visuals[i].depth == bpp)
+			break;
+
+	if (i == this->hidden->nvisuals) {
+		SDL_SetError("No matching visual for requested depth. Should never happen!");
+		return NULL;	/* should never happen */
+	}
+	SDL_Visual = this->hidden->visuals[i].visual;
+
+	/* Create a new window */
+	if (CGX_CreateWindow(this, current, width, height, bpp, flags) < 0)
+		current = NULL;
+	else
+		current->flags |= (flags & SDL_RESIZABLE); /* Resizable only if the user asked it */
+
+	/* Release the event thread */
+	SDL_Unlock_EventThread();
+
+	/* We're done! */
+	return(current);
+}
+
+#if !defined(PROTO_SDL_H)
+static int CGX_ToggleFullScreen(_THIS, int on)
+#else
+static int CGX_ToggleFullScreenI(_THIS, int on, struct SDLBase *SDLBase)
+#endif
+{
+	Uint32 event_thread;
+
+	/* Don't lock if we are the event thread */
+	event_thread = SDL_EventThreadID();
+	if (event_thread && (SDL_ThreadID() == event_thread)) event_thread = 0;
+	if (event_thread) SDL_Lock_EventThread();
+
+	if (on)
+	{
+		Uint32 flags = this->screen->flags;
+		flags |= SDL_FULLSCREEN;
+
+		/* Call video mode change */		
+		CGX_SetVideoMode(this, this->screen, this->screen->w, this->screen->h, this->hidden->depth, flags);
+	} 
+	else
+	{
+		Uint32 flags = this->screen->flags;
+		flags &= ~SDL_FULLSCREEN;
+
+		/* Call video mode change */		
+		CGX_SetVideoMode(this, this->screen, this->screen->w, this->screen->h, this->hidden->depth, flags);
+	}
+
+	/* SDL does not take care of hinding cursor in this case. If it was hidden, hide it
+	   again. Call Intuition direclty */
+	if ((this->hidden->CursorVisible == 0) && (SDL_BlankCursor != NULL))
+		SetPointer(SDL_Window, (UWORD *)SDL_BlankCursor, 1, 1, 0, 0);
+
+
+	CGX_RefreshDisplay(this);
+	
+	if (event_thread) SDL_Unlock_EventThread();
+
+	SDL_ResetKeyboard();
+	return(1);
+}
+
+/* Update the current mouse state and position */
+#if !defined(PROTO_SDL_H)
+static void CGX_UpdateMouse(_THIS)
+#else
+static void CGX_UpdateMouseI(_THIS, struct SDLBase *SDLBase)
+#endif
+{
+	/* Lock the event thread, in multi-threading environments */
+	SDL_Lock_EventThread();
+
+	if(currently_fullscreen)
+	{
+			SDL_PrivateAppActive(1, SDL_APPMOUSEFOCUS);
+			SDL_PrivateMouseMotion(0, 0, SDL_Display->MouseX, SDL_Display->MouseY);
+	}
+	else
+	{
+		if(	SDL_Display->MouseX>=(SDL_Window->LeftEdge+SDL_Window->BorderLeft) && SDL_Display->MouseX<(SDL_Window->LeftEdge+SDL_Window->Width-SDL_Window->BorderRight) &&
+			SDL_Display->MouseY>=(SDL_Window->TopEdge+SDL_Window->BorderLeft) && SDL_Display->MouseY<(SDL_Window->TopEdge+SDL_Window->Height-SDL_Window->BorderBottom)
+			)
+		{
+			SDL_PrivateAppActive(1, SDL_APPMOUSEFOCUS);
+			SDL_PrivateMouseMotion(0, 0, SDL_Display->MouseX-SDL_Window->LeftEdge-SDL_Window->BorderLeft,
+										SDL_Display->MouseY-SDL_Window->TopEdge-SDL_Window->BorderTop);
+		}
+		else
+		{
+			SDL_PrivateAppActive(0, SDL_APPMOUSEFOCUS);
+		}
+	}
+	SDL_Unlock_EventThread();
+}
+
+#if !defined(PROTO_SDL_H)
+static int CGX_SetColors(_THIS, int firstcolor, int ncolors, SDL_Color *colors)
+#else
+static int CGX_SetColorsI(_THIS, int firstcolor, int ncolors, SDL_Color *colors, struct SDLBase *SDLBase)
+#endif
+{
+	int i;
+
+	if ( (this->screen->flags & SDL_HWPALETTE) && currently_fullscreen )
+	{
+		ULONG  cmap[256*3+2];
+
+		cmap[0]=(ncolors<<16);
+		cmap[0]+=firstcolor;
+
+		for ( i=0; i<ncolors; i++ )
+		{
+			cmap[i*3+1] = colors[i].r<<24;
+			cmap[i*3+2] = colors[i].g<<24;
+			cmap[i*3+3] = colors[i].b<<24;
+		}
+		cmap[ncolors*3+1]=0;
+		LoadRGB32(&GFX_Display->ViewPort,cmap);
+	} 
+	else
+	{
+		// Pens are not needed on 8bit screen with hwpalette
+		unsigned long pen;
+
+		if ( SDL_Pens == NULL ) {
+			D(bug("SetColors without colormap!"));
+			return(0);
+		}
+
+		if(this->hidden->depth==8)
+		{
+			for ( pen=firstcolor; pen<ncolors+firstcolor; pen++ )
+			{
+				if(SDL_Pens[pen]>=0)
+					ReleasePen(GFX_Display->ViewPort.ColorMap,SDL_Pens[pen]);
+			}
+
+			/* Try to allocate all the colors */
+			for ( i=0; i<ncolors; i++ )
+			{
+				SDL_Pens[i+firstcolor]=ObtainBestPenA(GFX_Display->ViewPort.ColorMap,colors[i].r<<24,colors[i].g<<24,colors[i].b<<24,NULL);
+			}
+		}
+		else
+		{
+			for(i=0;i<ncolors;i++)
+				SDL_Pens[i+firstcolor]=(colors[i].r<<16)+(colors[i].g<<8)+colors[i].b;
+		}
+	}
+	return 1;
+}
+
+/* 
+	Note:  If we are terminated, this could be called in the middle of
+	another SDL video routine -- notably UpdateRects.
+*/
+#if !defined(PROTO_SDL_H)
+static void CGX_VideoQuit(_THIS)
+#else
+static void CGX_VideoQuitI(_THIS, struct SDLBase *SDLBase)
+#endif
+{
+	/* Shutdown everything that's still up */
+	/* The event thread should be done, so we can touch SDL_Display */
+	D(bug("CGX_VideoQuit\n"));
+
+	if ( SDL_Display != NULL )
+	{
+		/* Clean up OpenGL */
+		CGX_GL_Quit(this);
+
+		/* Start shutting down the windows */
+		D(bug("Destroying image...\n"));
+		CGX_DestroyImage(this, this->screen);
+		D(bug("Destroying window...\n"));
+		CGX_DestroyWindow(this, this->screen, 0);
+		/* Otherwise SDL_VideoQuit will try to free it! */
+		SDL_VideoSurface=NULL;
+		CGX_FreeVideoModes(this);
+
+		/* Free that blank cursor */
+		if ( SDL_BlankCursor != NULL )
+		{
+			FreeMem(SDL_BlankCursor,16);
+			SDL_BlankCursor = NULL;
+		}
+
+		D(bug("Destroying screen...\n"));
+
+		if ( GFX_Display != NULL )
+			CGX_CloseUnlockScreen(this, NULL);
+
+		SDL_Display = NULL;
+	}
+
+	if (SDL_ConReq)
+	{
+		DeleteIORequest(SDL_ConReq);
+		SDL_ConReq = NULL;
+	}
+	
+	if (SDL_ConPort)
+	{
+		DeleteMsgPort(SDL_ConPort);
+		SDL_ConPort = NULL;
+	}
+
+	if ( this->screen && (this->screen->flags & SDL_HWSURFACE) )
+	{
+		/* Direct screen access, no memory buffer */
+		this->screen->pixels = NULL;
+	}
+	D(bug("End of CGX_VideoQuit.\n"));
+
+}
+
+/* Gamma correction functions (Not supported) */
+#if !defined(PROTO_SDL_H)
+static  int CGX_SetGamma(_THIS, float red, float green, float blue)
+#else
+static  int CGX_SetGammaI(_THIS, float red, float green, float blue, struct SDLBase *SDLBase)
+#endif
+{
+	SDL_SetError("Gamma correction not supported");
+	return -1;
+}
+
+#if !defined(PROTO_SDL_H)
+static  int CGX_GetGamma(_THIS, float *red, float *green, float *blue)
+#else
+static  int CGX_GetGammaI(_THIS, float *red, float *green, float *blue, struct SDLBase *SDLBase)
+#endif
+{
+	SDL_SetError("Gamma correction not supported");
+	return -1;
+}
+
+#if !defined(PROTO_SDL_H)
+static  int CGX_SetGammaRamp(_THIS, Uint16 *ramp)
+#else
+static  int CGX_SetGammaRampI(_THIS, Uint16 *ramp, struct SDLBase *SDLBase)
+#endif
+{
+	SDL_SetError("Gamma correction not supported");
+	return(-1);
+}
+
+#if !defined(PROTO_SDL_H)
+static int CGX_GetGammaRamp(_THIS, Uint16 *ramp)
+#else
+static int CGX_GetGammaRampI(_THIS, Uint16 *ramp, struct SDLBase *SDLBase)
+#endif
+{
+	SDL_SetError("Gamma correction not supported");
+	return(-1);
+}
diff -Naur SDL-1.2.15-orig/src/video/cgx/SDL_cgxvideo.h SDL-1.2.15/src/video/cgx/SDL_cgxvideo.h
--- SDL-1.2.15-orig/src/video/cgx/SDL_cgxvideo.h	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.15/src/video/cgx/SDL_cgxvideo.h	2015-05-09 15:09:59.769739506 +0200
@@ -0,0 +1,138 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#ifndef _SDL_cgxvideo_h
+#define _SDL_cgxvideo_h
+
+
+#include <exec/exec.h>
+#include <cybergraphx/cybergraphics.h>
+#include <graphics/scale.h>
+#include <graphics/gfx.h>
+#include <intuition/intuition.h>
+#include <proto/exec.h>
+#include <proto/cybergraphics.h>
+#include <proto/graphics.h>
+#include <proto/intuition.h>
+#include <proto/console.h>
+#include <devices/rawkeycodes.h>
+
+#include "SDL_mouse.h"
+#include "../SDL_sysvideo.h"
+#include "../../main/aros/mydebug.h"
+
+/* Hidden "this" pointer for the video functions */
+#define _THIS	SDL_VideoDevice *this
+#define WINDOW_NAME_BUFFER_SIZE	256
+
+/* Private display data */
+struct SDL_PrivateVideoData {
+    struct Screen 	*Public_Display; 	/* Used for events and window management */
+    struct Screen 	*GFX_Display;		/* Used for graphics and colormap stuff */
+    struct Window 	*SDL_Window;		/* The SDL Window */
+	struct RastPort *RP;
+	TEXT			WindowName[WINDOW_NAME_BUFFER_SIZE];
+	
+    unsigned char *BlankCursor;			/* The invisible cursor */
+
+    /* The variables used for displaying graphics */
+    Uint8 *Image;						/* The image for our window */
+	
+    /* The current list of available video modes */
+    SDL_Rect **modelist;
+
+    /* available visuals of interest to us, sorted deepest first */
+    struct {
+		Uint32 visual;
+		int depth;						/* number of significant bits/pixel */
+		int bpp;						/* pixel quantum in bits */
+    } visuals[5];						/* at most entries for 8, 15, 16, 24, 32*/
+    int nvisuals;
+
+    Uint32 vis;						/* current visual in use */
+    int depth;						/* current visual depth (not bpp) */
+    int currently_fullscreen;		/* Fullscreen flag */
+	
+	/* Support for internal mouse warping */
+	int FocusActive;				/* Flag indicating that application has keyboard/mouse focus */
+	int WindowActive;				/* Flag indicating that AROS Window in in active state */
+	int GrabMouse;					/* Flag indicating that mouse shall be grabbed */
+	int CursorVisible;				/* Flag indicating that cursor is visible */
+	int ExplicitFocusActivation;	/* Flag indicating that focus should not be activated automatically when moving to inner area */
+	int LastMouseX;
+	int LastMouseY;
+	
+	/* Double buffering handling */
+	int dbuffer;					/* flag indicating that double buffering is in use */
+	struct ScreenBuffer *SB[2];		/* Double buffered screens */
+	struct MsgPort 	*safeport;
+	struct MsgPort 	*dispport;
+	ULONG safe_sigbit;
+	ULONG disp_sigbit;
+	struct BitMap *BlitBitMap;		/* Used to fake double buffering in Window mode, also used in FullScreen if AllocScreenBuffer fails */
+	
+	/* Temporary rastport used for HW bliting to non display surface */
+	struct RastPort *temprp;
+	
+    /* Colormap handling */
+    Sint32 *Pens;					/* A list of Pens that have been allocated, the size depends on the screen format */
+};
+
+/* Old variable names */
+#define SDL_Display				(this->hidden->Public_Display)
+#define GFX_Display				(this->hidden->GFX_Display)
+#define SDL_Visual				(this->hidden->vis)
+#define SDL_Window				(this->hidden->SDL_Window)
+#define SDL_BlankCursor			(this->hidden->BlankCursor)
+#define SDL_Image				(this->hidden->Image)
+#define SDL_modelist			(this->hidden->modelist)
+#define SDL_RastPort			(this->hidden->RP)
+#define currently_fullscreen	(this->hidden->currently_fullscreen)
+#define SDL_DisplayColormap		(this->hidden->GFX_Display->ViewPort.ColorMap)
+#define SDL_Pens				(this->hidden->Pens)
+#define SDL_temprp				(this->hidden->temprp)
+
+extern struct Library 			*CyberGfxBase;
+extern struct IntuitionBase 	*IntuitionBase;
+extern struct GfxBase 			*GfxBase;
+extern struct ExecBase 			*SysBase;
+extern struct DosLibrary 		*DOSBase;
+
+extern struct IOStdReq 			*SDL_ConReq;
+extern struct MsgPort			*SDL_ConPort;
+
+/* Private data for HW surfaces */
+struct private_hwdata
+{
+	struct BitMap 			*bmap;				// Pointer to HW surface bitmap
+	APTR 					lock;				// Pointer to lock
+	struct SDL_VideoDevice 	*videodata;			// Needed to keep track of window BorderLeft and BorderTop while bliting
+	APTR 					mask;				// Mask used for ColorKey bliting
+	APTR					pixarrayalpha;		// Pixel array with alpha channel used for Alpha and ColorKey bliting
+	ULONG					pixfmt;				// pixfmt of the surface
+	BOOL 					allocated;			// Set to 1 if the bitmap has been allocated (remains 0 for the display surface)
+	BOOL					update;				// Flag used to force pending display update due to locks on destination surface after unlocking
+};
+
+#endif /* _SDL_cgxvideo_h */
+
diff -Naur SDL-1.2.15-orig/src/video/cgx/SDL_cgxwm.c SDL-1.2.15/src/video/cgx/SDL_cgxwm.c
--- SDL-1.2.15-orig/src/video/cgx/SDL_cgxwm.c	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.15/src/video/cgx/SDL_cgxwm.c	2015-05-09 15:09:59.769739506 +0200
@@ -0,0 +1,111 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
+#include "SDL_config.h"
+
+#include "SDL_version.h"
+#include "SDL_video.h"
+#include "SDL_syswm.h"
+#include "SDL_mouse.h"
+#include "../../events/SDL_events_c.h"
+#include "SDL_cgxmodes_c.h"
+#include "SDL_cgxwm_c.h"
+#include "SDL_cgxmouse_c.h"
+
+#if !defined(PROTO_SDL_H)
+void CGX_SetIcon(_THIS, SDL_Surface *icon, Uint8 *mask)
+#else
+#include "SDL_intern.h"
+
+void CGX_SetIconI(_THIS, SDL_Surface *icon, Uint8 *mask, struct SDLBase *SDLBase)
+#endif
+{
+	/* Not yet implemented */
+}
+
+#if !defined(PROTO_SDL_H)
+int CGX_IconifyWindow(_THIS)
+#else
+int CGX_IconifyWindowI(_THIS, struct SDLBase *SDLBase)
+#endif
+{
+	/* Not yet implemented */
+	return 0;
+}
+
+#if !defined(PROTO_SDL_H)
+void CGX_SetCaption(_THIS, const char *title, const char *icon)
+#else
+void CGX_SetCaptionI(_THIS, const char *title, const char *icon, struct SDLBase *SDLBase)
+#endif
+{
+	strncpy(this->hidden->WindowName, title, WINDOW_NAME_BUFFER_SIZE);
+	if(SDL_Window) SetWindowTitles(SDL_Window, this->hidden->WindowName, NULL);
+}
+
+#if !defined(PROTO_SDL_H)
+int CGX_GetWMInfo(_THIS, SDL_SysWMinfo *info)
+#else
+int CGX_GetWMInfoI(_THIS, SDL_SysWMinfo *info, struct SDLBase *SDLBase)
+#endif
+{
+	if ( info->version.major <= SDL_MAJOR_VERSION )
+	{
+		return(1);
+	}
+	else
+	{
+		SDL_SetError("Application not compiled with SDL %d.%d\n", SDL_MAJOR_VERSION, SDL_MINOR_VERSION);
+		return(-1);
+	}
+}
+
+#if !defined(PROTO_SDL_H)
+SDL_GrabMode CGX_GrabWMInput(_THIS, SDL_GrabMode mode)
+#else
+SDL_GrabMode CGX_GrabWMInputI(_THIS, SDL_GrabMode mode, struct SDLBase *SDLBase)
+#endif
+{
+	D(bug("CGX_GrabWMInput()\n"));
+
+	SDL_Lock_EventThread();
+	
+	if ( this->screen == NULL )	return(SDL_GRAB_OFF);
+	if ( ! SDL_Window ) return(mode);	/* Will be set later on mode switch */
+
+
+	if (mode == SDL_GRAB_OFF)
+		this->hidden->GrabMouse = 0;
+	else /* Match the X11 driver behaviour - this always grabs at full screen. Yes - condition makes no sense. */
+	{
+		this->hidden->GrabMouse = 1;
+		CGX_WarpWMCursor(this, this->screen->w / 2, this->screen->h / 2); /* Jump into window */
+	}
+		
+	SDL_Unlock_EventThread();
+	return(mode);
+}
+
diff -Naur SDL-1.2.15-orig/src/video/cgx/SDL_cgxwm_c.h SDL-1.2.15/src/video/cgx/SDL_cgxwm_c.h
--- SDL-1.2.15-orig/src/video/cgx/SDL_cgxwm_c.h	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.15/src/video/cgx/SDL_cgxwm_c.h	2015-05-09 15:09:59.769739506 +0200
@@ -0,0 +1,45 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#include "SDL_cgxvideo.h"
+
+/* Functions to be exported */
+#if !defined(PROTO_SDL_H)
+extern void 		CGX_SetCaption(_THIS, const char *title, const char *icon);
+extern void 		CGX_SetIcon(_THIS, SDL_Surface *icon, Uint8 *mask);
+extern int			CGX_IconifyWindow(_THIS);
+extern int 			CGX_GetWMInfo(_THIS, SDL_SysWMinfo *info);
+extern SDL_GrabMode CGX_GrabWMInput(_THIS, SDL_GrabMode mode);
+#else
+extern void CGX_SetCaptionI(_THIS, const char *title, const char *icon, struct SDLBase *SDLBase);
+extern void CGX_SetIconI(_THIS, SDL_Surface *icon, Uint8 *mask, struct SDLBase *SDLBase);
+extern int CGX_IconifyWindowI(_THIS, struct SDLBase *SDLBase);
+extern int CGX_GetWMInfoI(_THIS, SDL_SysWMinfo *info, struct SDLBase *SDLBase);
+extern SDL_GrabMode CGX_GrabWMInputI(_THIS, SDL_GrabMode mode, struct SDLBase *SDLBase);
+
+#define CGX_SetCaption(this, title, icon) CGX_SetCaptionI(this, title, icon, SDLBase)
+#define CGX_SetIcon(this, icon, mask) CGX_SetIconI(this, icon, mask, SDLBase)
+#define CGX_IconifyWindow(this) CGX_IconifyWindowI(this, SDLBase)
+#define CGX_GetWMInfo(this, info) CGX_GetWMInfoI(this, info, SDLBase)
+#define CGX_GrabWMInput(this, mode) CGX_GrabWMInputI(this, mode, SDLBase)
+#endif
diff -Naur SDL-1.2.15-orig/src/video/dummy/SDL_nullevents.c SDL-1.2.15/src/video/dummy/SDL_nullevents.c
--- SDL-1.2.15-orig/src/video/dummy/SDL_nullevents.c	2015-05-09 17:47:54.283774294 +0200
+++ SDL-1.2.15/src/video/dummy/SDL_nullevents.c	2015-05-09 15:09:59.769739506 +0200
@@ -19,6 +19,11 @@
     Sam Lantinga
     slouken@libsdl.org
 */
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
 #include "SDL_config.h"
 
 /* Being a null driver, there's no event stream. We just define stubs for
@@ -31,12 +36,20 @@
 #include "SDL_nullvideo.h"
 #include "SDL_nullevents_c.h"
 
+#if !defined(PROTO_SDL_H)
 void DUMMY_PumpEvents(_THIS)
+#else
+void DUMMY_PumpEvents(_THIS, struct SDLBase *SDLBase)
+#endif
 {
 	/* do nothing. */
 }
 
+#if !defined(PROTO_SDL_H)
 void DUMMY_InitOSKeymap(_THIS)
+#else
+void DUMMY_InitOSKeymap(_THIS, struct SDLBase *SDLBase)
+#endif
 {
 	/* do nothing. */
 }
diff -Naur SDL-1.2.15-orig/src/video/dummy/SDL_nullevents_c.h SDL-1.2.15/src/video/dummy/SDL_nullevents_c.h
--- SDL-1.2.15-orig/src/video/dummy/SDL_nullevents_c.h	2015-05-09 17:47:54.283774294 +0200
+++ SDL-1.2.15/src/video/dummy/SDL_nullevents_c.h	2015-05-09 15:09:59.769739506 +0200
@@ -26,8 +26,13 @@
 /* Variables and functions exported by SDL_sysevents.c to other parts 
    of the native video subsystem (SDL_sysvideo.c)
 */
+#if !defined(PROTO_SDL_H)
 extern void DUMMY_InitOSKeymap(_THIS);
 extern void DUMMY_PumpEvents(_THIS);
+#else
+extern void DUMMY_InitOSKeymap(_THIS, struct SDLBase *SDLBase);
+extern void DUMMY_PumpEvents(_THIS, struct SDLBase *SDLBase);
+#endif
 
 /* end of SDL_nullevents_c.h ... */
 
diff -Naur SDL-1.2.15-orig/src/video/dummy/SDL_nullmouse.c SDL-1.2.15/src/video/dummy/SDL_nullmouse.c
--- SDL-1.2.15-orig/src/video/dummy/SDL_nullmouse.c	2015-05-09 17:47:54.283774294 +0200
+++ SDL-1.2.15/src/video/dummy/SDL_nullmouse.c	2015-05-09 15:09:59.770739504 +0200
@@ -19,6 +19,11 @@
     Sam Lantinga
     slouken@libsdl.org
 */
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
 #include "SDL_config.h"
 
 #include "SDL_mouse.h"
diff -Naur SDL-1.2.15-orig/src/video/dummy/SDL_nullvideo.c SDL-1.2.15/src/video/dummy/SDL_nullvideo.c
--- SDL-1.2.15-orig/src/video/dummy/SDL_nullvideo.c	2015-05-09 17:47:54.283774294 +0200
+++ SDL-1.2.15/src/video/dummy/SDL_nullvideo.c	2015-05-09 15:09:59.770739504 +0200
@@ -19,6 +19,11 @@
     Sam Lantinga
     slouken@libsdl.org
 */
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
 #include "SDL_config.h"
 
 /* Dummy SDL video driver implementation; this is just enough to make an
@@ -48,6 +53,7 @@
 
 #define DUMMYVID_DRIVER_NAME "dummy"
 
+#if !defined(PROTO_SDL_H)
 /* Initialization/Query functions */
 static int DUMMY_VideoInit(_THIS, SDL_PixelFormat *vformat);
 static SDL_Rect **DUMMY_ListModes(_THIS, SDL_PixelFormat *format, Uint32 flags);
@@ -63,10 +69,27 @@
 
 /* etc. */
 static void DUMMY_UpdateRects(_THIS, int numrects, SDL_Rect *rects);
+#else
+#include "SDL_intern.h"
 
+static int DUMMY_VideoInit(_THIS, SDL_PixelFormat *vformat, struct SDLBase *SDLBase);
+static SDL_Rect **DUMMY_ListModes(_THIS, SDL_PixelFormat *format, Uint32 flags, struct SDLBase *SDLBase);
+static SDL_Surface *DUMMY_SetVideoMode(_THIS, SDL_Surface *current, int width, int height, int bpp, Uint32 flags, struct SDLBase *SDLBase);
+static int DUMMY_SetColors(_THIS, int firstcolor, int ncolors, SDL_Color *colors, struct SDLBase *SDLBase);
+static void DUMMY_VideoQuit(_THIS, struct SDLBase *SDLBase);
+static int DUMMY_AllocHWSurface(_THIS, SDL_Surface *surface, struct SDLBase *SDLBase);
+static int DUMMY_LockHWSurface(_THIS, SDL_Surface *surface, struct SDLBase *SDLBase);
+static void DUMMY_UnlockHWSurface(_THIS, SDL_Surface *surface, struct SDLBase *SDLBase);
+static void DUMMY_FreeHWSurface(_THIS, SDL_Surface *surface, struct SDLBase *SDLBase);
+static void DUMMY_UpdateRects(_THIS, int numrects, SDL_Rect *rects, struct SDLBase *SDLBase);
+#endif
 /* DUMMY driver bootstrap functions */
 
+#if !defined(PROTO_SDL_H)
 static int DUMMY_Available(void)
+#else
+static int DUMMY_Available(struct SDLBase *SDLBase)
+#endif
 {
 	const char *envr = SDL_getenv("SDL_VIDEODRIVER");
 	if ((envr) && (SDL_strcmp(envr, DUMMYVID_DRIVER_NAME) == 0)) {
@@ -76,13 +99,21 @@
 	return(0);
 }
 
+#if !defined(PROTO_SDL_H)
 static void DUMMY_DeleteDevice(SDL_VideoDevice *device)
+#else
+static void DUMMY_DeleteDevice(SDL_VideoDevice *device, struct SDLBase *SDLBase)
+#endif
 {
 	SDL_free(device->hidden);
 	SDL_free(device);
 }
 
+#if !defined(PROTO_SDL_H)
 static SDL_VideoDevice *DUMMY_CreateDevice(int devindex)
+#else
+static SDL_VideoDevice *DUMMY_CreateDevice(int devindex, struct SDLBase *SDLBase)
+#endif
 {
 	SDL_VideoDevice *device;
 
@@ -137,8 +168,11 @@
 	DUMMY_Available, DUMMY_CreateDevice
 };
 
-
+#if !defined(PROTO_SDL_H)
 int DUMMY_VideoInit(_THIS, SDL_PixelFormat *vformat)
+#else
+int DUMMY_VideoInit(_THIS, SDL_PixelFormat *vformat, struct SDLBase *SDLBase)
+#endif
 {
 	/*
 	fprintf(stderr, "WARNING: You are using the SDL dummy video driver!\n");
@@ -153,13 +187,21 @@
 	return(0);
 }
 
+#if !defined(PROTO_SDL_H)
 SDL_Rect **DUMMY_ListModes(_THIS, SDL_PixelFormat *format, Uint32 flags)
+#else
+SDL_Rect **DUMMY_ListModes(_THIS, SDL_PixelFormat *format, Uint32 flags, struct SDLBase *SDLBase)
+#endif
 {
    	 return (SDL_Rect **) -1;
 }
 
+#if !defined(PROTO_SDL_H)
 SDL_Surface *DUMMY_SetVideoMode(_THIS, SDL_Surface *current,
 				int width, int height, int bpp, Uint32 flags)
+#else
+SDL_Surface *DUMMY_SetVideoMode(_THIS, SDL_Surface *current, int width, int height, int bpp, Uint32 flags, struct SDLBase *SDLBase)
+#endif
 {
 	if ( this->hidden->buffer ) {
 		SDL_free( this->hidden->buffer );
@@ -195,32 +237,56 @@
 }
 
 /* We don't actually allow hardware surfaces other than the main one */
+#if !defined(PROTO_SDL_H)
 static int DUMMY_AllocHWSurface(_THIS, SDL_Surface *surface)
+#else
+static int DUMMY_AllocHWSurface(_THIS, SDL_Surface *surface, struct SDLBase *SDLBase)
+#endif
 {
 	return(-1);
 }
+#if !defined(PROTO_SDL_H)
 static void DUMMY_FreeHWSurface(_THIS, SDL_Surface *surface)
+#else
+static void DUMMY_FreeHWSurface(_THIS, SDL_Surface *surface, struct SDLBase *SDLBase)
+#endif
 {
 	return;
 }
 
 /* We need to wait for vertical retrace on page flipped displays */
+#if !defined(PROTO_SDL_H)
 static int DUMMY_LockHWSurface(_THIS, SDL_Surface *surface)
+#else
+static int DUMMY_LockHWSurface(_THIS, SDL_Surface *surface, struct SDLBase *SDLBase)
+#endif
 {
 	return(0);
 }
 
+#if !defined(PROTO_SDL_H)
 static void DUMMY_UnlockHWSurface(_THIS, SDL_Surface *surface)
+#else
+static void DUMMY_UnlockHWSurface(_THIS, SDL_Surface *surface, struct SDLBase *SDLBase)
+#endif
 {
 	return;
 }
 
+#if !defined(PROTO_SDL_H)
 static void DUMMY_UpdateRects(_THIS, int numrects, SDL_Rect *rects)
+#else
+static void DUMMY_UpdateRects(_THIS, int numrects, SDL_Rect *rects, struct SDLBase *SDLBase)
+#endif
 {
 	/* do nothing. */
 }
 
+#if !defined(PROTO_SDL_H)
 int DUMMY_SetColors(_THIS, int firstcolor, int ncolors, SDL_Color *colors)
+#else
+int DUMMY_SetColors(_THIS, int firstcolor, int ncolors, SDL_Color *colors, struct SDLBase *SDLBase)
+#endif
 {
 	/* do nothing of note. */
 	return(1);
@@ -229,7 +295,11 @@
 /* Note:  If we are terminated, this could be called in the middle of
    another SDL video routine -- notably UpdateRects.
 */
+#if !defined(PROTO_SDL_H)
 void DUMMY_VideoQuit(_THIS)
+#else
+void DUMMY_VideoQuit(_THIS, struct SDLBase *SDLBase)
+#endif
 {
 	if (this->screen->pixels != NULL)
 	{
diff -Naur SDL-1.2.15-orig/src/video/SDL_blit_0.c SDL-1.2.15/src/video/SDL_blit_0.c
--- SDL-1.2.15-orig/src/video/SDL_blit_0.c	2015-05-09 17:47:54.310774223 +0200
+++ SDL-1.2.15/src/video/SDL_blit_0.c	2015-05-09 15:09:59.770739504 +0200
@@ -19,6 +19,11 @@
     Sam Lantinga
     slouken@libsdl.org
 */
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
 #include "SDL_config.h"
 
 #include "SDL_video.h"
@@ -440,7 +445,11 @@
     NULL, BlitBto1Key, BlitBto2Key, BlitBto3Key, BlitBto4Key
 };
 
+#if !defined(PROTO_SDL_H)
 SDL_loblit SDL_CalculateBlit0(SDL_Surface *surface, int blit_index)
+#else
+SDL_loblit SDL_CalculateBlit0I(SDL_Surface *surface, int blit_index, struct SDLBase *SDLBase)
+#endif
 {
 	int which;
 
diff -Naur SDL-1.2.15-orig/src/video/SDL_blit_1.c SDL-1.2.15/src/video/SDL_blit_1.c
--- SDL-1.2.15-orig/src/video/SDL_blit_1.c	2015-05-09 17:47:54.309774226 +0200
+++ SDL-1.2.15/src/video/SDL_blit_1.c	2015-05-09 15:09:59.770739504 +0200
@@ -19,6 +19,11 @@
     Sam Lantinga
     slouken@libsdl.org
 */
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
 #include "SDL_config.h"
 
 #include "SDL_video.h"
@@ -491,7 +496,11 @@
         NULL, Blit1to1Key, Blit1to2Key, Blit1to3Key, Blit1to4Key
 };
 
+#if !defined(PROTO_SDL_H)
 SDL_loblit SDL_CalculateBlit1(SDL_Surface *surface, int blit_index)
+#else
+SDL_loblit SDL_CalculateBlit1I(SDL_Surface *surface, int blit_index, struct SDLBase *SDLBase)
+#endif
 {
 	int which;
 	SDL_PixelFormat *dstfmt;
diff -Naur SDL-1.2.15-orig/src/video/SDL_blit_A.c SDL-1.2.15/src/video/SDL_blit_A.c
--- SDL-1.2.15-orig/src/video/SDL_blit_A.c	2015-05-09 17:47:54.282774297 +0200
+++ SDL-1.2.15/src/video/SDL_blit_A.c	2015-05-09 15:09:59.770739504 +0200
@@ -19,6 +19,11 @@
     Sam Lantinga
     slouken@libsdl.org
 */
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
 #include "SDL_config.h"
 
 #include "SDL_video.h"
@@ -2719,8 +2724,11 @@
 	}
 }
 
-
+#if !defined(PROTO_SDL_H)
 SDL_loblit SDL_CalculateAlphaBlit(SDL_Surface *surface, int blit_index)
+#else
+SDL_loblit SDL_CalculateAlphaBlitI(SDL_Surface *surface, int blit_index, struct SDLBase *SDLBase)
+#endif
 {
     SDL_PixelFormat *sf = surface->format;
     SDL_PixelFormat *df = surface->map->dst->format;
diff -Naur SDL-1.2.15-orig/src/video/SDL_blit.c SDL-1.2.15/src/video/SDL_blit.c
--- SDL-1.2.15-orig/src/video/SDL_blit.c	2015-05-09 17:47:54.282774297 +0200
+++ SDL-1.2.15/src/video/SDL_blit.c	2015-05-09 15:09:59.771739502 +0200
@@ -19,6 +19,11 @@
     Sam Lantinga
     slouken@libsdl.org
 */
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
 #include "SDL_config.h"
 
 #include "SDL_video.h"
@@ -39,6 +44,12 @@
 #include "mmx.h"
 #endif
 
+#if defined(PROTO_SDL_H)
+#include "SDL_intern.h"
+
+#define current_video SDLBase->current_video
+#endif
+
 /* The general purpose software blit routine */
 static int SDL_SoftBlit(SDL_Surface *src, SDL_Rect *srcrect,
 			SDL_Surface *dst, SDL_Rect *dstrect)
@@ -47,6 +58,9 @@
 	int src_locked;
 	int dst_locked;
 
+#if defined(PROTO_SDL_H)
+        struct Library __unused *SDLBase = src->SDLLib;
+#endif
 	/* Everything is okay at the beginning...  */
 	okay = 1;
 
@@ -75,6 +89,10 @@
 		SDL_loblit RunBlit;
 
 		/* Set up the blit information */
+
+#if defined(PROTO_SDL_H)
+                info.SDLLib = SDLBase;
+#endif
 		info.s_pixels = (Uint8 *)src->pixels +
 				(Uint16)srcrect->y*src->pitch +
 				(Uint16)srcrect->x*src->format->BytesPerPixel;
@@ -158,6 +176,10 @@
 	int w, h;
 	int srcskip, dstskip;
 
+#if defined(PROTO_SDL_H)
+        struct Library __unused *SDLBase = info->SDLLib;
+#endif
+
 	w = info->d_width*info->dst->BytesPerPixel;
 	h = info->d_height;
 	src = info->s_pixels;
@@ -206,6 +228,10 @@
 	int w, h;
 	int srcskip, dstskip;
 
+#if defined(PROTO_SDL_H)
+        struct Library __unused *SDLBase = info->SDLLib;
+#endif
+
 	w = info->d_width*info->dst->BytesPerPixel;
 	h = info->d_height;
 	src = info->s_pixels;
@@ -230,7 +256,11 @@
 }
 
 /* Figure out which of many blit routines to set up on a surface */
+#if !defined(PROTO_SDL_H)
 int SDL_CalculateBlit(SDL_Surface *surface)
+#else
+int SDL_CalculateBlitI(SDL_Surface *surface, struct SDLBase *SDLBase)
+#endif
 {
 	int blit_index;
 
@@ -275,7 +305,11 @@
 		if ( hw_blit_ok ) {
 			SDL_VideoDevice *video = current_video;
 			SDL_VideoDevice *this  = current_video;
+#if !defined(PROTO_SDL_H)
 			video->CheckHWBlit(this, surface, surface->map->dst);
+#else
+			video->CheckHWBlit(this, surface, surface->map->dst, SDLBase);
+#endif
 		}
 	}
 	
@@ -286,7 +320,11 @@
 			if ( current_video->info.blit_hw_A ) {
 				SDL_VideoDevice *video = current_video;
 				SDL_VideoDevice *this  = current_video;
+#if !defined(PROTO_SDL_H)
 				video->CheckHWBlit(this, surface, surface->map->dst);
+#else
+				video->CheckHWBlit(this, surface, surface->map->dst, SDLBase);
+#endif
 			}
 	}
 
diff -Naur SDL-1.2.15-orig/src/video/SDL_blit.h SDL-1.2.15/src/video/SDL_blit.h
--- SDL-1.2.15-orig/src/video/SDL_blit.h	2015-05-09 17:47:54.281774300 +0200
+++ SDL-1.2.15/src/video/SDL_blit.h	2015-05-09 15:09:59.771739502 +0200
@@ -40,6 +40,9 @@
 	SDL_PixelFormat *src;
 	Uint8 *table;
 	SDL_PixelFormat *dst;
+#if defined(__AROS__)
+    struct Library *SDLLib;
+#endif
 } SDL_BlitInfo;
 
 /* The type definition for the low level blit functions */
@@ -67,14 +70,28 @@
 } SDL_BlitMap;
 
 
+#if !defined(PROTO_SDL_H)
 /* Functions found in SDL_blit.c */
 extern int SDL_CalculateBlit(SDL_Surface *surface);
-
 /* Functions found in SDL_blit_{0,1,N,A}.c */
 extern SDL_loblit SDL_CalculateBlit0(SDL_Surface *surface, int complex);
 extern SDL_loblit SDL_CalculateBlit1(SDL_Surface *surface, int complex);
 extern SDL_loblit SDL_CalculateBlitN(SDL_Surface *surface, int complex);
 extern SDL_loblit SDL_CalculateAlphaBlit(SDL_Surface *surface, int complex);
+#else
+#include "SDL_intern.h"
+
+extern int SDL_CalculateBlitI(SDL_Surface *surface, struct SDLBase *SDLBase);
+extern SDL_loblit SDL_CalculateBlit0I(SDL_Surface *surface, int complex, struct SDLBase *SDLBase);
+extern SDL_loblit SDL_CalculateBlit1I(SDL_Surface *surface, int complex, struct SDLBase *SDLBase);
+extern SDL_loblit SDL_CalculateBlitNI(SDL_Surface *surface, int complex, struct SDLBase *SDLBase);
+extern SDL_loblit SDL_CalculateAlphaBlitI(SDL_Surface *surface, int complex, struct SDLBase *SDLBase);
+#define SDL_CalculateBlit(surface) SDL_CalculateBlitI(surface, SDLBase)
+#define SDL_CalculateBlit0(surface, complex) SDL_CalculateBlit0I(surface, complex, SDLBase)
+#define SDL_CalculateBlit1(surface, complex) SDL_CalculateBlit1I(surface, complex, SDLBase)
+#define SDL_CalculateBlitN(surface, complex) SDL_CalculateBlitNI(surface, complex, SDLBase)
+#define SDL_CalculateAlphaBlit(surface, complex) SDL_CalculateAlphaBlitI(surface, complex, SDLBase)
+#endif
 
 /*
  * Useful macros for blitting routines
diff -Naur SDL-1.2.15-orig/src/video/SDL_blit_N.c SDL-1.2.15/src/video/SDL_blit_N.c
--- SDL-1.2.15-orig/src/video/SDL_blit_N.c	2015-05-09 17:47:54.284774292 +0200
+++ SDL-1.2.15/src/video/SDL_blit_N.c	2015-05-09 15:09:59.771739502 +0200
@@ -19,6 +19,11 @@
     Sam Lantinga
     slouken@libsdl.org
 */
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
 #include "SDL_config.h"
 
 #include "SDL_video.h"
@@ -2371,7 +2376,11 @@
 /* Mask matches table, or table entry is zero */
 #define MASKOK(x, y) (((x) == (y)) || ((y) == 0x00000000))
 
+#if !defined(PROTO_SDL_H)
 SDL_loblit SDL_CalculateBlitN(SDL_Surface *surface, int blit_index)
+#else
+SDL_loblit SDL_CalculateBlitNI(SDL_Surface *surface, int blit_index, struct SDLBase *SDLBase)
+#endif
 {
 	struct private_swaccel *sdata;
 	SDL_PixelFormat *srcfmt;
diff -Naur SDL-1.2.15-orig/src/video/SDL_bmp.c SDL-1.2.15/src/video/SDL_bmp.c
--- SDL-1.2.15-orig/src/video/SDL_bmp.c	2015-05-09 17:47:54.282774297 +0200
+++ SDL-1.2.15/src/video/SDL_bmp.c	2015-05-09 15:09:59.772739500 +0200
@@ -19,6 +19,11 @@
     Sam Lantinga
     slouken@libsdl.org
 */
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
 #include "SDL_config.h"
 
 /* 
@@ -44,9 +49,19 @@
 #define BI_BITFIELDS	3
 #endif
 
+struct SDLBase;
 
+#if !defined(PROTO_SDL_H)
 SDL_Surface * SDL_LoadBMP_RW (SDL_RWops *src, int freesrc)
 {
+#else
+AROS_LH2(SDL_Surface *, SDL_LoadBMP_RW,
+	AROS_LHA(SDL_RWops *, src, A0),
+	AROS_LHA(int, freesrc, D0),
+	struct SDLBase *, SDLBase, 22, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	SDL_bool was_error;
 	long fp_offset = 0;
 	int bmpPitch;
@@ -355,10 +370,23 @@
 		SDL_RWclose(src);
 	}
 	return(surface);
+#if defined(PROTO_SDL_H)
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 int SDL_SaveBMP_RW (SDL_Surface *saveme, SDL_RWops *dst, int freedst)
 {
+#else
+AROS_LH3(int, SDL_SaveBMP_RW,
+	AROS_LHA(SDL_Surface *, saveme, A0),
+	AROS_LHA(SDL_RWops *, dst, A1),
+	AROS_LHA(int, freedst, D0),
+	struct SDLBase *, SDLBase, 52, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	long fp_offset;
 	int i, pad;
 	SDL_Surface *surface;
@@ -546,4 +574,7 @@
 		SDL_RWclose(dst);
 	}
 	return((SDL_strcmp(SDL_GetError(), "") == 0) ? 0 : -1);
+#if defined(PROTO_SDL_H)
+    AROS_LIBFUNC_EXIT
+#endif
 }
diff -Naur SDL-1.2.15-orig/src/video/SDL_cursor.c SDL-1.2.15/src/video/SDL_cursor.c
--- SDL-1.2.15-orig/src/video/SDL_cursor.c	2015-05-09 17:47:54.309774226 +0200
+++ SDL-1.2.15/src/video/SDL_cursor.c	2015-05-09 15:09:59.772739500 +0200
@@ -19,6 +19,11 @@
     Sam Lantinga
     slouken@libsdl.org
 */
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
 #include "SDL_config.h"
 
 /* General cursor handling code for SDL */
@@ -35,13 +40,30 @@
 #include "../events/SDL_events_c.h"
 
 /* These are static for our cursor handling code */
+#if !defined(PROTO_SDL_H)
 volatile int SDL_cursorstate = CURSOR_VISIBLE;
 SDL_Cursor *SDL_cursor = NULL;
 static SDL_Cursor *SDL_defcursor = NULL;
 SDL_mutex *SDL_cursorlock = NULL;
+#else
+#include "SDL_intern.h"
+
+#define SDL_cursorstate SDLBase->SDL_cursorstate
+#define SDL_cursor SDLBase->SDL_cursor
+#define SDL_defcursor SDLBase->SDL_defcursor
+#define SDL_cursorlock SDLBase->SDL_cursorlock
+#define palette_changed SDLBase->palette_changed
+#define pixels8 SDLBase->pixels8
+
+#define current_video SDLBase->current_video
+#endif
 
 /* Public functions */
+#if !defined(PROTO_SDL_H)
 void SDL_CursorQuit(void)
+#else
+void SDL_CursorQuitI(struct SDLBase *SDLBase)
+#endif
 {
 	if ( SDL_cursor != NULL ) {
 		SDL_Cursor *cursor;
@@ -62,7 +84,11 @@
 		SDL_cursorlock = NULL;
 	}
 }
+#if !defined(PROTO_SDL_H)
 int SDL_CursorInit(Uint32 multithreaded)
+#else
+int SDL_CursorInitI(Uint32 multithreaded, struct SDLBase *SDLBase)
+#endif
 {
 	/* We don't have mouse focus, and the cursor isn't drawn yet */
 #ifndef IPOD
@@ -105,9 +131,22 @@
 #endif
 
 /* Software cursor drawing support */
+#if !defined(PROTO_SDL_H)
 SDL_Cursor * SDL_CreateCursor (Uint8 *data, Uint8 *mask, 
 					int w, int h, int hot_x, int hot_y)
 {
+#else
+AROS_LH6(SDL_Cursor *, SDL_CreateCursor,
+	AROS_LHA(Uint8 *, data, A0),
+	AROS_LHA(Uint8 *, mask, A1),
+	AROS_LHA(int, w, D0),
+	AROS_LHA(int, h, D1),
+	AROS_LHA(int, hot_x, D2),
+	AROS_LHA(int, hot_y, D3),
+	struct SDLBase *, SDLBase, 116, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	SDL_VideoDevice *video = current_video;
 	int savelen;
 	int i;
@@ -153,20 +192,36 @@
 
 	/* If the window manager gives us a good cursor, we're done! */
 	if ( video->CreateWMCursor ) {
+#if !defined(PROTO_SDL_H)
 		cursor->wm_cursor = video->CreateWMCursor(video, data, mask,
 							w, h, hot_x, hot_y);
+#else
+		cursor->wm_cursor = video->CreateWMCursor(video, data, mask,
+							w, h, hot_x, hot_y, SDLBase);
+#endif
 	} else {
 		cursor->wm_cursor = NULL;
 	}
 	return(cursor);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 /* SDL_SetCursor(NULL) can be used to force the cursor redraw,
    if this is desired for any reason.  This is used when setting
    the video mode and when the SDL window gains the mouse focus.
  */
+#if !defined(PROTO_SDL_H)
 void SDL_SetCursor (SDL_Cursor *cursor)
 {
+#else
+AROS_LH1(void, SDL_SetCursor,
+	AROS_LHA(SDL_Cursor *, cursor, A0),
+	struct SDLBase *, SDLBase, 117, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	SDL_VideoDevice *video = current_video;
 	SDL_VideoDevice *this  = current_video;
 
@@ -189,7 +244,11 @@
 			   showing the new one.  (But don't erase NULL cursor)
 			 */
 			if ( SDL_cursor && video->ShowWMCursor ) {
+#if !defined(PROTO_SDL_H)
 				video->ShowWMCursor(this, NULL);
+#else
+				video->ShowWMCursor(this, NULL, SDLBase);
+#endif
 			}
 		}
 		SDL_cursor = cursor;
@@ -200,14 +259,22 @@
 		/* Use window manager cursor if possible */
 		int show_wm_cursor = 0;
 		if ( SDL_cursor->wm_cursor && video->ShowWMCursor ) {
+#if !defined(PROTO_SDL_H)
 			show_wm_cursor = video->ShowWMCursor(this, SDL_cursor->wm_cursor);
+#else
+			show_wm_cursor = video->ShowWMCursor(this, SDL_cursor->wm_cursor, SDLBase);
+#endif
 		}
 		if ( show_wm_cursor ) {
 			SDL_cursorstate &= ~CURSOR_USINGSW;
 		} else {
 			SDL_cursorstate |= CURSOR_USINGSW;
 			if ( video->ShowWMCursor ) {
+#if !defined(PROTO_SDL_H)
 				video->ShowWMCursor(this, NULL);
+#else
+				video->ShowWMCursor(this, NULL, SDLBase);
+#endif
 			}
 			{ int x, y;
 				SDL_GetMouseState(&x, &y);
@@ -223,21 +290,46 @@
 		} else {
 			if ( video ) {
 				if ( video->ShowWMCursor ) {
+#if !defined(PROTO_SDL_H)
 					video->ShowWMCursor(this, NULL);
+#else
+					video->ShowWMCursor(this, NULL, SDLBase);
+#endif
 				}
 			}
 		}
 	}
 	SDL_UnlockCursor();
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 SDL_Cursor * SDL_GetCursor (void)
 {
+#else
+AROS_LH0(SDL_Cursor *, SDL_GetCursor,
+	struct SDLBase *, SDLBase, 118, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	return(SDL_cursor);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 void SDL_FreeCursor (SDL_Cursor *cursor)
 {
+#else
+AROS_LH1(void, SDL_FreeCursor,
+	AROS_LHA(SDL_Cursor *, cursor, A0),
+	struct SDLBase *, SDLBase, 119, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	if ( cursor ) {
 		if ( cursor == SDL_cursor ) {
 			SDL_SetCursor(SDL_defcursor);
@@ -254,16 +346,31 @@
 			}
 			if ( video && cursor->wm_cursor ) {
 				if ( video->FreeWMCursor ) {
+#if !defined(PROTO_SDL_H)
 					video->FreeWMCursor(this, cursor->wm_cursor);
+#else
+					video->FreeWMCursor(this, cursor->wm_cursor, SDLBase);
+#endif
 				}
 			}
 			SDL_free(cursor);
 		}
 	}
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 int SDL_ShowCursor (int toggle)
 {
+#else
+AROS_LH1(int, SDL_ShowCursor,
+	AROS_LHA(int, toggle, D0),
+	struct SDLBase *, SDLBase, 120, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	int showing;
 
 	showing = (SDL_cursorstate & CURSOR_VISIBLE);
@@ -281,17 +388,33 @@
 
 			SDL_SetCursor(NULL);
 			if ( video && video->CheckMouseMode ) {
+#if !defined(PROTO_SDL_H)
 				video->CheckMouseMode(this);
+#else
+				video->CheckMouseMode(this, SDLBase);
+#endif
 			}
 		}
 	} else {
 		/* Query current state */ ;
 	}
 	return(showing ? 1 : 0);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 void SDL_WarpMouse (Uint16 x, Uint16 y)
 {
+#else
+AROS_LH2(void, SDL_WarpMouse,
+	AROS_LHA(Uint16, x, D0),
+	AROS_LHA(Uint16, y, D1),
+	struct SDLBase *, SDLBase, 115, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	SDL_VideoDevice *video = current_video;
 	SDL_VideoDevice *this  = current_video;
 
@@ -312,13 +435,24 @@
 
 	/* This generates a mouse motion event */
 	if ( video->WarpWMCursor ) {
+#if !defined(PROTO_SDL_H)
 		video->WarpWMCursor(this, x, y);
+#else
+		video->WarpWMCursor(this, x, y, SDLBase);
+#endif
 	} else {
 		SDL_PrivateMouseMotion(0, 0, x, y);
 	}
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 void SDL_MoveCursor(int x, int y)
+#else
+void SDL_MoveCursorI(int x, int y, struct SDLBase *SDLBase)
+#endif
 {
 	SDL_VideoDevice *video = current_video;
 
@@ -332,20 +466,32 @@
 		SDL_DrawCursor(SDL_VideoSurface);
 		SDL_UnlockCursor();
 	} else if ( video->MoveWMCursor ) {
+#if !defined(PROTO_SDL_H)
 		video->MoveWMCursor(video, x, y);
+#else
+		video->MoveWMCursor(video, x, y, SDLBase);
+#endif
 	}
 }
 
+#if !defined(PROTO_SDL_H)
 /* Keep track of the current cursor colors */
 static int palette_changed = 1;
 static Uint8 pixels8[2];
 
 void SDL_CursorPaletteChanged(void)
+#else
+void SDL_CursorPaletteChangedI(struct SDLBase *SDLBase)
+#endif
 {
 	palette_changed = 1;
 }
 
+#if !defined(PROTO_SDL_H)
 void SDL_MouseRect(SDL_Rect *area)
+#else
+void SDL_MouseRectI(SDL_Rect *area, struct SDLBase *SDLBase)
+#endif
 {
 	int clip_diff;
 
@@ -368,7 +514,12 @@
 	}
 }
 
+#if !defined(PROTO_SDL_H)
 static void SDL_DrawCursorFast(SDL_Surface *screen, SDL_Rect *area)
+#else
+#define SDL_DrawCursorFast(screen, area) SDL_DrawCursorFastI(screen, area, SDLBase)
+static void SDL_DrawCursorFastI(SDL_Surface *screen, SDL_Rect *area, struct SDLBase *SDLBase)
+#endif
 {
 	const Uint32 pixels[2] = { 0xFFFFFFFF, 0x00000000 };
 	int i, w, h;
@@ -494,7 +645,12 @@
 	}
 }
 
+#if !defined(PROTO_SDL_H)
 static void SDL_DrawCursorSlow(SDL_Surface *screen, SDL_Rect *area)
+#else
+#define SDL_DrawCursorSlow(screen, area) SDL_DrawCursorSlowI(screen, area, SDLBase)
+static void SDL_DrawCursorSlowI(SDL_Surface *screen, SDL_Rect *area, struct SDLBase *SDLBase)
+#endif
 {
 	const Uint32 pixels[2] = { 0xFFFFFF, 0x000000 };
 	int h;
@@ -563,7 +719,12 @@
    This is only necessary when blitting from a shadow surface of a different
    pixel format than the video surface, and using a software rendered cursor.
 */
+#if !defined(PROTO_SDL_H)
 static void SDL_ConvertCursorSave(SDL_Surface *screen, int w, int h)
+#else
+#define SDL_ConvertCursorSave(screen, w, h) SDL_ConvertCursorSaveI(screen, w, h, SDLBase)
+static void SDL_ConvertCursorSaveI(SDL_Surface *screen, int w, int h, struct SDLBase *SDLBase)
+#endif
 {
 	SDL_BlitInfo info;
 	SDL_loblit RunBlit;
@@ -592,7 +753,11 @@
 	RunBlit(&info);
 }
 
+#if !defined(PROTO_SDL_H)
 void SDL_DrawCursorNoLock(SDL_Surface *screen)
+#else
+void SDL_DrawCursorNoLockI(SDL_Surface *screen, struct SDLBase *SDLBase)
+#endif
 {
 	SDL_Rect area;
 
@@ -637,7 +802,11 @@
 	}
 }
 
+#if !defined(PROTO_SDL_H)
 void SDL_DrawCursor(SDL_Surface *screen)
+#else
+void SDL_DrawCursorI(SDL_Surface *screen, struct SDLBase *SDLBase)
+#endif
 {
 	/* Lock the screen if necessary */
 	if ( screen == NULL ) {
@@ -665,12 +834,20 @@
 
 		/* This can be called before a video mode is set */
 		if ( video->UpdateRects ) {
+#if !defined(PROTO_SDL_H)
 			video->UpdateRects(this, 1, &area);
+#else
+			video->UpdateRects(this, 1, &area, SDLBase);
+#endif
 		}
 	}
 }
 
+#if !defined(PROTO_SDL_H)
 void SDL_EraseCursorNoLock(SDL_Surface *screen)
+#else
+void SDL_EraseCursorNoLockI(SDL_Surface *screen, struct SDLBase *SDLBase)
+#endif
 {
 	SDL_Rect area;
 
@@ -711,7 +888,11 @@
 	}
 }
 
+#if !defined(PROTO_SDL_H)
 void SDL_EraseCursor(SDL_Surface *screen)
+#else
+void SDL_EraseCursorI(SDL_Surface *screen, struct SDLBase *SDLBase)
+#endif
 {
 	/* Lock the screen if necessary */
 	if ( screen == NULL ) {
@@ -737,7 +918,11 @@
 
 		SDL_MouseRect(&area);
 		if ( video->UpdateRects ) {
+#if !defined(PROTO_SDL_H)
 			video->UpdateRects(this, 1, &area);
+#else
+			video->UpdateRects(this, 1, &area, SDLBase);
+#endif
 		}
 	}
 }
@@ -745,7 +930,11 @@
 /* Reset the cursor on video mode change
    FIXME:  Keep track of all cursors, and reset them all.
  */
+#if !defined(PROTO_SDL_H)
 void SDL_ResetCursor(void)
+#else
+void SDL_ResetCursorI(struct SDLBase *SDLBase)
+#endif
 {
 	int savelen;
 
diff -Naur SDL-1.2.15-orig/src/video/SDL_cursor_c.h SDL-1.2.15/src/video/SDL_cursor_c.h
--- SDL-1.2.15-orig/src/video/SDL_cursor_c.h	2015-05-09 17:47:54.283774294 +0200
+++ SDL-1.2.15/src/video/SDL_cursor_c.h	2015-05-09 15:09:59.772739500 +0200
@@ -24,6 +24,7 @@
 /* Useful variables and functions from SDL_cursor.c */
 #include "SDL_mouse.h"
 
+#if !defined(PROTO_SDL_H)
 extern int  SDL_CursorInit(Uint32 flags);
 extern void SDL_CursorPaletteChanged(void);
 extern void SDL_DrawCursor(SDL_Surface *screen);
@@ -34,13 +35,42 @@
 extern void SDL_ResetCursor(void);
 extern void SDL_MoveCursor(int x, int y);
 extern void SDL_CursorQuit(void);
+#else
+#include "SDL_intern.h"
+
+extern int  SDL_CursorInitI(Uint32 flags, struct SDLBase *SDLBase);
+extern void SDL_CursorPaletteChangedI(struct SDLBase *SDLBase);
+extern void SDL_DrawCursorI(SDL_Surface *screen, struct SDLBase *SDLBase);
+extern void SDL_DrawCursorNoLockI(SDL_Surface *screen, struct SDLBase *SDLBase);
+extern void SDL_EraseCursorI(SDL_Surface *screen, struct SDLBase *SDLBase);
+extern void SDL_EraseCursorNoLockI(SDL_Surface *screen, struct SDLBase *SDLBase);
+extern void SDL_UpdateCursorI(SDL_Surface *screen, struct SDLBase *SDLBase);
+extern void SDL_ResetCursorI(struct SDLBase *SDLBase);
+extern void SDL_MoveCursorI(int x, int y, struct SDLBase *SDLBase);
+extern void SDL_CursorQuitI(struct SDLBase *SDLBase);
+
+#define SDL_CursorInit(flags) SDL_CursorInitI(flags, SDLBase)
+#define SDL_CursorPaletteChanged() SDL_CursorPaletteChangedI(SDLBase)
+#define SDL_DrawCursor(screen) SDL_DrawCursorI(screen, SDLBase)
+#define SDL_DrawCursorNoLock(screen) SDL_DrawCursorNoLockI(screen, SDLBase)
+#define SDL_EraseCursor(screen) SDL_EraseCursorI(screen, SDLBase)
+#define SDL_EraseCursorNoLock(screen) SDL_EraseCursorNoLockI(screen, SDLBase)
+#define SDL_UpdateCursor(screen) SDL_UpdateCursorI(screen, SDLBase)
+#define SDL_ResetCursor() SDL_ResetCursorI(SDLBase)
+#define SDL_MoveCursor(x, y) SDL_MoveCursorI(x, y, SDLBase)
+#define SDL_CursorQuit() SDL_CursorQuitI(SDLBase)
+#endif
 
 #define INLINE_MOUSELOCK
 #ifdef INLINE_MOUSELOCK
 /* Inline (macro) versions of the mouse lock functions */
 #include "SDL_mutex.h"
 
+#if !defined(PROTO_SDL_H)
 extern SDL_mutex *SDL_cursorlock;
+#else
+#define SDL_cursorlock SDLBase->SDL_cursorlock
+#endif
 
 #define SDL_LockCursor()						\
 	do {								\
@@ -59,15 +89,22 @@
 extern void SDL_UnlockCursor(void);
 #endif /* INLINE_MOUSELOCK */
 
+#if !defined(PROTO_SDL_H)
 /* Only for low-level mouse cursor drawing */
 extern SDL_Cursor *SDL_cursor;
 extern void SDL_MouseRect(SDL_Rect *area);
+extern volatile int SDL_cursorstate;
 
-/* State definitions for the SDL cursor */
 #define CURSOR_VISIBLE	0x01
+#else
+extern void SDL_MouseRectI(SDL_Rect *area, struct SDLBase *SDLBase);
+#define SDL_MouseRect(area) SDL_MouseRectI(area, SDLBase)
+#define SDL_cursorstate SDLBase->SDL_cursorstate
+#endif
+
+/* State definitions for the SDL cursor */
 #define CURSOR_USINGSW	0x10
 #define SHOULD_DRAWCURSOR(X) 						\
 			(((X)&(CURSOR_VISIBLE|CURSOR_USINGSW)) ==  	\
 					(CURSOR_VISIBLE|CURSOR_USINGSW))
 
-extern volatile int SDL_cursorstate;
diff -Naur SDL-1.2.15-orig/src/video/SDL_gamma.c SDL-1.2.15/src/video/SDL_gamma.c
--- SDL-1.2.15-orig/src/video/SDL_gamma.c	2015-05-09 17:47:54.309774226 +0200
+++ SDL-1.2.15/src/video/SDL_gamma.c	2015-05-09 15:09:59.772739500 +0200
@@ -19,6 +19,11 @@
     Sam Lantinga
     slouken@libsdl.org
 */
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
 #include "SDL_config.h"
 
 /* Gamma correction support */
@@ -37,6 +42,11 @@
 
 #include "SDL_sysvideo.h"
 
+#if defined(PROTO_SDL_H)
+#include "SDL_intern.h"
+
+#define current_video SDLBase->current_video
+#endif
 
 static void CalculateGammaRamp(float gamma, Uint16 *ramp)
 {
@@ -90,8 +100,18 @@
 	}
 }
 
+#if !defined(PROTO_SDL_H)
 int SDL_SetGamma(float red, float green, float blue)
 {
+#else
+AROS_LH3(int, SDL_SetGamma,
+	AROS_LHA(float, red, D0),
+	AROS_LHA(float, green, D1),
+	AROS_LHA(float, blue, D2),
+	struct SDLBase *, SDLBase, 41, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	int succeeded;
 	SDL_VideoDevice *video = current_video;
 	SDL_VideoDevice *this  = current_video;	
@@ -108,15 +128,26 @@
 	}
 	if ( (succeeded < 0) && video->SetGamma ) {
 		SDL_ClearError();
+#if !defined(PROTO_SDL_H)
 		succeeded = video->SetGamma(this, red, green, blue);
+#else
+		succeeded = video->SetGamma(this, red, green, blue, SDLBase);
+#endif
 	}
 	return succeeded;
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 /* Calculating the gamma by integrating the gamma ramps isn't exact,
    so this function isn't officially supported.
 */
+#if !defined(PROTO_SDL_H)
 int SDL_GetGamma(float *red, float *green, float *blue)
+#else
+int SDL_GetGamma(float *red, float *green, float *blue, struct SDLBase *SDLBase)
+#endif
 {
 	int succeeded;
 	SDL_VideoDevice *video = current_video;
@@ -136,13 +167,27 @@
 	}
 	if ( (succeeded < 0) && video->GetGamma ) {
 		SDL_ClearError();
+#if !defined(PROTO_SDL_H)
 		succeeded = video->GetGamma(this, red, green, blue);
+#else
+		succeeded = video->GetGamma(this, red, green, blue, SDLBase);
+#endif
 	}
 	return succeeded;
 }
 
+#if !defined(PROTO_SDL_H)
 int SDL_SetGammaRamp(const Uint16 *red, const Uint16 *green, const Uint16 *blue)
 {
+#else
+AROS_LH3(int, SDL_SetGammaRamp,
+	AROS_LHA(const Uint16 *, red, A0),
+	AROS_LHA(const Uint16 *, green, A0),
+	AROS_LHA(const Uint16 *, blue, A0),
+	struct SDLBase *, SDLBase, 42, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	int succeeded;
 	SDL_VideoDevice *video = current_video;
 	SDL_VideoDevice *this  = current_video;	
@@ -186,15 +231,32 @@
 	/* Try to set the gamma ramp in the driver */
 	succeeded = -1;
 	if ( video->SetGammaRamp ) {
+#if !defined(PROTO_SDL_H)
 		succeeded = video->SetGammaRamp(this, video->gamma);
+#else
+		succeeded = video->SetGammaRamp(this, video->gamma, SDLBase);
+#endif
 	} else {
 		SDL_SetError("Gamma ramp manipulation not supported");
 	}
 	return succeeded;
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 int SDL_GetGammaRamp(Uint16 *red, Uint16 *green, Uint16 *blue)
 {
+#else
+AROS_LH3(int, SDL_GetGammaRamp,
+	AROS_LHA(Uint16 *, red, A0),
+	AROS_LHA(Uint16 *, green, A0),
+	AROS_LHA(Uint16 *, blue, A0),
+	struct SDLBase *, SDLBase, 43, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	SDL_VideoDevice *video = current_video;
 	SDL_VideoDevice *this  = current_video;	
 
@@ -207,7 +269,11 @@
 		}
 		if ( video->GetGammaRamp ) {
 			/* Get the real hardware gamma */
+#if !defined(PROTO_SDL_H)
 			video->GetGammaRamp(this, video->gamma);
+#else
+			video->GetGammaRamp(this, video->gamma, SDLBase);
+#endif
 		} else {
 			/* Assume an identity gamma */
 			int i;
@@ -230,4 +296,7 @@
 		SDL_memcpy(blue, &video->gamma[2*256], 256*sizeof(*blue));
 	}
 	return 0;
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
diff -Naur SDL-1.2.15-orig/src/video/SDL_pixels.c SDL-1.2.15/src/video/SDL_pixels.c
--- SDL-1.2.15-orig/src/video/SDL_pixels.c	2015-05-09 17:47:54.281774300 +0200
+++ SDL-1.2.15/src/video/SDL_pixels.c	2015-05-09 15:09:59.773739499 +0200
@@ -19,6 +19,11 @@
     Sam Lantinga
     slouken@libsdl.org
 */
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
 #include "SDL_config.h"
 
 /* General (mostly internal) pixel/color manipulation routines for SDL */
@@ -34,8 +39,13 @@
 /*
  * Allocate a pixel format structure and fill it according to the given info.
  */
+#if !defined(PROTO_SDL_H)
 SDL_PixelFormat *SDL_AllocFormat(int bpp,
 			Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask)
+#else
+SDL_PixelFormat *SDL_AllocFormatI(int bpp,
+			Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask, struct SDLBase *SDLBase)
+#endif
 {
 	SDL_PixelFormat *format;
 	Uint32 mask;
@@ -221,8 +231,13 @@
 	}
 	return(format);
 }
+#if !defined(PROTO_SDL_H)
 SDL_PixelFormat *SDL_ReallocFormat(SDL_Surface *surface, int bpp,
 			Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask)
+#else
+SDL_PixelFormat *SDL_ReallocFormatI(SDL_Surface *surface, int bpp,
+			Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask, struct SDLBase *SDLBase)
+#endif
 {
 	if ( surface->format ) {
 		SDL_FreeFormat(surface->format);
@@ -337,10 +352,21 @@
 }
 
 /* Find the opaque pixel value corresponding to an RGB triple */
+#if !defined(PROTO_SDL_H)
 Uint32 SDL_MapRGB
 (const SDL_PixelFormat * const format,
  const Uint8 r, const Uint8 g, const Uint8 b)
 {
+#else
+AROS_LH4(Uint32, SDL_MapRGB,
+	AROS_LHA(const SDL_PixelFormat * const, format, A0),
+	AROS_LHA(const Uint8, r, D0),
+	AROS_LHA(const Uint8, g, D1),
+	AROS_LHA(const Uint8, b, D2),
+	struct SDLBase *, SDLBase, 32, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	if ( format->palette == NULL ) {
 		return (r >> format->Rloss) << format->Rshift
 		       | (g >> format->Gloss) << format->Gshift
@@ -349,13 +375,28 @@
 	} else {
 		return SDL_FindColor(format->palette, r, g, b);
 	}
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 /* Find the pixel value corresponding to an RGBA quadruple */
+#if !defined(PROTO_SDL_H)
 Uint32 SDL_MapRGBA
 (const SDL_PixelFormat * const format,
  const Uint8 r, const Uint8 g, const Uint8 b, const Uint8 a)
 {
+#else
+AROS_LH5(Uint32, SDL_MapRGBA,
+	AROS_LHA(const SDL_PixelFormat * const, format, A0),
+	AROS_LHA(const Uint8, r, D0),
+	AROS_LHA(const Uint8, g, D1),
+	AROS_LHA(const Uint8, b, D2),
+	AROS_LHA(const Uint8, a, D3),
+	struct SDLBase *, SDLBase, 33, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	if ( format->palette == NULL ) {
 	        return (r >> format->Rloss) << format->Rshift
 		    | (g >> format->Gloss) << format->Gshift
@@ -364,11 +405,27 @@
 	} else {
 		return SDL_FindColor(format->palette, r, g, b);
 	}
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 void SDL_GetRGBA(Uint32 pixel, const SDL_PixelFormat * const fmt,
 		 Uint8 *r, Uint8 *g, Uint8 *b, Uint8 *a)
 {
+#else
+AROS_LH6(void, SDL_GetRGBA,
+	AROS_LHA(Uint32, pixel, D0),
+	AROS_LHA(const SDL_PixelFormat * const, fmt, A0),
+	AROS_LHA(Uint8 *, r, A1),
+	AROS_LHA(Uint8 *, g, A2),
+	AROS_LHA(Uint8 *, b, A3),
+	AROS_LHA(Uint8 *, a, A4),
+	struct SDLBase *, SDLBase, 47, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	if ( fmt->palette == NULL ) {
 	        /*
 		 * This makes sure that the result is mapped to the
@@ -398,11 +455,26 @@
 		*b = fmt->palette->colors[pixel].b;
 		*a = SDL_ALPHA_OPAQUE;
 	}
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 void SDL_GetRGB(Uint32 pixel, const SDL_PixelFormat * const fmt,
                 Uint8 *r,Uint8 *g,Uint8 *b)
 {
+#else
+AROS_LH5(void, SDL_GetRGB,
+	AROS_LHA(Uint32, pixel, D0),
+	AROS_LHA(const SDL_PixelFormat * const, fmt, A0),
+	AROS_LHA(Uint8 *, r, A1),
+	AROS_LHA(Uint8 *, g, A2),
+	AROS_LHA(Uint8 *, b, A3),
+	struct SDLBase *, SDLBase, 46, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	if ( fmt->palette == NULL ) {
 	        /* the note for SDL_GetRGBA above applies here too */
 	        unsigned v;
@@ -417,6 +489,9 @@
 		*g = fmt->palette->colors[pixel].g;
 		*b = fmt->palette->colors[pixel].b;
 	}
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 /* Apply gamma to a set of colors - this is easy. :) */
@@ -433,7 +508,12 @@
 }
 
 /* Map from Palette to Palette */
+#if !defined(PROTO_SDL_H)
 static Uint8 *Map1to1(SDL_Palette *src, SDL_Palette *dst, int *identical)
+#else
+#define Map1to1(src, dst, identical) Map1to1I(src, dst, identical, SDLBase)
+static Uint8 *Map1to1I(SDL_Palette *src, SDL_Palette *dst, int *identical, struct SDLBase *SDLBase)
+#endif
 {
 	Uint8 *map;
 	int i;
@@ -461,7 +541,12 @@
 	return(map);
 }
 /* Map from Palette to BitField */
+#if !defined(PROTO_SDL_H)
 static Uint8 *Map1toN(SDL_PixelFormat *src, SDL_PixelFormat *dst)
+#else
+#define Map1toN(src, dst) Map1toNI(src, dst, SDLBase)
+static Uint8 *Map1toNI(SDL_PixelFormat *src, SDL_PixelFormat *dst, struct SDLBase *SDLBase)
+#endif
 {
 	Uint8 *map;
 	int i;
@@ -486,7 +571,12 @@
 	return(map);
 }
 /* Map from BitField to Dithered-Palette to Palette */
+#if !defined(PROTO_SDL_H)
 static Uint8 *MapNto1(SDL_PixelFormat *src, SDL_PixelFormat *dst, int *identical)
+#else
+#define MapNto1(src, dst, identical) MapNto1I(src, dst, identical, SDLBase)
+static Uint8 *MapNto1I(SDL_PixelFormat *src, SDL_PixelFormat *dst, int *identical, struct SDLBase *SDLBase)
+#endif
 {
 	/* Generate a 256 color dither palette */
 	SDL_Palette dithered;
@@ -503,7 +593,11 @@
 	return(Map1to1(&dithered, pal, identical));
 }
 
+#if !defined(PROTO_SDL_H)
 SDL_BlitMap *SDL_AllocBlitMap(void)
+#else
+SDL_BlitMap *SDL_AllocBlitMapI(struct SDLBase *SDLBase)
+#endif
 {
 	SDL_BlitMap *map;
 
@@ -539,7 +633,11 @@
 		map->table = NULL;
 	}
 }
+#if !defined(PROTO_SDL_H)
 int SDL_MapSurface (SDL_Surface *src, SDL_Surface *dst)
+#else
+int SDL_MapSurfaceI(SDL_Surface *src, SDL_Surface *dst, struct SDLBase *SDLBase)
+#endif
 {
 	SDL_PixelFormat *srcfmt;
 	SDL_PixelFormat *dstfmt;
diff -Naur SDL-1.2.15-orig/src/video/SDL_pixels_c.h SDL-1.2.15/src/video/SDL_pixels_c.h
--- SDL-1.2.15-orig/src/video/SDL_pixels_c.h	2015-05-09 17:47:54.310774223 +0200
+++ SDL-1.2.15/src/video/SDL_pixels_c.h	2015-05-09 15:09:59.773739499 +0200
@@ -25,18 +25,30 @@
 
 #include "SDL_blit.h"
 
-/* Pixel format functions */
+#if !defined(PROTO_SDL_H)
 extern SDL_PixelFormat *SDL_AllocFormat(int bpp,
 		Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask);
 extern SDL_PixelFormat *SDL_ReallocFormat(SDL_Surface *surface, int bpp,
 		Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask);
+extern SDL_BlitMap *SDL_AllocBlitMap(void);
+extern int SDL_MapSurface (SDL_Surface *src, SDL_Surface *dst);
+#else
+extern SDL_PixelFormat *SDL_AllocFormatI(int bpp, Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask, struct SDLBase *SDLBase);
+extern SDL_PixelFormat *SDL_ReallocFormatI(SDL_Surface *surface, int bpp, Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask, struct SDLBase *SDLBase);
+extern SDL_BlitMap *SDL_AllocBlitMapI(struct SDLBase *SDLBase);
+extern int SDL_MapSurfaceI(SDL_Surface *src, SDL_Surface *dst, struct SDLBase *SDLBase);
+
+#define SDL_AllocFormat(bpp, Rmask, Gmask, Bmask, Amask) SDL_AllocFormatI(bpp, Rmask, Gmask, Bmask, Amask, SDLBase)
+#define SDL_ReallocFormat(surface, bpp, Rmask, Gmask, Bmask, Amask) SDL_ReallocFormatI(surface, bpp, Rmask, Gmask, Bmask, Amask, SDLBase)
+#define SDL_AllocBlitMap() SDL_AllocBlitMapI(SDLBase)
+#define SDL_MapSurface(src, dst) SDL_MapSurfaceI(src, dst, SDLBase)
+#endif
+/* Pixel format functions */
 extern void SDL_FormatChanged(SDL_Surface *surface);
 extern void SDL_FreeFormat(SDL_PixelFormat *format);
 
 /* Blit mapping functions */
-extern SDL_BlitMap *SDL_AllocBlitMap(void);
 extern void SDL_InvalidateMap(SDL_BlitMap *map);
-extern int SDL_MapSurface (SDL_Surface *src, SDL_Surface *dst);
 extern void SDL_FreeBlitMap(SDL_BlitMap *map);
 
 /* Miscellaneous functions */
diff -Naur SDL-1.2.15-orig/src/video/SDL_RLEaccel.c SDL-1.2.15/src/video/SDL_RLEaccel.c
--- SDL-1.2.15-orig/src/video/SDL_RLEaccel.c	2015-05-09 17:47:54.282774297 +0200
+++ SDL-1.2.15/src/video/SDL_RLEaccel.c	2015-05-09 15:09:59.773739499 +0200
@@ -19,6 +19,11 @@
     Sam Lantinga
     slouken@libsdl.org
 */
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
 #include "SDL_config.h"
 
 /*
@@ -101,6 +106,10 @@
 #include "SDL_cpuinfo.h"
 #endif
 
+#if defined(PROTO_SDL_H)
+#include "SDL_intern.h"
+#endif
+
 #ifndef MAX
 #define MAX(a, b) ((a) > (b) ? (a) : (b))
 #endif
@@ -837,6 +846,7 @@
 
 
 /* blit a colorkeyed RLE surface */
+
 int SDL_RLEBlit(SDL_Surface *src, SDL_Rect *srcrect,
 		SDL_Surface *dst, SDL_Rect *dstrect)
 {
@@ -846,6 +856,10 @@
 	int w = src->w;
 	unsigned alpha;
 
+#if defined(PROTO_SDL_H)
+        struct Library __unused *SDLBase = src->SDLLib;
+#endif
+
 	/* Lock the destination if necessary */
 	if ( SDL_MUSTLOCK(dst) ) {
 		if ( SDL_LockSurface(dst) < 0 ) {
@@ -1015,6 +1029,10 @@
 static void RLEAlphaClipBlit(int w, Uint8 *srcbuf, SDL_Surface *dst,
 			     Uint8 *dstbuf, SDL_Rect *srcrect)
 {
+#if defined(PROTO_SDL_H)
+    struct Library __unused *SDLBase = dst->SDLLib;
+#endif
+
     SDL_PixelFormat *df = dst->format;
     /*
      * clipped blitter: Ptype is the destination pixel type,
@@ -1112,6 +1130,10 @@
     Uint8 *srcbuf, *dstbuf;
     SDL_PixelFormat *df = dst->format;
 
+#if defined(PROTO_SDL_H)
+    struct Library __unused *SDLBase = src->SDLLib;
+#endif
+
     /* Lock the destination if necessary */
     if ( SDL_MUSTLOCK(dst) ) {
 	if ( SDL_LockSurface(dst) < 0 ) {
@@ -1397,7 +1419,12 @@
     ((unsigned)((((pixel) & fmt->Amask) >> fmt->Ashift) - 1U) < 254U)
 
 /* convert surface to be quickly alpha-blittable onto dest, if possible */
+#if !defined(PROTO_SDL_H)
 static int RLEAlphaSurface(SDL_Surface *surface)
+#else
+#define RLEAlphaSurface(surface) RLEAlphaSurfaceI(surface, SDLBase)
+static int RLEAlphaSurfaceI(SDL_Surface *surface, struct SDLBase *SDLBase)
+#endif
 {
     SDL_Surface *dest;
     SDL_PixelFormat *df;
@@ -1640,7 +1667,12 @@
     getpix_8, getpix_16, getpix_24, getpix_32
 };
 
+#if !defined(PROTO_SDL_H)
 static int RLEColorkeySurface(SDL_Surface *surface)
+#else
+#define RLEColorkeySurface(surface) RLEColorkeySurfaceI(surface, SDLBase)
+static int RLEColorkeySurfaceI(SDL_Surface *surface, struct SDLBase *SDLBase)
+#endif
 {
         Uint8 *rlebuf, *dst;
 	int maxn;
@@ -1768,7 +1800,12 @@
 	return(0);
 }
 
+#if !defined(PROTO_SDL_H)
 int SDL_RLESurface(SDL_Surface *surface)
+#else
+#define SDL_RLESurface(surface) SDL_RLESurfaceI(surface, SDLBase)
+int SDL_RLESurfaceI(SDL_Surface *surface, struct SDLBase *SDLBase)
+#endif
 {
 	int retcode;
 
@@ -1892,7 +1929,12 @@
     return(SDL_TRUE);
 }
 
+#if !defined(PROTO_SDL_H)
 void SDL_UnRLESurface(SDL_Surface *surface, int recode)
+#else
+#define SDL_UnRLESurface(surface, recode) SDL_UnRLESurfaceI(surface, recode, SDLBase)
+void SDL_UnRLESurfaceI(SDL_Surface *surface, int recode, struct SDLBase *SDLBase)
+#endif
 {
     if ( (surface->flags & SDL_RLEACCEL) == SDL_RLEACCEL ) {
 	surface->flags &= ~SDL_RLEACCEL;
diff -Naur SDL-1.2.15-orig/src/video/SDL_RLEaccel_c.h SDL-1.2.15/src/video/SDL_RLEaccel_c.h
--- SDL-1.2.15-orig/src/video/SDL_RLEaccel_c.h	2015-05-09 17:47:54.309774226 +0200
+++ SDL-1.2.15/src/video/SDL_RLEaccel_c.h	2015-05-09 15:09:59.773739499 +0200
@@ -23,9 +23,20 @@
 
 /* Useful functions and variables from SDL_RLEaccel.c */
 
-extern int SDL_RLESurface(SDL_Surface *surface);
 extern int SDL_RLEBlit(SDL_Surface *src, SDL_Rect *srcrect,
                        SDL_Surface *dst, SDL_Rect *dstrect);
 extern int SDL_RLEAlphaBlit(SDL_Surface *src, SDL_Rect *srcrect,
 			    SDL_Surface *dst, SDL_Rect *dstrect);
+
+#if !defined (SDL_AROS_SHARED)
+extern int SDL_RLESurface(SDL_Surface *surface);
 extern void SDL_UnRLESurface(SDL_Surface *surface, int recode);
+#else
+#include "SDL_intern.h"
+
+extern int SDL_RLESurfaceI(SDL_Surface *surface, struct SDLBase *SDLBase);
+extern void SDL_UnRLESurfaceI(SDL_Surface *surface, int recode, struct SDLBase *SDLBase);
+
+#define SDL_RLESurface(surface) SDL_RLESurfaceI(surface, SDLBase)
+#define SDL_UnRLESurface(surface, recode) SDL_UnRLESurfaceI(surface, recode, SDLBase)
+#endif
\ No newline at end of file
diff -Naur SDL-1.2.15-orig/src/video/SDL_stretch.c SDL-1.2.15/src/video/SDL_stretch.c
--- SDL-1.2.15-orig/src/video/SDL_stretch.c	2015-05-09 17:47:54.309774226 +0200
+++ SDL-1.2.15/src/video/SDL_stretch.c	2015-05-09 15:09:59.773739499 +0200
@@ -19,6 +19,11 @@
     Sam Lantinga
     slouken@libsdl.org
 */
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
 #include "SDL_config.h"
 
 /* This a stretch blit implementation based on ideas given to me by
@@ -65,7 +70,13 @@
 #error Need assembly opcodes for this architecture
 #endif
 
+#if !defined(PROTO_SDL_H)
 static unsigned char copy_row[4096] PAGE_ALIGNED;
+#else
+#include "SDL_intern.h"
+#define copy_row SDLBase->copy_row
+#endif
+
 
 static int generate_rowbytes(int src_w, int dst_w, int bpp)
 {
@@ -199,9 +210,20 @@
 /* Perform a stretch blit between two surfaces of the same format.
    NOTE:  This function is not safe to call from multiple threads!
 */
+#if !defined(PROTO_SDL_H)
 int SDL_SoftStretch(SDL_Surface *src, SDL_Rect *srcrect,
                     SDL_Surface *dst, SDL_Rect *dstrect)
 {
+#else
+AROS_LH4(int, SDL_SoftStretch,
+	AROS_LHA(SDL_Surface *, src, A0),
+	AROS_LHA(SDL_Rect *, srcrect, A1),
+	AROS_LHA(SDL_Surface *, dst, A2),
+	AROS_LHA(SDL_Rect *, dstrect, A3),
+	struct SDLBase *, SDLBase, 145, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	int src_locked;
 	int dst_locked;
 	int pos, inc;
@@ -354,5 +376,8 @@
 		SDL_UnlockSurface(src);
 	}
 	return(0);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
diff -Naur SDL-1.2.15-orig/src/video/SDL_stretch_c.h SDL-1.2.15/src/video/SDL_stretch_c.h
--- SDL-1.2.15-orig/src/video/SDL_stretch_c.h	2015-05-09 17:47:54.282774297 +0200
+++ SDL-1.2.15/src/video/SDL_stretch_c.h	2015-05-09 15:09:59.774739497 +0200
@@ -24,6 +24,7 @@
 /* Perform a stretch blit between two surfaces of the same format.
    NOTE:  This function is not safe to call from multiple threads!
 */
+#if !defined(PROTO_SDL_H)
 extern int SDL_SoftStretch(SDL_Surface *src, SDL_Rect *srcrect,
                            SDL_Surface *dst, SDL_Rect *dstrect);
-
+#endif
diff -Naur SDL-1.2.15-orig/src/video/SDL_surface.c SDL-1.2.15/src/video/SDL_surface.c
--- SDL-1.2.15-orig/src/video/SDL_surface.c	2015-05-09 17:47:54.282774297 +0200
+++ SDL-1.2.15/src/video/SDL_surface.c	2015-05-09 15:09:59.774739497 +0200
@@ -19,6 +19,11 @@
     Sam Lantinga
     slouken@libsdl.org
 */
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
 #include "SDL_config.h"
 
 #include "SDL_video.h"
@@ -34,10 +39,29 @@
 /*
  * Create an empty RGB surface of the appropriate depth
  */
+#if !defined(PROTO_SDL_H)
 SDL_Surface * SDL_CreateRGBSurface (Uint32 flags,
 			int width, int height, int depth,
 			Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask)
 {
+#else
+#include "SDL_intern.h"
+
+#define current_video SDLBase->current_video
+
+AROS_LH8(SDL_Surface *, SDL_CreateRGBSurface,
+	AROS_LHA(Uint32, flags, D0),
+	AROS_LHA(int, width, D1),
+	AROS_LHA(int, height, D2),
+	AROS_LHA(int, depth, D3),
+	AROS_LHA(Uint32, Rmask, D4),
+	AROS_LHA(Uint32, Gmask, D5),
+	AROS_LHA(Uint32, Bmask, D6),
+	AROS_LHA(Uint32, Amask, D7),
+	struct SDLBase *, SDLBase, 48, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	SDL_VideoDevice *video = current_video;
 	SDL_VideoDevice *this  = current_video;
 	SDL_Surface *screen;
@@ -80,6 +104,9 @@
 		SDL_OutOfMemory();
 		return(NULL);
 	}
+#if defined(PROTO_SDL_H)
+        surface->SDLLib = (struct Library *)SDLBase;
+#endif
 	surface->flags = SDL_SWSURFACE;
 	if ( (flags & SDL_HWSURFACE) == SDL_HWSURFACE ) {
 		if ((Amask) && (video->displayformatalphapixel))
@@ -121,7 +148,11 @@
 
 	/* Get the pixels */
 	if ( ((flags&SDL_HWSURFACE) == SDL_SWSURFACE) || 
+#if !defined(PROTO_SDL_H)
 				(video->AllocHWSurface(this, surface) < 0) ) {
+#else
+				(video->AllocHWSurface(this, surface, SDLBase) < 0) ) {
+#endif
 		if ( surface->w && surface->h ) {
 			surface->pixels = SDL_malloc(surface->h*surface->pitch);
 			if ( surface->pixels == NULL ) {
@@ -147,14 +178,33 @@
 	++surfaces_allocated;
 #endif
 	return(surface);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 /*
  * Create an RGB surface from an existing memory buffer
  */
+#if !defined(PROTO_SDL_H)
 SDL_Surface * SDL_CreateRGBSurfaceFrom (void *pixels,
 			int width, int height, int depth, int pitch,
 			Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask)
 {
+#else
+AROS_LH9(SDL_Surface *, SDL_CreateRGBSurfaceFrom,
+	AROS_LHA(void *, pixels, A0),
+	AROS_LHA(int, width, D0),
+	AROS_LHA(int, height, D1),
+	AROS_LHA(int, depth, D2),
+	AROS_LHA(int, pitch, D3),
+	AROS_LHA(Uint32, Rmask, D4),
+	AROS_LHA(Uint32, Gmask, D5),
+	AROS_LHA(Uint32, Bmask, D6),
+	AROS_LHA(Uint32, Amask, D7),
+	struct SDLBase *, SDLBase, 49, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	SDL_Surface *surface;
 
 	surface = SDL_CreateRGBSurface(SDL_SWSURFACE, 0, 0, depth,
@@ -168,12 +218,26 @@
 		SDL_SetClipRect(surface, NULL);
 	}
 	return(surface);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 /*
  * Set the color key in a blittable surface
  */
+#if !defined(PROTO_SDL_H)
 int SDL_SetColorKey (SDL_Surface *surface, Uint32 flag, Uint32 key)
 {
+#else
+AROS_LH3(int, SDL_SetColorKey,
+	AROS_LHA(SDL_Surface *, surface, A0),
+	AROS_LHA(Uint32, flag, D0),
+	AROS_LHA(Uint32, key, D1),
+	struct SDLBase *, SDLBase, 53, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
+
 	/* Sanity check the flag as it gets passed in */
 	if ( flag & SDL_SRCCOLORKEY ) {
 		if ( flag & (SDL_RLEACCEL|SDL_RLEACCELOK) ) {
@@ -205,7 +269,11 @@
 		surface->format->colorkey = key;
 		if ( (surface->flags & SDL_HWACCEL) == SDL_HWACCEL ) {
 			if ( (video->SetHWColorKey == NULL) ||
+#if !defined(PROTO_SDL_H)
 			     (video->SetHWColorKey(this, surface, key) < 0) ) {
+#else
+			     (video->SetHWColorKey(this, surface, key, SDLBase) < 0) ) {
+#endif
 				surface->flags &= ~SDL_HWACCEL;
 			}
 		}
@@ -220,10 +288,23 @@
 	}
 	SDL_InvalidateMap(surface->map);
 	return(0);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 /* This function sets the alpha channel of a surface */
+#if !defined(PROTO_SDL_H)
 int SDL_SetAlpha (SDL_Surface *surface, Uint32 flag, Uint8 value)
 {
+#else
+AROS_LH3(int, SDL_SetAlpha,
+	AROS_LHA(SDL_Surface *, surface, A0),
+	AROS_LHA(Uint32, flag, D0),
+	AROS_LHA(Uint8, value, D1),
+	struct SDLBase *, SDLBase, 54, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	Uint32 oldflags = surface->flags;
 	Uint32 oldalpha = surface->format->alpha;
 
@@ -255,7 +336,11 @@
 		surface->format->alpha = value;
 		if ( (surface->flags & SDL_HWACCEL) == SDL_HWACCEL ) {
 			if ( (video->SetHWAlpha == NULL) ||
+#if !defined(PROTO_SDL_H)
 			     (video->SetHWAlpha(this, surface, value) < 0) ) {
+#else
+			     (video->SetHWAlpha(this, surface, value, SDLBase) < 0) ) {
+#endif
 				surface->flags &= ~SDL_HWACCEL;
 			}
 		}
@@ -279,8 +364,15 @@
 	   || (((oldalpha + 1) ^ (value + 1)) & 0x100))
 		SDL_InvalidateMap(surface->map);
 	return(0);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
+#if !defined(PROTO_SDL_H)
 int SDL_SetAlphaChannel(SDL_Surface *surface, Uint8 value)
+#else
+int SDL_SetAlphaChannel(SDL_Surface *surface, Uint8 value, struct SDLBase *SDLBase)
+#endif
 {
 	int row, col;
 	int offset;
@@ -365,8 +457,17 @@
 /*
  * Set the clipping rectangle for a blittable surface
  */
+#if !defined(PROTO_SDL_H)
 SDL_bool SDL_SetClipRect(SDL_Surface *surface, const SDL_Rect *rect)
 {
+#else
+AROS_LH2(SDL_bool, SDL_SetClipRect,
+	AROS_LHA(SDL_Surface *, surface, A0),
+	AROS_LHA(SDL_Rect *, rect, A1),
+	struct SDLBase *, SDLBase, 55, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	SDL_Rect full_rect;
 
 	/* Don't do anything if there's no surface to act on */
@@ -386,12 +487,27 @@
 		return 1;
 	}
 	return SDL_IntersectRect(rect, &full_rect, &surface->clip_rect);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
+#if !defined(PROTO_SDL_H)
 void SDL_GetClipRect(SDL_Surface *surface, SDL_Rect *rect)
 {
+#else
+AROS_LH2(void, SDL_GetClipRect,
+	AROS_LHA(SDL_Surface *, surface, A0),
+	AROS_LHA(SDL_Rect *, rect, A1),
+	struct SDLBase *, SDLBase, 56, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	if ( surface && rect ) {
 		*rect = surface->clip_rect;
 	}
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 /* 
  * Set up a blit between two surfaces -- split into three parts:
@@ -404,9 +520,20 @@
  * you know exactly what you are doing, you can optimize your code
  * by calling the one(s) you need.
  */
+#if !defined(PROTO_SDL_H)
 int SDL_LowerBlit (SDL_Surface *src, SDL_Rect *srcrect,
 				SDL_Surface *dst, SDL_Rect *dstrect)
 {
+#else
+AROS_LH4(int, SDL_LowerBlit,
+	AROS_LHA(SDL_Surface *, src, A0),
+    	AROS_LHA(SDL_Rect *, srcrect, A1),
+	AROS_LHA(SDL_Surface *, dst, A2),
+	AROS_LHA(SDL_Rect *, dstrect, A3),
+	struct SDLBase *, SDLBase, 27, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	SDL_blit do_blit;
 	SDL_Rect hw_srcrect;
 	SDL_Rect hw_dstrect;
@@ -437,13 +564,28 @@
 	} else {
 		do_blit = src->map->sw_blit;
 	}
+      
 	return(do_blit(src, srcrect, dst, dstrect));
+#if defined(PROTO_SDL_H)  
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 
+#if !defined(PROTO_SDL_H)
 int SDL_UpperBlit (SDL_Surface *src, SDL_Rect *srcrect,
 		   SDL_Surface *dst, SDL_Rect *dstrect)
 {
+#else
+AROS_LH4(int, SDL_UpperBlit,
+	AROS_LHA(SDL_Surface *, src, A0),
+    	AROS_LHA(SDL_Rect *, srcrect, A1),
+	AROS_LHA(SDL_Surface *, dst, A2),
+	AROS_LHA(SDL_Rect *, dstrect, A3),
+	struct SDLBase *, SDLBase, 26, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
         SDL_Rect fulldst;
 	int srcx, srcy, w, h;
 
@@ -531,16 +673,29 @@
 	}
 	dstrect->w = dstrect->h = 0;
 	return 0;
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 static int SDL_FillRect1(SDL_Surface *dst, SDL_Rect *dstrect, Uint32 color)
+#else
+#define SDL_FillRect1(dst, dstrect, color) SDL_FillRect1I(dst, dstrect, color, SDLBase)
+static int SDL_FillRect1I(SDL_Surface *dst, SDL_Rect *dstrect, Uint32 color, struct SDLBase *SDLBase)
+#endif
 {
 	/* FIXME: We have to worry about packing order.. *sigh* */
 	SDL_SetError("1-bpp rect fill not yet implemented");
 	return -1;
 }
 
+#if !defined(PROTO_SDL_H)
 static int SDL_FillRect4(SDL_Surface *dst, SDL_Rect *dstrect, Uint32 color)
+#else
+#define SDL_FillRect4(dst, dstrect, color) SDL_FillRect4I(dst, dstrect, color, SDLBase)
+static int SDL_FillRect4I(SDL_Surface *dst, SDL_Rect *dstrect, Uint32 color, struct SDLBase *SDLBase)
+#endif
 {
 	/* FIXME: We have to worry about packing order.. *sigh* */
 	SDL_SetError("4-bpp rect fill not yet implemented");
@@ -550,8 +705,18 @@
 /* 
  * This function performs a fast fill of the given rectangle with 'color'
  */
+#if !defined(PROTO_SDL_H)
 int SDL_FillRect(SDL_Surface *dst, SDL_Rect *dstrect, Uint32 color)
 {
+#else
+AROS_LH3(int, SDL_FillRect,
+	AROS_LHA(SDL_Surface *, dst, A0),
+	AROS_LHA(SDL_Rect *, dstrect, A1),
+	AROS_LHA(Uint32, color, D0),
+	struct SDLBase *, SDLBase, 25, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	SDL_VideoDevice *video = current_video;
 	SDL_VideoDevice *this  = current_video;
 	int x, y;
@@ -593,7 +758,11 @@
 			hw_rect.y += current_video->offset_y;
 			dstrect = &hw_rect;
 		}
+#if !defined(PROTO_SDL_H)
 		return(video->FillHWRect(this, dst, dstrect, color));
+#else
+		return(video->FillHWRect(this, dst, dstrect, color, SDLBase));
+#endif
 	}
 
 	/* Perform software fill */
@@ -728,19 +897,34 @@
 
 	/* We're done! */
 	return(0);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 /*
  * Lock a surface to directly access the pixels
  */
+#if !defined(PROTO_SDL_H)
 int SDL_LockSurface (SDL_Surface *surface)
 {
+#else
+AROS_LH1(int, SDL_LockSurface,
+	AROS_LHA(SDL_Surface *, surface, A0),
+	struct SDLBase *, SDLBase, 50, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	if ( ! surface->locked ) {
 		/* Perform the lock */
 		if ( surface->flags & (SDL_HWSURFACE|SDL_ASYNCBLIT) ) {
 			SDL_VideoDevice *video = current_video;
 			SDL_VideoDevice *this  = current_video;
+#if !defined(PROTO_SDL_H)
 			if ( video->LockHWSurface(this, surface) < 0 ) {
+#else
+			if ( video->LockHWSurface(this, surface, SDLBase) < 0 ) {
+#endif
 				return(-1);
 			}
 		}
@@ -757,12 +941,23 @@
 
 	/* Ready to go.. */
 	return(0);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 /*
  * Unlock a previously locked surface
  */
+#if !defined(PROTO_SDL_H)
 void SDL_UnlockSurface (SDL_Surface *surface)
 {
+#else
+AROS_LH1(void, SDL_UnlockSurface,
+	AROS_LHA(SDL_Surface *, surface, A0),
+	struct SDLBase *, SDLBase, 51, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	/* Only perform an unlock if we are locked */
 	if ( ! surface->locked || (--surface->locked > 0) ) {
 		return;
@@ -775,7 +970,11 @@
 	if ( surface->flags & (SDL_HWSURFACE|SDL_ASYNCBLIT) ) {
 		SDL_VideoDevice *video = current_video;
 		SDL_VideoDevice *this  = current_video;
+#if !defined(PROTO_SDL_H)
 		video->UnlockHWSurface(this, surface);
+#else
+		video->UnlockHWSurface(this, surface, SDLBase);
+#endif
 	} else {
 		/* Update RLE encoded surface with new data */
 		if ( (surface->flags & SDL_RLEACCEL) == SDL_RLEACCEL ) {
@@ -783,14 +982,27 @@
 			SDL_RLESurface(surface);
 		}
 	}
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 /* 
  * Convert a surface into the specified pixel format.
  */
+#if !defined(PROTO_SDL_H)
 SDL_Surface * SDL_ConvertSurface (SDL_Surface *surface,
 					SDL_PixelFormat *format, Uint32 flags)
 {
+#else
+AROS_LH3(SDL_Surface *, SDL_ConvertSurface,
+	AROS_LHA(SDL_Surface *, surface, A0),
+	AROS_LHA(SDL_PixelFormat *, format, A1),
+	AROS_LHA(Uint32, flags, D0),
+	struct SDLBase *, SDLBase, 57, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	SDL_Surface *convert;
 	Uint32 colorkey = 0;
 	Uint8 alpha = 0;
@@ -895,13 +1107,24 @@
 
 	/* We're ready to go! */
 	return(convert);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 /*
  * Free a surface created by the above function.
  */
+#if !defined(PROTO_SDL_H)
 void SDL_FreeSurface (SDL_Surface *surface)
 {
+#else
+AROS_LH1(void, SDL_FreeSurface,
+	AROS_LHA(SDL_Surface *, surface, A0),
+	struct SDLBase *, SDLBase, 24, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	/* Free anything that's not NULL, and not the screen surface */
 	if ((surface == NULL) ||
 	    (current_video &&
@@ -928,7 +1151,11 @@
 	if ( surface->hwdata ) {
 		SDL_VideoDevice *video = current_video;
 		SDL_VideoDevice *this  = current_video;
+#if !defined(PROTO_SDL_H)
 		video->FreeHWSurface(this, surface);
+#else
+		video->FreeHWSurface(this, surface, SDLBase);
+#endif
 	}
 	if ( surface->pixels &&
 	     ((surface->flags & SDL_PREALLOC) != SDL_PREALLOC) ) {
@@ -938,4 +1165,7 @@
 #ifdef CHECK_LEAKS
 	--surfaces_allocated;
 #endif
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
diff -Naur SDL-1.2.15-orig/src/video/SDL_sysvideo.h SDL-1.2.15/src/video/SDL_sysvideo.h
--- SDL-1.2.15-orig/src/video/SDL_sysvideo.h	2015-05-09 17:47:54.284774292 +0200
+++ SDL-1.2.15/src/video/SDL_sysvideo.h	2015-05-09 15:09:59.774739497 +0200
@@ -37,6 +37,10 @@
 #include "SDL_opengl.h"
 #endif /* SDL_VIDEO_OPENGL */
 
+#if defined(PROTO_SDL_H)
+#include "SDL_intern.h"
+#endif
+
 /* The SDL video driver */
 typedef struct SDL_VideoDevice SDL_VideoDevice;
 
@@ -52,11 +56,11 @@
 
 	/* * * */
 	/* Initialization/Query functions */
-
+#if !defined(PROTO_SDL_H)
 	/* Initialize the native video subsystem, filling 'vformat' with the 
 	   "best" display pixel format, returning 0 or -1 if there's an error.
 	 */
-	int (*VideoInit)(_THIS, SDL_PixelFormat *vformat);
+    	int (*VideoInit)(_THIS, SDL_PixelFormat *vformat);
 
 	/* List the available video modes for the given pixel format, sorted
 	   from largest to smallest.
@@ -110,7 +114,17 @@
 	   or if the application is shutting down the video subsystem.
 	*/
 	void (*VideoQuit)(_THIS);
-
+#else
+        int (*VideoInit)(_THIS, SDL_PixelFormat *vformat, struct SDLBase *SDLBase);
+	SDL_Rect **(*ListModes)(_THIS, SDL_PixelFormat *format, Uint32 flags, struct SDLBase *SDLBase);
+	SDL_Surface *(*SetVideoMode)(_THIS, SDL_Surface *current, int width, int height, int bpp, Uint32 flags, struct SDLBase *SDLBase);
+	int (*ToggleFullScreen)(_THIS, int on, struct SDLBase *SDLBase);
+	void (*UpdateMouse)(_THIS, struct SDLBase *SDLBase);
+	SDL_Overlay *(*CreateYUVOverlay)(_THIS, int width, int height, Uint32 format, SDL_Surface *display, struct SDLBase *SDLBase);
+	int (*SetColors)(_THIS, int firstcolor, int ncolors, SDL_Color *colors, struct SDLBase *SDLBase);
+	void (*UpdateRects)(_THIS, int numrects, SDL_Rect *rects, struct SDLBase *SDLBase);
+	void (*VideoQuit)(_THIS, struct SDLBase *SDLBase);
+#endif
 	/* * * */
 	/* Hardware acceleration functions */
 
@@ -120,6 +134,7 @@
 	/* The pixel format used when SDL_CreateRGBSurface creates SDL_HWSURFACEs with alpha */
 	SDL_PixelFormat* displayformatalphapixel;
 	
+#if !defined(PROTO_SDL_H)
 	/* Allocates a surface in video memory */
 	int (*AllocHWSurface)(_THIS, SDL_Surface *surface);
 
@@ -146,12 +161,22 @@
 
 	/* Frees a previously allocated video surface */
 	void (*FreeHWSurface)(_THIS, SDL_Surface *surface);
-
+#else
+	int (*AllocHWSurface)(_THIS, SDL_Surface *surface, struct SDLBase *SDLBase);
+	int (*CheckHWBlit)(_THIS, SDL_Surface *src, SDL_Surface *dst, struct SDLBase *SDLBase);
+	int (*FillHWRect)(_THIS, SDL_Surface *dst, SDL_Rect *rect, Uint32 color, struct SDLBase *SDLBase);
+	int (*SetHWColorKey)(_THIS, SDL_Surface *surface, Uint32 key, struct SDLBase *SDLBase);
+	int (*SetHWAlpha)(_THIS, SDL_Surface *surface, Uint8 value, struct SDLBase *SDLBase);
+	int (*LockHWSurface)(_THIS, SDL_Surface *surface, struct SDLBase *SDLBase);
+	void (*UnlockHWSurface)(_THIS, SDL_Surface *surface, struct SDLBase *SDLBase);
+	int (*FlipHWSurface)(_THIS, SDL_Surface *surface, struct SDLBase *SDLBase);
+	void (*FreeHWSurface)(_THIS, SDL_Surface *surface, struct SDLBase *SDLBase);
+#endif
 	/* * * */
 	/* Gamma support */
 
 	Uint16 *gamma;
-
+#if !defined(PROTO_SDL_H)
 	/* Set the gamma correction directly (emulated with gamma ramps) */
 	int (*SetGamma)(_THIS, float red, float green, float blue);
 
@@ -181,7 +206,17 @@
 
 	/* Swap the current buffers in double buffer mode. */
 	void (*GL_SwapBuffers)(_THIS);
-
+#else
+	int (*SetGamma)(_THIS, float red, float green, float blue, struct SDLBase *SDLBase);
+	int (*GetGamma)(_THIS, float *red, float *green, float *blue, struct SDLBase *SDLBase);
+	int (*SetGammaRamp)(_THIS, Uint16 *ramp, struct SDLBase *SDLBase);
+	int (*GetGammaRamp)(_THIS, Uint16 *ramp, struct SDLBase *SDLBase);
+	int (*GL_LoadLibrary)(_THIS, const char *path, struct SDLBase *SDLBase);
+	void* (*GL_GetProcAddress)(_THIS, const char *proc, struct SDLBase *SDLBase);
+	int (*GL_GetAttribute)(_THIS, SDL_GLattr attrib, int* value, struct SDLBase *SDLBase);
+	int (*GL_MakeCurrent)(_THIS, struct SDLBase *SDLBase);
+	void (*GL_SwapBuffers)(_THIS, struct SDLBase *SDLBase);
+#endif
   	/* OpenGL functions for SDL_OPENGLBLIT */
 #if SDL_VIDEO_OPENGL
 #if !defined(__WIN32__)
@@ -199,6 +234,7 @@
 	/* * * */
 	/* Window manager functions */
 
+#if !defined(PROTO_SDL_H)
 	/* Set the title and icon text */
 	void (*SetCaption)(_THIS, const char *title, const char *icon);
 
@@ -257,7 +293,21 @@
 
 	/* Handle any queued OS events */
 	void (*PumpEvents)(_THIS);
-
+#else
+	void (*SetCaption)(_THIS, const char *title, const char *icon, struct SDLBase *SDLBase);
+	void (*SetIcon)(_THIS, SDL_Surface *icon, Uint8 *mask, struct SDLBase *SDLBase);
+	int (*IconifyWindow)(_THIS, struct SDLBase *SDLBase);
+	SDL_GrabMode (*GrabInput)(_THIS, SDL_GrabMode mode, struct SDLBase *SDLBase);
+	int (*GetWMInfo)(_THIS, SDL_SysWMinfo *info, struct SDLBase *SDLBase);
+	void (*FreeWMCursor)(_THIS, WMcursor *cursor, struct SDLBase *SDLBase);
+	WMcursor *(*CreateWMCursor)(_THIS, Uint8 *data, Uint8 *mask, int w, int h, int hot_x, int hot_y, struct SDLBase *SDLBase);
+	int (*ShowWMCursor)(_THIS, WMcursor *cursor, struct SDLBase *SDLBase);
+	void (*WarpWMCursor)(_THIS, Uint16 x, Uint16 y, struct SDLBase *SDLBase);
+	void (*MoveWMCursor)(_THIS, int x, int y, struct SDLBase *SDLBase);
+	void (*CheckMouseMode)(_THIS, struct SDLBase *SDLBase);
+	void (*InitOSKeymap)(_THIS, struct SDLBase *SDLBase);
+	void (*PumpEvents)(_THIS, struct SDLBase *SDLBase);
+#endif
 	/* * * */
 	/* Data common to all drivers */
 	SDL_Surface *screen;
@@ -306,15 +356,24 @@
 
 	/* * * */
 	/* The function used to dispose of this structure */
+#if !defined(PROTO_SDL_H)
 	void (*free)(_THIS);
+#else
+	void (*free)(_THIS, struct SDLBase *SDLBase);
+#endif
 };
 #undef _THIS
 
 typedef struct VideoBootStrap {
 	const char *name;
 	const char *desc;
+#if !defined(PROTO_SDL_H)
 	int (*available)(void);
 	SDL_VideoDevice *(*create)(int devindex);
+#else
+	int (*available)(struct SDLBase *SDLBase);
+	SDL_VideoDevice *(*create)(int devindex, struct SDLBase *SDLBase);
+#endif
 } VideoBootStrap;
 
 #if SDL_VIDEO_DRIVER_QUARTZ
@@ -413,9 +472,14 @@
 #if SDL_VIDEO_DRIVER_DUMMY
 extern VideoBootStrap DUMMY_bootstrap;
 #endif
+#if SDL_VIDEO_DRIVER_CGX
+extern VideoBootStrap CGX_bootstrap;
+#endif
 
 /* This is the current video device */
+#if !defined(PROTO_SDL_H)
 extern SDL_VideoDevice *current_video;
+#endif
 
 #define SDL_VideoSurface	(current_video->screen)
 #define SDL_ShadowSurface	(current_video->shadow)
diff -Naur SDL-1.2.15-orig/src/video/SDL_video.c SDL-1.2.15/src/video/SDL_video.c
--- SDL-1.2.15-orig/src/video/SDL_video.c	2015-05-09 17:47:54.282774297 +0200
+++ SDL-1.2.15/src/video/SDL_video.c	2015-05-09 15:09:59.775739495 +0200
@@ -19,6 +19,11 @@
     Sam Lantinga
     slouken@libsdl.org
 */
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
 #include "SDL_config.h"
 
 /* The high-level video driver subsystem */
@@ -129,17 +134,28 @@
 #if SDL_VIDEO_DRIVER_DUMMY
 	&DUMMY_bootstrap,
 #endif
+#if SDL_VIDEO_DRIVER_CGX
+	&CGX_bootstrap,
+#endif
 	NULL
 };
 
-SDL_VideoDevice *current_video = NULL;
-
-/* Various local functions */
+#if !defined(PROTO_SDL_H)
 int SDL_VideoInit(const char *driver_name, Uint32 flags);
 void SDL_VideoQuit(void);
-void SDL_GL_UpdateRectsLock(SDL_VideoDevice* this, int numrects, SDL_Rect* rects);
 
+SDL_VideoDevice *current_video = NULL;
+void SDL_GL_UpdateRectsLock(SDL_VideoDevice* this, int numrects, SDL_Rect* rects);
 static SDL_GrabMode SDL_WM_GrabInputOff(void);
+#else
+void SDL_GL_UpdateRectsLockI(SDL_VideoDevice* this, int numrects, SDL_Rect* rects, struct SDLBase *SDLBase);
+#define current_video SDLBase->current_video
+#define SDL_GL_UpdateRectsLock SDL_GL_UpdateRectsLockI
+static SDL_GrabMode SDL_WM_GrabInputOffI(struct SDLBase *SDLBase);
+#define SDL_WM_GrabInputOff() SDL_WM_GrabInputOffI(SDLBase)
+#endif
+
+/* Various local functions */
 #if SDL_VIDEO_OPENGL
 static int lock_count = 0;
 #endif
@@ -148,8 +164,18 @@
 /*
  * Initialize the video and event subsystems -- determine native pixel format
  */
+#if !defined(PROTO_SDL_H)
 int SDL_VideoInit (const char *driver_name, Uint32 flags)
 {
+#else
+AROS_LH2(int, SDL_VideoInit,
+	AROS_LHA(const char *, driver_name, A0),
+	AROS_LHA(Uint32, flags, D0),
+	struct SDLBase *, SDLBase, 34, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
+
 	SDL_VideoDevice *video;
 	int index;
 	int i;
@@ -182,16 +208,26 @@
 #endif
 		for ( i=0; bootstrap[i]; ++i ) {
 			if ( SDL_strcasecmp(bootstrap[i]->name, driver_name) == 0) {
+#if !defined(PROTO_SDL_H)
 				if ( bootstrap[i]->available() ) {
 					video = bootstrap[i]->create(index);
+#else
+				if ( bootstrap[i]->available(SDLBase) ) {
+					video = bootstrap[i]->create(index, SDLBase);
+#endif
 					break;
 				}
 			}
 		}
 	} else {
 		for ( i=0; bootstrap[i]; ++i ) {
+#if !defined(PROTO_SDL_H)
 			if ( bootstrap[i]->available() ) {
 				video = bootstrap[i]->create(index);
+#else
+			if ( bootstrap[i]->available(SDLBase) ) {
+				video = bootstrap[i]->create(index, SDLBase);
+#endif
 				if ( video != NULL ) {
 					break;
 				}
@@ -243,7 +279,11 @@
 	
 	/* Initialize the video subsystem */
 	SDL_memset(&vformat, 0, sizeof(vformat));
+#if !defined(PROTO_SDL_H)
 	if ( video->VideoInit(video, &vformat) < 0 ) {
+#else
+	if ( video->VideoInit(video, &vformat, SDLBase) < 0 ) {
+#endif
 		SDL_VideoQuit();
 		return(-1);
 	}
@@ -282,22 +322,45 @@
 
 	/* We're ready to go! */
 	return(0);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 char *SDL_VideoDriverName(char *namebuf, int maxlen)
 {
+#else
+AROS_LH2(char *, SDL_VideoDriverName,
+	AROS_LHA(char *, namebuf, A0),
+	AROS_LHA(int, maxlen, D0),
+	struct SDLBase *, SDLBase, 36, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	if ( current_video != NULL ) {
 		SDL_strlcpy(namebuf, current_video->name, maxlen);
 		return(namebuf);
 	}
 	return(NULL);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 /*
  * Get the current display surface
  */
+
+#if !defined(PROTO_SDL_H)
 SDL_Surface *SDL_GetVideoSurface(void)
 {
+#else
+AROS_LH0(SDL_Surface *, SDL_GetVideoSurface,
+	struct SDLBase *, SDLBase, 38, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	SDL_Surface *visible;
 
 	visible = NULL;
@@ -305,13 +368,23 @@
 		visible = current_video->visible;
 	}
 	return(visible);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 /*
  * Get the current information about the video hardware
  */
+#if !defined(PROTO_SDL_H)
 const SDL_VideoInfo *SDL_GetVideoInfo(void)
 {
+#else
+AROS_LH0(const SDL_VideoInfo *, SDL_GetVideoInfo,
+	struct SDLBase *, SDLBase, 35, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	const SDL_VideoInfo *info;
 
 	info = NULL;
@@ -319,6 +392,9 @@
 		info = &current_video->info;
 	}
 	return(info);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 /*
@@ -328,8 +404,17 @@
  * if any dimension is okay for the given format.  If 'format' is NULL,
  * the mode list will be for the format given by SDL_GetVideoInfo()->vfmt
  */
+#if !defined(PROTO_SDL_H)
 SDL_Rect ** SDL_ListModes (SDL_PixelFormat *format, Uint32 flags)
 {
+#else
+AROS_LH2(SDL_Rect **, SDL_ListModes ,
+	AROS_LHA(SDL_PixelFormat *, format, A0),
+	AROS_LHA(Uint32, flags, D0),
+	struct SDLBase *, SDLBase, 40, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	SDL_VideoDevice *video = current_video;
 	SDL_VideoDevice *this  = current_video;
 	SDL_Rect **modes;
@@ -339,9 +424,16 @@
 		if ( format == NULL ) {
 			format = SDL_VideoSurface->format;
 		}
+#if !defined(PROTO_SDL_H)
 		modes = video->ListModes(this, format, flags);
+#else
+		modes = video->ListModes(this, format, flags, SDLBase);
+#endif
 	}
 	return(modes);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 /*
@@ -370,8 +462,19 @@
 #define NEGATIVE_ONE -1
 #endif
 
+#if !defined(PROTO_SDL_H)
 int SDL_VideoModeOK (int width, int height, int bpp, Uint32 flags)
 {
+#else
+AROS_LH4(int, SDL_VideoModeOK,
+	AROS_LHA(int, width, D0),
+	AROS_LHA(int, height, D1),
+	AROS_LHA(int, bpp, D2),
+	AROS_LHA(Uint32, flags, D3),
+	struct SDLBase *, SDLBase, 39, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	int table, b, i;
 	int supported;
 	SDL_PixelFormat format;
@@ -424,12 +527,20 @@
 	} else {
 		return(0);
 	}
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 /*
  * Get the closest non-emulated video mode to the one requested
  */
+#if !defined(PROTO_SDL_H)
 static int SDL_GetVideoMode (int *w, int *h, int *BitsPerPixel, Uint32 flags)
+#else
+#define SDL_GetVideoMode(w, h, BitsPerPixel, flags) SDL_GetVideoModeI(w, h, BitsPerPixel, flags, SDLBase)
+static int SDL_GetVideoModeI(int *w, int *h, int *BitsPerPixel, Uint32 flags, struct SDLBase *SDLBase)
+#endif
 {
 	int table, b, i;
 	int supported;
@@ -499,7 +610,12 @@
 }
 
 /* This should probably go somewhere else -- like SDL_surface.c */
+#if !defined(PROTO_SDL_H)
 static void SDL_ClearSurface(SDL_Surface *surface)
+#else
+#define SDL_ClearSurface(surface) SDL_ClearSurfaceI(surface, SDLBase)
+static void SDL_ClearSurfaceI(SDL_Surface *surface, struct SDLBase *SDLBase)
+#endif
 {
 	Uint32 black;
 
@@ -517,7 +633,12 @@
 /*
  * Create a shadow surface suitable for fooling the app. :-)
  */
+#if !defined(PROTO_SDL_H)
 static void SDL_CreateShadowSurface(int depth)
+#else
+#define SDL_CreateShadowSurface(depth) SDL_CreateShadowSurfaceI(depth, SDLBase)
+static void SDL_CreateShadowSurfaceI(int depth, struct SDLBase *SDLBase)
+#endif
 {
 	Uint32 Rmask, Gmask, Bmask;
 
@@ -580,8 +701,19 @@
 /*
  * Set the requested video mode, allocating a shadow buffer if necessary.
  */
+#if !defined(PROTO_SDL_H)
 SDL_Surface * SDL_SetVideoMode (int width, int height, int bpp, Uint32 flags)
 {
+#else
+AROS_LH4(SDL_Surface *, SDL_SetVideoMode,
+	AROS_LHA(int, width, D0),
+	AROS_LHA(int, height, D1),
+	AROS_LHA(int, bpp, D2),
+	AROS_LHA(Uint32, flags, D3),
+	struct SDLBase *, SDLBase, 31, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	SDL_VideoDevice *video, *this;
 	SDL_Surface *prev_mode, *mode;
 	int video_w;
@@ -680,7 +812,11 @@
 	prev_mode = SDL_VideoSurface;
 	SDL_LockCursor();
 	SDL_VideoSurface = NULL;	/* In case it's freed by driver */
+#if !defined(PROTO_SDL_H)
 	mode = video->SetVideoMode(this, prev_mode,video_w,video_h,video_bpp,flags);
+#else
+	mode = video->SetVideoMode(this, prev_mode,video_w,video_h,video_bpp,flags, SDLBase);
+#endif
 	if ( mode ) { /* Prevent resize events from mode change */
           /* But not on OS/2 */
 #ifndef __OS2__
@@ -717,8 +853,12 @@
 		if ( mode->format->palette ) {
 			SDL_PixelFormat *vf = mode->format;
 			SDL_DitherColors(vf->palette->colors, vf->BitsPerPixel);
+#if !defined(PROTO_SDL_H)
 			video->SetColors(this, 0, vf->palette->ncolors,
 			                           vf->palette->colors);
+#else
+			video->SetColors(this, 0, vf->palette->ncolors, vf->palette->colors, SDLBase);
+#endif
 		}
 
 		/* Clear the surface to black */
@@ -759,7 +899,11 @@
 	/* Reset the mouse cursor and grab for new video mode */
 	SDL_SetCursor(NULL);
 	if ( video->UpdateMouse ) {
+#if !defined(PROTO_SDL_H)
 		video->UpdateMouse(this);
+#else
+		video->UpdateMouse(this, SDLBase);
+#endif
 	}
 	SDL_WM_GrabInput(saved_grab);
 	SDL_GetRelativeMouseState(NULL, NULL); /* Clear first large delta */
@@ -795,7 +939,11 @@
 	/* If we're running OpenGL, make the context current */
 	if ( (video->screen->flags & SDL_OPENGL) &&
 	      video->GL_MakeCurrent ) {
+#if !defined(PROTO_SDL_H)
 		if ( video->GL_MakeCurrent(this) < 0 ) {
+#else
+		if ( video->GL_MakeCurrent(this, SDLBase) < 0 ) {
+#endif
 			return(NULL);
 		}
 	}
@@ -919,13 +1067,24 @@
 
 	/* We're done! */
 	return(SDL_PublicSurface);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 /* 
  * Convert a surface into the video pixel format.
  */
+#if !defined(PROTO_SDL_H)
 SDL_Surface * SDL_DisplayFormat (SDL_Surface *surface)
 {
+#else
+AROS_LH1(SDL_Surface *, SDL_DisplayFormat,
+	AROS_LHA(SDL_Surface *, surface, A0),
+	struct SDLBase *, SDLBase, 23, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	Uint32 flags;
 
 	if ( ! SDL_PublicSurface ) {
@@ -944,14 +1103,25 @@
 	flags |= surface->flags & (SDL_SRCCOLORKEY|SDL_SRCALPHA|SDL_RLEACCELOK);
 #endif
 	return(SDL_ConvertSurface(surface, SDL_PublicSurface->format, flags));
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 /*
  * Convert a surface into a format that's suitable for blitting to
  * the screen, but including an alpha channel.
  */
+#if !defined(PROTO_SDL_H)
 SDL_Surface *SDL_DisplayFormatAlpha(SDL_Surface *surface)
 {
+#else
+AROS_LH1(SDL_Surface *, SDL_DisplayFormatAlpha,
+	AROS_LHA(SDL_Surface *, surface, A0),
+	struct SDLBase *, SDLBase, 58, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	SDL_PixelFormat *vf;
 	SDL_PixelFormat *format;
 	SDL_Surface *converted;
@@ -1006,13 +1176,28 @@
 	converted = SDL_ConvertSurface(surface, format, flags);
 	SDL_FreeFormat(format);
 	return(converted);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 /*
  * Update a specific portion of the physical screen
  */
+#if !defined(PROTO_SDL_H)
 void SDL_UpdateRect(SDL_Surface *screen, Sint32 x, Sint32 y, Uint32 w, Uint32 h)
 {
+#else
+AROS_LH5(void, SDL_UpdateRect,
+	AROS_LHA(SDL_Surface *, screen, A0),
+	AROS_LHA(Sint32, x, D0),
+	AROS_LHA(Sint32, y, D1),
+	AROS_LHA(Uint32, w, D2),
+	AROS_LHA(Uint32, h, D3),
+	struct SDLBase *, SDLBase, 30, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	if ( screen ) {
 		SDL_Rect rect;
 
@@ -1033,9 +1218,23 @@
 		rect.h = (Uint16)h;
 		SDL_UpdateRects(screen, 1, &rect);
 	}
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
+
+#if !defined(PROTO_SDL_H)
 void SDL_UpdateRects (SDL_Surface *screen, int numrects, SDL_Rect *rects)
 {
+#else
+AROS_LH3(void, SDL_UpdateRects,
+	AROS_LHA(SDL_Surface *, screen, A0),
+	AROS_LHA(int, numrects, D0),
+	AROS_LHA(SDL_Rect *, rects, A1),
+	struct SDLBase *, SDLBase, 29, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	int i;
 	SDL_VideoDevice *video = current_video;
 	SDL_VideoDevice *this = current_video;
@@ -1088,22 +1287,41 @@
 				rects[i].x += video->offset_x;
 				rects[i].y += video->offset_y;
 			}
+#if !defined(PROTO_SDL_H)
 			video->UpdateRects(this, numrects, rects);
+#else
+			video->UpdateRects(this, numrects, rects, SDLBase);
+#endif
 			for ( i=0; i<numrects; ++i ) {
 				rects[i].x -= video->offset_x;
 				rects[i].y -= video->offset_y;
 			}
 		} else {
+#if !defined(PROTO_SDL_H)
 			video->UpdateRects(this, numrects, rects);
+#else
+			video->UpdateRects(this, numrects, rects, SDLBase);
+#endif
 		}
 	}
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 /*
  * Performs hardware double buffering, if possible, or a full update if not.
  */
+#if !defined(PROTO_SDL_H)
 int SDL_Flip(SDL_Surface *screen)
 {
+#else
+AROS_LH1(int, SDL_Flip,
+	AROS_LHA(SDL_Surface *, screen, A0),
+	struct SDLBase *, SDLBase, 28, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	SDL_VideoDevice *video = current_video;
 	/* Copy the shadow surface to the video surface */
 	if ( screen == SDL_ShadowSurface ) {
@@ -1146,15 +1364,28 @@
 	}
 	if ( (screen->flags & SDL_DOUBLEBUF) == SDL_DOUBLEBUF ) {
 		SDL_VideoDevice *this  = current_video;
+#if !defined(PROTO_SDL_H)
 		return(video->FlipHWSurface(this, SDL_VideoSurface));
+#else
+		return(video->FlipHWSurface(this, SDL_VideoSurface, SDLBase));
+#endif
 	} else {
 		SDL_UpdateRect(screen, 0, 0, 0, 0);
 	}
 	return(0);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 static void SetPalette_logical(SDL_Surface *screen, SDL_Color *colors,
 			       int firstcolor, int ncolors)
+#else
+#define SetPalette_logical(screen, colors, firstcolor, ncolors) SetPalette_logicalI(screen, colors, firstcolor, ncolors, SDLBase)
+static void SetPalette_logicalI(SDL_Surface *screen, SDL_Color *colors,
+			       int firstcolor, int ncolors, struct SDLBase *SDLBase)
+#endif
 {
 	SDL_Palette *pal = screen->format->palette;
 	SDL_Palette *vidpal;
@@ -1180,8 +1411,14 @@
 	SDL_FormatChanged(screen);
 }
 
+#if !defined(PROTO_SDL_H)
 static int SetPalette_physical(SDL_Surface *screen,
                                SDL_Color *colors, int firstcolor, int ncolors)
+#else
+#define SetPalette_physical(screen, colors, firstcolor, ncolors) SetPalette_physicalI(screen, colors, firstcolor, ncolors, SDLBase)
+static int SetPalette_physicalI(SDL_Surface *screen,
+                               SDL_Color *colors, int firstcolor, int ncolors, struct SDLBase *SDLBase)
+#endif
 {
 	SDL_VideoDevice *video = current_video;
 	int gotall = 1;
@@ -1239,7 +1476,11 @@
 			SDL_ApplyGamma(video->gamma, colors, gcolors, ncolors);
 			colors = gcolors;
 		}
+#if !defined(PROTO_SDL_H)
 		gotall = video->SetColors(video, firstcolor, ncolors, colors);
+#else
+		gotall = video->SetColors(video, firstcolor, ncolors, colors, SDLBase);
+#endif
 		if ( ! gotall ) {
 			/* The video flags shouldn't have SDL_HWPALETTE, and
 			   the video driver is responsible for copying back the
@@ -1261,9 +1502,21 @@
  *
  * Return nonzero if all colours were set as requested, or 0 otherwise.
  */
+#if !defined(PROTO_SDL_H)
 int SDL_SetPalette(SDL_Surface *screen, int which,
 		   SDL_Color *colors, int firstcolor, int ncolors)
 {
+#else
+AROS_LH5(int, SDL_SetPalette,
+	AROS_LHA(SDL_Surface *, screen, A0),
+	AROS_LHA(int, which, D0),
+	AROS_LHA(SDL_Color *, colors, A1),
+	AROS_LHA(int, firstcolor, D1),
+	AROS_LHA(int, ncolors, D2),
+	struct SDLBase *, SDLBase, 45, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	SDL_Palette *pal;
 	int gotall;
 	int palsize;
@@ -1323,26 +1576,50 @@
 			}
 			SDL_memcpy(pp->colors, pal->colors, size);
 		}
-		if ( ! SetPalette_physical(screen,
-		                           colors, firstcolor, ncolors) ) {
+		if ( ! SetPalette_physical(screen, colors, firstcolor, ncolors) ) {
 			gotall = 0;
 		}
 	}
 	return gotall;
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 int SDL_SetColors(SDL_Surface *screen, SDL_Color *colors, int firstcolor,
 		  int ncolors)
 {
+#else
+AROS_LH4(int, SDL_SetColors,
+	AROS_LHA(SDL_Surface *, screen, A0),
+	AROS_LHA(SDL_Color *, colors, A1),
+	AROS_LHA(int, firstcolor, D0),
+	AROS_LHA(int, ncolors, D1),
+	struct SDLBase *, SDLBase, 44, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	return SDL_SetPalette(screen, SDL_LOGPAL | SDL_PHYSPAL,
 			      colors, firstcolor, ncolors);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 /*
  * Clean up the video subsystem
  */
+#if !defined(PROTO_SDL_H)
 void SDL_VideoQuit (void)
 {
+#else
+AROS_LH0(void, SDL_VideoQuit,
+	struct SDLBase *, SDLBase, 37, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
+
 	SDL_Surface *ready_to_go;
 
 	if ( current_video ) {
@@ -1362,7 +1639,11 @@
 		SDL_WM_GrabInputOff();
 
 		/* Clean up the system video */
+#if !defined(PROTO_SDL_H)
 		video->VideoQuit(this);
+#else
+		video->VideoQuit(this, SDLBase);
+#endif
 
 		/* Free any lingering surfaces */
 		ready_to_go = SDL_ShadowSurface;
@@ -1399,15 +1680,30 @@
 		}
 
 		/* Finish cleaning up video subsystem */
+#if !defined(PROTO_SDL_H)
 		video->free(this);
+#else
+		video->free(this, SDLBase);
+#endif
 		current_video = NULL;
 	}
 	return;
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 /* Load the GL driver library */
+#if !defined(PROTO_SDL_H)
 int SDL_GL_LoadLibrary(const char *path)
 {
+#else
+AROS_LH1(int, SDL_GL_LoadLibrary,
+	AROS_LHA(const char *, path, A0),
+	struct SDLBase *, SDLBase, 64, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	SDL_VideoDevice *video = current_video;
 	SDL_VideoDevice *this = current_video;
 	int retval;
@@ -1417,16 +1713,31 @@
 		SDL_SetError("Video subsystem has not been initialized");
 	} else {
 		if ( video->GL_LoadLibrary ) {
+#if !defined(PROTO_SDL_H)
 			retval = video->GL_LoadLibrary(this, path);
+#else
+			retval = video->GL_LoadLibrary(this, path, SDLBase);
+#endif
 		} else {
 			SDL_SetError("No dynamic GL support in video driver");
 		}
 	}
 	return(retval);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 void *SDL_GL_GetProcAddress(const char* proc)
 {
+#else
+AROS_LH1(void *, SDL_GL_GetProcAddress,
+	AROS_LHA(const char*, proc, A0),
+	struct SDLBase *, SDLBase, 65, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	SDL_VideoDevice *video = current_video;
 	SDL_VideoDevice *this = current_video;
 	void *func;
@@ -1434,7 +1745,11 @@
 	func = NULL;
 	if ( video->GL_GetProcAddress ) {
 		if ( video->gl_config.driver_loaded ) {
+#if !defined(PROTO_SDL_H)
 			func = video->GL_GetProcAddress(this, proc);
+#else
+			func = video->GL_GetProcAddress(this, proc, SDLBase);
+#endif
 		} else {
 			SDL_SetError("No GL driver has been loaded");
 		}
@@ -1442,11 +1757,23 @@
 		SDL_SetError("No dynamic GL support in video driver");
 	}
 	return func;
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 /* Set the specified GL attribute for setting up a GL video mode */
+#if !defined(PROTO_SDL_H)
 int SDL_GL_SetAttribute( SDL_GLattr attr, int value )
 {
+#else
+AROS_LH2(int, SDL_GL_SetAttribute,
+	AROS_LHA(SDL_GLattr, attr, D0),
+	AROS_LHA(int, value, D1),
+	struct SDLBase *, SDLBase, 66, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	int retval;
 	SDL_VideoDevice *video = current_video;
 
@@ -1509,39 +1836,80 @@
 			break;
 	}
 	return(retval);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 /* Retrieve an attribute value from the windowing system. */
+#if !defined(PROTO_SDL_H)
 int SDL_GL_GetAttribute(SDL_GLattr attr, int* value)
 {
+#else
+AROS_LH2(int, SDL_GL_GetAttribute,
+	AROS_LHA(SDL_GLattr, attr, D0),
+	AROS_LHA(int *, value, A0),
+	struct SDLBase *, SDLBase, 67, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	int retval = -1;
 	SDL_VideoDevice* video = current_video;
 	SDL_VideoDevice* this = current_video;
 
 	if ( video->GL_GetAttribute ) {
+#if !defined(PROTO_SDL_H)
 		retval = this->GL_GetAttribute(this, attr, value);
+#else
+		retval = this->GL_GetAttribute(this, attr, value, SDLBase);
+#endif
 	} else {
 		*value = 0;
 		SDL_SetError("GL_GetAttribute not supported");
 	}
 	return retval;
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 /* Perform a GL buffer swap on the current GL context */
+#if !defined(PROTO_SDL_H)
 void SDL_GL_SwapBuffers(void)
 {
+#else
+AROS_LH0(void, SDL_GL_SwapBuffers,
+	struct SDLBase *, SDLBase, 68, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	SDL_VideoDevice *video = current_video;
 	SDL_VideoDevice *this = current_video;
 
 	if ( video->screen->flags & SDL_OPENGL ) {
+#if !defined(PROTO_SDL_H)
 		video->GL_SwapBuffers(this);
+#else
+		video->GL_SwapBuffers(this, SDLBase);
+#endif
 	} else {
 		SDL_SetError("OpenGL video mode has not been set");
 	}
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 /* Update rects with locking */
+#if !defined(PROTO_SDL_H)
 void SDL_GL_UpdateRectsLock(SDL_VideoDevice* this, int numrects, SDL_Rect *rects)
+#else
+#ifdef SDL_GL_UpdateRectsLock
+#undef SDL_GL_UpdateRectsLock
+#endif
+#define SDL_GL_UpdateRectsLock(this, numrects, rects) SDL_GL_UpdateRectsLockI(this, numrects, rects, SDLBase)
+void SDL_GL_UpdateRectsLockI(SDL_VideoDevice* this, int numrects, SDL_Rect *rects, struct SDLBase *SDLBase)
+#endif
 {
 	SDL_GL_Lock();
  	SDL_GL_UpdateRects(numrects, rects);
@@ -1549,8 +1917,17 @@
 }
 
 /* Update rects without state setting and changing (the caller is responsible for it) */
+#if !defined(PROTO_SDL_H)
 void SDL_GL_UpdateRects(int numrects, SDL_Rect *rects)
 {
+#else
+AROS_LH2(void, SDL_GL_UpdateRects,
+	AROS_LHA(Uint32, numrects, D0),
+	AROS_LHA(SDL_Rect *, rects, A0),
+	struct SDLBase *, SDLBase, 69, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 #if SDL_VIDEO_OPENGL
 	SDL_VideoDevice *this = current_video;
 	SDL_Rect update, tmp;
@@ -1620,11 +1997,21 @@
 		}
 	}
 #endif
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 /* Lock == save current state */
+#if !defined(PROTO_SDL_H)
 void SDL_GL_Lock()
 {
+#else
+AROS_LH0(void, SDL_GL_Lock,
+	struct SDLBase *, SDLBase, 70, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 #if SDL_VIDEO_OPENGL
 	lock_count--;
 	if (lock_count==-1)
@@ -1668,11 +2055,21 @@
 		this->glLoadIdentity();
 	}
 #endif
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 /* Unlock == restore saved state */
+#if !defined(PROTO_SDL_H)
 void SDL_GL_Unlock()
 {
+#else
+AROS_LH0(void, SDL_GL_Unlock,
+	struct SDLBase *, SDLBase, 71, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 #if SDL_VIDEO_OPENGL
 	lock_count++;
 	if (lock_count==0)
@@ -1687,16 +2084,29 @@
 		this->glPopAttrib();
 	}
 #endif
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
-
+#if !defined(PROTO_SDL_H)
 void SDL_Audio_SetCaption(const char *caption);
+#endif
 
 /*
  * Sets/Gets the title and icon text of the display window, if any.
  */
+#if !defined(PROTO_SDL_H)
 void SDL_WM_SetCaption (const char *title, const char *icon)
 {
+#else
+AROS_LH2(void, SDL_WM_SetCaption,
+	AROS_LHA(const char *, title, A0),
+	AROS_LHA(const char *, icon, A1),
+	struct SDLBase *, SDLBase, 72, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	SDL_VideoDevice *video = current_video;
 	SDL_VideoDevice *this  = current_video;
 
@@ -1714,16 +2124,32 @@
 			video->wm_icon = SDL_strdup(icon);
 		}
 		if ( (title || icon) && (video->SetCaption != NULL) ) {
+#if !defined(PROTO_SDL_H)
 			video->SetCaption(this, video->wm_title,video->wm_icon);
+#else
+			video->SetCaption(this, video->wm_title,video->wm_icon, SDLBase);
+#endif
 		}
 	}
 
 	/* PulseAudio can make use of this information. */
 	SDL_Audio_SetCaption(title);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 void SDL_WM_GetCaption (char **title, char **icon)
 {
+#else
+AROS_LH2(void, SDL_WM_GetCaption,
+	AROS_LHA(char **, title, A0),
+	AROS_LHA(char **, icon, A1),
+	struct SDLBase *, SDLBase, 73, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	SDL_VideoDevice *video = current_video;
 
 	if ( video ) {
@@ -1734,11 +2160,19 @@
 			*icon = video->wm_icon;
 		}
 	}
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 /* Utility function used by SDL_WM_SetIcon();
  * flags & 1 for color key, flags & 2 for alpha channel. */
+#if !defined(PROTO_SDL_H)
 static void CreateMaskFromColorKeyOrAlpha(SDL_Surface *icon, Uint8 *mask, int flags)
+#else
+#define CreateMaskFromColorKeyOrAlpha(icon, mask, flags) CreateMaskFromColorKeyOrAlphaI(icon, mask, flags, SDLBase)
+static void CreateMaskFromColorKeyOrAlphaI(SDL_Surface *icon, Uint8 *mask, int flags, struct SDLBase *SDLBase)
+#endif
 {
 	int x, y;
 	Uint32 colorkey;
@@ -1796,8 +2230,17 @@
 /*
  * Sets the window manager icon for the display window.
  */
+#if !defined(PROTO_SDL_H)
 void SDL_WM_SetIcon (SDL_Surface *icon, Uint8 *mask)
 {
+#else
+AROS_LH2(void, SDL_WM_SetIcon,
+	AROS_LHA(SDL_Surface *, icon, A0),
+	AROS_LHA(Uint8 *, mask, A1),
+	struct SDLBase *, SDLBase, 74, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	SDL_VideoDevice *video = current_video;
 	SDL_VideoDevice *this  = current_video;
 
@@ -1816,12 +2259,23 @@
 			if( flags ) {
 				CreateMaskFromColorKeyOrAlpha(icon, mask, flags);
 			}
+#if !defined(PROTO_SDL_H)
 			video->SetIcon(video, icon, mask);
+#else
+			video->SetIcon(video, icon, mask, SDLBase);
+#endif
 			SDL_free(mask);
 		} else {
+#if !defined(PROTO_SDL_H)
 			video->SetIcon(this, icon, mask);
+#else
+			video->SetIcon(this, icon, mask, SDLBase);
+#endif
 		}
 	}
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 /*
@@ -1829,7 +2283,12 @@
  * This function returns the final grab mode after calling the
  * driver dependent function.
  */
+#if !defined(PROTO_SDL_H)
 static SDL_GrabMode SDL_WM_GrabInputRaw(SDL_GrabMode mode)
+#else
+#define SDL_WM_GrabInputRaw(mode) SDL_WM_GrabInputRawI(mode, SDLBase)
+static SDL_GrabMode SDL_WM_GrabInputRawI(SDL_GrabMode mode, struct SDLBase *SDLBase)
+#endif
 {
 	SDL_VideoDevice *video = current_video;
 	SDL_VideoDevice *this  = current_video;
@@ -1845,17 +2304,29 @@
 #endif
 	if ( mode == SDL_GRAB_OFF ) {
 		if ( video->input_grab != SDL_GRAB_OFF ) {
+#if !defined(PROTO_SDL_H)
 			mode = video->GrabInput(this, mode);
+#else
+			mode = video->GrabInput(this, mode, SDLBase);
+#endif
 		}
 	} else {
 		if ( video->input_grab == SDL_GRAB_OFF ) {
+#if !defined(PROTO_SDL_H)
 			mode = video->GrabInput(this, mode);
+#else
+			mode = video->GrabInput(this, mode, SDLBase);
+#endif
 		}
 	}
 	if ( mode != video->input_grab ) {
 		video->input_grab = mode;
 		if ( video->CheckMouseMode ) {
+#if !defined(PROTO_SDL_H)
 			video->CheckMouseMode(this);
+#else
+			video->CheckMouseMode(this, SDLBase);
+#endif
 		}
 	}
 #ifdef DEBUG_GRAB
@@ -1868,8 +2339,16 @@
 	}
 	return(mode);
 }
+#if !defined(PROTO_SDL_H)
 SDL_GrabMode SDL_WM_GrabInput(SDL_GrabMode mode)
 {
+#else
+AROS_LH1(SDL_GrabMode, SDL_WM_GrabInput,
+	AROS_LHA(SDL_GrabMode, mode, D0),
+	struct SDLBase *, SDLBase, 77, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	SDL_VideoDevice *video = current_video;
 
 	/* If the video isn't initialized yet, we can't do anything */
@@ -1897,8 +2376,15 @@
 		mode += SDL_GRAB_FULLSCREEN;
 	}
 	return(SDL_WM_GrabInputRaw(mode));
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
+#if !defined(PROTO_SDL_H)
 static SDL_GrabMode SDL_WM_GrabInputOff(void)
+#else
+static SDL_GrabMode SDL_WM_GrabInputOffI(struct SDLBase *SDLBase)
+#endif
 {
 	SDL_GrabMode mode;
 
@@ -1916,24 +2402,46 @@
  * Iconify the window in window managed environments.
  * A successful iconification will result in an SDL_APPACTIVE loss event.
  */
+#if !defined(PROTO_SDL_H)
 int SDL_WM_IconifyWindow(void)
 {
+#else
+AROS_LH0(int, SDL_WM_IconifyWindow,
+	struct SDLBase *, SDLBase, 75, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	SDL_VideoDevice *video = current_video;
 	SDL_VideoDevice *this  = current_video;
 	int retval;
 
 	retval = 0;
 	if ( video->IconifyWindow ) {
+#if !defined(PROTO_SDL_H)
 		retval = video->IconifyWindow(this);
+#else
+		retval = video->IconifyWindow(this, SDLBase);
+#endif
 	}
 	return(retval);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 /*
  * Toggle fullscreen mode
  */
+#if !defined(PROTO_SDL_H)
 int SDL_WM_ToggleFullScreen(SDL_Surface *surface)
 {
+#else
+AROS_LH1(int, SDL_WM_ToggleFullScreen,
+	AROS_LHA(SDL_Surface *, surface, A0),
+	struct SDLBase *, SDLBase, 76, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	SDL_VideoDevice *video = current_video;
 	SDL_VideoDevice *this  = current_video;
 	int toggled;
@@ -1942,13 +2450,21 @@
 	if ( SDL_PublicSurface && (surface == SDL_PublicSurface) &&
 	     video->ToggleFullScreen ) {
 		if ( surface->flags & SDL_FULLSCREEN ) {
+#if !defined(PROTO_SDL_H)
 			toggled = video->ToggleFullScreen(this, 0);
+#else
+			toggled = video->ToggleFullScreen(this, 0, SDLBase);
+#endif
 			if ( toggled ) {
 				SDL_VideoSurface->flags &= ~SDL_FULLSCREEN;
 				SDL_PublicSurface->flags &= ~SDL_FULLSCREEN;
 			}
 		} else {
+#if !defined(PROTO_SDL_H)
 			toggled = video->ToggleFullScreen(this, 1);
+#else
+			toggled = video->ToggleFullScreen(this, 1, SDLBase);
+#endif
 			if ( toggled ) {
 				SDL_VideoSurface->flags |= SDL_FULLSCREEN;
 				SDL_PublicSurface->flags |= SDL_FULLSCREEN;
@@ -1960,18 +2476,29 @@
 		}
 	}
 	return(toggled);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
 /*
  * Get some platform dependent window manager information
  */
+#if !defined(PROTO_SDL_H)
 int SDL_GetWMInfo (SDL_SysWMinfo *info)
+#else
+int SDL_GetWMInfo (SDL_SysWMinfo *info, struct SDLBase *SDLBase)
+#endif
 {
 	SDL_VideoDevice *video = current_video;
 	SDL_VideoDevice *this  = current_video;
 
 	if ( video && video->GetWMInfo ) {
+#if !defined(PROTO_SDL_H)
 		return(video->GetWMInfo(this, info));
+#else
+		return(video->GetWMInfo(this, info, SDLBase));
+#endif
 	} else {
 		return(0);
 	}
diff -Naur SDL-1.2.15-orig/src/video/SDL_yuv.c SDL-1.2.15/src/video/SDL_yuv.c
--- SDL-1.2.15-orig/src/video/SDL_yuv.c	2015-05-09 17:47:54.283774294 +0200
+++ SDL-1.2.15/src/video/SDL_yuv.c	2015-05-09 15:09:59.775739495 +0200
@@ -19,6 +19,11 @@
     Sam Lantinga
     slouken@libsdl.org
 */
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
 #include "SDL_config.h"
 
 /* This is the implementation of the YUV video surface support */
@@ -28,10 +33,24 @@
 #include "SDL_yuvfuncs.h"
 #include "SDL_yuv_sw_c.h"
 
-
+#if !defined(PROTO_SDL_H)
 SDL_Overlay *SDL_CreateYUVOverlay(int w, int h, Uint32 format,
                                   SDL_Surface *display)
 {
+#else
+#include "SDL_intern.h"
+
+#define current_video SDLBase->current_video
+
+AROS_LH4(SDL_Overlay *, SDL_CreateYUVOverlay,
+	AROS_LHA(int, w, D0),
+	AROS_LHA(int, h, D1),
+	AROS_LHA(Uint32, format, D2),
+	AROS_LHA(SDL_Surface *, display, A0),
+	struct SDLBase *, SDLBase, 59, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	SDL_VideoDevice *video = current_video;
 	SDL_VideoDevice *this  = current_video;
 	const char *yuv_hwaccel;
@@ -54,34 +73,77 @@
         yuv_hwaccel = SDL_getenv("SDL_VIDEO_YUV_HWACCEL");
 	if ( ((display == SDL_VideoSurface) && video->CreateYUVOverlay) &&
 	     (!yuv_hwaccel || (SDL_atoi(yuv_hwaccel) > 0)) ) {
+#if !defined(PROTO_SDL_H)
 		overlay = video->CreateYUVOverlay(this, w, h, format, display);
+#else
+		overlay = video->CreateYUVOverlay(this, w, h, format, display, SDLBase);
+#endif
 	}
 	/* If hardware YUV overlay failed ... */
 	if ( overlay == NULL ) {
 		overlay = SDL_CreateYUV_SW(this, w, h, format, display);
 	}
 	return overlay;
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 int SDL_LockYUVOverlay(SDL_Overlay *overlay)
 {
+#else
+AROS_LH1(int, SDL_LockYUVOverlay,
+	AROS_LHA(SDL_Overlay *, overlay, A0),
+	struct SDLBase *, SDLBase, 60, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	if ( overlay == NULL ) {
 		SDL_SetError("Passed NULL overlay");
 		return -1;
 	}
+#if !defined(PROTO_SDL_H)
 	return overlay->hwfuncs->Lock(current_video, overlay);
+#else
+	return overlay->hwfuncs->Lock(current_video, overlay, SDLBase);
+
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 void SDL_UnlockYUVOverlay(SDL_Overlay *overlay)
 {
+#else
+AROS_LH1(void, SDL_UnlockYUVOverlay,
+	AROS_LHA(SDL_Overlay *, overlay, A0),
+	struct SDLBase *, SDLBase, 61, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	if ( overlay == NULL ) {
 		return;
 	}
+#if !defined(PROTO_SDL_H)
 	overlay->hwfuncs->Unlock(current_video, overlay);
+#else
+	overlay->hwfuncs->Unlock(current_video, overlay, SDLBase);
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 int SDL_DisplayYUVOverlay(SDL_Overlay *overlay, SDL_Rect *dstrect)
 {
+#else
+AROS_LH2(int, SDL_DisplayYUVOverlay,
+	AROS_LHA(SDL_Overlay *, overlay, A0),
+	AROS_LHA(SDL_Rect *, dstrect, A1),
+	struct SDLBase *, SDLBase, 62, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	SDL_Rect src, dst;
 	int srcx, srcy, srcw, srch;
 	int dstx, dsty, dstw, dsth;
@@ -135,16 +197,37 @@
 	dst.y = dsty;
 	dst.w = dstw;
 	dst.h = dsth;
+#if !defined(PROTO_SDL_H)
 	return overlay->hwfuncs->Display(current_video, overlay, &src, &dst);
+#else
+	return overlay->hwfuncs->Display(current_video, overlay, &src, &dst, SDLBase);
+
+    AROS_LIBFUNC_EXIT
+#endif
 }
 
+#if !defined(PROTO_SDL_H)
 void SDL_FreeYUVOverlay(SDL_Overlay *overlay)
 {
+#else
+AROS_LH1(void, SDL_FreeYUVOverlay,
+	AROS_LHA(SDL_Overlay *, overlay, A0),
+	struct SDLBase *, SDLBase, 63, SDL)
+{
+    AROS_LIBFUNC_INIT
+#endif
 	if ( overlay == NULL ) {
 		return;
 	}
 	if ( overlay->hwfuncs ) {
+#if !defined(PROTO_SDL_H)
 		overlay->hwfuncs->FreeHW(current_video, overlay);
+#else
+		overlay->hwfuncs->FreeHW(current_video, overlay, SDLBase);
+#endif
 	}
 	SDL_free(overlay);
+#if defined(PROTO_SDL_H)        
+    AROS_LIBFUNC_EXIT
+#endif
 }
diff -Naur SDL-1.2.15-orig/src/video/SDL_yuvfuncs.h SDL-1.2.15/src/video/SDL_yuvfuncs.h
--- SDL-1.2.15-orig/src/video/SDL_yuvfuncs.h	2015-05-09 17:47:54.309774226 +0200
+++ SDL-1.2.15/src/video/SDL_yuvfuncs.h	2015-05-09 15:09:59.775739495 +0200
@@ -30,8 +30,15 @@
 #define _THIS	SDL_VideoDevice *_this
 #endif
 struct private_yuvhwfuncs {
+#if !defined(PROTO_SDL_H)
 	int (*Lock)(_THIS, SDL_Overlay *overlay);
 	void (*Unlock)(_THIS, SDL_Overlay *overlay);
 	int (*Display)(_THIS, SDL_Overlay *overlay, SDL_Rect *src, SDL_Rect *dst);
 	void (*FreeHW)(_THIS, SDL_Overlay *overlay);
+#else
+	int (*Lock)(_THIS, SDL_Overlay *overlay, struct SDLBase *SDLBase);
+	void (*Unlock)(_THIS, SDL_Overlay *overlay, struct SDLBase *SDLBase);
+	int (*Display)(_THIS, SDL_Overlay *overlay, SDL_Rect *src, SDL_Rect *dst, struct SDLBase *SDLBase);
+	void (*FreeHW)(_THIS, SDL_Overlay *overlay, struct SDLBase *SDLBase);
+#endif
 };
diff -Naur SDL-1.2.15-orig/src/video/SDL_yuv_mmx.c SDL-1.2.15/src/video/SDL_yuv_mmx.c
--- SDL-1.2.15-orig/src/video/SDL_yuv_mmx.c	2015-05-09 17:47:54.309774226 +0200
+++ SDL-1.2.15/src/video/SDL_yuv_mmx.c	2015-05-09 15:09:59.775739495 +0200
@@ -19,6 +19,11 @@
     Sam Lantinga
     slouken@libsdl.org
 */
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
 #include "SDL_config.h"
 
 #if (__GNUC__ > 2) && defined(__i386__) && __OPTIMIZE__ && SDL_ASSEMBLY_ROUTINES
diff -Naur SDL-1.2.15-orig/src/video/SDL_yuv_sw.c SDL-1.2.15/src/video/SDL_yuv_sw.c
--- SDL-1.2.15-orig/src/video/SDL_yuv_sw.c	2015-05-09 17:47:54.283774294 +0200
+++ SDL-1.2.15/src/video/SDL_yuv_sw.c	2015-05-09 15:09:59.776739493 +0200
@@ -19,6 +19,11 @@
     Sam Lantinga
     slouken@libsdl.org
 */
+#if defined (SDL_AROS_SHARED)
+#define __NOLIBBASE__
+#include <proto/SDL.h>
+#endif
+
 #include "SDL_config.h"
 
 /* This is the software implementation of the YUV video overlay support */
@@ -923,7 +928,11 @@
 }
 
 
+#if !defined(PROTO_SDL_H)
 SDL_Overlay *SDL_CreateYUV_SW(_THIS, int width, int height, Uint32 format, SDL_Surface *display)
+#else
+SDL_Overlay *SDL_CreateYUV_SWI(_THIS, int width, int height, Uint32 format, SDL_Surface *display, struct SDLBase *SDLBase)
+#endif
 {
 	SDL_Overlay *overlay;
 	struct private_yuvhwdata *swdata;
@@ -1154,17 +1163,29 @@
 	return(overlay);
 }
 
+#if !defined(PROTO_SDL_H)
 int SDL_LockYUV_SW(_THIS, SDL_Overlay *overlay)
+#else
+int SDL_LockYUV_SWI(_THIS, SDL_Overlay *overlay, struct SDLBase *SDLBase)
+#endif
 {
 	return(0);
 }
 
+#if !defined(PROTO_SDL_H)
 void SDL_UnlockYUV_SW(_THIS, SDL_Overlay *overlay)
+#else
+void SDL_UnlockYUV_SWI(_THIS, SDL_Overlay *overlay, struct SDLBase *SDLBase)
+#endif
 {
 	return;
 }
 
+#if !defined(PROTO_SDL_H)
 int SDL_DisplayYUV_SW(_THIS, SDL_Overlay *overlay, SDL_Rect *src, SDL_Rect *dst)
+#else
+int SDL_DisplayYUV_SWI(_THIS, SDL_Overlay *overlay, SDL_Rect *src, SDL_Rect *dst, struct SDLBase *SDLBase)
+#endif
 {
 	struct private_yuvhwdata *swdata;
 	int stretch;
@@ -1275,7 +1296,11 @@
 	return(0);
 }
 
+#if !defined(PROTO_SDL_H)
 void SDL_FreeYUV_SW(_THIS, SDL_Overlay *overlay)
+#else
+void SDL_FreeYUV_SWI(_THIS, SDL_Overlay *overlay, struct SDLBase *SDLBase)
+#endif
 {
 	struct private_yuvhwdata *swdata;
 
diff -Naur SDL-1.2.15-orig/src/video/SDL_yuv_sw_c.h SDL-1.2.15/src/video/SDL_yuv_sw_c.h
--- SDL-1.2.15-orig/src/video/SDL_yuv_sw_c.h	2015-05-09 17:47:54.308774229 +0200
+++ SDL-1.2.15/src/video/SDL_yuv_sw_c.h	2015-05-09 15:09:59.776739493 +0200
@@ -25,7 +25,7 @@
 #include "SDL_sysvideo.h"
 
 /* This is the software implementation of the YUV video overlay support */
-
+#if !defined(PROTO_SDL_H)
 extern SDL_Overlay *SDL_CreateYUV_SW(_THIS, int width, int height, Uint32 format, SDL_Surface *display);
 
 extern int SDL_LockYUV_SW(_THIS, SDL_Overlay *overlay);
@@ -35,3 +35,19 @@
 extern int SDL_DisplayYUV_SW(_THIS, SDL_Overlay *overlay, SDL_Rect *src, SDL_Rect *dst);
 
 extern void SDL_FreeYUV_SW(_THIS, SDL_Overlay *overlay);
+
+#else
+#include "SDL_intern.h"
+
+extern SDL_Overlay *SDL_CreateYUV_SWI(_THIS, int width, int height, Uint32 format, SDL_Surface *display, struct SDLBase *SDLBase);
+extern int SDL_LockYUV_SWI(_THIS, SDL_Overlay *overlay, struct SDLBase *SDLBase);
+extern void SDL_UnlockYUV_SWI(_THIS, SDL_Overlay *overlay, struct SDLBase *SDLBase);
+extern int SDL_DisplayYUV_SWI(_THIS, SDL_Overlay *overlay, SDL_Rect *src, SDL_Rect *dst, struct SDLBase *SDLBase);
+extern void SDL_FreeYUV_SWI(_THIS, SDL_Overlay *overlay, struct SDLBase *SDLBase);
+
+#define SDL_CreateYUV_SW(this, width, height, format, display) SDL_CreateYUV_SWI(this, width, height, format, display, SDLBase)
+#define SDL_LockYUV_SW SDL_LockYUV_SWI
+#define SDL_UnlockYUV_SW SDL_UnlockYUV_SWI
+#define SDL_DisplayYUV_SW SDL_DisplayYUV_SWI
+#define SDL_FreeYUV_SW SDL_FreeYUV_SWI
+#endif
diff -Naur SDL-1.2.15-orig/test/testplatform.c SDL-1.2.15/test/testplatform.c
--- SDL-1.2.15-orig/test/testplatform.c	2015-05-09 17:47:54.279774305 +0200
+++ SDL-1.2.15/test/testplatform.c	2015-05-09 15:09:59.776739493 +0200
@@ -197,6 +197,8 @@
 #else
 			"Windows"
 #endif
+#elif __AROS__
+			"AROS"
 #else
 			"an unknown operating system! (see SDL_platform.h)"
 #endif
