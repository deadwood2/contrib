diff -ruN SDL2-2.32.8/docs/README-macos.md SDL2-2.32.8.aros/docs/README-macos.md
--- SDL2-2.32.8/docs/README-macos.md	2024-07-16 12:27:12.000000000 +0000
+++ SDL2-2.32.8.aros/docs/README-macos.md	2025-07-27 14:24:11.344841312 +0000
@@ -1,285 +1,285 @@
-# Mac OS X (aka macOS).
-
-These instructions are for people using Apple's Mac OS X (pronounced
-"ten"), which in newer versions is just referred to as "macOS".
-
-From the developer's point of view, macOS is a sort of hybrid Mac and
-Unix system, and you have the option of using either traditional
-command line tools or Apple's IDE Xcode.
-
-# Command Line Build
-
-To build SDL using the command line, use the standard configure and make
-process:
-
-```bash
-mkdir build
-cd build
-../configure
-make
-sudo make install
-```
-
-CMake is also known to work, although it continues to be a work in progress:
-
-```bash
-mkdir build
-cd build
-cmake -DCMAKE_BUILD_TYPE=Release ..
-make
-sudo make install
-```
-
-
-You can also build SDL as a Universal library (a single binary for both
-64-bit Intel and ARM architectures), by using the build-scripts/clang-fat.sh
-script.
-
-```bash
-mkdir build
-cd build
-CC=$PWD/../build-scripts/clang-fat.sh ../configure
-make
-sudo make install
-```
-
-This script builds SDL with 10.9 ABI compatibility on 64-bit Intel and 11.0
-ABI compatibility on ARM64 architectures.  For best compatibility you
-should compile your application the same way.
-
-Please note that building SDL requires at least Xcode 6 and the 10.9 SDK.
-PowerPC support for macOS has been officially dropped as of SDL 2.0.2.
-32-bit Intel and macOS 10.8 runtime support has been officially dropped as
-of SDL 2.24.0.
-
-To use the library once it's built, you essential have two possibilities:
-use the traditional autoconf/automake/make method, or use Xcode.
-
-
-# Caveats for using SDL with Mac OS X
-
-If you register your own NSApplicationDelegate (using [NSApp setDelegate:]),
-SDL will not register its own. This means that SDL will not terminate using
-SDL_Quit if it receives a termination request, it will terminate like a
-normal app, and it will not send a SDL_DROPFILE when you request to open a
-file with the app. To solve these issues, put the following code in your
-NSApplicationDelegate implementation:
-
-
-```objc
-- (NSApplicationTerminateReply)applicationShouldTerminate:(NSApplication *)sender
-{
-    if (SDL_GetEventState(SDL_QUIT) == SDL_ENABLE) {
-        SDL_Event event;
-        event.type = SDL_QUIT;
-        SDL_PushEvent(&event);
-    }
-
-    return NSTerminateCancel;
-}
-
-- (BOOL)application:(NSApplication *)theApplication openFile:(NSString *)filename
-{
-    if (SDL_GetEventState(SDL_DROPFILE) == SDL_ENABLE) {
-        SDL_Event event;
-        event.type = SDL_DROPFILE;
-        event.drop.file = SDL_strdup([filename UTF8String]);
-        return (SDL_PushEvent(&event) > 0);
-    }
-
-    return NO;
-}
-```
-
-# Using the Simple DirectMedia Layer with a traditional Makefile
-
-An existing autoconf/automake build system for your SDL app has good chances
-to work almost unchanged on macOS. However, to produce a "real" Mac binary
-that you can distribute to users, you need to put the generated binary into a
-so called "bundle", which is basically a fancy folder with a name like
-"MyCoolGame.app".
-
-To get this build automatically, add something like the following rule to
-your Makefile.am:
-
-```make
-bundle_contents = APP_NAME.app/Contents
-APP_NAME_bundle: EXE_NAME
-	mkdir -p $(bundle_contents)/MacOS
-	mkdir -p $(bundle_contents)/Resources
-	echo "APPL????" > $(bundle_contents)/PkgInfo
-	$(INSTALL_PROGRAM) $< $(bundle_contents)/MacOS/
-```
-
-You should replace `EXE_NAME` with the name of the executable. `APP_NAME` is
-what will be visible to the user in the Finder. Usually it will be the same
-as `EXE_NAME` but capitalized. E.g. if `EXE_NAME` is "testgame" then `APP_NAME`
-usually is "TestGame". You might also want to use `@PACKAGE@` to use the
-package name as specified in your configure.ac file.
-
-If your project builds more than one application, you will have to do a bit
-more. For each of your target applications, you need a separate rule.
-
-If you want the created bundles to be installed, you may want to add this
-rule to your Makefile.am:
-
-```make
-install-exec-hook: APP_NAME_bundle
-	rm -rf $(DESTDIR)$(prefix)/Applications/APP_NAME.app
-	mkdir -p $(DESTDIR)$(prefix)/Applications/
-	cp -r $< /$(DESTDIR)$(prefix)Applications/
-```
-
-This rule takes the Bundle created by the rule from step 3 and installs them
-into "$(DESTDIR)$(prefix)/Applications/".
-
-Again, if you want to install multiple applications, you will have to augment
-the make rule accordingly.
-
-But beware! That is only part of the story! With the above, you end up with
-a barebones .app bundle, which is double-clickable from the Finder. But
-there are some more things you should do before shipping your product...
-
-1. The bundle right now probably is dynamically linked against SDL. That
-   means that when you copy it to another computer, *it will not run*,
-   unless you also install SDL on that other computer. A good solution
-   for this dilemma is to static link against SDL. On OS X, you can
-   achieve that by linking against the libraries listed by
-
-   ```bash
-   sdl-config --static-libs
-   ```
-
-   instead of those listed by
-
-   ```bash
-   sdl-config --libs
-   ```
-
-   Depending on how exactly SDL is integrated into your build systems, the
-   way to achieve that varies, so I won't describe it here in detail
-
-2. Add an 'Info.plist' to your application. That is a special XML file which
-   contains some meta-information about your application (like some copyright
-   information, the version of your app, the name of an optional icon file,
-   and other things). Part of that information is displayed by the Finder
-   when you click on the .app, or if you look at the "Get Info" window.
-   More information about Info.plist files can be found on Apple's homepage.
-
-
-As a final remark, let me add that I use some of the techniques (and some
-variations of them) in [Exult](https://github.com/exult/exult) and
-[ScummVM](https://github.com/scummvm/scummvm); both are available in source on
-the net, so feel free to take a peek at them for inspiration!
-
-
-# Using the Simple DirectMedia Layer with Xcode
-
-These instructions are for using Apple's Xcode IDE to build SDL applications.
-
-## First steps
-
-The first thing to do is to unpack the Xcode.tar.gz archive in the
-top level SDL directory (where the Xcode.tar.gz archive resides).
-Because Stuffit Expander will unpack the archive into a subdirectory,
-you should unpack the archive manually from the command line:
-
-```bash
-cd [path_to_SDL_source]
-tar zxf Xcode.tar.gz
-```
-
-This will create a new folder called Xcode, which you can browse
-normally from the Finder.
-
-## Building the Framework
-
-The SDL Library is packaged as a framework bundle, an organized
-relocatable folder hierarchy of executable code, interface headers,
-and additional resources. For practical purposes, you can think of a
-framework as a more user and system-friendly shared library, whose library
-file behaves more or less like a standard UNIX shared library.
-
-To build the framework, simply open the framework project and build it.
-By default, the framework bundle "SDL.framework" is installed in
-/Library/Frameworks. Therefore, the testers and project stationary expect
-it to be located there. However, it will function the same in any of the
-following locations:
-
-* ~/Library/Frameworks
-* /Local/Library/Frameworks
-* /System/Library/Frameworks
-
-## Build Options
-
-There are two "Build Styles" (See the "Targets" tab) for SDL.
-"Deployment" should be used if you aren't tweaking the SDL library.
-"Development" should be used to debug SDL apps or the library itself.
-
-## Building the Testers
-
-Open the SDLTest project and build away!
-
-## Using the Project Stationary
-
-Copy the stationary to the indicated folders to access it from
-the "New Project" and "Add target" menus. What could be easier?
-
-## Setting up a new project by hand
-
-Some of you won't want to use the Stationary so I'll give some tips:
-
-(this is accurate as of Xcode 12.5.)
-
-* Click "File" -> "New" -> "Project...
-* Choose "macOS" and then "App" from the "Application" section.
-* Fill out the options in the next window. User interface is "XIB" and
-  Language is "Objective-C".
-* Remove "main.m" from your project
-* Remove "MainMenu.xib" from your project
-* Remove "AppDelegates.*" from your project
-* Add "\$(HOME)/Library/Frameworks/SDL.framework/Headers" to include path
-* Add "\$(HOME)/Library/Frameworks" to the frameworks search path
-* Add "-framework SDL -framework Foundation -framework AppKit" to "OTHER_LDFLAGS"
-* Add your files
-* Clean and build
-
-## Building from command line
-
-Use `xcode-build` in the same directory as your .pbxproj file
-
-## Running your app
-
-You can send command line args to your app by either invoking it from
-the command line (in *.app/Contents/MacOS) or by entering them in the
-Executables" panel of the target settings.
-
-# Implementation Notes
-
-Some things that may be of interest about how it all works...
-
-## Working directory
-
-In SDL 1.2, the working directory of your SDL app is by default set to its
-parent, but this is no longer the case in SDL 2.0 and later. SDL2 does not
-change the working directory, which means it'll be whatever the command line
-prompt that launched the program was using, or if launched by double-clicking
-in the Finder, it will be "/", the _root of the filesystem_. Plan accordingly!
-You can use SDL_GetBasePath() to find where the program is running from and
-chdir() there directly.
-
-
-## You have a Cocoa App!
-
-Your SDL app is essentially a Cocoa application. When your app
-starts up and the libraries finish loading, a Cocoa procedure is called,
-which sets up the working directory and calls your main() method.
-You are free to modify your Cocoa app with generally no consequence
-to SDL. You cannot, however, easily change the SDL window itself.
-Functionality may be added in the future to help this.
-
-# Bug reports
-
-Bugs are tracked at [the GitHub issue tracker](https://github.com/libsdl-org/SDL/issues/).
-Please feel free to report bugs there!
-
+# Mac OS X (aka macOS).
+
+These instructions are for people using Apple's Mac OS X (pronounced
+"ten"), which in newer versions is just referred to as "macOS".
+
+From the developer's point of view, macOS is a sort of hybrid Mac and
+Unix system, and you have the option of using either traditional
+command line tools or Apple's IDE Xcode.
+
+# Command Line Build
+
+To build SDL using the command line, use the standard configure and make
+process:
+
+```bash
+mkdir build
+cd build
+../configure
+make
+sudo make install
+```
+
+CMake is also known to work, although it continues to be a work in progress:
+
+```bash
+mkdir build
+cd build
+cmake -DCMAKE_BUILD_TYPE=Release ..
+make
+sudo make install
+```
+
+
+You can also build SDL as a Universal library (a single binary for both
+64-bit Intel and ARM architectures), by using the build-scripts/clang-fat.sh
+script.
+
+```bash
+mkdir build
+cd build
+CC=$PWD/../build-scripts/clang-fat.sh ../configure
+make
+sudo make install
+```
+
+This script builds SDL with 10.9 ABI compatibility on 64-bit Intel and 11.0
+ABI compatibility on ARM64 architectures.  For best compatibility you
+should compile your application the same way.
+
+Please note that building SDL requires at least Xcode 6 and the 10.9 SDK.
+PowerPC support for macOS has been officially dropped as of SDL 2.0.2.
+32-bit Intel and macOS 10.8 runtime support has been officially dropped as
+of SDL 2.24.0.
+
+To use the library once it's built, you essential have two possibilities:
+use the traditional autoconf/automake/make method, or use Xcode.
+
+
+# Caveats for using SDL with Mac OS X
+
+If you register your own NSApplicationDelegate (using [NSApp setDelegate:]),
+SDL will not register its own. This means that SDL will not terminate using
+SDL_Quit if it receives a termination request, it will terminate like a
+normal app, and it will not send a SDL_DROPFILE when you request to open a
+file with the app. To solve these issues, put the following code in your
+NSApplicationDelegate implementation:
+
+
+```objc
+- (NSApplicationTerminateReply)applicationShouldTerminate:(NSApplication *)sender
+{
+    if (SDL_GetEventState(SDL_QUIT) == SDL_ENABLE) {
+        SDL_Event event;
+        event.type = SDL_QUIT;
+        SDL_PushEvent(&event);
+    }
+
+    return NSTerminateCancel;
+}
+
+- (BOOL)application:(NSApplication *)theApplication openFile:(NSString *)filename
+{
+    if (SDL_GetEventState(SDL_DROPFILE) == SDL_ENABLE) {
+        SDL_Event event;
+        event.type = SDL_DROPFILE;
+        event.drop.file = SDL_strdup([filename UTF8String]);
+        return (SDL_PushEvent(&event) > 0);
+    }
+
+    return NO;
+}
+```
+
+# Using the Simple DirectMedia Layer with a traditional Makefile
+
+An existing autoconf/automake build system for your SDL app has good chances
+to work almost unchanged on macOS. However, to produce a "real" Mac binary
+that you can distribute to users, you need to put the generated binary into a
+so called "bundle", which is basically a fancy folder with a name like
+"MyCoolGame.app".
+
+To get this build automatically, add something like the following rule to
+your Makefile.am:
+
+```make
+bundle_contents = APP_NAME.app/Contents
+APP_NAME_bundle: EXE_NAME
+	mkdir -p $(bundle_contents)/MacOS
+	mkdir -p $(bundle_contents)/Resources
+	echo "APPL????" > $(bundle_contents)/PkgInfo
+	$(INSTALL_PROGRAM) $< $(bundle_contents)/MacOS/
+```
+
+You should replace `EXE_NAME` with the name of the executable. `APP_NAME` is
+what will be visible to the user in the Finder. Usually it will be the same
+as `EXE_NAME` but capitalized. E.g. if `EXE_NAME` is "testgame" then `APP_NAME`
+usually is "TestGame". You might also want to use `@PACKAGE@` to use the
+package name as specified in your configure.ac file.
+
+If your project builds more than one application, you will have to do a bit
+more. For each of your target applications, you need a separate rule.
+
+If you want the created bundles to be installed, you may want to add this
+rule to your Makefile.am:
+
+```make
+install-exec-hook: APP_NAME_bundle
+	rm -rf $(DESTDIR)$(prefix)/Applications/APP_NAME.app
+	mkdir -p $(DESTDIR)$(prefix)/Applications/
+	cp -r $< /$(DESTDIR)$(prefix)Applications/
+```
+
+This rule takes the Bundle created by the rule from step 3 and installs them
+into "$(DESTDIR)$(prefix)/Applications/".
+
+Again, if you want to install multiple applications, you will have to augment
+the make rule accordingly.
+
+But beware! That is only part of the story! With the above, you end up with
+a barebones .app bundle, which is double-clickable from the Finder. But
+there are some more things you should do before shipping your product...
+
+1. The bundle right now probably is dynamically linked against SDL. That
+   means that when you copy it to another computer, *it will not run*,
+   unless you also install SDL on that other computer. A good solution
+   for this dilemma is to static link against SDL. On OS X, you can
+   achieve that by linking against the libraries listed by
+
+   ```bash
+   sdl-config --static-libs
+   ```
+
+   instead of those listed by
+
+   ```bash
+   sdl-config --libs
+   ```
+
+   Depending on how exactly SDL is integrated into your build systems, the
+   way to achieve that varies, so I won't describe it here in detail
+
+2. Add an 'Info.plist' to your application. That is a special XML file which
+   contains some meta-information about your application (like some copyright
+   information, the version of your app, the name of an optional icon file,
+   and other things). Part of that information is displayed by the Finder
+   when you click on the .app, or if you look at the "Get Info" window.
+   More information about Info.plist files can be found on Apple's homepage.
+
+
+As a final remark, let me add that I use some of the techniques (and some
+variations of them) in [Exult](https://github.com/exult/exult) and
+[ScummVM](https://github.com/scummvm/scummvm); both are available in source on
+the net, so feel free to take a peek at them for inspiration!
+
+
+# Using the Simple DirectMedia Layer with Xcode
+
+These instructions are for using Apple's Xcode IDE to build SDL applications.
+
+## First steps
+
+The first thing to do is to unpack the Xcode.tar.gz archive in the
+top level SDL directory (where the Xcode.tar.gz archive resides).
+Because Stuffit Expander will unpack the archive into a subdirectory,
+you should unpack the archive manually from the command line:
+
+```bash
+cd [path_to_SDL_source]
+tar zxf Xcode.tar.gz
+```
+
+This will create a new folder called Xcode, which you can browse
+normally from the Finder.
+
+## Building the Framework
+
+The SDL Library is packaged as a framework bundle, an organized
+relocatable folder hierarchy of executable code, interface headers,
+and additional resources. For practical purposes, you can think of a
+framework as a more user and system-friendly shared library, whose library
+file behaves more or less like a standard UNIX shared library.
+
+To build the framework, simply open the framework project and build it.
+By default, the framework bundle "SDL.framework" is installed in
+/Library/Frameworks. Therefore, the testers and project stationary expect
+it to be located there. However, it will function the same in any of the
+following locations:
+
+* ~/Library/Frameworks
+* /Local/Library/Frameworks
+* /System/Library/Frameworks
+
+## Build Options
+
+There are two "Build Styles" (See the "Targets" tab) for SDL.
+"Deployment" should be used if you aren't tweaking the SDL library.
+"Development" should be used to debug SDL apps or the library itself.
+
+## Building the Testers
+
+Open the SDLTest project and build away!
+
+## Using the Project Stationary
+
+Copy the stationary to the indicated folders to access it from
+the "New Project" and "Add target" menus. What could be easier?
+
+## Setting up a new project by hand
+
+Some of you won't want to use the Stationary so I'll give some tips:
+
+(this is accurate as of Xcode 12.5.)
+
+* Click "File" -> "New" -> "Project...
+* Choose "macOS" and then "App" from the "Application" section.
+* Fill out the options in the next window. User interface is "XIB" and
+  Language is "Objective-C".
+* Remove "main.m" from your project
+* Remove "MainMenu.xib" from your project
+* Remove "AppDelegates.*" from your project
+* Add "\$(HOME)/Library/Frameworks/SDL.framework/Headers" to include path
+* Add "\$(HOME)/Library/Frameworks" to the frameworks search path
+* Add "-framework SDL -framework Foundation -framework AppKit" to "OTHER_LDFLAGS"
+* Add your files
+* Clean and build
+
+## Building from command line
+
+Use `xcode-build` in the same directory as your .pbxproj file
+
+## Running your app
+
+You can send command line args to your app by either invoking it from
+the command line (in *.app/Contents/MacOS) or by entering them in the
+Executables" panel of the target settings.
+
+# Implementation Notes
+
+Some things that may be of interest about how it all works...
+
+## Working directory
+
+In SDL 1.2, the working directory of your SDL app is by default set to its
+parent, but this is no longer the case in SDL 2.0 and later. SDL2 does not
+change the working directory, which means it'll be whatever the command line
+prompt that launched the program was using, or if launched by double-clicking
+in the Finder, it will be "/", the _root of the filesystem_. Plan accordingly!
+You can use SDL_GetBasePath() to find where the program is running from and
+chdir() there directly.
+
+
+## You have a Cocoa App!
+
+Your SDL app is essentially a Cocoa application. When your app
+starts up and the libraries finish loading, a Cocoa procedure is called,
+which sets up the working directory and calls your main() method.
+You are free to modify your Cocoa app with generally no consequence
+to SDL. You cannot, however, easily change the SDL window itself.
+Functionality may be added in the future to help this.
+
+# Bug reports
+
+Bugs are tracked at [the GitHub issue tracker](https://github.com/libsdl-org/SDL/issues/).
+Please feel free to report bugs there!
+
diff -ruN SDL2-2.32.8/include/begin_code.h SDL2-2.32.8.aros/include/begin_code.h
--- SDL2-2.32.8/include/begin_code.h	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/include/begin_code.h	2025-07-28 13:13:58.433582407 +0000
@@ -66,7 +66,7 @@
 #    define DECLSPEC
 #   endif
 # else
-#  if defined(__GNUC__) && __GNUC__ >= 4
+#  if !defined(__AROS__) && defined(__GNUC__) && __GNUC__ >= 4
 #   define DECLSPEC __attribute__ ((visibility("default")))
 #  else
 #   define DECLSPEC
diff -ruN SDL2-2.32.8/include/SDL_config_aros.h SDL2-2.32.8.aros/include/SDL_config_aros.h
--- SDL2-2.32.8/include/SDL_config_aros.h	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/include/SDL_config_aros.h	2025-07-28 16:03:48.979186309 +0000
@@ -0,0 +1,490 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2022 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#ifndef _SDL_config_aros_h
+#define _SDL_config_aros_h
+
+/**
+ *  \file SDL_config.h.in
+ *
+ *  This is a set of defines to configure the SDL features
+ */
+
+/* General platform specific identifiers */
+#include "SDL_platform.h"
+
+/* C datatypes */
+#define SIZEOF_VOIDP sizeof(IPTR)
+
+#define HAVE_GCC_ATOMICS 1
+/* #undef HAVE_GCC_SYNC_LOCK_TEST_AND_SET */
+
+//#define HAVE_STDDEF_H   1
+
+#define LACKS_SYS_MMAN_H 1
+
+/* Useful headers */
+#define STDC_HEADERS 1
+#define HAVE_ALLOCA_H 1
+#define HAVE_CTYPE_H 1
+#define HAVE_FLOAT_H 1
+#define HAVE_ICONV_H 1
+#define HAVE_INTTYPES_H 1
+#define HAVE_LIMITS_H 1
+#define HAVE_MALLOC_H 1
+#define HAVE_MATH_H 1
+#define HAVE_MEMORY_H 1
+#if !defined(BUILD_SDL2_LIBRARY)
+#define HAVE_SIGNAL_H 1
+#endif
+#define HAVE_STDARG_H 1
+#define HAVE_STDINT_H 1
+#define HAVE_STDIO_H 1
+#define HAVE_STDLIB_H 1
+#define HAVE_STRINGS_H 1
+#define HAVE_STRING_H 1
+#define HAVE_SYS_TYPES_H 1
+#define HAVE_WCHAR_H 1
+/* #undef HAVE_PTHREAD_NP_H */
+/* #undef HAVE_LIBUNWIND_H */
+
+/* C library functions */
+#define HAVE_MALLOC 1
+#define HAVE_CALLOC 1
+#define HAVE_REALLOC    1
+#define HAVE_FREE   1
+#define HAVE_ALLOCA 1
+//#ifndef __WIN32__ /* Don't use C runtime versions of these on Windows */
+//#define HAVE_GETENV 1
+//#define HAVE_SETENV 1
+//#define HAVE_PUTENV 1
+//#define HAVE_UNSETENV 1
+//#endif
+#define HAVE_QSORT  1
+#define HAVE_ABS    1
+#define HAVE_BCOPY  1
+#define HAVE_MEMSET 1
+#define HAVE_MEMCPY 1
+#define HAVE_MEMMOVE    1
+#define HAVE_MEMCMP 1
+#define HAVE_WCSLEN 1
+/* #undef HAVE_WCSLCPY */
+/* #undef HAVE_WCSLCAT */
+#define HAVE_WCSCMP 1
+#define HAVE_STRLEN 1
+#define HAVE_STRLCPY    1
+#define HAVE_STRLCAT    1
+/* #undef HAVE__STRREV */
+/* #undef HAVE__STRUPR */
+/* #undef HAVE__STRLWR */
+/* #undef HAVE_INDEX */
+/* #undef HAVE_RINDEX */
+#define HAVE_STRCHR 1
+#define HAVE_STRRCHR    1
+#define HAVE_STRSTR 1
+/* #undef HAVE_ITOA */
+/* #undef HAVE__LTOA */
+/* #undef HAVE__UITOA */
+/* #undef HAVE__ULTOA */
+#define HAVE_STRTOL 1
+#define HAVE_STRTOUL    1
+/* #undef HAVE__I64TOA */
+/* #undef HAVE__UI64TOA */
+#define HAVE_STRTOLL    1
+#define HAVE_STRTOULL   1
+/* #undef HAVE_STRTOD */
+#define HAVE_STRTOD 1
+#define HAVE_ATOI   1
+#define HAVE_ATOF   1
+#define HAVE_STRCMP 1
+#define HAVE_STRNCMP    1
+/* #undef HAVE__STRICMP */
+#define HAVE_STRCASECMP 1
+/* #undef HAVE__STRNICMP */
+#define HAVE_STRNCASECMP 1
+/* #undef HAVE_SSCANF */
+#define HAVE_VSSCANF 1
+/* #undef HAVE_SNPRINTF */
+#define HAVE_VSNPRINTF  1
+#define HAVE_M_PI /**/
+#define HAVE_ACOS 1
+#define HAVE_ACOSF 1
+#define HAVE_ASIN 1
+#define HAVE_ASINF 1
+#define HAVE_ATAN 1
+#define HAVE_ATANF 1
+#define HAVE_ATAN2 1
+#define HAVE_ATAN2F 1
+#define HAVE_CEIL   1
+#define HAVE_CEILF 1
+#define HAVE_COPYSIGN   1
+#define HAVE_COPYSIGNF 1
+#define HAVE_COS    1
+#define HAVE_COSF   1
+#define HAVE_EXP    1
+#define HAVE_EXPF   1
+#define HAVE_FABS   1
+#define HAVE_FABSF 1
+#define HAVE_FLOOR  1
+#define HAVE_FLOORF 1
+#define HAVE_FMOD 1
+#define HAVE_FMODF 1
+#define HAVE_LOG    1
+#define HAVE_LOGF 1
+#define HAVE_LOG10 1
+#define HAVE_LOG10F 1
+#define HAVE_POW	1
+#define HAVE_POWF 	1
+#define HAVE_SCALBN 1
+#define HAVE_SCALBNF 1
+#define HAVE_SIN    1
+#define HAVE_SINF   1
+#define HAVE_SQRT   1
+#define HAVE_SQRTF  1
+#define HAVE_TAN 1
+#define HAVE_TANF 1
+/* #undef HAVE_FOPEN64 1 */
+/* #undef HAVE_FSEEKO 1 */
+/* #undef HAVE_FSEEKO64 1 */
+/* #undef HAVE_SIGACTION */
+/* #undef HAVE_SA_SIGACTION */
+#define HAVE_SETJMP 1
+#define HAVE_NANOSLEEP  1
+#define HAVE_SYSCONF    1
+/* #undef HAVE_SYSCTLBYNAME */
+/* #undef HAVE_CLOCK_GETTIME */
+/* #undef HAVE_GETPAGESIZE */
+#define HAVE_MPROTECT 1
+#define HAVE_ICONV 1
+#define SDL_USE_LIBICONV 1
+/* #undef HAVE_PTHREAD_SETNAME_NP */
+/* #undef HAVE_PTHREAD_SET_NAME_NP */
+/* #undef HAVE_SEM_TIMEDWAIT */
+/* #undef HAVE_GETAUXVAL */
+/* #undef HAVE_ELF_AUX_INFO */
+// #undef HAVE_POLL 1
+// #undef HAVE__EXIT 1
+
+/* #undef HAVE_O_CLOEXEC */
+/* #undef HAVE_ALTIVEC_H */
+/* #undef HAVE_DBUS_DBUS_H */
+/* #undef HAVE_FCITX */
+/* #undef HAVE_SYS_INOTIFY_H */
+/* #undef HAVE_INOTIFY_INIT */
+/* #undef HAVE_INOTIFY_INIT1 */
+/* #undef HAVE_INOTIFY */
+/* #undef HAVE_IBUS_IBUS_H */
+/* #undef HAVE_IMMINTRIN_H */
+/* #undef HAVE_LIBUDEV_H */
+/* #undef HAVE_LIBUSB */
+/* #undef HAVE_LIBSAMPLERATE_H */
+/* #undef HAVE_LIBDECOR_H */
+/* #undef HAVE_LSXINTRIN_H */
+/* #undef HAVE_LASXINTRIN_H */
+
+/* #undef HAVE_DDRAW_H */
+/* #undef HAVE_DINPUT_H */
+/* #undef HAVE_DSOUND_H */
+/* #undef HAVE_DXGI_H */
+/* #undef HAVE_WINDOWS_GAMING_INPUT_H */
+/* #undef HAVE_XINPUT_H */
+/* #undef HAVE_XINPUT_GAMEPAD_EX */
+/* #undef HAVE_XINPUT_STATE_EX */
+
+/* #undef HAVE_MMDEVICEAPI_H */
+/* #undef HAVE_AUDIOCLIENT_H */
+/* #undef HAVE_TPCSHRD_H */
+/* #undef HAVE_SENSORSAPI_H */
+/* #undef HAVE_ROAPI_H */
+/* #undef HAVE_SHELLSCALINGAPI_H */
+
+/* SDL internal assertion support */
+/* #undef SDL_DEFAULT_ASSERT_LEVEL */
+
+/* Allow disabling of core subsystems */
+/* #undef SDL_ATOMIC_DISABLED */
+/* #undef SDL_AUDIO_DISABLED */
+/* #undef SDL_CPUINFO_DISABLED */
+/* #undef SDL_EVENTS_DISABLED */
+/* #undef SDL_FILE_DISABLED */
+/* #undef SDL_JOYSTICK_DISABLED */
+//#define SDL_HAPTIC_DISABLED 1
+#define SDL_HIDAPI_DISABLED 1
+#define SDL_SENSOR_DISABLED 1
+#define SDL_LOADSO_DISABLED 1
+/* #undef SDL_RENDER_DISABLED */
+/* #undef SDL_THREADS_DISABLED */
+/* #undef SDL_TIMERS_DISABLED */
+/* #undef SDL_VIDEO_DISABLED */
+/* #undef SDL_POWER_DISABLED */
+/* #undef SDL_FILESYSTEM_DISABLED */
+/* #undef SDL_LOCALE_DISABLED */
+/* #undef SDL_MISC_DISABLED */
+
+/* Enable various audio drivers */
+/* #undef SDL_AUDIO_DRIVER_AAUDIO */
+/* #undef SDL_AUDIO_DRIVER_ALSA */
+/* #undef SDL_AUDIO_DRIVER_ALSA_DYNAMIC */
+/* #undef SDL_AUDIO_DRIVER_ANDROID */
+/* #undef SDL_AUDIO_DRIVER_ARTS */
+/* #undef SDL_AUDIO_DRIVER_ARTS_DYNAMIC */
+/* #undef SDL_AUDIO_DRIVER_COREAUDIO */
+/* #undef SDL_AUDIO_DRIVER_DISK */
+/* #undef SDL_AUDIO_DRIVER_DSOUND */
+/* #undef SDL_AUDIO_DRIVER_DUMMY */
+/* #undef SDL_AUDIO_DRIVER_EMSCRIPTEN */
+/* #undef SDL_AUDIO_DRIVER_ESD */
+/* #undef SDL_AUDIO_DRIVER_ESD_DYNAMIC */
+/* #undef SDL_AUDIO_DRIVER_FUSIONSOUND */
+/* #undef SDL_AUDIO_DRIVER_FUSIONSOUND_DYNAMIC */
+/* #undef SDL_AUDIO_DRIVER_HAIKU */
+/* #undef SDL_AUDIO_DRIVER_JACK */
+/* #undef SDL_AUDIO_DRIVER_JACK_DYNAMIC */
+/* #undef SDL_AUDIO_DRIVER_NACL */
+/* #undef SDL_AUDIO_DRIVER_NAS */
+/* #undef SDL_AUDIO_DRIVER_NAS_DYNAMIC */
+/* #undef SDL_AUDIO_DRIVER_NETBSD */
+/* #undef SDL_AUDIO_DRIVER_OPENSLES */
+/* #undef SDL_AUDIO_DRIVER_OSS */
+/* #undef SDL_AUDIO_DRIVER_OSS_SOUNDCARD_H */
+/* #undef SDL_AUDIO_DRIVER_PAUDIO */
+/* #undef SDL_AUDIO_DRIVER_PIPEWIRE */
+/* #undef SDL_AUDIO_DRIVER_PIPEWIRE_DYNAMIC */
+/* #undef SDL_AUDIO_DRIVER_PULSEAUDIO */
+/* #undef SDL_AUDIO_DRIVER_PULSEAUDIO_DYNAMIC */
+/* #undef SDL_AUDIO_DRIVER_QSA */
+/* #undef SDL_AUDIO_DRIVER_SNDIO */
+/* #undef SDL_AUDIO_DRIVER_SNDIO_DYNAMIC */
+/* #undef SDL_AUDIO_DRIVER_SUNAUDIO */
+/* #undef SDL_AUDIO_DRIVER_WASAPI */
+/* #undef SDL_AUDIO_DRIVER_WINMM */
+/* #undef SDL_AUDIO_DRIVER_OS2 */
+#define SDL_AUDIO_DRIVER_AHI 1
+
+/* Enable various input drivers */
+/* #undef SDL_INPUT_LINUXEV */
+/* #undef SDL_INPUT_FBSDKBIO */
+/* #undef SDL_INPUT_LINUXKD */
+/* #undef SDL_INPUT_WSCONS */
+/* #undef SDL_JOYSTICK_HAIKU */
+/* #undef SDL_JOYSTICK_DINPUT */
+/* #undef SDL_JOYSTICK_WGI */
+/* #undef SDL_JOYSTICK_XINPUT */
+/* #undef SDL_JOYSTICK_DUMMY */
+/* #undef SDL_JOYSTICK_IOKIT */
+/* #undef SDL_JOYSTICK_MFI */
+/* #undef SDL_JOYSTICK_LINUX */
+/* #undef SDL_JOYSTICK_ANDROID */
+/* #undef SDL_JOYSTICK_OS2 */
+/* #undef SDL_JOYSTICK_USBHID */
+/* #undef SDL_HAVE_MACHINE_JOYSTICK_H */
+/* #undef SDL_JOYSTICK_HIDAPI */
+/* #undef SDL_JOYSTICK_RAWINPUT */
+/* #undef SDL_JOYSTICK_EMSCRIPTEN */
+/* #undef SDL_JOYSTICK_VIRTUAL */
+#define SDL_JOYSTICK_AROS   1
+//#define SDL_JOYSTICK_MORPHOS   1 /* Enable MORPHOS SENSORS JOYSTICK/GAMEPAD */ 
+#define SDL_HAPTIC_DUMMY 1
+/* #undef SDL_HAPTIC_ANDROID */
+/* #undef SDL_HAPTIC_LINUX */
+/* #undef SDL_HAPTIC_IOKIT */
+/* #undef SDL_HAPTIC_DINPUT */
+/* #undef SDL_HAPTIC_XINPUT */
+
+/* Enable various sensor drivers */
+/* #undef SDL_SENSOR_ANDROID */
+/* #undef SDL_SENSOR_COREMOTION */
+/* #undef SDL_SENSOR_WINDOWS */
+/* #undef SDL_SENSOR_DUMMY */
+
+/* Enable various shared object loading systems */
+/* #undef SDL_LOADSO_DLOPEN */
+/* #undef SDL_LOADSO_DUMMY */
+/* #undef SDL_LOADSO_LDG */
+/* #undef SDL_LOADSO_WINDOWS */
+/* #undef SDL_LOADSO_OS2 */
+
+/* Enable various threading systems */
+/* #undef SDL_THREAD_GENERIC_COND_SUFFIX */
+/* #undef SDL_THREAD_PTHREAD */
+/* #undef SDL_THREAD_PTHREAD_RECURSIVE_MUTEX */
+/* #undef SDL_THREAD_PTHREAD_RECURSIVE_MUTEX_NP */
+/* #undef SDL_THREAD_WINDOWS */
+/* #undef SDL_THREAD_OS2 */
+#define SDL_THREAD_AROS    1
+#define SDL_THREAD_MORPHOS    1
+
+/* Enable various timer systems */
+/* #undef SDL_TIMER_HAIKU */
+/* #undef SDL_TIMER_DUMMY */
+/* #undef SDL_TIMER_UNIX */
+/* #undef SDL_TIMER_WINDOWS */
+/* #undef SDL_TIMER_OS2 */
+#define SDL_TIMER_AROS 1
+#define SDL_TIMER_MORPHOS 1
+
+/* Enable various video drivers */
+/* #undef SDL_VIDEO_DRIVER_HAIKU */
+/* #undef SDL_VIDEO_DRIVER_COCOA */
+/* #undef SDL_VIDEO_DRIVER_DIRECTFB */
+/* #undef SDL_VIDEO_DRIVER_DIRECTFB_DYNAMIC */
+#define SDL_VIDEO_DRIVER_DUMMY 1
+/* #undef SDL_VIDEO_DRIVER_WINDOWS */
+/* #undef SDL_VIDEO_DRIVER_WAYLAND */
+/* #undef SDL_VIDEO_DRIVER_WAYLAND_QT_TOUCH */
+/* #undef SDL_VIDEO_DRIVER_WAYLAND_DYNAMIC */
+/* #undef SDL_VIDEO_DRIVER_WAYLAND_DYNAMIC_EGL */
+/* #undef SDL_VIDEO_DRIVER_WAYLAND_DYNAMIC_CURSOR */
+/* #undef SDL_VIDEO_DRIVER_WAYLAND_DYNAMIC_XKBCOMMON */
+/* #undef SDL_VIDEO_DRIVER_WAYLAND_DYNAMIC_LIBDECOR */
+/* #undef SDL_VIDEO_DRIVER_X11 */
+/* #undef SDL_VIDEO_DRIVER_RPI */
+/* #undef SDL_VIDEO_DRIVER_KMSDRM */
+/* #undef SDL_VIDEO_DRIVER_KMSDRM_DYNAMIC */
+/* #undef SDL_VIDEO_DRIVER_KMSDRM_DYNAMIC_GBM */
+/* #undef SDL_VIDEO_DRIVER_ANDROID */
+/* #undef SDL_VIDEO_DRIVER_EMSCRIPTEN */
+/* #undef SDL_VIDEO_DRIVER_OFFSCREEN */
+/* #undef SDL_VIDEO_DRIVER_X11_DYNAMIC */
+/* #undef SDL_VIDEO_DRIVER_X11_DYNAMIC_XEXT */
+/* #undef SDL_VIDEO_DRIVER_X11_DYNAMIC_XCURSOR */
+/* #undef SDL_VIDEO_DRIVER_X11_DYNAMIC_XINPUT2 */
+/* #undef SDL_VIDEO_DRIVER_X11_DYNAMIC_XFIXES */
+/* #undef SDL_VIDEO_DRIVER_X11_DYNAMIC_XRANDR */
+/* #undef SDL_VIDEO_DRIVER_X11_DYNAMIC_XSS */
+/* #undef SDL_VIDEO_DRIVER_X11_XCURSOR */
+/* #undef SDL_VIDEO_DRIVER_X11_XDBE */
+/* #undef SDL_VIDEO_DRIVER_X11_XINPUT2 */
+/* #undef SDL_VIDEO_DRIVER_X11_XINPUT2_SUPPORTS_MULTITOUCH */
+/* #undef SDL_VIDEO_DRIVER_X11_XFIXES */
+/* #undef SDL_VIDEO_DRIVER_X11_XRANDR */
+/* #undef SDL_VIDEO_DRIVER_X11_XSCRNSAVER */
+/* #undef SDL_VIDEO_DRIVER_X11_XSHAPE */
+/* #undef SDL_VIDEO_DRIVER_X11_SUPPORTS_GENERIC_EVENTS */
+/* #undef SDL_VIDEO_DRIVER_X11_HAS_XKBKEYCODETOKEYSYM */
+/* #undef SDL_VIDEO_DRIVER_NACL */
+/* #undef SDL_VIDEO_DRIVER_VIVANTE */
+/* #undef SDL_VIDEO_DRIVER_VIVANTE_VDK */
+/* #undef SDL_VIDEO_DRIVER_OS2 */
+/* #undef SDL_VIDEO_DRIVER_QNX */
+/* #undef SDL_VIDEO_DRIVER_RISCOS */
+#define SDL_VIDEO_DRIVER_AROS 1
+//#define SDL_VIDEO_DRIVER_MORPHOS 1
+
+/* #undef SDL_VIDEO_RENDER_D3D */
+/* #undef SDL_VIDEO_RENDER_D3D11 */
+/* #undef SDL_VIDEO_RENDER_D3D12 */
+#define SDL_VIDEO_RENDER_OGL 1
+/* #undef SDL_VIDEO_RENDER_OGL_ES */
+/* #undef SDL_VIDEO_RENDER_OGL_ES2 */
+/* #undef SDL_VIDEO_RENDER_DIRECTFB */
+/* #undef SDL_VIDEO_RENDER_METAL */
+
+/* Enable OpenGL support */
+#define SDL_VIDEO_OPENGL 1
+#define SDL_VIDEO_OPENGL_AGL 1
+/* #undef SDL_VIDEO_OPENGL_ES */
+/* #undef SDL_VIDEO_OPENGL_ES2 */
+/* #undef SDL_VIDEO_OPENGL_BGL */
+/* #undef SDL_VIDEO_OPENGL_CGL */
+/* #undef SDL_VIDEO_OPENGL_EGL */
+/* #undef SDL_VIDEO_OPENGL_GLX */
+/* #undef SDL_VIDEO_OPENGL_WGL */
+/* #undef SDL_VIDEO_OPENGL_OSMESA */
+/* #undef SDL_VIDEO_OPENGL_OSMESA_DYNAMIC */
+
+/* Enable Vulkan support */
+/* #undef SDL_VIDEO_VULKAN */
+
+/* Enable Metal support */
+/* #undef SDL_VIDEO_METAL */
+
+/* Enable system power support */
+/* #undef SDL_POWER_LINUX */
+/* #undef SDL_POWER_WINDOWS */
+/* #undef SDL_POWER_MACOSX */
+/* #undef SDL_POWER_HAIKU */
+/* #undef SDL_POWER_ANDROID */
+/* #undef SDL_POWER_EMSCRIPTEN */
+/* #undef SDL_POWER_HARDWIRED */
+#define SDL_POWER_AROS 1
+/* #undef SDL_POWER_MORPHOS */
+
+/* Enable system filesystem support */
+/* #undef SDL_FILESYSTEM_ANDROID */
+/* #undef SDL_FILESYSTEM_HAIKU */
+/* #undef SDL_FILESYSTEM_COCOA */
+/* #undef SDL_FILESYSTEM_DUMMY */
+/* #undef SDL_FILESYSTEM_RISCOS */
+/* #undef SDL_FILESYSTEM_UNIX */
+/* #undef SDL_FILESYSTEM_WINDOWS */
+/* #undef SDL_FILESYSTEM_NACL */
+/* #undef SDL_FILESYSTEM_EMSCRIPTEN */
+/* #undef SDL_FILESYSTEM_OS2 */
+/* #undef SDL_FILESYSTEM_VITA */
+/* #undef SDL_FILESYSTEM_PSP */
+/* #undef SDL_FILESYSTEM_PS2 */
+#define SDL_FILESYSTEM_AROS  1
+#define SDL_FILESYSTEM_MORPHOS  1
+
+/* Enable misc subsystem */
+/* #undef SDL_MISC_DUMMY */
+
+/* Enable locale subsystem */
+/* #undef SDL_LOCALE_DUMMY */
+
+/* Enable assembly routines */
+
+#if defined(__PPC__) || defined(__powerpc__)
+#define SDL_ALTIVEC_BLITTERS  1
+#define SDL_ENABLE_ALTIVEC_H 1
+#endif
+#if defined(__arm__)
+#define SDL_ARM_SIMD_BLITTERS 1
+#define SDL_ARM_NEON_BLITTERS 1
+#endif
+
+/* Whether SDL_DYNAMIC_API needs dlopen() */
+/* #undef DYNAPI_NEEDS_DLOPEN */
+
+/* Enable ime support */
+/* #undef SDL_USE_IME */
+
+/* Enable dynamic udev support */
+/* #undef SDL_UDEV_DYNAMIC */
+
+/* Enable dynamic libusb support */
+/* #undef SDL_LIBUSB_DYNAMIC */
+
+/* Enable dynamic libsamplerate support */
+/* #undef SDL_LIBSAMPLERATE_DYNAMIC */
+
+#ifndef D
+#if defined(__SDL_DEBUG)
+    #include <exec/types.h>
+    extern struct ExecBase *SysBase;
+    #define D(fmt, ...) ({((STRPTR (*)(void *, CONST_STRPTR , APTR (*)(APTR, UBYTE), STRPTR , ...))*(void**)((long)(SysBase) - 922))((void*)(SysBase), fmt, (APTR)1, NULL, ##__VA_ARGS__);})
+#else
+    #define D(fmt, ...)
+#endif
+#endif
+
+#endif /* _SDL_config_aros_h */
diff -ruN SDL2-2.32.8/include/SDL_config.h SDL2-2.32.8.aros/include/SDL_config.h
--- SDL2-2.32.8/include/SDL_config.h	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/include/SDL_config.h	2025-07-27 14:24:11.508841313 +0000
@@ -43,10 +43,14 @@
 #include "SDL_config_android.h"
 #elif defined(__OS2__)
 #include "SDL_config_os2.h"
+#elif defined(__MORPHOS__)
+#include "SDL_config_morphos.h"
 #elif defined(__EMSCRIPTEN__)
 #include "SDL_config_emscripten.h"
 #elif defined(__NGAGE__)
 #include "SDL_config_ngage.h"
+#elif defined(__AROS__)
+#include "SDL_config_aros.h"
 #else
 /* This is a minimal configuration just to get SDL running on new platforms. */
 #include "SDL_config_minimal.h"
diff -ruN SDL2-2.32.8/include/SDL_config_morphos.h SDL2-2.32.8.aros/include/SDL_config_morphos.h
--- SDL2-2.32.8/include/SDL_config_morphos.h	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/include/SDL_config_morphos.h	2025-07-27 14:24:11.548841313 +0000
@@ -0,0 +1,479 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2022 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#ifndef _SDL_config_morphos_h
+#define _SDL_config_morphos_h
+
+/**
+ *  \file SDL_config.h.in
+ *
+ *  This is a set of defines to configure the SDL features
+ */
+
+/* General platform specific identifiers */
+#include "SDL_platform.h"
+
+/* C datatypes */
+#define SIZEOF_VOIDP sizeof(IPTR)
+
+#define HAVE_GCC_ATOMICS 1
+/* #undef HAVE_GCC_SYNC_LOCK_TEST_AND_SET */
+
+//#define HAVE_STDDEF_H   1
+
+/* Useful headers */
+#define STDC_HEADERS 1
+#define HAVE_ALLOCA_H 1
+#define HAVE_CTYPE_H 1
+#define HAVE_FLOAT_H 1
+#define HAVE_ICONV_H 1
+#define HAVE_INTTYPES_H 1
+#define HAVE_LIMITS_H 1
+#define HAVE_MALLOC_H 1
+#define HAVE_MATH_H 1
+#define HAVE_MEMORY_H 1
+#if !defined(BUILD_SDL2_LIBRARY)
+#define HAVE_SIGNAL_H 1
+#endif
+#define HAVE_STDARG_H 1
+#define HAVE_STDINT_H 1
+#define HAVE_STDIO_H 1
+#define HAVE_STDLIB_H 1
+#define HAVE_STRINGS_H 1
+#define HAVE_STRING_H 1
+#define HAVE_SYS_TYPES_H 1
+#define HAVE_WCHAR_H 1
+/* #undef HAVE_PTHREAD_NP_H */
+/* #undef HAVE_LIBUNWIND_H */
+
+/* C library functions */
+#define HAVE_MALLOC 1
+#define HAVE_CALLOC 1
+#define HAVE_REALLOC    1
+#define HAVE_FREE   1
+#define HAVE_ALLOCA 1
+//#ifndef __WIN32__ /* Don't use C runtime versions of these on Windows */
+//#define HAVE_GETENV 1
+//#define HAVE_SETENV 1
+//#define HAVE_PUTENV 1
+//#define HAVE_UNSETENV 1
+//#endif
+#define HAVE_QSORT  1
+#define HAVE_ABS    1
+#define HAVE_BCOPY  1
+#define HAVE_MEMSET 1
+#define HAVE_MEMCPY 1
+#define HAVE_MEMMOVE    1
+#define HAVE_MEMCMP 1
+#define HAVE_WCSLEN 1
+/* #undef HAVE_WCSLCPY */
+/* #undef HAVE_WCSLCAT */
+#define HAVE_WCSCMP 1
+#define HAVE_STRLEN 1
+#define HAVE_STRLCPY    1
+#define HAVE_STRLCAT    1
+/* #undef HAVE__STRREV */
+/* #undef HAVE__STRUPR */
+/* #undef HAVE__STRLWR */
+/* #undef HAVE_INDEX */
+/* #undef HAVE_RINDEX */
+#define HAVE_STRCHR 1
+#define HAVE_STRRCHR    1
+#define HAVE_STRSTR 1
+/* #undef HAVE_ITOA */
+/* #undef HAVE__LTOA */
+/* #undef HAVE__UITOA */
+/* #undef HAVE__ULTOA */
+#define HAVE_STRTOL 1
+#define HAVE_STRTOUL    1
+/* #undef HAVE__I64TOA */
+/* #undef HAVE__UI64TOA */
+#define HAVE_STRTOLL    1
+#define HAVE_STRTOULL   1
+/* #undef HAVE_STRTOD */
+#define HAVE_STRTOD 1
+#define HAVE_ATOI   1
+#define HAVE_ATOF   1
+#define HAVE_STRCMP 1
+#define HAVE_STRNCMP    1
+/* #undef HAVE__STRICMP */
+#define HAVE_STRCASECMP 1
+/* #undef HAVE__STRNICMP */
+#define HAVE_STRNCASECMP 1
+/* #undef HAVE_SSCANF */
+#define HAVE_VSSCANF 1
+/* #undef HAVE_SNPRINTF */
+#define HAVE_VSNPRINTF  1
+#define HAVE_M_PI /**/
+#define HAVE_ACOS 1
+#define HAVE_ACOSF 1
+#define HAVE_ASIN 1
+#define HAVE_ASINF 1
+#define HAVE_ATAN 1
+#define HAVE_ATANF 1
+#define HAVE_ATAN2 1
+#define HAVE_ATAN2F 1
+#define HAVE_CEIL   1
+#define HAVE_CEILF 1
+#define HAVE_COPYSIGN   1
+#define HAVE_COPYSIGNF 1
+#define HAVE_COS    1
+#define HAVE_COSF   1
+#define HAVE_EXP    1
+#define HAVE_EXPF   1
+#define HAVE_FABS   1
+#define HAVE_FABSF 1
+#define HAVE_FLOOR  1
+#define HAVE_FLOORF 1
+#define HAVE_FMOD 1
+#define HAVE_FMODF 1
+#define HAVE_LOG    1
+#define HAVE_LOGF 1
+#define HAVE_LOG10 1
+#define HAVE_LOG10F 1
+#define HAVE_POW	1
+#define HAVE_POWF 	1
+#define HAVE_SCALBN 1
+#define HAVE_SCALBNF 1
+#define HAVE_SIN    1
+#define HAVE_SINF   1
+#define HAVE_SQRT   1
+#define HAVE_SQRTF  1
+#define HAVE_TAN 1
+#define HAVE_TANF 1
+/* #undef HAVE_FOPEN64 1 */
+/* #undef HAVE_FSEEKO 1 */
+/* #undef HAVE_FSEEKO64 1 */
+/* #undef HAVE_SIGACTION */
+/* #undef HAVE_SA_SIGACTION */
+#define HAVE_SETJMP 1
+#define HAVE_NANOSLEEP  1
+#define HAVE_SYSCONF    1
+/* #undef HAVE_SYSCTLBYNAME */
+/* #undef HAVE_CLOCK_GETTIME */
+/* #undef HAVE_GETPAGESIZE */
+#define HAVE_MPROTECT 1
+#define HAVE_ICONV 1
+#define SDL_USE_LIBICONV 1
+/* #undef HAVE_PTHREAD_SETNAME_NP */
+/* #undef HAVE_PTHREAD_SET_NAME_NP */
+/* #undef HAVE_SEM_TIMEDWAIT */
+/* #undef HAVE_GETAUXVAL */
+/* #undef HAVE_ELF_AUX_INFO */
+// #undef HAVE_POLL 1
+// #undef HAVE__EXIT 1
+
+/* #undef HAVE_O_CLOEXEC */
+#define HAVE_ALTIVEC_H 1
+/* #undef HAVE_DBUS_DBUS_H */
+/* #undef HAVE_FCITX */
+/* #undef HAVE_SYS_INOTIFY_H */
+/* #undef HAVE_INOTIFY_INIT */
+/* #undef HAVE_INOTIFY_INIT1 */
+/* #undef HAVE_INOTIFY */
+/* #undef HAVE_IBUS_IBUS_H */
+/* #undef HAVE_IMMINTRIN_H */
+/* #undef HAVE_LIBUDEV_H */
+/* #undef HAVE_LIBUSB */
+/* #undef HAVE_LIBSAMPLERATE_H */
+/* #undef HAVE_LIBDECOR_H */
+/* #undef HAVE_LSXINTRIN_H */
+/* #undef HAVE_LASXINTRIN_H */
+
+/* #undef HAVE_DDRAW_H */
+/* #undef HAVE_DINPUT_H */
+/* #undef HAVE_DSOUND_H */
+/* #undef HAVE_DXGI_H */
+/* #undef HAVE_WINDOWS_GAMING_INPUT_H */
+/* #undef HAVE_XINPUT_H */
+/* #undef HAVE_XINPUT_GAMEPAD_EX */
+/* #undef HAVE_XINPUT_STATE_EX */
+
+/* #undef HAVE_MMDEVICEAPI_H */
+/* #undef HAVE_AUDIOCLIENT_H */
+/* #undef HAVE_TPCSHRD_H */
+/* #undef HAVE_SENSORSAPI_H */
+/* #undef HAVE_ROAPI_H */
+/* #undef HAVE_SHELLSCALINGAPI_H */
+
+/* SDL internal assertion support */
+/* #undef SDL_DEFAULT_ASSERT_LEVEL */
+
+/* Allow disabling of core subsystems */
+/* #undef SDL_ATOMIC_DISABLED */
+/* #undef SDL_AUDIO_DISABLED */
+/* #undef SDL_CPUINFO_DISABLED */
+/* #undef SDL_EVENTS_DISABLED */
+/* #undef SDL_FILE_DISABLED */
+/* #undef SDL_JOYSTICK_DISABLED */
+//#define SDL_HAPTIC_DISABLED 1
+#define SDL_HIDAPI_DISABLED 1
+#define SDL_SENSOR_DISABLED 1
+#define SDL_LOADSO_DISABLED 1
+/* #undef SDL_RENDER_DISABLED */
+/* #undef SDL_THREADS_DISABLED */
+/* #undef SDL_TIMERS_DISABLED */
+/* #undef SDL_VIDEO_DISABLED */
+/* #undef SDL_POWER_DISABLED */
+/* #undef SDL_FILESYSTEM_DISABLED */
+/* #undef SDL_LOCALE_DISABLED */
+/* #undef SDL_MISC_DISABLED */
+
+/* Enable various audio drivers */
+/* #undef SDL_AUDIO_DRIVER_AAUDIO */
+/* #undef SDL_AUDIO_DRIVER_ALSA */
+/* #undef SDL_AUDIO_DRIVER_ALSA_DYNAMIC */
+/* #undef SDL_AUDIO_DRIVER_ANDROID */
+/* #undef SDL_AUDIO_DRIVER_ARTS */
+/* #undef SDL_AUDIO_DRIVER_ARTS_DYNAMIC */
+/* #undef SDL_AUDIO_DRIVER_COREAUDIO */
+/* #undef SDL_AUDIO_DRIVER_DISK */
+/* #undef SDL_AUDIO_DRIVER_DSOUND */
+/* #undef SDL_AUDIO_DRIVER_DUMMY */
+/* #undef SDL_AUDIO_DRIVER_EMSCRIPTEN */
+/* #undef SDL_AUDIO_DRIVER_ESD */
+/* #undef SDL_AUDIO_DRIVER_ESD_DYNAMIC */
+/* #undef SDL_AUDIO_DRIVER_FUSIONSOUND */
+/* #undef SDL_AUDIO_DRIVER_FUSIONSOUND_DYNAMIC */
+/* #undef SDL_AUDIO_DRIVER_HAIKU */
+/* #undef SDL_AUDIO_DRIVER_JACK */
+/* #undef SDL_AUDIO_DRIVER_JACK_DYNAMIC */
+/* #undef SDL_AUDIO_DRIVER_NACL */
+/* #undef SDL_AUDIO_DRIVER_NAS */
+/* #undef SDL_AUDIO_DRIVER_NAS_DYNAMIC */
+/* #undef SDL_AUDIO_DRIVER_NETBSD */
+/* #undef SDL_AUDIO_DRIVER_OPENSLES */
+/* #undef SDL_AUDIO_DRIVER_OSS */
+/* #undef SDL_AUDIO_DRIVER_OSS_SOUNDCARD_H */
+/* #undef SDL_AUDIO_DRIVER_PAUDIO */
+/* #undef SDL_AUDIO_DRIVER_PIPEWIRE */
+/* #undef SDL_AUDIO_DRIVER_PIPEWIRE_DYNAMIC */
+/* #undef SDL_AUDIO_DRIVER_PULSEAUDIO */
+/* #undef SDL_AUDIO_DRIVER_PULSEAUDIO_DYNAMIC */
+/* #undef SDL_AUDIO_DRIVER_QSA */
+/* #undef SDL_AUDIO_DRIVER_SNDIO */
+/* #undef SDL_AUDIO_DRIVER_SNDIO_DYNAMIC */
+/* #undef SDL_AUDIO_DRIVER_SUNAUDIO */
+/* #undef SDL_AUDIO_DRIVER_WASAPI */
+/* #undef SDL_AUDIO_DRIVER_WINMM */
+/* #undef SDL_AUDIO_DRIVER_OS2 */
+#define SDL_AUDIO_DRIVER_AHI 1
+
+/* Enable various input drivers */
+/* #undef SDL_INPUT_LINUXEV */
+/* #undef SDL_INPUT_FBSDKBIO */
+/* #undef SDL_INPUT_LINUXKD */
+/* #undef SDL_INPUT_WSCONS */
+/* #undef SDL_JOYSTICK_HAIKU */
+/* #undef SDL_JOYSTICK_DINPUT */
+/* #undef SDL_JOYSTICK_WGI */
+/* #undef SDL_JOYSTICK_XINPUT */
+/* #undef SDL_JOYSTICK_DUMMY */
+/* #undef SDL_JOYSTICK_IOKIT */
+/* #undef SDL_JOYSTICK_MFI */
+/* #undef SDL_JOYSTICK_LINUX */
+/* #undef SDL_JOYSTICK_ANDROID */
+/* #undef SDL_JOYSTICK_OS2 */
+/* #undef SDL_JOYSTICK_USBHID */
+/* #undef SDL_HAVE_MACHINE_JOYSTICK_H */
+/* #undef SDL_JOYSTICK_HIDAPI */
+/* #undef SDL_JOYSTICK_RAWINPUT */
+/* #undef SDL_JOYSTICK_EMSCRIPTEN */
+/* #undef SDL_JOYSTICK_VIRTUAL */
+#define SDL_JOYSTICK_MORPHOS   1 /* Enable MORPHOS SENSORS JOYSTICK/GAMEPAD */ 
+#define SDL_HAPTIC_DUMMY 1
+/* #undef SDL_HAPTIC_ANDROID */
+/* #undef SDL_HAPTIC_LINUX */
+/* #undef SDL_HAPTIC_IOKIT */
+/* #undef SDL_HAPTIC_DINPUT */
+/* #undef SDL_HAPTIC_XINPUT */
+
+/* Enable various sensor drivers */
+/* #undef SDL_SENSOR_ANDROID */
+/* #undef SDL_SENSOR_COREMOTION */
+/* #undef SDL_SENSOR_WINDOWS */
+/* #undef SDL_SENSOR_DUMMY */
+
+/* Enable various shared object loading systems */
+/* #undef SDL_LOADSO_DLOPEN */
+/* #undef SDL_LOADSO_DUMMY */
+/* #undef SDL_LOADSO_LDG */
+/* #undef SDL_LOADSO_WINDOWS */
+/* #undef SDL_LOADSO_OS2 */
+
+/* Enable various threading systems */
+/* #undef SDL_THREAD_GENERIC_COND_SUFFIX */
+/* #undef SDL_THREAD_PTHREAD */
+/* #undef SDL_THREAD_PTHREAD_RECURSIVE_MUTEX */
+/* #undef SDL_THREAD_PTHREAD_RECURSIVE_MUTEX_NP */
+/* #undef SDL_THREAD_WINDOWS */
+/* #undef SDL_THREAD_OS2 */
+#define SDL_THREAD_MORPHOS    1
+
+/* Enable various timer systems */
+/* #undef SDL_TIMER_HAIKU */
+/* #undef SDL_TIMER_DUMMY */
+/* #undef SDL_TIMER_UNIX */
+/* #undef SDL_TIMER_WINDOWS */
+/* #undef SDL_TIMER_OS2 */
+#define SDL_TIMER_MORPHOS 1
+
+/* Enable various video drivers */
+/* #undef SDL_VIDEO_DRIVER_HAIKU */
+/* #undef SDL_VIDEO_DRIVER_COCOA */
+/* #undef SDL_VIDEO_DRIVER_DIRECTFB */
+/* #undef SDL_VIDEO_DRIVER_DIRECTFB_DYNAMIC */
+#define SDL_VIDEO_DRIVER_DUMMY 1
+/* #undef SDL_VIDEO_DRIVER_WINDOWS */
+/* #undef SDL_VIDEO_DRIVER_WAYLAND */
+/* #undef SDL_VIDEO_DRIVER_WAYLAND_QT_TOUCH */
+/* #undef SDL_VIDEO_DRIVER_WAYLAND_DYNAMIC */
+/* #undef SDL_VIDEO_DRIVER_WAYLAND_DYNAMIC_EGL */
+/* #undef SDL_VIDEO_DRIVER_WAYLAND_DYNAMIC_CURSOR */
+/* #undef SDL_VIDEO_DRIVER_WAYLAND_DYNAMIC_XKBCOMMON */
+/* #undef SDL_VIDEO_DRIVER_WAYLAND_DYNAMIC_LIBDECOR */
+/* #undef SDL_VIDEO_DRIVER_X11 */
+/* #undef SDL_VIDEO_DRIVER_RPI */
+/* #undef SDL_VIDEO_DRIVER_KMSDRM */
+/* #undef SDL_VIDEO_DRIVER_KMSDRM_DYNAMIC */
+/* #undef SDL_VIDEO_DRIVER_KMSDRM_DYNAMIC_GBM */
+/* #undef SDL_VIDEO_DRIVER_ANDROID */
+/* #undef SDL_VIDEO_DRIVER_EMSCRIPTEN */
+/* #undef SDL_VIDEO_DRIVER_OFFSCREEN */
+/* #undef SDL_VIDEO_DRIVER_X11_DYNAMIC */
+/* #undef SDL_VIDEO_DRIVER_X11_DYNAMIC_XEXT */
+/* #undef SDL_VIDEO_DRIVER_X11_DYNAMIC_XCURSOR */
+/* #undef SDL_VIDEO_DRIVER_X11_DYNAMIC_XINPUT2 */
+/* #undef SDL_VIDEO_DRIVER_X11_DYNAMIC_XFIXES */
+/* #undef SDL_VIDEO_DRIVER_X11_DYNAMIC_XRANDR */
+/* #undef SDL_VIDEO_DRIVER_X11_DYNAMIC_XSS */
+/* #undef SDL_VIDEO_DRIVER_X11_XCURSOR */
+/* #undef SDL_VIDEO_DRIVER_X11_XDBE */
+/* #undef SDL_VIDEO_DRIVER_X11_XINPUT2 */
+/* #undef SDL_VIDEO_DRIVER_X11_XINPUT2_SUPPORTS_MULTITOUCH */
+/* #undef SDL_VIDEO_DRIVER_X11_XFIXES */
+/* #undef SDL_VIDEO_DRIVER_X11_XRANDR */
+/* #undef SDL_VIDEO_DRIVER_X11_XSCRNSAVER */
+/* #undef SDL_VIDEO_DRIVER_X11_XSHAPE */
+/* #undef SDL_VIDEO_DRIVER_X11_SUPPORTS_GENERIC_EVENTS */
+/* #undef SDL_VIDEO_DRIVER_X11_HAS_XKBKEYCODETOKEYSYM */
+/* #undef SDL_VIDEO_DRIVER_NACL */
+/* #undef SDL_VIDEO_DRIVER_VIVANTE */
+/* #undef SDL_VIDEO_DRIVER_VIVANTE_VDK */
+/* #undef SDL_VIDEO_DRIVER_OS2 */
+/* #undef SDL_VIDEO_DRIVER_QNX */
+/* #undef SDL_VIDEO_DRIVER_RISCOS */
+#define SDL_VIDEO_DRIVER_MORPHOS 1
+
+/* #undef SDL_VIDEO_RENDER_D3D */
+/* #undef SDL_VIDEO_RENDER_D3D11 */
+/* #undef SDL_VIDEO_RENDER_D3D12 */
+#define SDL_VIDEO_RENDER_OGL 1
+/* #undef SDL_VIDEO_RENDER_OGL_ES */
+/* #undef SDL_VIDEO_RENDER_OGL_ES2 */
+/* #undef SDL_VIDEO_RENDER_DIRECTFB */
+/* #undef SDL_VIDEO_RENDER_METAL */
+
+/* Enable OpenGL support */
+#define SDL_VIDEO_OPENGL 1
+/* #undef SDL_VIDEO_OPENGL_ES */
+/* #undef SDL_VIDEO_OPENGL_ES2 */
+/* #undef SDL_VIDEO_OPENGL_BGL */
+/* #undef SDL_VIDEO_OPENGL_CGL */
+/* #undef SDL_VIDEO_OPENGL_EGL */
+/* #undef SDL_VIDEO_OPENGL_GLX */
+/* #undef SDL_VIDEO_OPENGL_WGL */
+/* #undef SDL_VIDEO_OPENGL_OSMESA */
+/* #undef SDL_VIDEO_OPENGL_OSMESA_DYNAMIC */
+
+/* Enable Vulkan support */
+/* #undef SDL_VIDEO_VULKAN */
+
+/* Enable Metal support */
+/* #undef SDL_VIDEO_METAL */
+
+/* Enable system power support */
+/* #undef SDL_POWER_LINUX */
+/* #undef SDL_POWER_WINDOWS */
+/* #undef SDL_POWER_MACOSX */
+/* #undef SDL_POWER_HAIKU */
+/* #undef SDL_POWER_ANDROID */
+/* #undef SDL_POWER_EMSCRIPTEN */
+/* #undef SDL_POWER_HARDWIRED */
+#define SDL_POWER_MORPHOS 1
+
+/* Enable system filesystem support */
+/* #undef SDL_FILESYSTEM_ANDROID */
+/* #undef SDL_FILESYSTEM_HAIKU */
+/* #undef SDL_FILESYSTEM_COCOA */
+/* #undef SDL_FILESYSTEM_DUMMY */
+/* #undef SDL_FILESYSTEM_RISCOS */
+/* #undef SDL_FILESYSTEM_UNIX */
+/* #undef SDL_FILESYSTEM_WINDOWS */
+/* #undef SDL_FILESYSTEM_NACL */
+/* #undef SDL_FILESYSTEM_EMSCRIPTEN */
+/* #undef SDL_FILESYSTEM_OS2 */
+/* #undef SDL_FILESYSTEM_VITA */
+/* #undef SDL_FILESYSTEM_PSP */
+/* #undef SDL_FILESYSTEM_PS2 */
+#define SDL_FILESYSTEM_MORPHOS  1
+
+/* Enable misc subsystem */
+/* #undef SDL_MISC_DUMMY */
+
+/* Enable locale subsystem */
+/* #undef SDL_LOCALE_DUMMY */
+
+/* Enable assembly routines */
+#define SDL_ALTIVEC_BLITTERS 1
+/* #undef SDL_ARM_SIMD_BLITTERS */
+/* #undef SDL_ARM_NEON_BLITTERS */
+
+#define SDL_ENABLE_ALTIVEC_H 1
+
+/* Whether SDL_DYNAMIC_API needs dlopen() */
+/* #undef DYNAPI_NEEDS_DLOPEN */
+
+/* Enable ime support */
+/* #undef SDL_USE_IME */
+
+/* Enable dynamic udev support */
+/* #undef SDL_UDEV_DYNAMIC */
+
+/* Enable dynamic libusb support */
+/* #undef SDL_LIBUSB_DYNAMIC */
+
+/* Enable dynamic libsamplerate support */
+/* #undef SDL_LIBSAMPLERATE_DYNAMIC */
+
+#if defined(__MORPHOS__)
+	#if defined(__SDL_DEBUG)
+		#include <exec/types.h>
+		extern struct ExecBase *SysBase;
+		#define D(fmt, ...) ({((STRPTR (*)(void *, CONST_STRPTR , APTR (*)(APTR, UBYTE), STRPTR , ...))*(void**)((long)(SysBase) - 922))((void*)(SysBase), fmt, (APTR)1, NULL, ##__VA_ARGS__);})
+	#else
+		#define D(fmt, ...)
+	#endif
+#else
+	#define D(fmt, ...)
+#endif
+
+#endif /* _SDL_config_morphos_h */
diff -ruN SDL2-2.32.8/include/SDL_endian.h SDL2-2.32.8.aros/include/SDL_endian.h
--- SDL2-2.32.8/include/SDL_endian.h	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/include/SDL_endian.h	2025-07-27 14:24:11.608841313 +0000
@@ -353,6 +353,12 @@
     return swapper.f;
 }
 
+#ifdef __MORPHOS__
+#include <exec/types.h>
+extern void SDL_CopyAndSwap16(APTR srcx, APTR destx, LONG units);
+extern void SDL_CopyAndSwap32(APTR srcx, APTR destx, LONG units);
+#endif
+
 /* remove extra macros */
 #undef HAS_BROKEN_BSWAP
 #undef HAS_BUILTIN_BSWAP16
diff -ruN SDL2-2.32.8/include/SDL_opengl_glext.h SDL2-2.32.8.aros/include/SDL_opengl_glext.h
--- SDL2-2.32.8/include/SDL_opengl_glext.h	2023-02-04 07:02:10.000000000 +0000
+++ SDL2-2.32.8.aros/include/SDL_opengl_glext.h	2025-07-27 14:24:11.772841314 +0000
@@ -762,8 +762,10 @@
 
 #ifndef GL_VERSION_1_5
 #define GL_VERSION_1_5 1
+#ifndef __MORPHOS__
 typedef khronos_ssize_t GLsizeiptr;
 typedef khronos_intptr_t GLintptr;
+#endif
 #define GL_BUFFER_SIZE                    0x8764
 #define GL_BUFFER_USAGE                   0x8765
 #define GL_QUERY_COUNTER_BITS             0x8864
@@ -1680,7 +1682,9 @@
 #ifndef GL_VERSION_3_2
 #define GL_VERSION_3_2 1
 typedef struct __GLsync *GLsync;
+#ifndef __MORPHOS__
 typedef khronos_uint64_t GLuint64;
+#endif
 typedef khronos_int64_t GLint64;
 #define GL_CONTEXT_CORE_PROFILE_BIT       0x00000001
 #define GL_CONTEXT_COMPATIBILITY_PROFILE_BIT 0x00000002
@@ -3208,7 +3212,9 @@
 
 #ifndef GL_ARB_bindless_texture
 #define GL_ARB_bindless_texture 1
+#ifndef __MORPHOS__
 typedef khronos_uint64_t GLuint64EXT;
+#endif
 #define GL_UNSIGNED_INT64_ARB             0x140F
 typedef GLuint64 (APIENTRYP PFNGLGETTEXTUREHANDLEARBPROC) (GLuint texture);
 typedef GLuint64 (APIENTRYP PFNGLGETTEXTURESAMPLERHANDLEARBPROC) (GLuint texture, GLuint sampler);
@@ -4992,8 +4998,10 @@
 
 #ifndef GL_ARB_vertex_buffer_object
 #define GL_ARB_vertex_buffer_object 1
+#ifndef __MORPHOS__
 typedef khronos_ssize_t GLsizeiptrARB;
 typedef khronos_intptr_t GLintptrARB;
+#endif
 #define GL_BUFFER_SIZE_ARB                0x8764
 #define GL_BUFFER_USAGE_ARB               0x8765
 #define GL_ARRAY_BUFFER_ARB               0x8892
diff -ruN SDL2-2.32.8/include/SDL_opengl.h SDL2-2.32.8.aros/include/SDL_opengl.h
--- SDL2-2.32.8/include/SDL_opengl.h	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/include/SDL_opengl.h	2025-07-27 14:24:11.728841314 +0000
@@ -31,6 +31,14 @@
 
 #include "SDL_config.h"
 
+#ifdef __MORPHOS__
+
+#include <tgl/gl.h>
+#include <tgl/glu.h>
+#include "SDL_opengl_glext.h"
+
+#else
+
 #ifndef __IPHONEOS__  /* No OpenGL on iOS. */
 
 /*
@@ -2121,6 +2129,8 @@
 
 #endif /* !__IPHONEOS__ */
 
+#endif /* __MORPHOS__ */
+
 #endif /* SDL_opengl_h_ */
 
 /* vi: set ts=4 sw=4 expandtab: */
diff -ruN SDL2-2.32.8/include/SDL_rwops.h SDL2-2.32.8.aros/include/SDL_rwops.h
--- SDL2-2.32.8/include/SDL_rwops.h	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/include/SDL_rwops.h	2025-07-28 14:22:41.854722088 +0000
@@ -47,6 +47,7 @@
 #define SDL_RWOPS_JNIFILE   3U  /**< Android asset */
 #define SDL_RWOPS_MEMORY    4U  /**< Memory stream */
 #define SDL_RWOPS_MEMORY_RO 5U  /**< Read-Only memory stream */
+#define SDL_RWOPS_MORPHOSFILE 6U  /**< MorphOS file */
 
 /**
  * This is the read/write operation structure -- very basic.
@@ -93,6 +94,11 @@
     int (SDLCALL * close) (struct SDL_RWops * context);
 
     Uint32 type;
+
+    #if defined(__MORPHOS__)
+    void *r13; /* must be at offset 24 and outside union (or change fileop routine accordingly) */
+    #endif
+
     union
     {
 #if defined(__ANDROID__)
@@ -112,6 +118,23 @@
                 size_t left;
             } buffer;
         } windowsio;
+#elif defined(__MORPHOS__) || defined(__AROS__)
+        struct
+        {
+            Uint8 AppendMode : 1, NoSeek : 1, IsAtEnd : 1, autoclose : 1;
+            Uint8 Writable : 1, Readable : 1;
+
+            union
+            {
+                size_t  dos;
+                void   *libc;
+            } fp;
+        } amigaosio;
+#if defined(__AROS__)
+#define AMIGAOSIO_BPTR fp.libc
+#else
+#define AMIGAOSIO_BPTR fp.dos
+#endif
 #endif
 
 #ifdef HAVE_STDIO_H
@@ -208,7 +231,7 @@
 extern DECLSPEC SDL_RWops *SDLCALL SDL_RWFromFile(const char *file,
                                                   const char *mode);
 
-#ifdef HAVE_STDIO_H
+#if defined(HAVE_STDIO_H) && !defined(__MORPHOS__) && !defined(__AROS__)
 
 extern DECLSPEC SDL_RWops *SDLCALL SDL_RWFromFP(FILE * fp, SDL_bool autoclose);
 
diff -ruN SDL2-2.32.8/include/SDL_syswm.h SDL2-2.32.8.aros/include/SDL_syswm.h
--- SDL2-2.32.8/include/SDL_syswm.h	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/include/SDL_syswm.h	2025-07-28 13:26:12.821909338 +0000
@@ -143,12 +143,14 @@
     SDL_SYSWM_WAYLAND,
     SDL_SYSWM_MIR,  /* no longer available, left for API/ABI compatibility. Remove in 2.1! */
     SDL_SYSWM_WINRT,
+    SDL_SYSWM_MORPHOS,
     SDL_SYSWM_ANDROID,
     SDL_SYSWM_VIVANTE,
     SDL_SYSWM_OS2,
     SDL_SYSWM_HAIKU,
     SDL_SYSWM_KMSDRM,
-    SDL_SYSWM_RISCOS
+    SDL_SYSWM_RISCOS,
+    SDL_SYSWM_AROS
 } SDL_SYSWM_TYPE;
 
 /**
@@ -317,6 +319,12 @@
             EGLSurface surface;
         } android;
 #endif
+#if defined(SDL_VIDEO_DRIVER_MORPHOS) || defined(SDL_VIDEO_DRIVER_AROS)
+        struct
+        {
+            struct Window *window;      /**< Intuition window */
+        } intui;
+#endif
 
 #if defined(SDL_VIDEO_DRIVER_OS2)
         struct
diff -ruN SDL2-2.32.8/include/SDL_test.h SDL2-2.32.8.aros/include/SDL_test.h
--- SDL2-2.32.8/include/SDL_test.h	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/include/SDL_test.h	2025-07-27 14:24:11.872841315 +0000
@@ -44,6 +44,14 @@
 #include "SDL_test_memory.h"
 #include "SDL_test_random.h"
 
+#if defined(__MORPHOS__)
+#ifndef LLONG_MIN
+#define LLONG_MIN  (-9223372036854775807LL - 1)
+#define LLONG_MAX  9223372036854775807LL
+#define ULLONG_MAX 18446744073709551615ULL
+#endif
+#endif
+
 #include "begin_code.h"
 /* Set up for C function definitions, even when using C++ */
 #ifdef __cplusplus
diff -ruN SDL2-2.32.8/Makefile.mos SDL2-2.32.8.aros/Makefile.mos
--- SDL2-2.32.8/Makefile.mos	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/Makefile.mos	2025-07-27 14:24:12.000841316 +0000
@@ -0,0 +1,126 @@
+# Makefile to build the SDL2 library MORPHOS
+#
+# You need tinygl.library 53.8+ and last SDK with last tinyGL SDK
+
+#
+# Enable debug with -D__SDL_DEBUG
+#
+
+CDEFS   = -DAROS_ALMOST_COMPATIBLE -DBUILD_SDL2_LIBRARY -D__SDL_DEBUG
+CC      = ppc-morphos-gcc-11 -noixemul
+AMIGADATE = $(shell date +"%-d.%-m.%Y")
+INCLUDE = -I./include -D__AMIGADATE__=\"$(AMIGADATE)\"
+CFLAGS  = -mcpu=750 -mtune=7450 -O3 $(INCLUDE) -mresident32 -Wall -Wno-pointer-sign -fno-strict-aliasing $(CDEFS)
+AR      = ppc-morphos-ar
+
+ECHE = echo -e
+BOLD = \033[1m
+NRML = \033[22m
+
+COMPILING = @$(ECHE) "compiling $(BOLD)$@$(NRML)..."
+LINKING = @$(ECHE) "linking $(BOLD)$@$(NRML)..."
+STRIPPING = @$(ECHE) "stripping $(BOLD)$@$(NRML)..."
+ARCHIVING = @$(ECHE) "archiving $(BOLD)$@$(NRML)..."
+HEADERING = @$(ECHE) "creating headers files $(BOLD)$@$(NRML)..."
+
+TARGET  = libSDL2.a
+LIBRARY = sdl2.library
+
+SOURCES = \
+	src/*.c \
+	src/atomic/*.c \
+	src/audio/*.c \
+	src/audio/ahi/*.c \
+	src/cpuinfo/*.c \
+	src/events/*.c \
+	src/file/*.c \
+	src/filesystem/morphos/*.c \
+	src/joystick/*.c \
+	src/joystick/morphos/*.c \
+	src/power/*.c \
+	src/power/morphos/*.c \
+	src/render/*.c \
+	src/render/software/*.c \
+	src/render/opengl/*.c \
+	src/stdlib/*.c \
+	src/thread/*.c \
+	src/thread/morphos/*.c \
+	src/thread/generic/SDL_syscond.c \
+	src/thread/generic/SDL_systls.c \
+	src/timer/*.c \
+	src/timer/morphos/*.c \
+	src/video/*.c \
+	src/video/dummy/*.c \
+	src/video/morphos/*.c \
+	src/video/yuv2rgb/*.c \
+	src/misc/*.c \
+	src/misc/morphos/*.c \
+	src/locale/*.c \
+	src/locale/morphos/*.c \
+	src/haptic/*.c \
+	src/haptic/dummy/*.c \
+#	src/loadso/dlopen/*.c
+#	src/sensor/*.c \
+#	src/sensor/dummy/*.c \
+#	src/hidapi/*.c \
+	
+CORESOURCES = src/core/morphos/*.c
+COREOBJECTS = $(shell echo $(CORESOURCES) | sed -e 's,\.c,\.o,g')
+
+OBJECTS = $(shell echo $(SOURCES) | sed -e 's,\.c,\.o,g')
+
+all: $(LIBRARY) lib
+
+sdk: $(LIBRARY)
+	mkdir -p /gg/usr/local/bin
+	mkdir -p /gg/usr/local/include/SDL2
+	mkdir -p /gg/usr/local/lib
+	mkdir -p /gg/usr/local/lib/libb32
+	cp include/*.h /gg/usr/local/include/SDL2
+	cp src/core/morphos/devenv/lib/libSDL2.a /gg/usr/local/lib/libSDL2.a
+	cp src/core/morphos/devenv/lib/libb32/libSDL2.a /gg/usr/local/lib/libb32/libSDL2.a
+	cp sdl2-config /gg/usr/local/bin/sdl2-config
+
+headers:
+	$(HEADERING)
+	/gg/bin/cvinclude.pl --fd=src/core/morphos/sdk/fd/sdl2_lib.fd --clib=src/core/morphos/sdk/clib/sdl2_protos.h --proto=src/core/morphos/sdk/proto/sdl2.h
+	/gg/bin/cvinclude.pl --fd=src/core/morphos/sdk/fd/sdl2_lib.fd --clib=src/core/morphos/sdk/clib/sdl2_protos.h --inline=src/core/morphos/sdk/ppcinline/sdl2.h
+	@perl -pe "s/va_list  __t__p1 = __p1;/va_list __t__p1;\\\\\n\t\tva_copy(__t__p1, __p1);/g" src/core/morphos/sdk/ppcinline/sdl2.h > src/core/morphos/sdk/ppcinline/sdl2tmp.h
+	@perl -pe "s/va_list  __t__p2 = __p2;/va_list __t__p2;\\\\\n\t\tva_copy(__t__p2, __p2);/g" src/core/morphos/sdk/ppcinline/sdl2tmp.h > src/core/morphos/sdk/ppcinline/sdl2.h
+	@perl -pe "s/va_list  __t__p3 = __p3;/va_list __t__p3;\\\\\n\t\tva_copy(__t__p3, __p3);/g" src/core/morphos/sdk/ppcinline/sdl2.h > src/core/morphos/sdk/ppcinline/sdl2tmp.h
+	@rm src/core/morphos/sdk/ppcinline/sdl2.h
+	@mv src/core/morphos/sdk/ppcinline/sdl2tmp.h src/core/morphos/sdk/ppcinline/sdl2.h
+	
+lib:
+	@cd src/core/morphos/devenv; if ! $(MAKE) $(MAKECMDGOALS); then exit 1; fi;
+
+install: $(LIBRARY) lib
+	cp $(LIBRARY) Libs:
+	-flushlib $(LIBRARY)
+
+src/video/SDL_blit_N.o: src/video/SDL_blit_N.c
+	$(CC) $(CFLAGS) -fvec -maltivec -faltivec -mabi=altivec -o $@ -c src/video/SDL_blit_N.c
+
+src/core/morphos/SDL_cpu.o: src/core/morphos/SDL_cpu.c
+	$(CC) $(CFLAGS) -fvec -maltivec -faltivec -mabi=altivec -o $@ -c $^
+
+src/core/morphos/SDL_library.o: src/core/morphos/SDL_library.c src/core/morphos/SDL_library.h src/core/morphos/SDL_stubs.h
+	$(COMPILING)
+	@$(CC) -mcpu=750 $(INCLUDE) -Wall -fno-strict-aliasing -DAROS_ALMOST_COMPATIBLE -o $@ -c $*.c
+
+$(TARGET): $(OBJECTS)
+	$(ARCHIVING)
+	@$(AR) crvs $@ $^
+
+$(LIBRARY): $(TARGET) $(COREOBJECTS)
+	$(LINKING)
+	@$(CC) -nostartfiles -mresident32 -Wl,-Map=sdl2.map $(COREOBJECTS) -o $@.db -L. -lSDL2 -lm
+	$(STRIPPING)
+	@ppc-morphos-strip -o $@ --remove-section=.comment $@.db
+
+clean:
+	rm -f $(LIBRARY) $(TARGET) $(OBJECTS) $(COREOBJECTS) *.db *.s
+	@cd src/core/morphos/devenv; if ! $(MAKE) $(MAKECMDGOALS); then exit 1; fi;
+
+dump:
+	ppc-morphos-objdump --disassemble-all --reloc $(LIBRARY).db >$(LIBRARY).s
diff -ruN SDL2-2.32.8/sdl2-config SDL2-2.32.8.aros/sdl2-config
--- SDL2-2.32.8/sdl2-config	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/sdl2-config	2025-07-27 14:24:12.084841316 +0000
@@ -0,0 +1,56 @@
+#!/bin/sh
+
+prefix=/gg/usr/local
+exec_prefix=${prefix}
+exec_prefix_set=no
+
+libmode=``
+
+usage="\
+Usage: sdl2-config [--prefix[=DIR]] [--exec-prefix[=DIR]] [--version] [--libs] [--cflags]"
+
+if test $# -eq 0; then
+      echo "${usage}" 1>&2
+      exit 1
+fi
+
+while test $# -gt 0; do
+  case "$1" in
+  -*=*) optarg=`echo "$1" | sed 's/[-_a-zA-Z0-9]*=//'` ;;
+  *) optarg= ;;
+  esac
+
+  case $1 in
+    --prefix=*)
+      prefix=$optarg
+      if test $exec_prefix_set = no ; then
+        exec_prefix=$optarg
+      fi
+      ;;
+    --prefix)
+      echo $prefix
+      ;;
+    --exec-prefix=*)
+      exec_prefix=$optarg
+      exec_prefix_set=yes
+      ;;
+    --exec-prefix)
+      echo $exec_prefix
+      ;;
+    --version)
+      echo 2.32.0
+      ;;
+    --cflags)
+     	echo -noixemul -I${prefix}/include/SDL2
+      ;;
+    --libs|--static-libs)
+      libdirs="-L${exec_prefix}/lib "
+      echo  $libdirs -noixemul -lSDL2 -lGL -lc -lm
+      ;;
+    *)
+      echo "${usage}" 1>&2
+      exit 1
+      ;;
+  esac
+  shift
+done
diff -ruN SDL2-2.32.8/SDL2_intern.h SDL2-2.32.8.aros/SDL2_intern.h
--- SDL2-2.32.8/SDL2_intern.h	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/SDL2_intern.h	2025-07-27 14:24:12.108841316 +0000
@@ -0,0 +1,16 @@
+#ifndef	_SDL2_INTERN_H
+#define	_SDL2_INTERN_H
+
+#include <exec/libraries.h>
+#include <exec/semaphores.h>
+#include <devices/timer.h>
+
+struct SDL2Base
+{
+    struct Library      _lib;
+    struct SDL2Base      *rootSDLBase;
+    struct Library      *LowLevelBase;
+    struct Library      *GLBase;
+};
+
+#endif /* _SDL2_INTERN_H */
diff -ruN SDL2-2.32.8/src/audio/ahi/SDL_ahi_audio.c SDL2-2.32.8.aros/src/audio/ahi/SDL_ahi_audio.c
--- SDL2-2.32.8/src/audio/ahi/SDL_ahi_audio.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/audio/ahi/SDL_ahi_audio.c	2025-07-27 14:24:12.196841317 +0000
@@ -0,0 +1,352 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2022 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#if defined(__AROS__)
+#include <aros/debug.h>
+#endif
+
+#include "../../SDL_internal.h"
+
+#include "SDL_audio.h"
+#include "SDL_timer.h"
+#include "../SDL_audio_c.h"
+#include "../SDL_sysaudio.h"
+#include "SDL_ahi_audio.h"
+
+#include "../../core/morphos/SDL_cpu.h"
+
+#include <sys/param.h>
+
+#include <dos/dos.h>
+#include <exec/execbase.h>
+#include <proto/exec.h>
+
+#if defined(__AROS__)
+#include <string.h>
+#endif
+
+#define RESTART_CAPTURE_THRESHOLD 	 500
+
+static Fixed AHI_Volume = 0x10000;
+
+void AHI_Mute(ULONG mute)
+{
+	AHI_Volume = mute ? 0 : 0x10000;
+}
+
+static void AHI_DetectDevices(void)
+{
+	D(bug("[SDL2:AHI] %s()\n", __func__));
+	
+	SDL_AudioSpec output, capture;
+	output.freq = 44100;
+	output.format = AUDIO_S16MSB;
+	output.channels = 2;
+	
+	capture.freq = 44100;
+	capture.format = AUDIO_S16MSB;
+	capture.channels = 1;
+	
+	SDL_AddAudioDevice(SDL_FALSE, "AHI output device", &output, SDL_strdup("default"));;
+	SDL_AddAudioDevice(SDL_TRUE, "AHI capture device", &capture, SDL_strdup("default"));
+	
+}
+
+static void AHI_WaitDevice(_THIS)
+{
+	MOSAudioData *hidden = this->hidden;
+	struct AHIRequest *req = &hidden->req[hidden->current_buffer];
+
+	if (req->ahir_Std.io_Data) {
+		WaitIO((struct IORequest *)req);
+
+		req->ahir_Std.io_Data = NULL;
+
+		GetMsg(&hidden->ahiport);
+	}
+}
+
+static void AHI_PlayDevice(_THIS)
+{
+	MOSAudioData *hidden = this->hidden;
+	struct AHIRequest *req;
+	ULONG current, current2;
+	
+	current = hidden->current_buffer;
+	current2 = current ^ 1;
+	req = &hidden->req[current];
+
+	req->ahir_Std.io_Data    = (APTR)hidden->buffers[current];
+	req->ahir_Std.io_Length  = hidden->audioBufferSize;
+	req->ahir_Std.io_Offset  = 0;
+	req->ahir_Frequency      = this->spec.freq;
+	req->ahir_Volume         = AHI_Volume; 
+	req->ahir_Type           = hidden->sample_format;
+	req->ahir_Position       = 0x8000;
+	req->ahir_Link           = (hidden->playing ? &hidden->req[current2] : NULL);
+
+	hidden->current_buffer = current2;
+	hidden->playing = 1;
+
+	SendIO((struct IORequest *)req);
+}
+
+static Uint8 * AHI_GetDeviceBuf(_THIS)
+{
+	MOSAudioData *hidden = this->hidden;
+	return (Uint8 *) hidden->buffers[hidden->current_buffer];
+}
+
+static void AHI_CloseDevice(_THIS)
+{
+	MOSAudioData *hidden = this->hidden;
+
+    if (hidden->buffers[0]) {
+        SDL_free(hidden->buffers[0]);
+        hidden->buffers[0] = NULL;
+    }
+
+    if (hidden->buffers[1]) {
+        SDL_free(hidden->buffers[1]);
+        hidden->buffers[1] = NULL;
+    }
+	
+	this->hidden = NULL;
+
+	CloseDevice((struct IORequest *)&hidden->req[0].ahir_Std);
+	SDL_free(hidden);
+}
+
+static void AHI_ThreadInit(_THIS)
+{
+	MOSAudioData *hidden = this->hidden;
+
+	hidden->ahiport.mp_Node.ln_Pri = 60;
+	hidden->ahiport.mp_Flags = PA_SIGNAL;
+	hidden->ahiport.mp_SigBit = SIGBREAKB_CTRL_E;
+	hidden->ahiport.mp_SigTask = SysBase->ThisTask;
+
+	NEWLIST(&hidden->ahiport.mp_MsgList);
+
+#if defined(__AROS__)
+	memmove(&hidden->req[1], &hidden->req[0], sizeof(hidden->req[1]));
+#else
+	bcopy(&hidden->req[0], &hidden->req[1], sizeof(hidden->req[1]));
+#endif
+}
+
+static int AHI_OpenDevice(_THIS, const char *devname)
+{
+	MOSAudioData *hidden;
+	SDL_AudioFormat test_format;
+	int sample_format = -1;
+
+	switch (this->spec.format) {
+		case AUDIO_F32LSB:
+		case AUDIO_F32MSB:
+		case AUDIO_S32LSB:
+		 	this->spec.format = AUDIO_S32MSB;
+			break;
+		case AUDIO_S16LSB:
+		default:
+			this->spec.format = AUDIO_S16MSB;
+			break;
+	}
+	/*if ((this->spec.format & 0xff) != 8)
+		 this->spec.format = AUDIO_S16MSB;*/
+
+	test_format = SDL_FirstAudioFormat(this->spec.format);
+	
+	while (sample_format < 0 && test_format) {
+
+		switch (test_format) {
+			case AUDIO_U8:
+			case AUDIO_S8:
+				sample_format = this->spec.channels == 1 ? AHIST_M8S : AHIST_S8S;
+				break; 
+			break;
+			case AUDIO_S16LSB:
+			case AUDIO_S16MSB:
+				sample_format = this->spec.channels == 1 ? AHIST_M16S : AHIST_S16S;
+				break;
+			case AUDIO_S32LSB:
+			case AUDIO_S32MSB:
+				sample_format = this->spec.channels == 1 ? AHIST_M32S : AHIST_S32S;
+				break;
+			default:
+				D("[%s] unsupported SDL format 0x%ld\n", __FUNCTION__, test_format);
+				test_format = SDL_NextAudioFormat();
+				break;
+		}
+	}
+
+	if (sample_format < 0)
+		return SDL_SetError("Unsupported audio format");
+
+	D("[%s] AHI sample format is %ld\n", __FUNCTION__, sample_format);
+
+	if (this->spec.channels > 2)
+		this->spec.channels = 2;
+
+	if (this->spec.samples > 1024) {
+		this->spec.samples = MAX(this->spec.freq / 20, 256);
+		this->spec.samples = (this->spec.samples + 7) & ~7;
+	}
+
+	/* Update the fragment size as size in bytes */
+	SDL_CalculateAudioSpec(&this->spec);
+
+	hidden = SDL_malloc(sizeof(MOSAudioData));
+
+	if (hidden == NULL)
+		return SDL_OutOfMemory();
+
+	hidden->req[0].ahir_Std.io_Message.mn_ReplyPort = &hidden->ahiport;
+	hidden->req[0].ahir_Std.io_Message.mn_Length = sizeof(struct AHIRequest);
+	hidden->req[0].ahir_Std.io_Command = CMD_WRITE;
+	hidden->req[0].ahir_Std.io_Data = NULL;
+	hidden->req[0].ahir_Version = 6;
+
+	hidden->audioBufferSize = this->spec.size;
+	hidden->buffers[0] = (Uint8 *) SDL_malloc(hidden->audioBufferSize);
+	hidden->buffers[1] = (Uint8 *) SDL_malloc(hidden->audioBufferSize);
+	if (hidden->buffers[0] == NULL || hidden->buffers[1] == NULL) {
+        SDL_SetError("No memory for audio buffer");
+        return -1;
+    }
+	
+    SDL_memset(hidden->buffers[0], this->spec.silence, hidden->audioBufferSize);
+    SDL_memset(hidden->buffers[1], this->spec.silence, hidden->audioBufferSize);
+	
+	//hidden->convert = convert;
+	hidden->current_buffer = 0;
+	hidden->sample_format = sample_format;
+	hidden->playing = 0;
+	hidden->requestSent = SDL_FALSE;
+
+	this->hidden = hidden;
+	
+	if (OpenDevice(AHINAME, 0, (struct IORequest *)&hidden->req[0].ahir_Std, 0) != 0) {
+		SDL_SetError("Unable to open ahi.device unit 0! Error code %d.\n", hidden->req[0].ahir_Std.io_Error);
+		return -1;
+	}
+	return 0;
+}
+
+static void AHI_FillCaptureRequest(struct AHIRequest *request, void *buffer, int length, int frequency, int type)
+{
+    request->ahir_Std.io_Message.mn_Node.ln_Pri = 60;
+    request->ahir_Std.io_Data    = buffer,
+    request->ahir_Std.io_Length  = length;
+    request->ahir_Std.io_Command = CMD_READ;
+    request->ahir_Volume = AHI_Volume;
+    request->ahir_Position = 0x8000;
+    request->ahir_Link = NULL;
+    request->ahir_Frequency = frequency;
+    request->ahir_Type = type;
+}
+
+static int AHI_CaptureFromDevice(_THIS, void *buffer, int buflen)
+{
+	struct AHIRequest  *request;
+	MOSAudioData *hidden = this->hidden;
+	Uint32 now;
+	UBYTE current;
+	size_t copyLen;
+    void *completedBuffer;
+	
+	now = SDL_GetTicks();
+	current = hidden->current_buffer;
+	request = &hidden->req[0];
+	
+    if (hidden->lastCaptureTicks == 0 || (now - hidden->lastCaptureTicks) > RESTART_CAPTURE_THRESHOLD) {
+
+	    if (hidden->requestSent)
+            WaitIO((struct IORequest *)request);
+		
+        AHI_FillCaptureRequest(
+            request,
+            hidden->buffers[current],
+            this->spec.size,
+            this->spec.freq,
+            hidden->sample_format);
+
+        request->ahir_Std.io_Offset = 0;
+
+        D("[%s] Start recording\n", __FUNCTION__);
+
+        DoIO((struct IORequest *)request);
+        hidden->requestSent = SDL_FALSE;
+		
+		current = 1 - current;
+
+    } else {
+		if (hidden->requestSent)
+        	WaitIO((struct IORequest *)request);
+    }
+
+    AHI_FillCaptureRequest(
+        request,
+        hidden->buffers[current],
+        this->spec.size,
+        this->spec.freq,
+        hidden->sample_format);
+
+    SendIO((struct IORequest *)request);
+    hidden->requestSent = SDL_TRUE;
+
+	current = 1 - current;
+	
+    completedBuffer = hidden->buffers[current];
+
+    copyLen = MIN(buflen, this->spec.size);
+
+    SDL_memcpy(buffer, completedBuffer, copyLen);
+
+    hidden->lastCaptureTicks = now;
+    hidden->current_buffer = current;
+
+    return copyLen;
+}
+
+static SDL_bool AHI_Init(SDL_AudioDriverImpl * impl)
+{
+	/* Set the function pointers */
+	impl->DetectDevices = AHI_DetectDevices;
+	impl->OpenDevice = AHI_OpenDevice;
+	impl->ThreadInit = AHI_ThreadInit;
+	impl->PlayDevice = AHI_PlayDevice;
+	impl->WaitDevice = AHI_WaitDevice;
+	impl->CaptureFromDevice = AHI_CaptureFromDevice;	
+	impl->GetDeviceBuf = AHI_GetDeviceBuf;
+	impl->CloseDevice = AHI_CloseDevice;
+
+	impl->ProvidesOwnCallbackThread = SDL_FALSE;
+	impl->HasCaptureSupport = SDL_TRUE;
+	impl->OnlyHasDefaultOutputDevice = SDL_TRUE;
+	impl->OnlyHasDefaultCaptureDevice = SDL_TRUE;
+	
+	return SDL_TRUE;   /* this audio target is available. */
+}
+
+AudioBootStrap AHIAUD_bootstrap = {
+    "ahi", "MorphOS AHI audio driver", AHI_Init, SDL_FALSE 
+};
diff -ruN SDL2-2.32.8/src/audio/ahi/SDL_ahi_audio.h SDL2-2.32.8.aros/src/audio/ahi/SDL_ahi_audio.h
--- SDL2-2.32.8/src/audio/ahi/SDL_ahi_audio.h	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/audio/ahi/SDL_ahi_audio.h	2025-07-27 14:24:12.204841317 +0000
@@ -0,0 +1,49 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2022 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifndef _SDL_ahi_audio_h
+#define _SDL_ahi_audio_h
+
+#include "SDL_types.h"
+
+#include <devices/ahi.h>
+
+/* Hidden "this" pointer for the audio functions */
+#define _THIS   SDL_AudioDevice *this
+
+struct SDL_PrivateAudioData
+{
+	struct MsgPort    ahiport;
+	struct AHIRequest req[2];
+
+	Uint8  *buffers[2];
+	Uint32 audioBufferSize;
+	UBYTE current_buffer;
+	UBYTE sample_format;
+	UBYTE playing;
+	Uint32	lastCaptureTicks;
+	SDL_bool requestSent;
+};
+
+typedef struct SDL_PrivateAudioData MOSAudioData;
+
+#endif /* _SDL_ahi_audio_h */
diff -ruN SDL2-2.32.8/src/audio/SDL_audio.c SDL2-2.32.8.aros/src/audio/SDL_audio.c
--- SDL2-2.32.8/src/audio/SDL_audio.c	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/src/audio/SDL_audio.c	2025-07-27 14:24:12.824841320 +0000
@@ -135,6 +135,9 @@
 #ifdef SDL_AUDIO_DRIVER_DUMMY
     &DUMMYAUDIO_bootstrap,
 #endif
+#if SDL_AUDIO_DRIVER_AHI
+    &AHIAUD_bootstrap,
+#endif
     NULL
 };
 
diff -ruN SDL2-2.32.8/src/audio/SDL_sysaudio.h SDL2-2.32.8.aros/src/audio/SDL_sysaudio.h
--- SDL2-2.32.8/src/audio/SDL_sysaudio.h	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/src/audio/SDL_sysaudio.h	2025-07-27 14:24:12.880841320 +0000
@@ -208,6 +208,7 @@
 extern AudioBootStrap VITAAUD_bootstrap;
 extern AudioBootStrap N3DSAUDIO_bootstrap;
 extern AudioBootStrap EMSCRIPTENAUDIO_bootstrap;
+extern AudioBootStrap AHIAUD_bootstrap;
 extern AudioBootStrap OS2AUDIO_bootstrap;
 
 #endif /* SDL_sysaudio_h_ */
diff -ruN SDL2-2.32.8/src/core/aros/SDL_cpu.c SDL2-2.32.8.aros/src/core/aros/SDL_cpu.c
--- SDL2-2.32.8/src/core/aros/SDL_cpu.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/core/aros/SDL_cpu.c	2025-07-27 14:24:13.576841324 +0000
@@ -0,0 +1,43 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2022 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#include "SDL_stdinc.h"
+
+#include <exec/types.h>
+
+//#include "SDL_library.h"
+
+void SDL_CopyAndSwap16(APTR srcx, APTR destx, LONG units)
+{
+	if (units > 0)
+	{
+//		copy_and_swap16_generic(srcx, destx, units);
+	}
+}
+
+void SDL_CopyAndSwap32(APTR srcx, APTR destx, LONG units)
+{
+	if (units > 0)
+	{
+//		copy_and_swap32_generic(srcx, destx, units);
+	}
+}
diff -ruN SDL2-2.32.8/src/core/aros/SDL_cpu.h SDL2-2.32.8.aros/src/core/aros/SDL_cpu.h
--- SDL2-2.32.8/src/core/aros/SDL_cpu.h	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/core/aros/SDL_cpu.h	2025-07-27 14:24:13.584841324 +0000
@@ -0,0 +1,34 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2020 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#ifndef SDL_CORE_MORPHOS_CPU_H
+#define SDL_CORE_MORPHOS_CPU_H
+
+#include "../../SDL_internal.h"
+
+#ifndef EXEC_TYPES_H
+#include <exec/types.h>
+#endif
+
+extern void SDL_CopyAndSwap16(APTR srcx, APTR destx, LONG units);
+extern void SDL_CopyAndSwap32(APTR srcx, APTR destx, LONG units);
+
+#endif /* SDL_CORE_MORPHOS_CPU_H */
diff -ruN SDL2-2.32.8/src/core/morphos/devenv/makefile SDL2-2.32.8.aros/src/core/morphos/devenv/makefile
--- SDL2-2.32.8/src/core/morphos/devenv/makefile	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/core/morphos/devenv/makefile	2025-07-27 14:24:13.128841321 +0000
@@ -0,0 +1,61 @@
+# Makefile to build the SDL 2 Library
+
+CC      = ppc-morphos-gcc-11 -noixemul
+INCLUDE = -I../../../../include -I../sdk
+CFLAGS  = -mcpu=750 -mtune=7450 -O3 $(INCLUDE) -Wall -Wno-pointer-sign -fno-strict-aliasing -D_LARGEFILE64_SOURCE
+AR	= ppc-morphos-ar
+CVI = /gg/bin/cvinclude.pl
+
+ECHE = echo -e
+BOLD = \033[1m
+NRML = \033[22m
+
+COMPILING = @$(ECHE) "compiling $(BOLD)$@$(NRML)..."
+LINKING = @$(ECHE) "linking $(BOLD)$@$(NRML)..."
+STRIPPING = @$(ECHE) "stripping $(BOLD)$@$(NRML)..."
+ARCHIVING = @$(ECHE) "archiving $(BOLD)$@$(NRML)..."
+
+all: lib/libSDL2.a lib/libb32/libSDL2.a lib/libb32/libSDL2-nc.a
+
+lib: all
+
+install: all
+install-iso: all
+
+sdl-startup.o: sdl-startup.c sdl-stubs.c
+	$(COMPILING)
+	@$(CC) $(CFLAGS) -o $@ -c sdl-startup.c
+
+sdl-startup-brel.o: sdl-startup.c sdl-stubs.c
+	$(COMPILING)
+	@$(CC) $(CFLAGS) -mresident32 -o $@ -c sdl-startup.c
+
+sdl-startup-brel-nc.o: sdl-startup.c sdl-stubs.c
+	$(COMPILING)
+	@$(CC) $(CFLAGS) -mresident32 -o $@ -c sdl-startup.c -D__NO_SDL_CONSTRUCTORS
+
+lib/libSDL2.a: sdl-startup.o ../sdk/fd/sdl2_lib.fd
+	$(ARCHIVING)
+	@mkdir -p lib
+	@-rm -f $@
+	@$(CVI) --fd=../sdk/fd/sdl2_lib.fd --clib=../sdk/clib/sdl2_protos.h --gluelib=$@
+	@$(AR) crus $@ sdl-startup.o 
+
+lib/libb32/libSDL2.a: sdl-startup-brel.o  ../sdk/fd/sdl2_lib.fd
+	$(ARCHIVING)
+	@mkdir -p lib/libb32
+	@-rm -f $@
+	@$(CVI) --fd=../sdk/fd/sdl2_lib.fd --clib=../sdk/clib/sdl2_protos.h --brelgluelib=$@
+	@$(AR) crus $@ sdl-startup-brel.o
+
+lib/libb32/libSDL2-nc.a: sdl-startup-brel-nc.o ../sdk/fd/sdl2_lib.fd
+	$(ARCHIVING)
+	@mkdir -p lib/libb32
+	@-rm -f $@
+	@$(CVI) --fd=../sdk/fd/sdl2_lib.fd --clib=../sdk/clib/sdl2_protos.h --brelgluelib=$@
+	@$(AR) crus $@ sdl-startup-brel-nc.o
+clean:
+	@-rm -rf lib *.s *.o
+
+dump:
+	ppc-morphos-objdump --disassemble-all --reloc lib/libSDL2.a >lib/libSDL2.s
diff -ruN SDL2-2.32.8/src/core/morphos/devenv/sdl-startup.c SDL2-2.32.8.aros/src/core/morphos/devenv/sdl-startup.c
--- SDL2-2.32.8/src/core/morphos/devenv/sdl-startup.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/core/morphos/devenv/sdl-startup.c	2025-07-27 14:24:13.132841321 +0000
@@ -0,0 +1,201 @@
+/*
+ * Copyright (C) 2004-2017 MorphOS Development Team
+ *
+ * $Id: sdl-startup.c,v 1.2 2017/11/25 21:56:56 itix Exp $
+ */
+
+#include <constructor.h>
+#include <stdio.h>
+
+#include <proto/exec.h>
+#include <proto/dos.h>
+#include <proto/muimaster.h>
+#include <proto/sdl2.h>
+#include <proto/tinygl.h>
+#include <proto/openurl.h>
+#include <tgl/gl.h> 
+
+#include "SDL_error.h"
+#include "SDL_rwops.h"
+#include "SDL_version.h"
+
+#include "../SDL_mosversion.h"
+
+#if defined(__NO_SDL_CONSTRUCTORS)
+extern struct Library *SDL2Base;
+#else
+int _INIT_4_SDL2Base(void) __attribute__((alias("__CSTP_init_SDL2Base")));
+void _EXIT_4_SDL2Base(void) __attribute__((alias("__DSTP_cleanup_SDL2Base")));
+
+struct Library *SDL2Base;
+struct Library *TinyGLBase;
+GLContext      *__tglContext;
+
+void __SDL2_OpenLibError(ULONG version, const char *name, ULONG revision)
+{
+	struct Library *MUIMasterBase = OpenLibrary("muimaster.library", 0);
+
+	if (MUIMasterBase)
+	{
+		if (!revision) revision = 0;
+		size_t args[3] = { version, revision, (size_t)name};
+		LONG ret = MUI_RequestA(NULL, NULL, 0, "SDL2 startup message", "_Ok|_MorphOS-Storage", "You need minimum version %.10ld.%.10ld of %s .\nYou can find last SDL2 package on MorphOS-Storage.net.", &args);
+		if (ret == 0){
+			static const struct TagItem URLTags[] = {{TAG_DONE, (ULONG) NULL}};
+			struct Library *OpenURLBase = OpenLibrary("openurl.library", 0);
+			if (OpenURLBase) {
+				URL_OpenA((STRPTR)"https://www.morphos-storage.net/?find=SDL_2", (struct TagItem*) URLTags);
+				CloseLibrary(OpenURLBase);
+			}
+		}
+		CloseLibrary(MUIMasterBase);
+	}
+}
+
+static const char libname[] = "sdl2.library";
+static BPTR OldLock, NewLock;
+
+static CONSTRUCTOR_P(init_SDL2Base, 100)
+{
+	struct Library *base = (void *) OpenLibrary((STRPTR)libname, VERSION);
+
+	if (base)
+	{
+		if (!LIB_MINVER(base, VERSION, REVISION))
+		{
+			CloseLibrary(base);
+			base = NULL;
+			__SDL2_OpenLibError(VERSION, libname, REVISION);
+			
+		} 
+		else 
+		{	
+			NewLock = Lock("PROGDIR:", ACCESS_READ); /* we let libauto open doslib */
+			if(NewLock)
+			{
+				OldLock = CurrentDir(NewLock);
+				
+				SDL2Base = base;
+
+#ifdef TGL_CONTEXT_VERSION_53_9
+				if (LIB_MINVER(base, 53, 17))
+				{
+					SDL_InitTGL2((void **) &__tglContext, (struct Library **) &TinyGLBase, TGLGetMaximumContextVersion);
+				}
+				else
+#endif
+				{
+					SDL_InitTGL((void **) &__tglContext, (struct Library **) &TinyGLBase);
+				}
+			}
+			else
+			{
+				CloseLibrary(base);
+				base = NULL;
+			}
+		}
+				
+	}
+	else
+	{
+		__SDL2_OpenLibError(VERSION, libname, REVISION);
+	}
+
+	return (base == NULL);
+}
+
+static DESTRUCTOR_P(cleanup_SDL2Base, 100)
+{
+	struct Library *base = SDL2Base;
+	if (base)
+	{
+		if (NewLock)
+		{
+			UnLock(CurrentDir(OldLock));
+		}
+		CloseLibrary(base);
+		base = NULL;
+	}
+}
+#endif
+
+#include "sdl-stubs.c"
+
+/* SDL_RWops() replacement
+ *
+ * Functions to read/write stdio file pointers. Will link with libc stdio.
+ */
+
+static Sint64 stdio_size(struct SDL_RWops *context)
+{
+	Sint64 size, offset;
+
+	offset = ftello64(context->hidden.morphosio.fp.libc);
+	fseeko64(context->hidden.morphosio.fp.libc, 0, SEEK_END);
+	size = ftello64(context->hidden.morphosio.fp.libc);
+	fseeko64(context->hidden.morphosio.fp.libc, offset, SEEK_SET);
+
+	return size;
+}
+
+static Sint64 stdio_seek(SDL_RWops *context, Sint64 offset, int whence)
+{
+	if (fseeko64(context->hidden.morphosio.fp.libc, offset, whence) == 0 )
+	{
+		return ftello64(context->hidden.morphosio.fp.libc);
+	}
+	else
+	{
+		SDL_Error(SDL_EFSEEK);
+		return -1;
+	}
+}
+static size_t stdio_read(SDL_RWops *context, void *ptr, size_t size, size_t maxnum)
+{
+	size_t nread = fread(ptr, size, maxnum, context->hidden.morphosio.fp.libc);
+
+	if (nread == 0 && ferror((FILE *)context->hidden.morphosio.fp.libc) )
+	{
+		SDL_Error(SDL_EFREAD);
+	}
+
+	return nread;
+}
+static size_t stdio_write(SDL_RWops *context, const void *ptr, size_t size, size_t num)
+{
+	size_t nwrote = fwrite(ptr, size, num, context->hidden.morphosio.fp.libc);
+
+	if (nwrote == 0 && ferror((FILE *)context->hidden.morphosio.fp.libc) )
+	{
+		SDL_Error(SDL_EFWRITE);
+	}
+
+	return nwrote;
+}
+static int stdio_close(struct SDL_RWops *context)
+{
+	if ( context )
+	{
+		if ( context->hidden.morphosio.autoclose )
+		{
+			/* WARNING:  Check the return value here! */
+			fclose(context->hidden.morphosio.fp.libc);
+		}
+		SDL_FreeRW(context);
+	}
+	return 0;
+}
+
+SDL_RWops *SDL_RWFromFP(void *fp, SDL_bool autoclose)
+{
+	return SDL_RWFromFP_clib(fp, autoclose, stdio_size, stdio_seek, stdio_read, stdio_write, stdio_close);
+}
+
+void *SDL_GL_GetProcAddress(const char *proc)
+{
+	void *func = NULL;
+
+	func = tglGetProcAddress(proc); 
+	
+	return func;
+}
diff -ruN SDL2-2.32.8/src/core/morphos/devenv/sdl-stubs.c SDL2-2.32.8.aros/src/core/morphos/devenv/sdl-stubs.c
--- SDL2-2.32.8/src/core/morphos/devenv/sdl-stubs.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/core/morphos/devenv/sdl-stubs.c	2025-07-27 14:24:13.144841321 +0000
@@ -0,0 +1,124 @@
+#include <stdio.h>
+
+#include <proto/sdl2.h>
+
+/* SDL_string.c */
+
+int
+SDL_sscanf(const char *text, const char *fmt, ...)
+{
+    int rc;
+    va_list ap;
+    va_start(ap, fmt);
+    rc = SDL_vsscanf(text, fmt, ap);
+    va_end(ap);
+    return rc;
+}
+
+int
+SDL_snprintf(char *text, size_t maxlen, const char *fmt, ...)
+{
+    va_list ap;
+    int retval;
+
+    va_start(ap, fmt);
+    retval = SDL_vsnprintf(text, maxlen, fmt, ap);
+    va_end(ap);
+
+    return retval;
+}
+
+/* SDL_error.c */
+
+int
+SDL_SetError(const char *fmt, ...)
+{
+    int rc;
+    va_list ap;
+    va_start(ap, fmt);
+    rc = SDL_VSetError(fmt, ap);
+    va_end(ap);
+    return rc;
+}
+
+/* SDL_log.c */
+
+void
+SDL_Log(const char *fmt, ...)
+{
+    va_list ap;
+
+    va_start(ap, fmt);
+    SDL_LogMessageV(SDL_LOG_CATEGORY_APPLICATION, SDL_LOG_PRIORITY_INFO, fmt, ap);
+    va_end(ap);
+}
+
+void
+SDL_LogVerbose(int category, const char *fmt, ...)
+{
+    va_list ap;
+
+    va_start(ap, fmt);
+    SDL_LogMessageV(category, SDL_LOG_PRIORITY_VERBOSE, fmt, ap);
+    va_end(ap);
+}
+
+void
+SDL_LogDebug(int category, const char *fmt, ...)
+{
+    va_list ap;
+
+    va_start(ap, fmt);
+    SDL_LogMessageV(category, SDL_LOG_PRIORITY_DEBUG, fmt, ap);
+    va_end(ap);
+}
+
+void
+SDL_LogInfo(int category, const char *fmt, ...)
+{
+    va_list ap;
+
+    va_start(ap, fmt);
+    SDL_LogMessageV(category, SDL_LOG_PRIORITY_INFO, fmt, ap);
+    va_end(ap);
+}
+
+void
+SDL_LogWarn(int category, const char *fmt, ...)
+{
+    va_list ap;
+
+    va_start(ap, fmt);
+    SDL_LogMessageV(category, SDL_LOG_PRIORITY_WARN, fmt, ap);
+    va_end(ap);
+}
+
+void
+SDL_LogError(int category, const char *fmt, ...)
+{
+    va_list ap;
+
+    va_start(ap, fmt);
+    SDL_LogMessageV(category, SDL_LOG_PRIORITY_ERROR, fmt, ap);
+    va_end(ap);
+}
+
+void
+SDL_LogCritical(int category, const char *fmt, ...)
+{
+    va_list ap;
+
+    va_start(ap, fmt);
+    SDL_LogMessageV(category, SDL_LOG_PRIORITY_CRITICAL, fmt, ap);
+    va_end(ap);
+}
+
+void
+SDL_LogMessage(int category, SDL_LogPriority priority, const char *fmt, ...)
+{
+    va_list ap;
+
+    va_start(ap, fmt);
+    SDL_LogMessageV(category, priority, fmt, ap);
+    va_end(ap);
+}
diff -ruN SDL2-2.32.8/src/core/morphos/sdk/clib/sdl2_protos.h SDL2-2.32.8.aros/src/core/morphos/sdk/clib/sdl2_protos.h
--- SDL2-2.32.8/src/core/morphos/sdk/clib/sdl2_protos.h	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/core/morphos/sdk/clib/sdl2_protos.h	2025-07-27 14:24:13.164841322 +0000
@@ -0,0 +1,887 @@
+#ifndef CLIB_SDL2_PROTOS_H
+#define CLIB_SDL2_PROTOS_H
+
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2016 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+/*
+ * Collection of SDL 2 functions.
+ */
+
+#ifndef _SDL_H
+#include <SDL.h>
+#endif
+
+struct Library;
+
+void SDL_InitTGL(void **glc, struct Library **tgl);
+void SDL_InitTGL2(void **glc, struct Library **tgl, unsigned int (*getmaximumcontextversion)(struct Library *TinyGLBase));
+void SDL_SetExitPointer(void (*exitfunc)(int));
+SDL_RWops *SDL_RWFromFP_clib(void *fp, int autoclose, Sint64 (*size)(struct SDL_RWops *), Sint64 (*seek)(struct SDL_RWops *, Sint64, int), size_t (*read)(struct SDL_RWops *, void *, size_t, size_t), size_t (*write)(struct SDL_RWops *, const void *, size_t, size_t), int (*close)(struct SDL_RWops *));
+int SDL_VSetError(const char *fmt, va_list ap);
+
+#if 0
+const char *SDL_GetPlatform(void);
+
+int SDL_Init(Uint32 flags);
+int SDL_InitSubSystem(Uint32 flags);
+void SDL_QuitSubSystem(Uint32 flags);
+Uint32 SDL_WasInit(Uint32 flags);
+void SDL_Quit(void);
+
+void SDL_SetMainReady(void);
+void *SDL_malloc(size_t size);
+void *SDL_calloc(size_t nmemb, size_t size);
+void *SDL_realloc(void *mem, size_t size);
+void SDL_free(void *mem);
+
+void SDL_qsort(void *base, size_t nmemb, size_t size, SDL_CompareCallback compare);
+
+int SDL_abs(int x);
+int SDL_isdigit(int x);
+int SDL_isspace(int x);
+int SDL_toupper(int x);
+int SDL_tolower(int x);
+
+void *SDL_memset(void *dst, int c, size_t len);
+void *SDL_memcpy(void *dst, const void *src, size_t len);
+void *SDL_memmove(void *dst, const void *src, size_t len);
+int SDL_memcmp(const void *s1, const void *s2, size_t len);
+size_t SDL_wcslen(const wchar_t *wstr);
+size_t SDL_wcslcpy(wchar_t *dst, const wchar_t *src, size_t maxlen);
+size_t SDL_wcslcat(wchar_t *dst, const wchar_t *src, size_t maxlen);
+size_t SDL_strlen(const char *str);
+size_t SDL_strlcpy(char *dst, const char *src, size_t maxlen);
+size_t SDL_utf8strlcpy(char *dst, const char *src, size_t dst_bytes);
+size_t SDL_strlcat(char *dst, const char *src, size_t maxlen);
+char *SDL_strdup(const char *str);
+char *SDL_strrev(char *str);
+char *SDL_strupr(char *str);
+char *SDL_strlwr(char *str);
+char *SDL_strchr(const char *str, int c);
+char *SDL_strrchr(const char *str, int c);
+char *SDL_strstr(const char *haystack, const char *needle);
+char *SDL_itoa(int value, char *str, int radix);
+char *SDL_uitoa(unsigned int value, char *str, int radix);
+char *SDL_ltoa(long value, char *str, int radix);
+char *SDL_ultoa(unsigned long value, char *str, int radix);
+char *SDL_lltoa(Sint64 value, char *str, int radix);
+char *SDL_ulltoa(Uint64 value, char *str, int radix);
+int SDL_atoi(const char *str);
+double SDL_atof(const char *str);
+long SDL_strtol(const char *str, char **endp, int base);
+unsigned long SDL_strtoul(const char *str, char **endp, int base);
+Sint64 SDL_strtoll(const char *str, char **endp, int base);
+Uint64 SDL_strtoull(const char *str, char **endp, int base);
+double SDL_strtod(const char *str, char **endp);
+int SDL_strcmp(const char *str1, const char *str2);
+int SDL_strncmp(const char *str1, const char *str2, size_t maxlen);
+int SDL_strcasecmp(const char *str1, const char *str2);
+int SDL_strncasecmp(const char *str1, const char *str2, size_t len);
+int SDL_vsscanf(const char *text, const char *fmt, va_list ap);
+int SDL_vsnprintf(char *text, size_t maxlen, const char *fmt, va_list ap);
+double SDL_acos(double x);
+double SDL_asin(double x);
+double SDL_atan(double x);
+double SDL_atan2(double x, double y);
+double SDL_ceil(double x);
+double SDL_copysign(double x, double y);
+double SDL_cos(double x);
+float SDL_cosf(float x);
+double SDL_fabs(double x);
+double SDL_floor(double x);
+double SDL_log(double x);
+double SDL_pow(double x, double y);
+double SDL_scalbn(double x, int n);
+double SDL_sin(double x);
+float SDL_sinf(float x);
+double SDL_sqrt(double x);
+
+SDL_iconv_t SDL_iconv_open(const char *tocode, const char *fromcode);
+int SDL_iconv_close(SDL_iconv_t cd);
+size_t SDL_iconv(SDL_iconv_t cd, const char **inbuf, size_t * inbytesleft, char **outbuf, size_t * outbytesleft);
+char *SDL_iconv_string(const char *tocode, const char *fromcode, const char *inbuf, size_t inbytesleft);
+
+SDL_AssertData SDL_ReportAssertion(SDL_AssertData *, const char *, const char *, int);
+void SDL_SetAssertionHandler(SDL_AssertionHandler handler, void *userdata);
+
+SDL_AssertionHandler SDL_GetDefaultAssertionHandler(void);
+SDL_AssertionHandler SDL_GetAssertionHandler(void **puserdata);
+const SDL_AssertData * SDL_GetAssertionReport(void);
+void SDL_ResetAssertionReport(void);
+SDL_bool SDL_AtomicTryLock(SDL_SpinLock *lock);
+void SDL_AtomicLock(SDL_SpinLock *lock);
+void SDL_AtomicUnlock(SDL_SpinLock *lock);
+SDL_bool SDL_AtomicCAS(SDL_atomic_t *a, int oldval, int newval);
+int SDL_AtomicSet(SDL_atomic_t *a, int v);
+int SDL_AtomicGet(SDL_atomic_t *a);
+int SDL_AtomicAdd(SDL_atomic_t *a, int v);
+SDL_bool SDL_AtomicCASPtr(void **a, void *oldval, void *newval);
+void* SDL_AtomicSetPtr(void **a, void* v);
+void* SDL_AtomicGetPtr(void **a);
+int SDL_GetNumAudioDrivers(void);
+const char *SDL_GetAudioDriver(int index);
+int SDL_AudioInit(const char *driver_name);
+void SDL_AudioQuit(void);
+const char *SDL_GetCurrentAudioDriver(void);
+int SDL_OpenAudio(SDL_AudioSpec * desired, SDL_AudioSpec * obtained);
+int SDL_GetNumAudioDevices(int iscapture);
+const char *SDL_GetAudioDeviceName(int index, int iscapture);
+SDL_AudioDeviceID SDL_OpenAudioDevice(const char *device, int iscapture, const SDL_AudioSpec *desired, SDL_AudioSpec *obtained, int allowed_changes);
+SDL_AudioStatus SDL_GetAudioStatus(void);
+SDL_AudioStatus SDL_GetAudioDeviceStatus(SDL_AudioDeviceID dev);
+void SDL_PauseAudio(int pause_on);
+void SDL_PauseAudioDevice(SDL_AudioDeviceID dev, int pause_on);
+SDL_AudioSpec *SDL_LoadWAV_RW(SDL_RWops * src, int freesrc, SDL_AudioSpec * spec, Uint8 ** audio_buf, Uint32 * audio_len);
+void SDL_FreeWAV(Uint8 * audio_buf);
+int SDL_BuildAudioCVT(SDL_AudioCVT * cvt, SDL_AudioFormat src_format, Uint8 src_channels, int src_rate, SDL_AudioFormat dst_format, Uint8 dst_channels, int dst_rate);
+int SDL_ConvertAudio(SDL_AudioCVT * cvt);
+void SDL_MixAudio(Uint8 * dst, const Uint8 * src, Uint32 len, int volume);
+void SDL_MixAudioFormat(Uint8 * dst, const Uint8 * src, SDL_AudioFormat format, Uint32 len, int volume);
+void SDL_LockAudio(void);
+void SDL_LockAudioDevice(SDL_AudioDeviceID dev);
+void SDL_UnlockAudio(void);
+void SDL_UnlockAudioDevice(SDL_AudioDeviceID dev);
+void SDL_CloseAudio(void);
+void SDL_CloseAudioDevice(SDL_AudioDeviceID dev);
+int SDL_SetClipboardText(const char *text);
+char * SDL_GetClipboardText(void);
+SDL_bool SDL_HasClipboardText(void);
+int SDL_GetCPUCount(void);
+int SDL_GetCPUCacheLineSize(void);
+SDL_bool SDL_HasRDTSC(void);
+SDL_bool SDL_HasAltiVec(void);
+SDL_bool SDL_HasMMX(void);
+SDL_bool SDL_Has3DNow(void);
+SDL_bool SDL_HasSSE(void);
+SDL_bool SDL_HasSSE2(void);
+SDL_bool SDL_HasSSE3(void);
+SDL_bool SDL_HasSSE41(void);
+SDL_bool SDL_HasSSE42(void);
+SDL_bool SDL_HasAVX(void);
+int SDL_GetSystemRAM(void);
+const char *SDL_GetError(void);
+void SDL_ClearError(void);
+int SDL_Error(SDL_errorcode code);
+void SDL_PumpEvents(void);
+int SDL_PeepEvents(SDL_Event * events, int numevents, SDL_eventaction action, Uint32 minType, Uint32 maxType);
+SDL_bool SDL_HasEvent(Uint32 type);
+SDL_bool SDL_HasEvents(Uint32 minType, Uint32 maxType);
+void SDL_FlushEvent(Uint32 type);
+void SDL_FlushEvents(Uint32 minType, Uint32 maxType);
+int SDL_PollEvent(SDL_Event * event);
+int SDL_WaitEvent(SDL_Event * event);
+int SDL_WaitEventTimeout(SDL_Event * event, int timeout);
+int SDL_PushEvent(SDL_Event * event);
+void SDL_SetEventFilter(SDL_EventFilter filter, void *userdata);
+SDL_bool SDL_GetEventFilter(SDL_EventFilter * filter, void **userdata);
+void SDL_AddEventWatch(SDL_EventFilter filter, void *userdata);
+void SDL_DelEventWatch(SDL_EventFilter filter, void *userdata);
+void SDL_FilterEvents(SDL_EventFilter filter, void *userdata);
+Uint8 SDL_EventState(Uint32 type, int state);
+Uint32 SDL_RegisterEvents(int numevents);
+char *SDL_GetBasePath(void);
+char *SDL_GetPrefPath(const char *org, const char *app);
+int SDL_NumJoysticks(void);
+const char *SDL_JoystickNameForIndex(int device_index);
+SDL_Joystick *SDL_JoystickOpen(int device_index);
+const char *SDL_JoystickName(SDL_Joystick * joystick);
+SDL_JoystickGUID SDL_JoystickGetDeviceGUID(int device_index);
+SDL_JoystickGUID SDL_JoystickGetGUID(SDL_Joystick * joystick);
+void SDL_JoystickGetGUIDString(SDL_JoystickGUID guid, char *pszGUID, int cbGUID);
+SDL_JoystickGUID SDL_JoystickGetGUIDFromString(const char *pchGUID);
+SDL_bool SDL_JoystickGetAttached(SDL_Joystick * joystick);
+SDL_JoystickID SDL_JoystickInstanceID(SDL_Joystick * joystick);
+int SDL_JoystickNumAxes(SDL_Joystick * joystick);
+int SDL_JoystickNumBalls(SDL_Joystick * joystick);
+int SDL_JoystickNumHats(SDL_Joystick * joystick);
+int SDL_JoystickNumButtons(SDL_Joystick * joystick);
+void SDL_JoystickUpdate(void);
+int SDL_JoystickEventState(int state);
+Sint16 SDL_JoystickGetAxis(SDL_Joystick * joystick, int axis);
+Uint8 SDL_JoystickGetHat(SDL_Joystick * joystick, int hat);
+int SDL_JoystickGetBall(SDL_Joystick * joystick, int ball, int *dx, int *dy);
+Uint8 SDL_JoystickGetButton(SDL_Joystick * joystick, int button);
+void SDL_JoystickClose(SDL_Joystick * joystick);
+int SDL_GameControllerAddMappingsFromRW( SDL_RWops * rw, int freerw );
+int SDL_GameControllerAddMapping( const char* mappingString );
+char * SDL_GameControllerMappingForGUID( SDL_JoystickGUID guid );
+char * SDL_GameControllerMapping( SDL_GameController * gamecontroller );
+SDL_bool SDL_IsGameController(int joystick_index);
+const char *SDL_GameControllerNameForIndex(int joystick_index);
+SDL_GameController *SDL_GameControllerOpen(int joystick_index);
+const char *SDL_GameControllerName(SDL_GameController *gamecontroller);
+SDL_bool SDL_GameControllerGetAttached(SDL_GameController *gamecontroller);
+SDL_Joystick *SDL_GameControllerGetJoystick(SDL_GameController *gamecontroller);
+int SDL_GameControllerEventState(int state);
+void SDL_GameControllerUpdate(void);
+SDL_GameControllerAxis SDL_GameControllerGetAxisFromString(const char *pchString);
+const char* SDL_GameControllerGetStringForAxis(SDL_GameControllerAxis axis);
+SDL_GameControllerButtonBind SDL_GameControllerGetBindForAxis(SDL_GameController *gamecontroller, SDL_GameControllerAxis axis);
+Sint16 SDL_GameControllerGetAxis(SDL_GameController *gamecontroller, SDL_GameControllerAxis axis);
+SDL_GameControllerButton SDL_GameControllerGetButtonFromString(const char *pchString);
+const char* SDL_GameControllerGetStringForButton(SDL_GameControllerButton button);
+SDL_GameControllerButtonBind SDL_GameControllerGetBindForButton(SDL_GameController *gamecontroller, SDL_GameControllerButton button);
+Uint8 SDL_GameControllerGetButton(SDL_GameController *gamecontroller, SDL_GameControllerButton button);
+void SDL_GameControllerClose(SDL_GameController *gamecontroller);
+int SDL_NumHaptics(void);
+const char *SDL_HapticName(int device_index);
+SDL_Haptic *SDL_HapticOpen(int device_index);
+int SDL_HapticOpened(int device_index);
+int SDL_HapticIndex(SDL_Haptic * haptic);
+int SDL_MouseIsHaptic(void);
+SDL_Haptic *SDL_HapticOpenFromMouse(void);
+int SDL_JoystickIsHaptic(SDL_Joystick * joystick);
+SDL_Haptic *SDL_HapticOpenFromJoystick(SDL_Joystick * joystick);
+void SDL_HapticClose(SDL_Haptic * haptic);
+int SDL_HapticNumEffects(SDL_Haptic * haptic);
+int SDL_HapticNumEffectsPlaying(SDL_Haptic * haptic);
+unsigned int SDL_HapticQuery(SDL_Haptic * haptic);
+int SDL_HapticNumAxes(SDL_Haptic * haptic);
+int SDL_HapticEffectSupported(SDL_Haptic * haptic, SDL_HapticEffect * effect);
+int SDL_HapticNewEffect(SDL_Haptic * haptic, SDL_HapticEffect * effect);
+int SDL_HapticUpdateEffect(SDL_Haptic * haptic, int effect, SDL_HapticEffect * data);
+int SDL_HapticRunEffect(SDL_Haptic * haptic, int effect, Uint32 iterations);
+int SDL_HapticStopEffect(SDL_Haptic * haptic, int effect);
+void SDL_HapticDestroyEffect(SDL_Haptic * haptic, int effect);
+int SDL_HapticGetEffectStatus(SDL_Haptic * haptic, int effect);
+int SDL_HapticSetGain(SDL_Haptic * haptic, int gain);
+int SDL_HapticSetAutocenter(SDL_Haptic * haptic, int autocenter);
+int SDL_HapticPause(SDL_Haptic * haptic);
+int SDL_HapticUnpause(SDL_Haptic * haptic);
+int SDL_HapticStopAll(SDL_Haptic * haptic);
+int SDL_HapticRumbleSupported(SDL_Haptic * haptic);
+int SDL_HapticRumbleInit(SDL_Haptic * haptic);
+int SDL_HapticRumblePlay(SDL_Haptic * haptic, float strength, Uint32 length );
+int SDL_HapticRumbleStop(SDL_Haptic * haptic);
+SDL_bool SDL_SetHintWithPriority(const char *name, const char *value, SDL_HintPriority priority);
+SDL_bool SDL_SetHint(const char *name, const char *value);
+const char * SDL_GetHint(const char *name);
+void SDL_AddHintCallback(const char *name, SDL_HintCallback callback, void *userdata);
+void SDL_DelHintCallback(const char *name, SDL_HintCallback callback, void *userdata);
+void SDL_ClearHints(void);
+void *SDL_LoadObject(const char *sofile);
+void *SDL_LoadFunction(void *handle, const char *name);
+void SDL_UnloadObject(void *handle);
+void SDL_LogSetAllPriority(SDL_LogPriority priority);
+void SDL_LogSetPriority(int category, SDL_LogPriority priority);
+SDL_LogPriority SDL_LogGetPriority(int category);
+void SDL_LogResetPriorities(void);
+void SDL_LogMessageV(int category, SDL_LogPriority priority, const char *fmt, va_list ap);
+void SDL_LogGetOutputFunction(SDL_LogOutputFunction *callback, void **userdata);
+void SDL_LogSetOutputFunction(SDL_LogOutputFunction callback, void *userdata);
+int SDL_ShowMessageBox(const SDL_MessageBoxData *messageboxdata, int *buttonid);
+int SDL_ShowSimpleMessageBox(Uint32 flags, const char *title, const char *message, SDL_Window *window);
+SDL_mutex *SDL_CreateMutex(void);
+int SDL_LockMutex(SDL_mutex * mutex);
+int SDL_TryLockMutex(SDL_mutex * mutex);
+int SDL_UnlockMutex(SDL_mutex * mutex);
+void SDL_DestroyMutex(SDL_mutex * mutex);
+SDL_sem *SDL_CreateSemaphore(Uint32 initial_value);
+void SDL_DestroySemaphore(SDL_sem * sem);
+int SDL_SemWait(SDL_sem * sem);
+int SDL_SemTryWait(SDL_sem * sem);
+int SDL_SemWaitTimeout(SDL_sem * sem, Uint32 ms);
+int SDL_SemPost(SDL_sem * sem);
+Uint32 SDL_SemValue(SDL_sem * sem);
+SDL_cond *SDL_CreateCond(void);
+void SDL_DestroyCond(SDL_cond * cond);
+int SDL_CondSignal(SDL_cond * cond);
+int SDL_CondBroadcast(SDL_cond * cond);
+int SDL_CondWait(SDL_cond * cond, SDL_mutex * mutex);
+int SDL_CondWaitTimeout(SDL_cond * cond, SDL_mutex * mutex, Uint32 ms);
+SDL_PowerState SDL_GetPowerInfo(int *secs, int *pct);
+int SDL_GetNumRenderDrivers(void);
+int SDL_GetRenderDriverInfo(int index, SDL_RendererInfo * info);
+int SDL_CreateWindowAndRenderer(int width, int height, Uint32 window_flags, SDL_Window **window, SDL_Renderer **renderer);
+SDL_Renderer * SDL_CreateRenderer(SDL_Window * window, int index, Uint32 flags);
+SDL_Renderer * SDL_CreateSoftwareRenderer(SDL_Surface * surface);
+SDL_Renderer * SDL_GetRenderer(SDL_Window * window);
+int SDL_GetRendererInfo(SDL_Renderer * renderer, SDL_RendererInfo * info);
+int SDL_GetRendererOutputSize(SDL_Renderer * renderer, int *w, int *h);
+SDL_Texture * SDL_CreateTexture(SDL_Renderer * renderer, Uint32 format, int access, int w, int h);
+SDL_Texture * SDL_CreateTextureFromSurface(SDL_Renderer * renderer, SDL_Surface * surface);
+int SDL_QueryTexture(SDL_Texture * texture, Uint32 * format, int *access, int *w, int *h);
+int SDL_SetTextureColorMod(SDL_Texture * texture, Uint8 r, Uint8 g, Uint8 b);
+int SDL_GetTextureColorMod(SDL_Texture * texture, Uint8 * r, Uint8 * g, Uint8 * b);
+int SDL_SetTextureAlphaMod(SDL_Texture * texture, Uint8 alpha);
+int SDL_GetTextureAlphaMod(SDL_Texture * texture, Uint8 * alpha);
+int SDL_SetTextureBlendMode(SDL_Texture * texture, SDL_BlendMode blendMode);
+int SDL_GetTextureBlendMode(SDL_Texture * texture, SDL_BlendMode *blendMode);
+int SDL_UpdateTexture(SDL_Texture * texture, const SDL_Rect * rect, const void *pixels, int pitch);
+int SDL_UpdateYUVTexture(SDL_Texture * texture, const SDL_Rect * rect, const Uint8 *Yplane, int Ypitch, const Uint8 *Uplane, int Upitch, const Uint8 *Vplane, int Vpitch);
+int SDL_LockTexture(SDL_Texture * texture, const SDL_Rect * rect, void **pixels, int *pitch);
+void SDL_UnlockTexture(SDL_Texture * texture);
+SDL_bool SDL_RenderTargetSupported(SDL_Renderer *renderer);
+int SDL_SetRenderTarget(SDL_Renderer *renderer, SDL_Texture *texture);
+SDL_Texture * SDL_GetRenderTarget(SDL_Renderer *renderer);
+int SDL_RenderSetLogicalSize(SDL_Renderer * renderer, int w, int h);
+void SDL_RenderGetLogicalSize(SDL_Renderer * renderer, int *w, int *h);
+int SDL_RenderSetViewport(SDL_Renderer * renderer, const SDL_Rect * rect);
+void SDL_RenderGetViewport(SDL_Renderer * renderer, SDL_Rect * rect);
+int SDL_RenderSetClipRect(SDL_Renderer * renderer, const SDL_Rect * rect);
+void SDL_RenderGetClipRect(SDL_Renderer * renderer, SDL_Rect * rect);
+int SDL_RenderSetScale(SDL_Renderer * renderer, float scaleX, float scaleY);
+void SDL_RenderGetScale(SDL_Renderer * renderer, float *scaleX, float *scaleY);
+int SDL_SetRenderDrawColor(SDL_Renderer * renderer, Uint8 r, Uint8 g, Uint8 b, Uint8 a);
+int SDL_GetRenderDrawColor(SDL_Renderer * renderer, Uint8 * r, Uint8 * g, Uint8 * b, Uint8 * a);
+int SDL_SetRenderDrawBlendMode(SDL_Renderer * renderer, SDL_BlendMode blendMode);
+int SDL_GetRenderDrawBlendMode(SDL_Renderer * renderer, SDL_BlendMode *blendMode);
+int SDL_RenderClear(SDL_Renderer * renderer);
+int SDL_RenderDrawPoint(SDL_Renderer * renderer, int x, int y);
+int SDL_RenderDrawPoints(SDL_Renderer * renderer, const SDL_Point * points, int count);
+int SDL_RenderDrawLine(SDL_Renderer * renderer, int x1, int y1, int x2, int y2);
+int SDL_RenderDrawLines(SDL_Renderer * renderer, const SDL_Point * points, int count);
+int SDL_RenderDrawRect(SDL_Renderer * renderer, const SDL_Rect * rect);
+int SDL_RenderDrawRects(SDL_Renderer * renderer, const SDL_Rect * rects, int count);
+int SDL_RenderFillRect(SDL_Renderer * renderer, const SDL_Rect * rect);
+int SDL_RenderFillRects(SDL_Renderer * renderer, const SDL_Rect * rects, int count);
+int SDL_RenderCopy(SDL_Renderer * renderer, SDL_Texture * texture, const SDL_Rect * srcrect, const SDL_Rect * dstrect);
+int SDL_RenderCopyEx(SDL_Renderer * renderer, SDL_Texture * texture, const SDL_Rect * srcrect, const SDL_Rect * dstrect, const double angle, const SDL_Point *center, const SDL_RendererFlip flip);
+int SDL_RenderReadPixels(SDL_Renderer * renderer, const SDL_Rect * rect, Uint32 format, void *pixels, int pitch);
+void SDL_RenderPresent(SDL_Renderer * renderer);
+void SDL_DestroyTexture(SDL_Texture * texture);
+void SDL_DestroyRenderer(SDL_Renderer * renderer);
+int SDL_GL_BindTexture(SDL_Texture *texture, float *texw, float *texh);
+int SDL_GL_UnbindTexture(SDL_Texture *texture);
+SDL_RWops *SDL_RWFromFile(const char *file, const char *mode);
+//SDL_RWops *SDL_RWFromFP(FILE * fp, SDL_bool autoclose);
+SDL_RWops *SDL_RWFromMem(void *mem, int size);
+SDL_RWops *SDL_RWFromConstMem(const void *mem, int size);
+SDL_RWops *SDL_AllocRW(void);
+void SDL_FreeRW(SDL_RWops * area);
+Uint8 SDL_ReadU8(SDL_RWops * src);
+Uint16 SDL_ReadLE16(SDL_RWops * src);
+Uint16 SDL_ReadBE16(SDL_RWops * src);
+Uint32 SDL_ReadLE32(SDL_RWops * src);
+Uint32 SDL_ReadBE32(SDL_RWops * src);
+Uint64 SDL_ReadLE64(SDL_RWops * src);
+Uint64 SDL_ReadBE64(SDL_RWops * src);
+size_t SDL_WriteU8(SDL_RWops * dst, Uint8 value);
+size_t SDL_WriteLE16(SDL_RWops * dst, Uint16 value);
+size_t SDL_WriteBE16(SDL_RWops * dst, Uint16 value);
+size_t SDL_WriteLE32(SDL_RWops * dst, Uint32 value);
+size_t SDL_WriteBE32(SDL_RWops * dst, Uint32 value);
+size_t SDL_WriteLE64(SDL_RWops * dst, Uint64 value);
+size_t SDL_WriteBE64(SDL_RWops * dst, Uint64 value);
+SDL_Thread *SDL_CreateThread(SDL_ThreadFunction fn, const char *name, void *data);
+const char *SDL_GetThreadName(SDL_Thread *thread);
+SDL_threadID SDL_ThreadID(void);
+SDL_threadID SDL_GetThreadID(SDL_Thread * thread);
+int SDL_SetThreadPriority(SDL_ThreadPriority priority);
+void SDL_WaitThread(SDL_Thread * thread, int *status);
+void SDL_DetachThread(SDL_Thread * thread);
+SDL_TLSID SDL_TLSCreate(void);
+void * SDL_TLSGet(SDL_TLSID id);
+int SDL_TLSSet(SDL_TLSID id, const void *value, SDL_TLSDestructorCallback destructor);
+Uint32 SDL_GetTicks(void);
+Uint64 SDL_GetPerformanceCounter(void);
+Uint64 SDL_GetPerformanceFrequency(void);
+void SDL_Delay(Uint32 ms);
+SDL_TimerID SDL_AddTimer(Uint32 interval, SDL_TimerCallback callback, void *param);
+SDL_bool SDL_RemoveTimer(SDL_TimerID id);
+void SDL_GetVersion(SDL_version * ver);
+const char *SDL_GetRevision(void);
+int SDL_GetRevisionNumber(void);
+int SDL_GetNumVideoDrivers(void);
+const char *SDL_GetVideoDriver(int index);
+int SDL_VideoInit(const char *driver_name);
+void SDL_VideoQuit(void);
+const char *SDL_GetCurrentVideoDriver(void);
+int SDL_GetNumVideoDisplays(void);
+const char * SDL_GetDisplayName(int displayIndex);
+int SDL_GetDisplayBounds(int displayIndex, SDL_Rect * rect);
+int SDL_GetNumDisplayModes(int displayIndex);
+int SDL_GetDisplayMode(int displayIndex, int modeIndex, SDL_DisplayMode * mode);
+int SDL_GetDesktopDisplayMode(int displayIndex, SDL_DisplayMode * mode);
+int SDL_GetCurrentDisplayMode(int displayIndex, SDL_DisplayMode * mode);
+SDL_DisplayMode * SDL_GetClosestDisplayMode(int displayIndex, const SDL_DisplayMode * mode, SDL_DisplayMode * closest);
+int SDL_GetWindowDisplayIndex(SDL_Window * window);
+int SDL_SetWindowDisplayMode(SDL_Window * window, const SDL_DisplayMode * mode);
+int SDL_GetWindowDisplayMode(SDL_Window * window, SDL_DisplayMode * mode);
+Uint32 SDL_GetWindowPixelFormat(SDL_Window * window);
+SDL_Window * SDL_CreateWindow(const char *title, int x, int y, int w, int h, Uint32 flags);
+SDL_Window * SDL_CreateWindowFrom(const void *data);
+Uint32 SDL_GetWindowID(SDL_Window * window);
+SDL_Window * SDL_GetWindowFromID(Uint32 id);
+Uint32 SDL_GetWindowFlags(SDL_Window * window);
+void SDL_SetWindowTitle(SDL_Window * window, const char *title);
+const char *SDL_GetWindowTitle(SDL_Window * window);
+void SDL_SetWindowIcon(SDL_Window * window, SDL_Surface * icon);
+void* SDL_SetWindowData(SDL_Window * window, const char *name, void *userdata);
+void *SDL_GetWindowData(SDL_Window * window, const char *name);
+void SDL_SetWindowPosition(SDL_Window * window, int x, int y);
+void SDL_GetWindowPosition(SDL_Window * window, int *x, int *y);
+void SDL_SetWindowSize(SDL_Window * window, int w, int h);
+void SDL_GetWindowSize(SDL_Window * window, int *w, int *h);
+void SDL_SetWindowMinimumSize(SDL_Window * window, int min_w, int min_h);
+void SDL_GetWindowMinimumSize(SDL_Window * window, int *w, int *h);
+void SDL_SetWindowMaximumSize(SDL_Window * window, int max_w, int max_h);
+void SDL_GetWindowMaximumSize(SDL_Window * window, int *w, int *h);
+void SDL_SetWindowBordered(SDL_Window * window, SDL_bool bordered);
+void SDL_ShowWindow(SDL_Window * window);
+void SDL_HideWindow(SDL_Window * window);
+void SDL_RaiseWindow(SDL_Window * window);
+void SDL_MaximizeWindow(SDL_Window * window);
+void SDL_MinimizeWindow(SDL_Window * window);
+void SDL_RestoreWindow(SDL_Window * window);
+int SDL_SetWindowFullscreen(SDL_Window * window, Uint32 flags);
+SDL_Surface * SDL_GetWindowSurface(SDL_Window * window);
+int SDL_UpdateWindowSurface(SDL_Window * window);
+int SDL_UpdateWindowSurfaceRects(SDL_Window * window, const SDL_Rect * rects, int numrects);
+void SDL_SetWindowGrab(SDL_Window * window, SDL_bool grabbed);
+SDL_bool SDL_GetWindowGrab(SDL_Window * window);
+int SDL_SetWindowBrightness(SDL_Window * window, float brightness);
+float SDL_GetWindowBrightness(SDL_Window * window);
+int SDL_SetWindowGammaRamp(SDL_Window * window, const Uint16 * red, const Uint16 * green, const Uint16 * blue);
+int SDL_GetWindowGammaRamp(SDL_Window * window, Uint16 * red, Uint16 * green, Uint16 * blue);
+void SDL_DestroyWindow(SDL_Window * window);
+SDL_bool SDL_IsScreenSaverEnabled(void);
+void SDL_EnableScreenSaver(void);
+void SDL_DisableScreenSaver(void);
+SDL_Window *SDL_GetKeyboardFocus(void);
+const Uint8 *SDL_GetKeyboardState(int *numkeys);
+SDL_Keymod SDL_GetModState(void);
+void SDL_SetModState(SDL_Keymod modstate);
+SDL_Keycode SDL_GetKeyFromScancode(SDL_Scancode scancode);
+SDL_Scancode SDL_GetScancodeFromKey(SDL_Keycode key);
+const char *SDL_GetScancodeName(SDL_Scancode scancode);
+SDL_Scancode SDL_GetScancodeFromName(const char *name);
+const char *SDL_GetKeyName(SDL_Keycode key);
+SDL_Keycode SDL_GetKeyFromName(const char *name);
+void SDL_StartTextInput(void);
+SDL_bool SDL_IsTextInputActive(void);
+void SDL_StopTextInput(void);
+void SDL_SetTextInputRect(const SDL_Rect *rect);
+SDL_bool SDL_HasScreenKeyboardSupport(void);
+SDL_bool SDL_IsScreenKeyboardShown(SDL_Window *window);
+
+SDL_Surface *SDL_CreateRGBSurface(Uint32 flags, int width, int height, int depth, Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask);
+SDL_Surface *SDL_CreateRGBSurfaceFrom(void *pixels, int width, int height, int depth, int pitch, Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask);
+void SDL_FreeSurface(SDL_Surface * surface);
+int SDL_SetSurfacePalette(SDL_Surface * surface, SDL_Palette * palette);
+int SDL_LockSurface(SDL_Surface * surface);
+void SDL_UnlockSurface(SDL_Surface * surface);
+SDL_Surface *SDL_LoadBMP_RW(SDL_RWops * src, int freesrc);
+int SDL_SaveBMP_RW(SDL_Surface * surface, SDL_RWops * dst, int freedst);
+int SDL_SetSurfaceRLE(SDL_Surface * surface, int flag);
+int SDL_SetColorKey(SDL_Surface * surface, int flag, Uint32 key);
+int SDL_GetColorKey(SDL_Surface * surface, Uint32 * key);
+int SDL_SetSurfaceColorMod(SDL_Surface * surface, Uint8 r, Uint8 g, Uint8 b);
+int SDL_GetSurfaceColorMod(SDL_Surface * surface, Uint8 * r, Uint8 * g, Uint8 * b);
+int SDL_SetSurfaceAlphaMod(SDL_Surface * surface, Uint8 alpha);
+int SDL_GetSurfaceAlphaMod(SDL_Surface * surface, Uint8 * alpha);
+int SDL_SetSurfaceBlendMode(SDL_Surface * surface, SDL_BlendMode blendMode);
+int SDL_GetSurfaceBlendMode(SDL_Surface * surface, SDL_BlendMode *blendMode);
+SDL_bool SDL_SetClipRect(SDL_Surface * surface, const SDL_Rect * rect);
+void SDL_GetClipRect(SDL_Surface * surface, SDL_Rect * rect);
+SDL_Surface *SDL_ConvertSurface(SDL_Surface * src, const SDL_PixelFormat * fmt, Uint32 flags);
+SDL_Surface *SDL_ConvertSurfaceFormat(SDL_Surface * src, Uint32 pixel_format, Uint32 flags);
+int SDL_ConvertPixels(int width, int height, Uint32 src_format, const void * src, int src_pitch, Uint32 dst_format, void * dst, int dst_pitch);
+int SDL_FillRect(SDL_Surface * dst, const SDL_Rect * rect, Uint32 color);
+int SDL_FillRects(SDL_Surface * dst, const SDL_Rect * rects, int count, Uint32 color);
+int SDL_UpperBlit(SDL_Surface * src, const SDL_Rect * srcrect, SDL_Surface * dst, SDL_Rect * dstrect);
+int SDL_LowerBlit(SDL_Surface * src, SDL_Rect * srcrect, SDL_Surface * dst, SDL_Rect * dstrect);
+int SDL_SoftStretch(SDL_Surface * src, const SDL_Rect * srcrect, SDL_Surface * dst, const SDL_Rect * dstrect);
+int SDL_UpperBlitScaled(SDL_Surface * src, const SDL_Rect * srcrect, SDL_Surface * dst, SDL_Rect * dstrect);
+int SDL_LowerBlitScaled(SDL_Surface * src, SDL_Rect * srcrect, SDL_Surface * dst, SDL_Rect * dstrect);
+
+SDL_Window *SDL_GetMouseFocus(void);
+Uint32 SDL_GetMouseState(int *x, int *y);
+Uint32 SDL_GetRelativeMouseState(int *x, int *y);
+void SDL_WarpMouseInWindow(SDL_Window * window, int x, int y);
+int SDL_SetRelativeMouseMode(SDL_bool enabled);
+SDL_bool SDL_GetRelativeMouseMode(void);
+SDL_Cursor *SDL_CreateCursor(const Uint8 * data, const Uint8 * mask, int w, int h, int hot_x, int hot_y);
+SDL_Cursor *SDL_CreateColorCursor(SDL_Surface *surface, int hot_x, int hot_y);
+SDL_Cursor *SDL_CreateSystemCursor(SDL_SystemCursor id);
+void SDL_SetCursor(SDL_Cursor * cursor);
+SDL_Cursor *SDL_GetCursor(void);
+SDL_Cursor *SDL_GetDefaultCursor(void);
+void SDL_FreeCursor(SDL_Cursor * cursor);
+int SDL_ShowCursor(int toggle);
+
+const char *SDL_GetPixelFormatName(Uint32 format);
+SDL_bool SDL_PixelFormatEnumToMasks(Uint32 format, int *bpp, Uint32 * Rmask, Uint32 * Gmask, Uint32 * Bmask, Uint32 * Amask);
+Uint32 SDL_MasksToPixelFormatEnum(int bpp, Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask);
+SDL_PixelFormat *SDL_AllocFormat(Uint32 pixel_format);
+void SDL_FreeFormat(SDL_PixelFormat *format);
+SDL_Palette *SDL_AllocPalette(int ncolors);
+int SDL_SetPixelFormatPalette(SDL_PixelFormat * format, SDL_Palette *palette);
+int SDL_SetPaletteColors(SDL_Palette * palette, const SDL_Color * colors, int firstcolor, int ncolors);
+void SDL_FreePalette(SDL_Palette * palette);
+Uint32 SDL_MapRGB(const SDL_PixelFormat * format, Uint8 r, Uint8 g, Uint8 b);
+Uint32 SDL_MapRGBA(const SDL_PixelFormat * format, Uint8 r, Uint8 g, Uint8 b, Uint8 a);
+void SDL_GetRGB(Uint32 pixel, const SDL_PixelFormat * format, Uint8 * r, Uint8 * g, Uint8 * b);
+void SDL_GetRGBA(Uint32 pixel, const SDL_PixelFormat * format, Uint8 * r, Uint8 * g, Uint8 * b, Uint8 * a);
+void SDL_CalculateGammaRamp(float gamma, Uint16 * ramp);
+
+SDL_bool SDL_HasIntersection(const SDL_Rect * A, const SDL_Rect * B);
+SDL_bool SDL_IntersectRect(const SDL_Rect * A, const SDL_Rect * B, SDL_Rect * result);
+void SDL_UnionRect(const SDL_Rect * A, const SDL_Rect * B, SDL_Rect * result);
+SDL_bool SDL_EnclosePoints(const SDL_Point * points, int count, const SDL_Rect * clip, SDL_Rect * result);
+SDL_bool SDL_IntersectRectAndLine(const SDL_Rect * rect, int *X1, int *Y1, int *X2, int *Y2);
+
+SDL_bool SDL_GetWindowWMInfo(SDL_Window * window, SDL_SysWMinfo * info);
+
+int SDL_RecordGesture(SDL_TouchID touchId);
+int SDL_SaveAllDollarTemplates(SDL_RWops *dst);
+int SDL_SaveDollarTemplate(SDL_GestureID gestureId,SDL_RWops *dst);
+int SDL_LoadDollarTemplates(SDL_TouchID touchId, SDL_RWops *src);
+
+SDL_Window *SDL_CreateShapedWindow(const char *title,unsigned int x,unsigned int y,unsigned int w,unsigned int h,Uint32 flags);
+SDL_bool SDL_IsShapedWindow(const SDL_Window *window);
+int SDL_SetWindowShape(SDL_Window *window,SDL_Surface *shape,SDL_WindowShapeMode *shape_mode);
+int SDL_GetShapedWindowMode(SDL_Window *window,SDL_WindowShapeMode *shape_mode);
+
+int SDL_GL_LoadLibrary(const char *path);
+//void *SDL_GL_GetProcAddress(const char *proc);
+void SDL_GL_UnloadLibrary(void);
+SDL_bool SDL_GL_ExtensionSupported(const char *extension);
+void SDL_GL_ResetAttributes(void);
+int SDL_GL_SetAttribute(SDL_GLattr attr, int value);
+int SDL_GL_GetAttribute(SDL_GLattr attr, int *value);
+SDL_GLContext SDL_GL_CreateContext(SDL_Window *window);
+int SDL_GL_MakeCurrent(SDL_Window * window, SDL_GLContext context);
+SDL_Window* SDL_GL_GetCurrentWindow(void);
+SDL_GLContext SDL_GL_GetCurrentContext(void);
+void SDL_GL_GetDrawableSize(SDL_Window * window, int *w, int *h);
+int SDL_GL_SetSwapInterval(int interval);
+int SDL_GL_GetSwapInterval(void);
+void SDL_GL_SwapWindow(SDL_Window * window);
+void SDL_GL_DeleteContext(SDL_GLContext context);
+
+/* 2.0.4 */
+float SDL_sqrtf(float x);
+double SDL_tan(double x);
+float SDL_tanf(float x);
+int SDL_QueueAudio(SDL_AudioDeviceID dev, const void *data, Uint32 len);
+Uint32 SDL_GetQueuedAudioSize(SDL_AudioDeviceID dev);
+void SDL_ClearQueuedAudio(SDL_AudioDeviceID dev);
+SDL_bool SDL_HasAVX2(void);
+SDL_Joystick *SDL_JoystickFromInstanceID(SDL_JoystickID joyid);
+SDL_JoystickPowerLevel SDL_JoystickCurrentPowerLevel(SDL_Joystick * joystick);
+SDL_GameController SDL_GameControllerFromInstanceID(SDL_JoystickID joyid);
+SDL_bool SDL_RenderIsClipEnabled(SDL_Renderer * renderer);
+int SDL_GetDisplayDPI(int displayIndex, float * ddpi, float * hdpi, float * vdpi);
+int SDL_SetWindowHitTest(SDL_Window * window, SDL_HitTest callback, void *callback_data);
+SDL_Window *SDL_GetGrabbedWindow(void);
+int SDL_WarpMouseGlobal(int x, int y);
+int SDL_CaptureMouse(SDL_bool enabled);
+Uint32 SDL_GetGlobalMouseState(int *x, int *y);
+
+/* 2.06 */
+void SDL_MemoryBarrierReleaseFunction(void);
+void SDL_MemoryBarrierAcquireFunction(void);
+Uint32 SDL_DequeueAudio(SDL_AudioDeviceID dev, void *data, Uint32 len);
+SDL_BlendMode SDL_ComposeCustomBlendMode(SDL_BlendFactor srcColorFactor, SDL_BlendFactor dstColorFactor, SDL_BlendOperation colorOperation, SDL_BlendFactor srcAlphaFactor, SDL_BlendFactor dstAlphaFactor, SDL_BlendOperation alphaOperation);
+SDL_bool SDL_HasNEON(void);
+int SDL_GameControllerNumMappings(void);
+char *SDL_GameControllerMappingForIndex(int mapping_index);
+Uint16 SDL_GameControllerGetVendor(SDL_GameController * gamecontroller);
+Uint16 SDL_GameControllerGetProduct(SDL_GameController * gamecontroller);
+Uint16 SDL_GameControllerGetProductVersion(SDL_GameController * gamecontroller);
+SDL_bool SDL_GetHintBoolean(const char *name, SDL_bool default_value);
+Uint16 SDL_JoystickGetDeviceVendor(int device_index);
+Uint16 SDL_JoystickGetDeviceProduct(int device_index);
+Uint16 SDL_JoystickGetDeviceProductVersion(int device_index);
+SDL_JoystickType SDL_JoystickGetDeviceType(int device_index);
+SDL_JoystickID SDL_JoystickGetDeviceInstanceID(int device_index);
+Uint16 SDL_JoystickGetVendor(SDL_Joystick * joystick);
+Uint16 SDL_JoystickGetProduct(SDL_Joystick * joystick);
+Uint16 SDL_JoystickGetProductVersion(SDL_Joystick * joystick);
+SDL_JoystickType SDL_JoystickGetType(SDL_Joystick * joystick);
+SDL_bool SDL_JoystickGetAxisInitialState(SDL_Joystick * joystick,int axis, Sint16 *state);
+
+int SDL_GetDisplayUsableBounds(int displayIndex, SDL_Rect * rect);
+int SDL_GetWindowBordersSize(SDL_Window * window, int *top, int *left, int *bottom, int *right);
+void SDL_SetWindowResizable(SDL_Window * window, SDL_bool resizable);
+int SDL_SetWindowOpacity(SDL_Window * window, float opacity);
+int SDL_GetWindowOpacity(SDL_Window * window, float * out_opacity);
+int SDL_SetWindowModalFor(SDL_Window * modal_window, SDL_Window * parent_window);
+int SDL_SetWindowInputFocus(SDL_Window * window);
+
+SDL_Surface * SDL_CreateRGBSurfaceWithFormat(Uint32 flags, int width, int height, int depth, Uint32 format);
+SDL_Surface * SDL_CreateRGBSurfaceWithFormatFrom(void *pixels, int width, int height, int depth, int pitch, Uint32 format);
+SDL_Surface * SDL_DuplicateSurface(SDL_Surface * surface);
+
+int SDL_wcscmp(const wchar_t *str1, const wchar_t *str2);
+size_t SDL_utf8strlen(const char *str);
+
+void * SDL_LoadFile_RW(SDL_RWops * src, size_t *datasize, int freesrc);
+
+int SDL_RenderSetIntegerScale(SDL_Renderer * renderer, SDL_bool enable);
+SDL_bool SDL_RenderGetIntegerScale(SDL_Renderer * renderer);
+
+/* 2.0.7 */
+void SDL_LockJoysticks(void);
+void SDL_UnlockJoysticks(void);
+SDL_AudioStream * SDL_NewAudioStream(const SDL_AudioFormat src_format, const Uint8 src_channels, const SDL_AudioFormat dst_format, const Uint8 dst_channels, const int dst_rate);
+int SDL_AudioStreamPut(SDL_AudioStream *stream, const void *buf, int len);
+int SDL_AudioStreamGet(SDL_AudioStream *stream, void *buf, int len);
+int SDL_AudioStreamAvailable(SDL_AudioStream *stream);
+int SDL_AudioStreamFlush(SDL_AudioStream *stream);
+void SDL_AudioStreamClear(SDL_AudioStream *stream);
+void SDL_FreeAudioStream(SDL_AudioStream *stream);
+void SDL_GetMemoryFunctions(SDL_malloc_func *malloc_func, SDL_calloc_func *calloc_func, SDL_realloc_func *realloc_func, SDL_free_func *free_func);
+int SDL_SetMemoryFunctions(SDL_malloc_func malloc_func, SDL_calloc_func calloc_func, SDL_realloc_func realloc_func, SDL_free_func free_func);
+int SDL_GetNumAllocations(void);
+
+/* 2.0.8 */
+void *SDL_RenderGetMetalLayer(SDL_Renderer * renderer);
+void *SDL_RenderGetMetalCommandEncoder(SDL_Renderer * renderer);
+float SDL_acosf(float x);
+float SDL_asinf(float x);
+float SDL_atanf(float x);
+float SDL_atan2f(float x, float y);
+float SDL_ceilf(float x);
+float SDL_copysignf(float x, float y);
+float SDL_fabsf(float x);
+float SDL_floorf(float x);
+double SDL_fmod(double x, double y);
+float SDL_fmodf(float x, float y);
+float SDL_logf(float x);
+double SDL_log10(double x);
+float SDL_log10f(float x);
+float SDL_powf(float x, float y);
+float SDL_scalbnf(float x, int n);
+void SDL_SetYUVConversionMode(SDL_YUV_CONVERSION_MODE mode);
+SDL_YUV_CONVERSION_MODE SDL_GetYUVConversionMode(void);
+SDL_YUV_CONVERSION_MODE SDL_GetYUVConversionModeForResolution(int width, int height);
+
+/* 2.0.9 */
+SDL_bool SDL_HasAVX512F(void);
+char *SDL_GameControllerMappingForDeviceIndex(int joystick_index);
+int SDL_GameControllerGetPlayerIndex(SDL_GameController *gamecontroller);
+int SDL_GameControllerRumble(SDL_GameController *gamecontroller, Uint16 low_frequency_rumble, Uint16 high_frequency_rumble, Uint32 duration_ms);
+int SDL_JoystickGetDevicePlayerIndex(int device_index);
+int SDL_JoystickGetPlayerIndex(SDL_Joystick * joystick);
+int SDL_JoystickRumble(SDL_Joystick * joystick, Uint16 low_frequency_rumble, Uint16 high_frequency_rumble, Uint32 duration_ms);
+wchar_t *SDL_wcsdup(const wchar_t *wstr);
+double SDL_exp(double x);
+float SDL_expf(float x);
+SDL_bool SDL_HasColorKey(SDL_Surface * surface);
+SDL_bool SDL_IsTablet(void);
+SDL_Thread *SDL_CreateThreadWithStackSize(SDL_ThreadFunction fn, const char *name, const size_t stacksize, void *data);
+SDL_DisplayOrientation SDL_GetDisplayOrientation(int displayIndex);
+
+/* 2.0.10 */
+size_t SDL_SIMDGetAlignment(void);
+void * SDL_SIMDAlloc(const size_t len);
+void SDL_SIMDFree(void *ptr);
+int SDL_RenderDrawPointF(SDL_Renderer * renderer, float x, float y);
+int SDL_RenderDrawPointsF(SDL_Renderer * renderer, const SDL_FPoint * points, int count);
+int SDL_RenderDrawLineF(SDL_Renderer * renderer, float x1, float y1, float x2, float y2);
+int SDL_RenderDrawLinesF(SDL_Renderer * renderer, const SDL_FPoint * points, int count);
+int SDL_RenderDrawRectF(SDL_Renderer * renderer, const SDL_FRect * rect);
+int SDL_RenderDrawRectsF(SDL_Renderer * renderer, const SDL_FRect * rects, int count);
+int SDL_RenderFillRectF(SDL_Renderer * renderer, const SDL_FRect * rect);
+int SDL_RenderFillRectsF(SDL_Renderer * renderer, const SDL_FRect * rects, int count);
+int SDL_RenderCopyF(SDL_Renderer * renderer, SDL_Texture * texture, const SDL_Rect * srcrect, const SDL_FRect * dstrect);
+int SDL_RenderCopyExF(SDL_Renderer * renderer, SDL_Texture * texture, const SDL_Rect * srcrect, const SDL_FRect * dstrect, const double angle, const SDL_FPoint *center, const SDL_RendererFlip flip);
+int SDL_RenderFlush(SDL_Renderer * renderer);
+Sint64 SDL_RWsize(SDL_RWops *context);
+Sint64 SDL_RWseek(SDL_RWops *context, Sint64 offset, int whence);
+Sint64 SDL_RWtell(SDL_RWops *context);
+size_t SDL_RWread(SDL_RWops *context, void *ptr, size_t size, size_t maxnum);
+size_t SDL_RWwrite(SDL_RWops *context, const void *ptr, size_t size, size_t num);
+int SDL_RWclose(SDL_RWops *context);
+void *SDL_LoadFile(const char *file, size_t *datasize);
+SDL_TouchDeviceType SDL_GetTouchDeviceType(SDL_TouchID touchID);
+
+/* 2.0.12 */
+SDL_bool SDL_HasARMSIMD(void);
+SDL_GameControllerType SDL_GameControllerTypeForIndex(int joystick_index);
+SDL_GameController *SDL_GameControllerFromPlayerIndex(int player_index);
+SDL_GameControllerType SDL_GameControllerGetType(SDL_GameController *gamecontroller);
+void SDL_GameControllerSetPlayerIndex(SDL_GameController *gamecontroller, int player_index);
+SDL_Joystick *SDL_JoystickFromPlayerIndex(int player_index);
+SDL_Joystick *SDL_JoystickSetPlayerIndex(SDL_Joystick * joystick, int player_index);
+int SDL_SetTextureScaleMode(SDL_Texture * texture, SDL_ScaleMode scaleMode);
+int SDL_GetTextureScaleMode(SDL_Texture * texture, SDL_ScaleMode *scaleMode);
+int SDL_LockTextureToSurface(SDL_Texture *texture, const SDL_Rect *rect, SDL_Surface **surface);
+wchar_t *SDL_wcsstr(const wchar_t *haystack, const wchar_t *needle);
+int SDL_wcsncmp(const wchar_t *str1, const wchar_t *str2, size_t maxlen);
+char *SDL_strtokr(char *s1, const char *s2, char **saveptr);
+
+/* 2.0.13 - 2.0.14 */
+int SDL_isupper(int x);
+int SDL_islower(int x);
+int SDL_JoystickAttachVirtual(SDL_JoystickType type, int naxes, int nbuttons, int nhats);
+int SDL_JoystickDetachVirtual(int device_index);
+SDL_bool SDL_JoystickIsVirtual(int device_index);
+int SDL_JoystickSetVirtualAxis(SDL_Joystick * joystick, int axis, Sint16 value);
+int SDL_JoystickSetVirtualButton(SDL_Joystick * joystick, int button, Uint8 value);
+int SDL_JoystickSetVirtualHat(SDL_Joystick * joystick, int hat, Uint8 value);
+char *SDL_GetErrorMsg(char *errstr, int maxlen);
+void SDL_LockSensors(void);
+void SDL_UnlockSensors(void);
+void *SDL_Metal_GetLayer(SDL_MetalView view);
+void SDL_Metal_GetDrawableSize(SDL_Window* window, int *w, int *h);
+double SDL_trunc(double x);
+float SDL_truncf(float x);
+SDL_Locale * SDL_GetPreferredLocales(void);
+void * SDL_SIMDRealloc(void *mem, const size_t len);
+int SDL_OpenURL(const char *url);
+SDL_bool SDL_HasSurfaceRLE(SDL_Surface * surface);
+SDL_bool SDL_GameControllerHasLED(SDL_GameController *gamecontroller);
+int SDL_GameControllerSetLED(SDL_GameController *gamecontroller, Uint8 red, Uint8 green, Uint8 blue);
+SDL_bool SDL_JoystickHasLED(SDL_Joystick * joystick);
+int SDL_JoystickSetLED(SDL_Joystick * joystick, Uint8 red, Uint8 green, Uint8 blue);
+int SDL_GameControllerRumbleTriggers(SDL_GameController *gamecontroller, Uint16 left_rumble, Uint16 right_rumble, Uint32 duration_ms);
+int SDL_JoystickRumbleTriggers(SDL_Joystick * joystick, Uint16 left_rumble, Uint16 right_rumble, Uint32 duration_ms);
+SDL_bool SDL_GameControllerHasAxis(SDL_GameController *gamecontroller, SDL_GameControllerAxis axis);
+SDL_bool SDL_GameControllerHasButton(SDL_GameController *gamecontroller, SDL_GameControllerButton button);
+int SDL_GameControllerGetNumTouchpads(SDL_GameController *gamecontroller);
+int SDL_GameControllerGetNumTouchpadFingers(SDL_GameController *gamecontroller, int touchpad);
+int SDL_GameControllerGetTouchpadFinger(SDL_GameController *gamecontroller, int touchpad, int finger, Uint8 *state, float *x, float *y, float *pressure);
+/* add support TouchDevice */
+int SDL_GetNumTouchDevices(void);
+SDL_TouchID SDL_GetTouchDevice(int index);
+int SDL_GetNumTouchFingers(SDL_TouchID touchID);
+SDL_Finger * SDL_GetTouchFinger(SDL_TouchID touchID, int index);
+Uint32 SDL_crc32(Uint32 crc, const void *data, size_t len);
+const char * SDL_GameControllerGetSerial(SDL_GameController *gamecontroller);
+const char * SDL_JoystickGetSerial(SDL_Joystick *joystick);
+SDL_bool SDL_GameControllerHasSensor(SDL_GameController *gamecontroller, SDL_SensorType type);
+int SDL_GameControllerSetSensorEnabled(SDL_GameController *gamecontroller, SDL_SensorType type, SDL_bool enabled);
+SDL_bool SDL_GameControllerIsSensorEnabled(SDL_GameController *gamecontroller, SDL_SensorType type);
+int SDL_GameControllerGetSensorData(SDL_GameController *gamecontroller, SDL_SensorType type, float *data, int num_values);
+int SDL_wcscasecmp(const wchar_t *str1, const wchar_t *str2);
+int SDL_wcsncasecmp(const wchar_t *str1, const wchar_t *str2, size_t len);
+/* Add Altivec Swap */
+void SDL_CopyAndSwap16(APTR srcx, APTR destx, LONG units);
+void SDL_CopyAndSwap32(APTR srcx, APTR destx, LONG units);
+/* 2.0.16 */
+int SDL_UpdateNVTexture(SDL_Texture * texture, const SDL_Rect * rect, const Uint8 *Yplane, int Ypitch, const Uint8 *UVplane, int UVpitch);
+double SDL_round(double x);
+float SDL_roundf(float x);
+long SDL_lround(double x);
+long SDL_lroundf(float x);
+int SDL_SoftStretchLinear(SDL_Surface * src, const SDL_Rect * srcrect, SDL_Surface * dst, const SDL_Rect * dstrect);
+void SDL_SetWindowKeyboardGrab(SDL_Window * window, SDL_bool grabbed);
+void SDL_SetWindowMouseGrab(SDL_Window * window, SDL_bool grabbed);
+SDL_bool SDL_GetWindowKeyboardGrab(SDL_Window * window);
+SDL_bool SDL_GetWindowMouseGrab(SDL_Window * window);
+int SDL_isalpha(int x);
+int SDL_isalnum(int x);
+int SDL_isblank(int x);
+int SDL_iscntrl(int a);
+int SDL_isxdigit(int a);
+int SDL_ispunct(int a);
+int SDL_isprint(int a);
+int SDL_isgraph(int a);
+int SDL_GetAudioDeviceSpec(int index, int iscapture, SDL_AudioSpec *spec);
+void SDL_TLSCleanup(void);
+void SDL_SetWindowAlwaysOnTop(SDL_Window * window, SDL_bool on_top);
+int SDL_FlashWindow(SDL_Window * window, SDL_FlashOperation operation);
+int SDL_GameControllerSendEffect(SDL_GameController *gamecontroller, const void *data, int size);
+int SDL_JoystickSendEffect(SDL_Joystick *joystick, const void *data, int size);
+float SDL_GameControllerGetSensorDataRate(SDL_GameController *gamecontroller, SDL_SensorType type);
+/* 2.0.18 */
+int SDL_SetTextureUserData(SDL_Texture * texture, void *userdata);
+void * SDL_GetTextureUserData(SDL_Texture * texture);
+int SDL_RenderGeometry(SDL_Renderer *renderer, SDL_Texture *texture, const SDL_Vertex *vertices, int num_vertices, const int *indices, int num_indices);
+int SDL_RenderGeometryRaw(SDL_Renderer *renderer, SDL_Texture *texture, const float *xy, int xy_stride, const int *color, int color_stride, const float *uv, int uv_stride, int num_vertices, const void *indices, int num_indices, int size_indices);
+int SDL_RenderSetVSync(SDL_Renderer* renderer, int vsync);
+int SDL_vasprintf(char **strp, const char *fmt, va_list ap);
+void* SDL_GetWindowICCProfile(SDL_Window * window, size_t* size);
+Uint64 SDL_GetTicks64(void);
+const char* SDL_GameControllerGetAppleSFSymbolsNameForButton(SDL_GameController *gamecontroller, SDL_GameControllerButton button);
+const char* SDL_GameControllerGetAppleSFSymbolsNameForAxis(SDL_GameController *gamecontroller, SDL_GameControllerAxis axis);
+int SDL_hid_init(void);
+int SDL_hid_exit(void);
+Uint32 SDL_hid_device_change_count(void);
+SDL_hid_device_info * SDL_hid_enumerate(unsigned short vendor_id, unsigned short product_id);
+void SDL_hid_free_enumeration(SDL_hid_device_info *devs);
+SDL_hid_device * SDL_hid_open(unsigned short vendor_id, unsigned short product_id, const wchar_t *serial_number);
+SDL_hid_device * SDL_hid_open_path(const char *path, int bExclusive);
+int SDL_hid_write(SDL_hid_device *dev, const unsigned char *data, size_t length);
+int SDL_hid_read_timeout(SDL_hid_device *dev, unsigned char *data, size_t length, int milliseconds);
+int SDL_hid_read(SDL_hid_device *dev, unsigned char *data, size_t length);
+int SDL_hid_set_nonblocking(SDL_hid_device *dev, int nonblock);
+int SDL_hid_send_feature_report(SDL_hid_device *dev, const unsigned char *data, size_t length);
+int SDL_hid_get_feature_report(SDL_hid_device *dev, unsigned char *data, size_t length);
+void SDL_hid_close(SDL_hid_device *dev);
+int SDL_hid_get_manufacturer_string(SDL_hid_device *dev, wchar_t *string, size_t maxlen);
+int SDL_hid_get_product_string(SDL_hid_device *dev, wchar_t *string, size_t maxlen);
+int SDL_hid_get_serial_number_string(SDL_hid_device *dev, wchar_t *string, size_t maxlen);
+int SDL_hid_get_indexed_string(SDL_hid_device *dev, int string_index, wchar_t *string, size_t maxlen);
+int SDL_SetWindowMouseRect(SDL_Window * window, const SDL_Rect * rect);
+const SDL_Rect * SDL_GetWindowMouseRect(SDL_Window * window);
+void SDL_RenderWindowToLogical(SDL_Renderer * renderer, int windowX, int windowY, float *logicalX, float *logicalY);
+void SDL_RenderLogicalToWindow(SDL_Renderer * renderer, float logicalX, float logicalY, int *windowX, int *windowY);
+SDL_bool SDL_JoystickHasRumble(SDL_Joystick *joystick);
+SDL_bool SDL_JoystickHasRumbleTriggers(SDL_Joystick *joystick);
+SDL_bool SDL_GameControllerHasRumble(SDL_GameController *gamecontroller);
+SDL_bool SDL_GameControllerHasRumbleTriggers(SDL_GameController *gamecontroller);
+void SDL_hid_ble_scan(SDL_bool active);
+int SDL_PremultiplyAlpha(int width, int height, Uint32 src_format, const void * src, int src_pitch, Uint32 dst_format, void * dst, int dst_pitch);
+
+char *SDL_getenv(const char *name);
+int SDL_setenv(const char *name, const char *value, int overwrite);
+
+/* 2.0.22 */
+const char* SDL_GetTouchName(int index);
+void SDL_ClearComposition(void);
+SDL_bool SDL_IsTextInputShown(void);
+SDL_bool SDL_HasIntersectionF(const SDL_FRect * A, const SDL_FRect * B);
+SDL_bool SDL_IntersectFRect(const SDL_FRect * A, const SDL_FRect * B, SDL_FRect * result);
+void SDL_UnionFRect(const SDL_FRect * A, const SDL_FRect * B, SDL_FRect * result);
+SDL_bool SDL_EncloseFPoints(const SDL_FPoint * points, int count, const SDL_FRect * clip, SDL_FRect * result);
+SDL_bool SDL_IntersectFRectAndLine(const SDL_FRect * rect, float *X1, float *Y1, float *X2, float *Y2);
+SDL_Window * SDL_RenderGetWindow(SDL_Renderer *renderer);
+/* 2.24.0 */
+void * SDL_bsearch(const void *key, const void *base, size_t nmemb, size_t size, SDL_CompareCallback compare);
+const char * SDL_GameControllerPathForIndex(int joystick_index);
+const char * SDL_GameControllerPath(SDL_GameController *gamecontroller);
+const char * SDL_JoystickPathForIndex(int device_index);
+const char * SDL_JoystickPath(SDL_Joystick *joystick);
+int SDL_JoystickAttachVirtualEx(const SDL_VirtualJoystickDesc *desc);
+SDL_bool SDL_HasLSX(void);
+SDL_bool SDL_HasLASX(void);
+Uint16 SDL_GameControllerGetFirmwareVersion(SDL_GameController *gamecontroller);
+void SDL_GUIDToString(SDL_GUID guid, char *pszGUID, int cbGUID);
+SDL_GUID SDL_GUIDFromString(const char *pchGUID);
+Uint16 SDL_JoystickGetFirmwareVersion(SDL_Joystick *joystick);
+int SDL_GetOriginalMemoryFunctions(SDL_malloc_func *malloc_func, SDL_calloc_func *calloc_func, SDL_realloc_func *realloc_func, SDL_free_func *free_func);
+void SDL_ResetKeyboard(void);
+int SDL_GetPointDisplayIndex(const SDL_Point * point);
+int SDL_GetRectDisplayIndex(const SDL_Rect * rect);
+SDL_bool SDL_ResetHint(const char *name);
+Uint16 SDL_crc16(Uint16 crc, const void *data, size_t len);
+int SDL_GetDefaultAudioInfo(char **name, SDL_AudioSpec *spec, int iscapture);
+/* 2.26.0 */
+void SDL_GetWindowSizeInPixels(SDL_Window * window, int *w, int *h);
+void SDL_GetJoystickGUIDInfo(SDL_JoystickGUID guid, Uint16 *vendor, Uint16 *product, Uint16 *version, Uint16 *crc16);
+int SDL_SetPrimarySelectionText(const char *text);
+char * SDL_GetPrimarySelectionText(void);
+SDL_bool SDL_HasPrimarySelectionText(void);
+void SDL_ResetHints(void);
+char *SDL_strcasestr(const char *haystack, const char *needle);
+/* 2.28.0 */
+SDL_bool SDL_HasWindowSurface(SDL_Window *window);
+int SDL_DestroyWindowSurface(SDL_Window *window);
+/* */
+Uint64 SDL_GameControllerGetSteamHandle(SDL_GameController *gamecontroller);
+#endif
+
+#endif /* CLIB_SDL2_PROTOS_H */
diff -ruN SDL2-2.32.8/src/core/morphos/sdk/fd/sdl2_lib.fd SDL2-2.32.8.aros/src/core/morphos/sdk/fd/sdl2_lib.fd
--- SDL2-2.32.8/src/core/morphos/sdk/fd/sdl2_lib.fd	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/core/morphos/sdk/fd/sdl2_lib.fd	2025-07-27 14:24:13.180841322 +0000
@@ -0,0 +1,806 @@
+##base _SDL2Base
+##bias 30
+* The SDL interface
+##public
+* general
+SDL_InitTGL(glcptr,tglptr)(base,sysv)
+SDL_SetExitPointer(exitfunc)(base,sysv)
+SDL_VSetError(fmt,va_list)(sysv,r12base)
+SDL_GetPlatform()(sysv,r12base)
+SDL_Init(flags)(sysv,r12base)
+SDL_InitSubSystem(flags)(sysv,r12base)
+SDL_QuitSubSystem(flags)(sysv,r12base)
+SDL_WasInit(flags)(sysv,r12base)
+SDL_Quit()(sysv,r12base)
+SDL_SetMainReady()(sysv,r12base)
+SDL_malloc(size)(sysv,r12base)
+SDL_calloc(nmemb,size)(sysv,r12base)
+SDL_realloc(mem,size)(sysv,r12base)
+SDL_free(mem)(sysv,r12base)
+SDL_qsort(base,nmemb,size,compare)(sysv,r12base)
+SDL_abs(x)(sysv,r12base)
+SDL_isdigit(x)(sysv,r12base)
+SDL_isspace(x)(sysv,r12base)
+SDL_toupper(x)(sysv,r12base)
+SDL_tolower(x)(sysv,r12base)
+SDL_memset(dst,c,len)(sysv,r12base)
+SDL_memcpy(dst,src,len)(sysv,r12base)
+SDL_memmove(dst,src,len)(sysv,r12base)
+SDL_memcmp(s1,s2,len)(sysv,r12base)
+SDL_wcslen(wstr)(sysv,r12base)
+SDL_wcslcpy(dst,src,maxlen)(sysv,r12base)
+SDL_wcslcat(dst,src,maxlen)(sysv,r12base)
+SDL_strlen(str)(sysv,r12base)
+SDL_strlcpy(dst,src,maxlen)(sysv,r12base)
+SDL_utf8strlcpy(dst,src,dst_bytes)(sysv,r12base)
+SDL_strlcat(dst,src,maxlen)(sysv,r12base)
+SDL_strdup(str)(sysv,r12base)
+SDL_strrev(str)(sysv,r12base)
+SDL_strupr(str)(sysv,r12base)
+SDL_strlwr(str)(sysv,r12base)
+SDL_strchr(str,c)(sysv,r12base)
+SDL_strrchr(str,c)(sysv,r12base)
+SDL_strstr(haystack,needle)(sysv,r12base)
+SDL_itoa(value,str,radix)(sysv,r12base)
+SDL_uitoa(value,str,radix)(sysv,r12base)
+SDL_ltoa(value,str,radix)(sysv,r12base)
+SDL_ultoa(value,str,radix)(sysv,r12base)
+SDL_lltoa(Sint64value,str,radix)(sysv,r12base)
+SDL_ulltoa(value,str,radix)(sysv,r12base)
+SDL_atoi(str)(sysv,r12base)
+SDL_atof(str)(sysv,r12base)
+SDL_strtol(str,endp,base)(sysv,r12base)
+SDL_strtoul(str,endp,base)(sysv,r12base)
+SDL_strtoll(str,endp,base)(sysv,r12base)
+SDL_strtoull(str,endp,base)(sysv,r12base)
+SDL_strtod(str,endp)(sysv,r12base)
+SDL_strcmp(str1,str2)(sysv,r12base)
+SDL_strncmp(str1,str2,maxlen)(sysv,r12base)
+SDL_strcasecmp(str1,str2)(sysv,r12base)
+SDL_strncasecmp(str1,str2,len)(sysv,r12base)
+SDL_vsscanf(text,fmt,ap)(sysv,r12base)
+SDL_vsnprintf(text,maxlen,fmt,ap)(sysv,r12base)
+SDL_acos(x)(sysv,r12base)
+SDL_asin(x)(sysv,r12base)
+SDL_atan(x)(sysv,r12base)
+SDL_atan2(x,y)(sysv,r12base)
+SDL_ceil(x)(sysv,r12base)
+SDL_copysign(x,y)(sysv,r12base)
+SDL_cos(x)(sysv,r12base)
+SDL_cosf(x)(sysv,r12base)
+SDL_fabs(x)(sysv,r12base)
+SDL_floor(x)(sysv,r12base)
+SDL_log(x)(sysv,r12base)
+SDL_pow(x,y)(sysv,r12base)
+SDL_scalbn(x,n)(sysv,r12base)
+SDL_sin(x)(sysv,r12base)
+SDL_sinf(x)(sysv,r12base)
+SDL_sqrt(x)(sysv,r12base)
+SDL_iconv_open(tocode,fromcode)(sysv,r12base)
+SDL_iconv_close(cd)(sysv,r12base)
+SDL_iconv(cd,inbuf,inbytesleft,outbuf,outbytesleft)(sysv,r12base)
+SDL_iconv_string(tocode,fromcode,inbuf,inbytesleft)(sysv,r12base)
+SDL_ReportAssertion(a,b,c,d)(sysv,r12base)
+SDL_SetAssertionHandler(handler,userdata)(sysv,r12base)
+SDL_GetDefaultAssertionHandler()(sysv,r12base)
+SDL_GetAssertionHandler(puserdata)(sysv,r12base)
+SDL_GetAssertionReport()(sysv,r12base)
+SDL_ResetAssertionReport()(sysv,r12base)
+SDL_AtomicTryLock(lock)(sysv,r12base)
+SDL_AtomicLock(lock)(sysv,r12base)
+SDL_AtomicUnlock(lock)(sysv,r12base)
+SDL_AtomicCAS(a,oldval,newval)(sysv,r12base)
+SDL_AtomicSet(a,v)(sysv,r12base)
+SDL_AtomicGet(a)(sysv,r12base)
+SDL_AtomicAdd(a,v)(sysv,r12base)
+SDL_AtomicCASPtr(a,oldval,newval)(sysv,r12base)
+SDL_AtomicSetPtr(a,voidv)(sysv,r12base)
+SDL_AtomicGetPtr(a)(sysv,r12base)
+SDL_GetNumAudioDrivers()(sysv,r12base)
+SDL_GetAudioDriver(index)(sysv,r12base)
+SDL_AudioInit(driver_name)(sysv,r12base)
+SDL_AudioQuit()(sysv,r12base)
+SDL_GetCurrentAudioDriver()(sysv,r12base)
+SDL_OpenAudio(desired,obtained)(sysv,r12base)
+SDL_GetNumAudioDevices(iscapture)(sysv,r12base)
+SDL_GetAudioDeviceName(index,iscapture)(sysv,r12base)
+SDL_OpenAudioDevice(device,iscapture,desired,obtained,allowed_changes)(sysv,r12base)
+SDL_GetAudioStatus()(sysv,r12base)
+SDL_GetAudioDeviceStatus(dev)(sysv,r12base)
+SDL_PauseAudio(pause_on)(sysv,r12base)
+SDL_PauseAudioDevice(dev,pause_on)(sysv,r12base)
+SDL_LoadWAV_RW(src,freesrc,spec,audio_buf,audio_len)(sysv,r12base)
+SDL_FreeWAV(audio_buf)(sysv,r12base)
+SDL_BuildAudioCVT(cvt,src_format,src_channels,src_rate,dst_format,dst_channels,dst_rate)(sysv,r12base)
+SDL_ConvertAudio(cvt)(sysv,r12base)
+SDL_MixAudio(dst,src,len,volume)(sysv,r12base)
+SDL_MixAudioFormat(dst,src,format,len,volume)(sysv,r12base)
+SDL_LockAudio()(sysv,r12base)
+SDL_LockAudioDevice(SDL_AudioDeviceIDdev)(sysv,r12base)
+SDL_UnlockAudio()(sysv,r12base)
+SDL_UnlockAudioDevice(SDL_AudioDeviceIDdev)(sysv,r12base)
+SDL_CloseAudio()(sysv,r12base)
+SDL_CloseAudioDevice(SDL_AudioDeviceIDdev)(sysv,r12base)
+SDL_SetClipboardText(text)(sysv,r12base)
+SDL_GetClipboardText()(sysv,r12base)
+SDL_HasClipboardText()(sysv,r12base)
+SDL_GetCPUCount()(sysv,r12base)
+SDL_GetCPUCacheLineSize()(sysv,r12base)
+SDL_HasRDTSC()(sysv,r12base)
+SDL_HasAltiVec()(sysv,r12base)
+SDL_HasMMX()(sysv,r12base)
+SDL_Has3DNow()(sysv,r12base)
+SDL_HasSSE()(sysv,r12base)
+SDL_HasSSE2()(sysv,r12base)
+SDL_HasSSE3()(sysv,r12base)
+SDL_HasSSE41()(sysv,r12base)
+SDL_HasSSE42()(sysv,r12base)
+SDL_HasAVX()(sysv,r12base)
+SDL_GetSystemRAM()(sysv,r12base)
+SDL_GetError()(sysv,r12base)
+SDL_ClearError()(sysv,r12base)
+SDL_Error(code)(sysv,r12base)
+SDL_PumpEvents()(sysv,r12base)
+SDL_PeepEvents(events,numevents,SDL_eventactionaction,minType,maxType)(sysv,r12base)
+SDL_HasEvent(type)(sysv,r12base)
+SDL_HasEvents(minType,maxType)(sysv,r12base)
+SDL_FlushEvent(type)(sysv,r12base)
+SDL_FlushEvents(minType,maxType)(sysv,r12base)
+SDL_PollEvent(event)(sysv,r12base)
+SDL_WaitEvent(event)(sysv,r12base)
+SDL_WaitEventTimeout(event,timeout)(sysv,r12base)
+SDL_PushEvent(event)(sysv,r12base)
+SDL_SetEventFilter(filter,userdata)(sysv,r12base)
+SDL_GetEventFilter(filter,userdata)(sysv,r12base)
+SDL_AddEventWatch(filter,userdata)(sysv,r12base)
+SDL_DelEventWatch(filter,userdata)(sysv,r12base)
+SDL_FilterEvents(filter,userdata)(sysv,r12base)
+SDL_EventState(type,state)(sysv,r12base)
+SDL_RegisterEvents(numevents)(sysv,r12base)
+SDL_GetBasePath()(sysv,r12base)
+SDL_GetPrefPath(org,app)(sysv,r12base)
+SDL_NumJoysticks()(sysv,r12base)
+SDL_JoystickNameForIndex(device_index)(sysv,r12base)
+SDL_JoystickOpen(device_index)(sysv,r12base)
+SDL_JoystickName(joystick)(sysv,r12base)
+SDL_JoystickGetDeviceGUID(device_index)(sysv,r12base)
+SDL_JoystickGetGUID(joystick)(sysv,r12base)
+SDL_JoystickGetGUIDString(guid,pszGUID,cbGUID)(sysv,r12base)
+SDL_JoystickGetGUIDFromString(pchGUID)(sysv,r12base)
+SDL_JoystickGetAttached(joystick)(sysv,r12base)
+SDL_JoystickInstanceID(joystick)(sysv,r12base)
+SDL_JoystickNumAxes(joystick)(sysv,r12base)
+SDL_JoystickNumBalls(joystick)(sysv,r12base)
+SDL_JoystickNumHats(joystick)(sysv,r12base)
+SDL_JoystickNumButtons(joystick)(sysv,r12base)
+SDL_JoystickUpdate()(sysv,r12base)
+SDL_JoystickEventState(state)(sysv,r12base)
+SDL_JoystickGetAxis(joystick,axis)(sysv,r12base)
+SDL_JoystickGetHat(joystick,hat)(sysv,r12base)
+SDL_JoystickGetBall(joystick,ball,dx,dy)(sysv,r12base)
+SDL_JoystickGetButton(joystick,button)(sysv,r12base)
+SDL_JoystickClose(joystick)(sysv,r12base)
+SDL_GameControllerAddMappingsFromRW(rw,freerw)(sysv,r12base)
+SDL_GameControllerAddMapping(mappingString)(sysv,r12base)
+SDL_GameControllerMappingForGUID(guid)(sysv,r12base)
+SDL_GameControllerMapping(gamecontroller)(sysv,r12base)
+SDL_IsGameController(joystick_index)(sysv,r12base)
+SDL_GameControllerNameForIndex(joystick_index)(sysv,r12base)
+SDL_GameControllerOpen(joystick_index)(sysv,r12base)
+SDL_GameControllerName(gamecontroller)(sysv,r12base)
+SDL_GameControllerGetAttached(gamecontroller)(sysv,r12base)
+SDL_GameControllerGetJoystick(gamecontroller)(sysv,r12base)
+SDL_GameControllerEventState(state)(sysv,r12base)
+SDL_GameControllerUpdate()(sysv,r12base)
+SDL_GameControllerGetAxisFromString(pchString)(sysv,r12base)
+SDL_GameControllerGetStringForAxis(axis)(sysv,r12base)
+SDL_GameControllerGetBindForAxis(gamecontroller,axis)(sysv,r12base)
+SDL_GameControllerGetAxis(gamecontroller,axis)(sysv,r12base)
+SDL_GameControllerGetButtonFromString(pchString)(sysv,r12base)
+SDL_GameControllerGetStringForButton(button)(sysv,r12base)
+SDL_GameControllerGetBindForButton(gamecontroller,button)(sysv,r12base)
+SDL_GameControllerGetButton(gamecontroller,button)(sysv,r12base)
+SDL_GameControllerClose(gamecontroller)(sysv,r12base)
+SDL_SetHintWithPriority(name,value,priority)(sysv,r12base)
+SDL_SetHint(name,value)(sysv,r12base)
+SDL_GetHint(name)(sysv,r12base)
+SDL_AddHintCallback(name,callback,userdata)(sysv,r12base)
+SDL_DelHintCallback(name,callback,userdata)(sysv,r12base)
+SDL_ClearHints()(sysv,r12base)
+SDL_LoadObject(sofile)(sysv,r12base)
+SDL_LoadFunction(handle,name)(sysv,r12base)
+SDL_UnloadObject(handle)(sysv,r12base)
+SDL_LogSetAllPriority(priority)(sysv,r12base)
+SDL_LogSetPriority(category,priority)(sysv,r12base)
+SDL_LogGetPriority(category)(sysv,r12base)
+SDL_LogResetPriorities()(sysv,r12base)
+SDL_LogMessageV(category,priority,fmt,ap)(sysv,r12base)
+SDL_LogGetOutputFunction(callback,userdata)(sysv,r12base)
+SDL_LogSetOutputFunction(callback,userdata)(sysv,r12base)
+SDL_ShowMessageBox(messageboxdata,buttonid)(sysv,r12base)
+SDL_ShowSimpleMessageBox(flags,title,message,window)(sysv,r12base)
+SDL_CreateMutex()(sysv,r12base)
+SDL_LockMutex(mutex)(sysv,r12base)
+SDL_TryLockMutex(mutex)(sysv,r12base)
+SDL_UnlockMutex(mutex)(sysv,r12base)
+SDL_DestroyMutex(mutex)(sysv,r12base)
+SDL_CreateSemaphore(initial_value)(sysv,r12base)
+SDL_DestroySemaphore(sem)(sysv,r12base)
+SDL_SemWait(sem)(sysv,r12base)
+SDL_SemTryWait(sem)(sysv,r12base)
+SDL_SemWaitTimeout(sem,ms)(sysv,r12base)
+SDL_SemPost(sem)(sysv,r12base)
+SDL_SemValue(sem)(sysv,r12base)
+SDL_CreateCond()(sysv,r12base)
+SDL_DestroyCond(cond)(sysv,r12base)
+SDL_CondSignal(cond)(sysv,r12base)
+SDL_CondBroadcast(cond)(sysv,r12base)
+SDL_CondWait(cond,mutex)(sysv,r12base)
+SDL_CondWaitTimeout(cond,mutex,ms)(sysv,r12base)
+SDL_GetPowerInfo(secs,pct)(sysv,r12base)
+SDL_GetNumRenderDrivers()(sysv,r12base)
+SDL_GetRenderDriverInfo(index,info)(sysv,r12base)
+SDL_CreateWindowAndRenderer(width,height,window_flags,window,renderer)(sysv,r12base)
+SDL_CreateRenderer(window,index,flags)(sysv,r12base)
+SDL_CreateSoftwareRenderer(surface)(sysv,r12base)
+SDL_GetRenderer(window)(sysv,r12base)
+SDL_GetRendererInfo(renderer,info)(sysv,r12base)
+SDL_GetRendererOutputSize(renderer,w,h)(sysv,r12base)
+SDL_CreateTexture(renderer,format,access,w,h)(sysv,r12base)
+SDL_CreateTextureFromSurface(renderer,surface)(sysv,r12base)
+SDL_QueryTexture(texture,format,access,w,h)(sysv,r12base)
+SDL_SetTextureColorMod(texture,r,g,b)(sysv,r12base)
+SDL_GetTextureColorMod(texture,r,g,b)(sysv,r12base)
+SDL_SetTextureAlphaMod(texture,alpha)(sysv,r12base)
+SDL_GetTextureAlphaMod(texture,alpha)(sysv,r12base)
+SDL_SetTextureBlendMode(texture,blendMode)(sysv,r12base)
+SDL_GetTextureBlendMode(texture,blendMode)(sysv,r12base)
+SDL_UpdateTexture(texture,rect,pixels,pitch)(sysv,r12base)
+SDL_UpdateYUVTexture(texture,rect,Yplane,Ypitch,Uplane,Upitch,Vplane,Vpitch)(sysv,r12base)
+SDL_LockTexture(texture,rect,pixels,pitch)(sysv,r12base)
+SDL_UnlockTexture(texture)(sysv,r12base)
+SDL_RenderTargetSupported(renderer)(sysv,r12base)
+SDL_SetRenderTarget(renderer,texture)(sysv,r12base)
+SDL_GetRenderTarget(renderer)(sysv,r12base)
+SDL_RenderSetLogicalSize(renderer,w,h)(sysv,r12base)
+SDL_RenderGetLogicalSize(renderer,w,h)(sysv,r12base)
+SDL_RenderSetViewport(renderer,rect)(sysv,r12base)
+SDL_RenderGetViewport(renderer,rect)(sysv,r12base)
+SDL_RenderSetClipRect(renderer,rect)(sysv,r12base)
+SDL_RenderGetClipRect(renderer,rect)(sysv,r12base)
+SDL_RenderSetScale(renderer,scaleX,scaleY)(sysv,r12base)
+SDL_RenderGetScale(renderer,scaleX,scaleY)(sysv,r12base)
+SDL_SetRenderDrawColor(renderer,r,g,b,a)(sysv,r12base)
+SDL_GetRenderDrawColor(renderer,r,g,b,a)(sysv,r12base)
+SDL_SetRenderDrawBlendMode(renderer,blendMode)(sysv,r12base)
+SDL_GetRenderDrawBlendMode(renderer,blendMode)(sysv,r12base)
+SDL_RenderClear(renderer)(sysv,r12base)
+SDL_RenderDrawPoint(renderer,x,y)(sysv,r12base)
+SDL_RenderDrawPoints(renderer,points,count)(sysv,r12base)
+SDL_RenderDrawLine(renderer,x1,y1,x2,y2)(sysv,r12base)
+SDL_RenderDrawLines(renderer,points,count)(sysv,r12base)
+SDL_RenderDrawRect(renderer,rect)(sysv,r12base)
+SDL_RenderDrawRects(renderer,rects,count)(sysv,r12base)
+SDL_RenderFillRect(renderer,rect)(sysv,r12base)
+SDL_RenderFillRects(renderer,rects,count)(sysv,r12base)
+SDL_RenderCopy(renderer,texture,srcrect,dstrect)(sysv,r12base)
+SDL_RenderCopyEx(renderer,texture,srcrect,dstrect,angle,center,flip)(sysv,r12base)
+SDL_RenderReadPixels(renderer,rect,format,pixels,pitch)(sysv,r12base)
+SDL_RenderPresent(renderer)(sysv,r12base)
+SDL_DestroyTexture(texture)(sysv,r12base)
+SDL_DestroyRenderer(renderer)(sysv,r12base)
+SDL_GL_BindTexture(texture,texw,texh)(sysv,r12base)
+SDL_GL_UnbindTexture(texture)(sysv,r12base)
+SDL_RWFromFile(file,mode)(sysv,r12base)
+SDL_RWFromFP_clib(fp,autoclose,size,seek,read,write,close)(sysv,r12base)
+SDL_RWFromMem(mem,size)(sysv,r12base)
+SDL_RWFromConstMem(mem,size)(sysv,r12base)
+SDL_AllocRW()(sysv,r12base)
+SDL_FreeRW(area)(sysv,r12base)
+SDL_ReadU8(src)(sysv,r12base)
+SDL_ReadLE16(src)(sysv,r12base)
+SDL_ReadBE16(src)(sysv,r12base)
+SDL_ReadLE32(src)(sysv,r12base)
+SDL_ReadBE32(src)(sysv,r12base)
+SDL_ReadLE64(src)(sysv,r12base)
+SDL_ReadBE64(src)(sysv,r12base)
+SDL_WriteU8(dst,svalue)(sysv,r12base)
+SDL_WriteLE16(dst,value)(sysv,r12base)
+SDL_WriteBE16(dst,value)(sysv,r12base)
+SDL_WriteLE32(dst,value)(sysv,r12base)
+SDL_WriteBE32(dst,value)(sysv,r12base)
+SDL_WriteLE64(dst,value)(sysv,r12base)
+SDL_WriteBE64(dst,value)(sysv,r12base)
+SDL_CreateThread(fn,name,data)(sysv,r12base)
+SDL_GetThreadName(thread)(sysv,r12base)
+SDL_ThreadID()(sysv,r12base)
+SDL_GetThreadID(thread)(sysv,r12base)
+SDL_SetThreadPriority(priority)(sysv,r12base)
+SDL_WaitThread(thread,status)(sysv,r12base)
+SDL_DetachThread(thread)(sysv,r12base)
+SDL_TLSCreate()(sysv,r12base)
+SDL_TLSGet(id)(sysv,r12base)
+SDL_TLSSet(id,value,destructor)(sysv,r12base)
+SDL_GetTicks()(sysv,r12base)
+SDL_GetPerformanceCounter()(sysv,r12base)
+SDL_GetPerformanceFrequency()(sysv,r12base)
+SDL_Delay(ms)(sysv,r12base)
+SDL_AddTimer(interval,callback,param)(sysv,r12base)
+SDL_RemoveTimer(id)(sysv,r12base)
+SDL_GetVersion(ver)(sysv,r12base)
+SDL_GetRevision()(sysv,r12base)
+SDL_GetRevisionNumber()(sysv,r12base)
+SDL_GetNumVideoDrivers()(sysv,r12base)
+SDL_GetVideoDriver(index)(sysv,r12base)
+SDL_VideoInit(driver_name)(sysv,r12base)
+SDL_VideoQuit()(sysv,r12base)
+SDL_GetCurrentVideoDriver()(sysv,r12base)
+SDL_GetNumVideoDisplays()(sysv,r12base)
+SDL_GetDisplayName(displayIndex)(sysv,r12base)
+SDL_GetDisplayBounds(displayIndex,rect)(sysv,r12base)
+SDL_GetNumDisplayModes(displayIndex)(sysv,r12base)
+SDL_GetDisplayMode(displayIndex,modeIndex,mode)(sysv,r12base)
+SDL_GetDesktopDisplayMode(displayIndex,mode)(sysv,r12base)
+SDL_GetCurrentDisplayMode(displayIndex,mode)(sysv,r12base)
+SDL_GetClosestDisplayMode(displayIndex,mode,closest)(sysv,r12base)
+SDL_GetWindowDisplayIndex(window)(sysv,r12base)
+SDL_SetWindowDisplayMode(window,SDL_DisplayModemode)(sysv,r12base)
+SDL_GetWindowDisplayMode(window,SDL_DisplayModemode)(sysv,r12base)
+SDL_GetWindowPixelFormat(window)(sysv,r12base)
+SDL_CreateWindow(title,x,y,w,h,flags)(sysv,r12base)
+SDL_CreateWindowFrom(data)(sysv,r12base)
+SDL_GetWindowID(window)(sysv,r12base)
+SDL_GetWindowFromID(id)(sysv,r12base)
+SDL_GetWindowFlags(window)(sysv,r12base)
+SDL_SetWindowTitle(window,title)(sysv,r12base)
+SDL_GetWindowTitle(window)(sysv,r12base)
+SDL_SetWindowIcon(window,icon)(sysv,r12base)
+SDL_SetWindowData(window,name,userdata)(sysv,r12base)
+SDL_GetWindowData(window,name)(sysv,r12base)
+SDL_SetWindowPosition(window,x,y)(sysv,r12base)
+SDL_GetWindowPosition(window,x,y)(sysv,r12base)
+SDL_SetWindowSize(window,w,h)(sysv,r12base)
+SDL_GetWindowSize(window,w,h)(sysv,r12base)
+SDL_SetWindowMinimumSize(window,min_w,min_h)(sysv,r12base)
+SDL_GetWindowMinimumSize(window,w,h)(sysv,r12base)
+SDL_SetWindowMaximumSize(window,max_w,max_h)(sysv,r12base)
+SDL_GetWindowMaximumSize(window,w,h)(sysv,r12base)
+SDL_SetWindowBordered(window,bordered)(sysv,r12base)
+SDL_ShowWindow(window)(sysv,r12base)
+SDL_HideWindow(window)(sysv,r12base)
+SDL_RaiseWindow(window)(sysv,r12base)
+SDL_MaximizeWindow(window)(sysv,r12base)
+SDL_MinimizeWindow(window)(sysv,r12base)
+SDL_RestoreWindow(window)(sysv,r12base)
+SDL_SetWindowFullscreen(window,flags)(sysv,r12base)
+SDL_GetWindowSurface(window)(sysv,r12base)
+SDL_UpdateWindowSurface(window)(sysv,r12base)
+SDL_UpdateWindowSurfaceRects(window,rects,numrects)(sysv,r12base)
+SDL_SetWindowGrab(window,grabbed)(sysv,r12base)
+SDL_GetWindowGrab(window)(sysv,r12base)
+SDL_SetWindowBrightness(window,brightness)(sysv,r12base)
+SDL_GetWindowBrightness(window)(sysv,r12base)
+SDL_SetWindowGammaRamp(window,red,green,blue)(sysv,r12base)
+SDL_GetWindowGammaRamp(window,red,green,blue)(sysv,r12base)
+SDL_DestroyWindow(window)(sysv,r12base)
+SDL_IsScreenSaverEnabled()(sysv,r12base)
+SDL_EnableScreenSaver()(sysv,r12base)
+SDL_DisableScreenSaver()(sysv,r12base)
+SDL_GetKeyboardFocus()(sysv,r12base)
+SDL_GetKeyboardState(numkeys)(sysv,r12base)
+SDL_GetModState()(sysv,r12base)
+SDL_SetModState(modstate)(sysv,r12base)
+SDL_GetKeyFromScancode(scancode)(sysv,r12base)
+SDL_GetScancodeFromKey(key)(sysv,r12base)
+SDL_GetScancodeName(scancode)(sysv,r12base)
+SDL_GetScancodeFromName(name)(sysv,r12base)
+SDL_GetKeyName(key)(sysv,r12base)
+SDL_GetKeyFromName(name)(sysv,r12base)
+SDL_StartTextInput()(sysv,r12base)
+SDL_IsTextInputActive()(sysv,r12base)
+SDL_StopTextInput()(sysv,r12base)
+SDL_SetTextInputRect(rect)(sysv,r12base)
+SDL_HasScreenKeyboardSupport()(sysv,r12base)
+SDL_IsScreenKeyboardShown(window)(sysv,r12base)
+SDL_CreateRGBSurface(flags,width,height,depth,Rmask,Gmask,Bmask,Amask)(sysv,r12base)
+SDL_CreateRGBSurfaceFrom(pixels,width,height,depth,pitch,Rmask,Gmask,Bmask,Amask)(sysv,r12base)
+SDL_FreeSurface(surface)(sysv,r12base)
+SDL_SetSurfacePalette(surface,palette)(sysv,r12base)
+SDL_LockSurface(surface)(sysv,r12base)
+SDL_UnlockSurface(surface)(sysv,r12base)
+SDL_LoadBMP_RW(src,freesrc)(sysv,r12base)
+SDL_SaveBMP_RW(surface,dst,freedst)(sysv,r12base)
+SDL_SetSurfaceRLE(surface,flag)(sysv,r12base)
+SDL_SetColorKey(surface,flag,key)(sysv,r12base)
+SDL_GetColorKey(surface,key)(sysv,r12base)
+SDL_SetSurfaceColorMod(surface,r,g,b)(sysv,r12base)
+SDL_GetSurfaceColorMod(surface,r,g,b)(sysv,r12base)
+SDL_SetSurfaceAlphaMod(surface,alpha)(sysv,r12base)
+SDL_GetSurfaceAlphaMod(surface,alpha)(sysv,r12base)
+SDL_SetSurfaceBlendMode(surface,blendMode)(sysv,r12base)
+SDL_GetSurfaceBlendMode(surface,blendMode)(sysv,r12base)
+SDL_SetClipRect(surface,rect)(sysv,r12base)
+SDL_GetClipRect(surface,rect)(sysv,r12base)
+SDL_ConvertSurface(src,fmt,flags)(sysv,r12base)
+SDL_ConvertSurfaceFormat(src,pixel_format,flags)(sysv,r12base)
+SDL_ConvertPixels(width,height,src_format,src,src_pitch,dst_format,dst,dst_pitch)(sysv,r12base)
+SDL_FillRect(dst,rect,color)(sysv,r12base)
+SDL_FillRects(dst,rects,count,color)(sysv,r12base)
+SDL_UpperBlit(src,srcrect,dst,dstrect)(sysv,r12base)
+SDL_LowerBlit(src,srcrect,dst,dstrect)(sysv,r12base)
+SDL_SoftStretch(src,srcrect,dst,dstrect)(sysv,r12base)
+SDL_UpperBlitScaled(src,srcrect,dst,dstrect)(sysv,r12base)
+SDL_LowerBlitScaled(src,srcrect,dst,dstrect)(sysv,r12base)
+SDL_GetMouseFocus()(sysv,r12base)
+SDL_GetMouseState(x,y)(sysv,r12base)
+SDL_GetRelativeMouseState(x,y)(sysv,r12base)
+SDL_WarpMouseInWindow(window,x,y)(sysv,r12base)
+SDL_SetRelativeMouseMode(enabled)(sysv,r12base)
+SDL_GetRelativeMouseMode()(sysv,r12base)
+SDL_CreateCursor(data,mask,w,h,hot_x,hot_y)(sysv,r12base)
+SDL_CreateColorCursor(surface,hot_x,hot_y)(sysv,r12base)
+SDL_CreateSystemCursor(id)(sysv,r12base)
+SDL_SetCursor(cursor)(sysv,r12base)
+SDL_GetCursor()(sysv,r12base)
+SDL_GetDefaultCursor()(sysv,r12base)
+SDL_FreeCursor(cursor)(sysv,r12base)
+SDL_ShowCursor(toggle)(sysv,r12base)
+SDL_GetPixelFormatName(format)(sysv,r12base)
+SDL_PixelFormatEnumToMasks(format,bpp,Rmask,Gmask,Bmask,Amask)(sysv,r12base)
+SDL_MasksToPixelFormatEnum(bpp,Rmask,Gmask,Bmask,Amask)(sysv,r12base)
+SDL_AllocFormat(pixel_format)(sysv,r12base)
+SDL_FreeFormat(format)(sysv,r12base)
+SDL_AllocPalette(ncolors)(sysv,r12base)
+SDL_SetPixelFormatPalette(format,palette)(sysv,r12base)
+SDL_SetPaletteColors(palette,colors,firstcolor,ncolors)(sysv,r12base)
+SDL_FreePalette(palette)(sysv,r12base)
+SDL_MapRGB(format,r,g,b)(sysv,r12base)
+SDL_MapRGBA(format,r,g,b,a)(sysv,r12base)
+SDL_GetRGB(pixel,format,r,g,b)(sysv,r12base)
+SDL_GetRGBA(pixel,format,r,g,b,a)(sysv,r12base)
+SDL_CalculateGammaRamp(gamma,ramp)(sysv,r12base)
+SDL_HasIntersection(A,B)(sysv,r12base)
+SDL_IntersectRect(A,B,result)(sysv,r12base)
+SDL_UnionRect(A,B,result)(sysv,r12base)
+SDL_EnclosePoints(points,count,clip,result)(sysv,r12base)
+SDL_IntersectRectAndLine(rect,X1,Y1,X2,Y2)(sysv,r12base)
+SDL_GetWindowWMInfo(window,info)(sysv,r12base)
+SDL_RecordGesture(touchId)(sysv,r12base)
+SDL_SaveAllDollarTemplates(dst)(sysv,r12base)
+SDL_SaveDollarTemplate(gestureId,dst)(sysv,r12base)
+SDL_LoadDollarTemplates(touchId,src)(sysv,r12base)
+SDL_CreateShapedWindow(title,x,y,w,h,flags)(sysv,r12base)
+SDL_IsShapedWindow(window)(sysv,r12base)
+SDL_SetWindowShape(window,shape,shape_mode)(sysv,r12base)
+SDL_GetShapedWindowMode(window,shape_mode)(sysv,r12base)
+SDL_CaptureMouse(enabled)(sysv,r12base)
+SDL_WarpMouseGlobal(x,y)(sysv,r12base)
+SDL_GetGlobalMouseState(x,y)(sysv,r12base)
+SDL_SetWindowHitTest(window,callback,calback_data)(sysv,r12base)
+SDL_GetGrabbedWindow()(sysv,r12base)
+SDL_GetDisplayDPI(displayindex,ddpi,hdpi,vdpi)(sysv,r12base)
+SDL_RenderIsClipEnabled(renderer)(sysv,r12base)
+SDL_GameControllerFromInstanceID(joystick)(sysv,r12base)
+SDL_JoystickCurrentPowerLevel(joystick)(sysv,r12base)
+SDL_JoystickFromInstanceID(joystick)(sysv,r12base)
+SDL_HasAVX2()(sysv,r12base)
+SDL_QueueAudio(dev,data,len)(sysv,r12base)
+SDL_GetQueuedAudioSize(dev)(sysv,r12base)
+SDL_ClearQueuedAudio(dev)(sysv,r12base)
+SDL_sqrtf(x)(sysv,r12base)
+SDL_tan(x)(sysv,r12base)
+SDL_tanf(x)(sysv,r12base)
+SDL_MemoryBarrierReleaseFunction()(sysv,r12base)
+SDL_MemoryBarrierAcquireFunction()(sysv,r12base)
+SDL_DequeueAudio(dev,data,len)(sysv,r12base)
+SDL_ComposeCustomBlendMode(srcColorFactor,dstColorFactor,colorOperation,srcAlphaFactor,dstAlphaFactor,alphaOperation)(sysv,r12base)
+SDL_HasNEON()(sysv,r12base)
+SDL_GameControllerNumMappings()(sysv,r12base)
+SDL_GameControllerMappingForIndex(mapping_index)(sysv,r12base)
+SDL_GameControllerGetVendor(gamecontroller)(sysv,r12base)
+SDL_GameControllerGetProduct(gamecontroller)(sysv,r12base)
+SDL_GameControllerGetProductVersion(gamecontroller)(sysv,r12base)
+SDL_GetHintBoolean(name,default_value)(sysv,r12base)
+SDL_JoystickGetDeviceVendor(device_index)(sysv,r12base)
+SDL_JoystickGetDeviceProduct(device_index)(sysv,r12base)
+SDL_JoystickGetDeviceProductVersion(device_index)(sysv,r12base)
+SDL_JoystickGetDeviceType(device_index)(sysv,r12base)
+SDL_JoystickGetDeviceInstanceID(device_index)(sysv,r12base)
+SDL_JoystickGetVendor(joystick)(sysv,r12base)
+SDL_JoystickGetProduct(joystick)(sysv,r12base)
+SDL_JoystickGetProductVersion(joystick)(sysv,r12base)
+SDL_JoystickGetType(joystick)(sysv,r12base)
+SDL_JoystickGetAxisInitialState(joystick,axis,state)(sysv,r12base)
+SDL_GetDisplayUsableBounds(displayIndex,rect)(sysv,r12base)
+SDL_GetWindowBordersSize(window,top,left,bottom,right)(sysv,r12base)
+SDL_SetWindowResizable(window,resizable)(sysv,r12base)
+SDL_SetWindowOpacity(window,opacity)(sysv,r12base)
+SDL_GetWindowOpacity(window,out_opacity)(sysv,r12base)
+SDL_SetWindowModalFor(modal_window,parent_window)(sysv,r12base)
+SDL_SetWindowInputFocus(window)(sysv,r12base)
+SDL_CreateRGBSurfaceWithFormat(flags,width,height,depth,format)(sysv,r12base)
+SDL_CreateRGBSurfaceWithFormatFrom(pixels,width,height,depth,pitch,format)(sysv,r12base)
+SDL_DuplicateSurface(surface)(sysv,r12base)
+SDL_wcscmp(str1,str2)(sysv,r12base)
+SDL_utf8strlen(str)(sysv,r12base)
+SDL_LoadFile_RW(src,datasize,freesrc)(sysv,r12base)
+SDL_RenderSetIntegerScale(renderer,enable)(sysv,r12base)
+SDL_RenderGetIntegerScale(renderer)(sysv,r12base)
+SDL_NewAudioStream(src_format,src_channels,dst_format,dst_channels,dst_rate)(sysv,r12base)
+SDL_AudioStreamPut(stream,buf,len)(sysv,r12base)
+SDL_AudioStreamGet(stream,buf,len)(sysv,r12base)
+SDL_AudioStreamAvailable(stream)(sysv,r12base)
+SDL_AudioStreamFlush(stream)(sysv,r12base)
+SDL_AudioStreamClear(stream)(sysv,r12base)
+SDL_FreeAudioStream(stream)(sysv,r12base)
+SDL_LockJoysticks()(sysv,r12base)
+SDL_UnlockJoysticks()(sysv,r12base)
+SDL_GetMemoryFunctions(malloc_func,calloc_func,realloc_func,free_func)(sysv,r12base)
+SDL_SetMemoryFunctions(malloc_func,calloc_func,realloc_func,free_func)(sysv,r12base)
+SDL_GetNumAllocations()(sysv,r12base)
+SDL_RenderGetMetalLayer(renderer)(sysv,r12base)
+SDL_RenderGetMetalCommandEncoder(renderer)(sysv,r12base)
+SDL_acosf(x)(sysv,r12base)
+SDL_asinf(x)(sysv,r12base)
+SDL_atanf(x)(sysv,r12base)
+SDL_atan2f(x,y)(sysv,r12base)
+SDL_ceilf(x)(sysv,r12base)
+SDL_copysignf(x,y)(sysv,r12base)
+SDL_fabsf(x)(sysv,r12base)
+SDL_floorf(x)(sysv,r12base)
+SDL_fmod(x,y)(sysv,r12base)
+SDL_fmodf(x,y)(sysv,r12base)
+SDL_logf(x)(sysv,r12base)
+SDL_log10(x)(sysv,r12base)
+SDL_log10f(x)(sysv,r12base)
+SDL_powf(x,y)(sysv,r12base)
+SDL_scalbnf(x,n)(sysv,r12base)
+SDL_SetYUVConversionMode(mode)(sysv,r12base)
+SDL_GetYUVConversionMode()(sysv,r12base)
+SDL_GetYUVConversionModeForResolution(width,height)(sysv,r12base)
+SDL_HasAVX512F()(sysv,r12base)
+SDL_GameControllerMappingForDeviceIndex(joystick_index)(sysv,r12base)
+SDL_GameControllerGetPlayerIndex(gamecontroller)(sysv,r12base)
+SDL_GameControllerRumble(gamecontroller,low_frequency_rumble,high_frequency_rumble,duration_ms)(sysv,r12base)
+SDL_JoystickGetDevicePlayerIndex(device_index)(sysv,r12base)
+SDL_JoystickGetPlayerIndex(joystick)(sysv,r12base)
+SDL_JoystickRumble(joystick,low_frequency_rumble,high_frequency_rumble,duration_ms)(sysv,r12base)
+SDL_wcsdup(wstr)(sysv,r12base)
+SDL_exp(x)(sysv,r12base)
+SDL_expf(x)(sysv,r12base)
+SDL_HasColorKey(surface)(sysv,r12base)
+SDL_IsTablet()(sysv,r12base)
+SDL_CreateThreadWithStackSize(fn,name,stacksize,data,pfnBeginThread,pfnEndThread)(sysv,r12base)
+SDL_GetDisplayOrientation(displayIndex)(sysv,r12base)
+SDL_SIMDGetAlignment()(sysv,r12base)
+SDL_SIMDAlloc(len)(sysv,r12base)
+SDL_SIMDFree(ptr)(sysv,r12base)
+SDL_RenderDrawPointF(renderer,x,y)(sysv,r12base)
+SDL_RenderDrawPointsF(renderer,points,count)(sysv,r12base)
+SDL_RenderDrawLineF(renderer,x1,y1,x2,y2)(sysv,r12base)
+SDL_RenderDrawLinesF(renderer,points,count)(sysv,r12base)
+SDL_RenderDrawRectF(renderer,rect)(sysv,r12base)
+SDL_RenderDrawRectsF(renderer,rects,count)(sysv,r12base)
+SDL_RenderFillRectF(renderer,rect)(sysv,r12base)
+SDL_RenderFillRectsF(renderer,rects,count)(sysv,r12base)
+SDL_RenderCopyF(renderer,texture,srcrect,dstrect)(sysv,r12base)
+SDL_RenderCopyExF(renderer,texture,srcrect,dstrect,angle,center,flip)(sysv,r12base)
+SDL_RenderFlush(renderer)(sysv,r12base)
+SDL_RWsize(context)(sysv,r12base)
+SDL_RWseek(context,offset,whence)(sysv,r12base)
+SDL_RWtell(context)(sysv,r12base)
+SDL_RWread(context,ptr,size,maxnum)(sysv,r12base)
+SDL_RWwrite(context,ptr,size,num)(sysv,r12base)
+SDL_RWclose(context)(sysv,r12base)
+SDL_LoadFile(file,datasize)(sysv,r12base)
+SDL_GetTouchDeviceType(touchID)(sysv,r12base)
+SDL_HasARMSIMD()(sysv,r12base)
+SDL_GameControllerTypeForIndex(joystick_index)(sysv,r12base)
+SDL_GameControllerFromPlayerIndex(player_index)(sysv,r12base)
+SDL_GameControllerGetType(gamecontroller)(sysv,r12base)
+SDL_GameControllerSetPlayerIndex(gamecontroller,player_index)(sysv,r12base)
+SDL_JoystickFromPlayerIndex(player_index)(sysv,r12base)
+SDL_JoystickSetPlayerIndex(joystick,player_index)(sysv,r12base)
+SDL_SetTextureScaleMode(texture,scaleMode)(sysv,r12base)
+SDL_GetTextureScaleMode(texture,scaleMode)(sysv,r12base)
+SDL_LockTextureToSurface(texture,rect,surface)(sysv,r12base)
+SDL_wcsstr(haystack,needle)(sysv,r12base)
+SDL_wcsncmp(str1,str2,maxlen)(sysv,r12base)
+SDL_strtokr(s1,s2,saveptr)(sysv,r12base)
+SDL_GL_LoadLibrary(path)(sysv,r12base)
+##private
+private1()()
+##public
+SDL_GL_UnloadLibrary()(sysv,r12base)
+SDL_GL_ExtensionSupported(extension)(sysv,r12base)
+SDL_GL_ResetAttributes()(sysv,r12base)
+SDL_GL_SetAttribute(attr,value)(sysv,r12base)
+SDL_GL_GetAttribute(attr,value)(sysv,r12base)
+SDL_GL_CreateContext(window)(sysv,r12base)
+SDL_GL_MakeCurrent(window,context)(sysv,r12base)
+SDL_GL_GetCurrentWindow()(sysv,r12base)
+SDL_GL_GetCurrentContext()(sysv,r12base)
+SDL_GL_GetDrawableSize(window,w,h)(sysv,r12base)
+SDL_GL_SetSwapInterval(interval)(sysv,r12base)
+SDL_GL_GetSwapInterval()(sysv,r12base)
+SDL_GL_SwapWindow(window)(sysv,r12base)
+SDL_GL_DeleteContext(context)(sysv,r12base)
+SDL_NumHaptics()(sysv,r12base)
+SDL_HapticName(device_index)(sysv,r12base)
+SDL_HapticOpen(device_index)(sysv,r12base)
+SDL_HapticOpened(device_index)(sysv,r12base)
+SDL_HapticIndex(haptic)(sysv,r12base)
+SDL_MouseIsHaptic()(sysv,r12base)
+SDL_HapticOpenFromMouse()(sysv,r12base)
+SDL_JoystickIsHaptic(joystick)(sysv,r12base)
+SDL_HapticOpenFromJoystick(joystick)(sysv,r12base)
+SDL_HapticClose(haptic)(sysv,r12base)
+SDL_HapticNumEffects(haptic)(sysv,r12base)
+SDL_HapticNumEffectsPlaying(haptic)(sysv,r12base)
+SDL_HapticQuery(haptic)(sysv,r12base)
+SDL_HapticNumAxes(haptic)(sysv,r12base)
+SDL_HapticEffectSupported(haptic,effect)(sysv,r12base)
+SDL_HapticNewEffect(haptic,effect)(sysv,r12base)
+SDL_HapticUpdateEffect(haptic,effect,data)(sysv,r12base)
+SDL_HapticRunEffect(haptic,effect,iterations)(sysv,r12base)
+SDL_HapticStopEffect(haptic,effect)(sysv,r12base)
+SDL_HapticDestroyEffect(haptic,effect)(sysv,r12base)
+SDL_HapticGetEffectStatus(haptic,effect)(sysv,r12base)
+SDL_HapticSetGain(haptic,gain)(sysv,r12base)
+SDL_HapticSetAutocenter(haptic,autocenter)(sysv,r12base)
+SDL_HapticPause(haptic)(sysv,r12base)
+SDL_HapticUnpause(haptic)(sysv,r12base)
+SDL_HapticStopAll(haptic)(sysv,r12base)
+SDL_HapticRumbleSupported(haptic)(sysv,r12base)
+SDL_HapticRumbleInit(haptic)(sysv,r12base)
+SDL_HapticRumblePlay(haptic,strength,length)(sysv,r12base)
+SDL_HapticRumbleStop(haptic)(sysv,r12base)
+SDL_isupper(x)(sysv,r12base)
+SDL_islower(x)(sysv,r12base)
+SDL_JoystickAttachVirtual(type,naxes,nbuttons,nhats)(sysv,r12base)
+SDL_JoystickDetachVirtual(device_index)(sysv,r12base)
+SDL_JoystickIsVirtual(device_index)(sysv,r12base)
+SDL_JoystickSetVirtualAxis(joystick,axis,value)(sysv,r12base)
+SDL_JoystickSetVirtualButton(joystick,button,value)(sysv,r12base)
+SDL_JoystickSetVirtualHat(joystick,hat,value)(sysv,r12base)
+SDL_GetErrorMsg(errstr,maxlen)(sysv,r12base)
+SDL_LockSensors()(sysv,r12base)
+SDL_UnlockSensors()(sysv,r12base)
+SDL_Metal_GetLayer(view)(sysv,r12base)
+SDL_Metal_GetDrawableSize(window,w,h)(sysv,r12base)
+SDL_trunc(x)(sysv,r12base)
+SDL_truncf(x)(sysv,r12base)
+SDL_GetPreferredLocales()(sysv,r12base)
+SDL_SIMDRealloc(mem,len)(sysv,r12base)
+SDL_OpenURL(url)(sysv,r12base)
+SDL_HasSurfaceRLE(surface)(sysv,r12base)
+SDL_GameControllerHasLED(gamecontroller)(sysv,r12base)
+SDL_GameControllerSetLED(gamecontroller,red,green,blue)(sysv,r12base)
+SDL_JoystickHasLED(joystick)(sysv,r12base)
+SDL_JoystickSetLED(joystick,red,green,blue)(sysv,r12base)
+SDL_GameControllerRumbleTriggers(gamecontroller,left_rumble,right_rumble,duration_ms)(sysv,r12base)
+SDL_JoystickRumbleTriggers(joystick,left_rumble,right_rumble,duration_ms)(sysv,r12base)
+SDL_GameControllerHasAxis(gamecontroller,axis)(sysv,r12base)
+SDL_GameControllerHasButton(gamecontroller,button)(sysv,r12base)
+SDL_GameControllerGetNumTouchpads(gamecontroller)(sysv,r12base)
+SDL_GameControllerGetNumTouchpadFingers(gamecontroller,touchpad)(sysv,r12base)
+SDL_GameControllerGetTouchpadFinger(gamecontroller,touchpad,finger,state,x,y,pressure)(sysv,r12base)
+SDL_GetNumTouchDevices()(sysv,r12base)
+SDL_GetTouchDevice(index)(sysv,r12base)
+SDL_GetNumTouchFingers(touchID)(sysv,r12base)
+SDL_GetTouchFinger(touchID,index)(sysv,r12base)
+SDL_crc32(crc,data,len)(sysv,r12base)
+SDL_GameControllerGetSerial(gamecontroller)(sysv,r12base)
+SDL_JoystickGetSerial(joystick)(sysv,r12base)
+SDL_GameControllerHasSensor(gamecontroller,type)(sysv,r12base)
+SDL_GameControllerSetSensorEnabled(gamecontroller,type,enabled)(sysv,r12base)
+SDL_GameControllerIsSensorEnabled(gamecontroller,type)(sysv,r12base)
+SDL_GameControllerGetSensorData(gamecontroller,type,data,num_values)(sysv,r12base)
+SDL_wcscasecmp(str1,str2)(sysv,r12base)
+SDL_wcsncasecmp(str1,str2,len)(sysv,r12base)
+SDL_CopyAndSwap16(src,dst,items)(sysv,r12base)
+SDL_CopyAndSwap32(src,dst,items)(sysv,r12base)
+SDL_UpdateNVTexture(texture,rect,Yplane,Ypitch,UVplane,UVpitch)(sysv,r12base)
+SDL_round(x)(sysv,r12base)
+SDL_roundf(x)(sysv,r12base)
+SDL_lround(x)(sysv,r12base)
+SDL_lroundf(x)(sysv,r12base)
+SDL_SoftStretchLinear(src,srcrect,dst,dstrect)(sysv,r12base)
+SDL_SetWindowKeyboardGrab(window,grabbed)(sysv,r12base)
+SDL_SetWindowMouseGrab(window,grabbed)(sysv,r12base)
+SDL_GetWindowKeyboardGrab(window)(sysv,r12base)
+SDL_GetWindowMouseGrab(window)(sysv,r12base)
+SDL_isalpha(a)(sysv,r12base)
+SDL_isalnum(a)(sysv,r12base)
+SDL_isblank(a)(sysv,r12base)
+SDL_iscntrl(a)(sysv,r12base)
+SDL_isxdigit(a)(sysv,r12base)
+SDL_ispunct(a)(sysv,r12base)
+SDL_isprint(a)(sysv,r12base)
+SDL_isgraph(a)(sysv,r12base)
+SDL_GetAudioDeviceSpec(index,iscapture,spec)(sysv,r12base)
+SDL_TLSCleanup()(sysv,r12base)
+SDL_SetWindowAlwaysOnTop(window,on_top)(sysv,r12base)
+SDL_FlashWindow(window,operation)(sysv,r12base)
+SDL_GameControllerSendEffect(gamecontroller,data,size)(sysv,r12base)
+SDL_JoystickSendEffect(joystick,data,size)(sysv,r12base)
+SDL_GameControllerGetSensorDataRate(gamecontroller,type)(sysv,r12base)
+SDL_SetTextureUserData(texture,userdata)(sysv,r12base)
+SDL_GetTextureUserData(texture)(sysv,r12base)
+SDL_RenderGeometry(renderer,texture,vertices,num_vertices,indices,num_indices)(sysv,r12base)
+SDL_RenderGeometryRaw(renderer,texture,xy,xy_stride,color,color_stride,uv,uv_stride,num_vertices,indices,num_indices,size_indices)(sysv,r12base)
+SDL_RenderSetVSync(renderer,vsync)(sysv,r12base)
+SDL_vasprintf(strp,fmt,ap)(sysv,r12base)
+SDL_GetWindowICCProfile(window,size)(sysv,r12base)
+SDL_GetTicks64()(sysv,r12base)
+SDL_GameControllerGetAppleSFSymbolsNameForButton(gamecontroller,button)(sysv,r12base)
+SDL_GameControllerGetAppleSFSymbolsNameForAxis(gamecontroller,axis)(sysv,r12base)
+SDL_hid_init()(sysv,r12base)
+SDL_hid_exit()(sysv,r12base)
+SDL_hid_device_change_count()(sysv,r12base)
+SDL_hid_enumerate(vendor_id,product_id)(sysv,r12base)
+SDL_hid_free_enumeration(devs)(sysv,r12base)
+SDL_hid_open(vendor_id,product_id,serial_number)(sysv,r12base)
+SDL_hid_open_path(path,bExclusive)(sysv,r12base)
+SDL_hid_write(dev,data,length)(sysv,r12base)
+SDL_hid_read_timeout(dev,data,length,milliseconds)(sysv,r12base)
+SDL_hid_read(dev,data,length)(sysv,r12base)
+SDL_hid_set_nonblocking(dev,nonblock)(sysv,r12base)
+SDL_hid_send_feature_report(dev,data,length)(sysv,r12base)
+SDL_hid_get_feature_report(dev,data,length)(sysv,r12base)
+SDL_hid_close(dev)(sysv,r12base)
+SDL_hid_get_manufacturer_string(dev,string,maxlen)(sysv,r12base)
+SDL_hid_get_product_string(dev,string,maxlen)(sysv,r12base)
+SDL_hid_get_serial_number_string(dev,string,maxlen)(sysv,r12base)
+SDL_hid_get_indexed_string(dev,string_index,string,maxlen)(sysv,r12base)
+SDL_SetWindowMouseRect(window,rect)(sysv,r12base)
+SDL_GetWindowMouseRect(window)(sysv,r12base)
+SDL_RenderWindowToLogical(renderer,windowX,windowY,logicalX,logicalY)(sysv,r12base)
+SDL_RenderLogicalToWindow(renderer,logicalX,logicalY,windowX,windowY)(sysv,r12base)
+SDL_JoystickHasRumble(joystick)(sysv,r12base)
+SDL_JoystickHasRumbleTriggers(joystick)(sysv,r12base)
+SDL_GameControllerHasRumble(gamecontroller)(sysv,r12base)
+SDL_GameControllerHasRumbleTriggers(gamecontroller)(sysv,r12base)
+SDL_hid_ble_scan(active)(sysv,r12base)
+SDL_PremultiplyAlpha(width,height,src_format,src,src_pitch,dst_format,dst,dst_pitch)(sysv,r12base)
+SDL_getenv(name)(sysv,r12base)
+SDL_setenv(name,value,overwrite)(sysv,r12base)
+SDL_GetTouchName(index)(sysv,r12base)
+SDL_ClearComposition()(sysv,r12base)
+SDL_IsTextInputShown()(sysv,r12base)
+SDL_HasIntersectionF(A,B)(sysv,r12base)
+SDL_IntersectFRect(A,B,result)(sysv,r12base)
+SDL_UnionFRect(A,B,result)(sysv,r12base)
+SDL_EncloseFPoints(points,count,clip,result)(sysv,r12base)
+SDL_IntersectFRectAndLine(rect,X1,Y1,X2,Y2)(sysv,r12base)
+SDL_RenderGetWindow(renderer)(sysv,r12base)
+SDL_bsearch(key,base,nmemb,size,*compare)(sysv,r12base)
+SDL_GameControllerPathForIndex(joystick_index)(sysv,r12base)
+SDL_GameControllerPath(gamecontroller)(sysv,r12base)
+SDL_JoystickPathForIndex(device_index)(sysv,r12base)
+SDL_JoystickPath(joystick)(sysv,r12base)
+SDL_JoystickAttachVirtualEx(desc)(sysv,r12base)
+SDL_HasLSX()(sysv,r12base)
+SDL_HasLASX()(sysv,r12base)
+SDL_GameControllerGetFirmwareVersion(gamecontroller)(sysv,r12base)
+SDL_GUIDToString(guid,pszGUID,cbGUID)(sysv,r12base)
+SDL_GUIDFromString(pchGUID)(sysv,r12base)
+SDL_JoystickGetFirmwareVersion(joystick)(sysv,r12base)
+SDL_GetOriginalMemoryFunctions(malloc_func,calloc_func,realloc_func,free_func)(sysv,r12base)
+SDL_ResetKeyboard()(sysv,r12base)
+SDL_GetPointDisplayIndex(point)(sysv,r12base)
+SDL_GetRectDisplayIndex(rect)(sysv,r12base)
+SDL_ResetHint(name)(sysv,r12base)
+SDL_crc16(crc,data,len)(sysv,r12base)
+SDL_GetDefaultAudioInfo(name,spec,iscapture)(sysv,r12base)
+SDL_GetWindowSizeInPixels(window,w,h)(sysv,r12base)
+SDL_GetJoystickGUIDInfo(guid,vendor,product,version,crc16)(sysv,r12base)
+SDL_SetPrimarySelectionText(text)(sysv,r12base)
+SDL_GetPrimarySelectionText()(sysv,r12base)
+SDL_HasPrimarySelectionText()(sysv,r12base)
+SDL_ResetHints()(sysv,r12base)
+SDL_strcasestr(haystack,needle)(sysv,r12base)
+SDL_HasWindowSurface(window)(sysv,r12base)
+SDL_DestroyWindowSurface(window)(sysv,r12base)
+SDL_GameControllerGetSteamHandle(gamecontroller)(sysv,r12base)
+SDL_InitTGL2(glcptr,tglptr,getmaximumcontextversion)(base,sysv)
diff -ruN SDL2-2.32.8/src/core/morphos/sdk/ppcinline/sdl2.h SDL2-2.32.8.aros/src/core/morphos/sdk/ppcinline/sdl2.h
--- SDL2-2.32.8/src/core/morphos/sdk/ppcinline/sdl2.h	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/core/morphos/sdk/ppcinline/sdl2.h	2025-07-27 14:24:13.196841322 +0000
@@ -0,0 +1,7038 @@
+/* Automatically generated header! Do not edit! */
+
+#ifndef _PPCINLINE_SDL2_H
+#define _PPCINLINE_SDL2_H
+
+#ifndef __PPCINLINE_MACROS_H
+#include <ppcinline/macros.h>
+#endif /* !__PPCINLINE_MACROS_H */
+
+#ifndef SDL2_BASE_NAME
+#define SDL2_BASE_NAME SDL2Base
+#endif /* !SDL2_BASE_NAME */
+
+#define SDL_InitTGL(__p0, __p1) \
+	(((void (*)(void *, void **, struct Library **))*(void**)((long)(SDL2_BASE_NAME) - 28))((void*)(SDL2_BASE_NAME), __p0, __p1))
+
+#define SDL_InitTGL2(__p0, __p1, __p2) \
+	(((void (*)(void *, void **, struct Library **, unsigned int (*)(struct Library *TinyGLBase)))*(void**)((long)(SDL2_BASE_NAME) - 4816))((void*)(SDL2_BASE_NAME), __p0, __p1, __p2))
+
+#define SDL_SetExitPointer(__p0) \
+	(((void (*)(void *, void (*)(int)))*(void**)((long)(SDL2_BASE_NAME) - 34))((void*)(SDL2_BASE_NAME), __p0))
+
+#define SDL_RWFromFP_clib(__p0, __p1, __p2, __p3, __p4, __p5, __p6) \
+	({ \
+		void * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		Sint64 (* __t__p2)(struct SDL_RWops *) = __p2;\
+		Sint64 (* __t__p3)(struct SDL_RWops *, Sint64, int) = __p3;\
+		size_t (* __t__p4)(struct SDL_RWops *, void *, size_t, size_t) = __p4;\
+		size_t (* __t__p5)(struct SDL_RWops *, const void *, size_t, size_t) = __p5;\
+		int (* __t__p6)(struct SDL_RWops *) = __p6;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_RWops *(*)(void *, int , Sint64 (*)(struct SDL_RWops *), Sint64 (*)(struct SDL_RWops *, Sint64, int), size_t (*)(struct SDL_RWops *, void *, size_t, size_t), size_t (*)(struct SDL_RWops *, const void *, size_t, size_t), int (*)(struct SDL_RWops *)))*(void**)(__base - 1762))(__t__p0, __t__p1, __t__p2, __t__p3, __t__p4, __t__p5, __t__p6));\
+	})
+
+#define SDL_VSetError(__p0, __p1) \
+	({ \
+		const char * __t__p0 = __p0;\
+		va_list __t__p1;\
+		va_copy(__t__p1, __p1);\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(const char *, va_list ))*(void**)(__base - 40))(__t__p0, __t__p1));\
+	})
+
+#define SDL_GetPlatform() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((const char *(*)(void))*(void**)(__base - 46))());\
+	})
+
+#define SDL_Init(__p0) \
+	({ \
+		Uint32  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(Uint32 ))*(void**)(__base - 52))(__t__p0));\
+	})
+
+#define SDL_InitSubSystem(__p0) \
+	({ \
+		Uint32  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(Uint32 ))*(void**)(__base - 58))(__t__p0));\
+	})
+
+#define SDL_QuitSubSystem(__p0) \
+	({ \
+		Uint32  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(Uint32 ))*(void**)(__base - 64))(__t__p0));\
+	})
+
+#define SDL_WasInit(__p0) \
+	({ \
+		Uint32  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((Uint32 (*)(Uint32 ))*(void**)(__base - 70))(__t__p0));\
+	})
+
+#define SDL_Quit() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(void))*(void**)(__base - 76))());\
+	})
+
+#define SDL_SetMainReady() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(void))*(void**)(__base - 82))());\
+	})
+
+#define SDL_malloc(__p0) \
+	({ \
+		size_t  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void *(*)(size_t ))*(void**)(__base - 88))(__t__p0));\
+	})
+
+#define SDL_calloc(__p0, __p1) \
+	({ \
+		size_t  __t__p0 = __p0;\
+		size_t  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void *(*)(size_t , size_t ))*(void**)(__base - 94))(__t__p0, __t__p1));\
+	})
+
+#define SDL_realloc(__p0, __p1) \
+	({ \
+		void * __t__p0 = __p0;\
+		size_t  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void *(*)(void *, size_t ))*(void**)(__base - 100))(__t__p0, __t__p1));\
+	})
+
+#define SDL_free(__p0) \
+	({ \
+		void * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(void *))*(void**)(__base - 106))(__t__p0));\
+	})
+
+#define SDL_qsort(__p0, __p1, __p2, __p3) \
+	({ \
+		void * __t__p0 = __p0;\
+		size_t  __t__p1 = __p1;\
+		size_t  __t__p2 = __p2;\
+		SDL_CompareCallback  __t__p3 = __p3;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(void *, size_t , size_t , SDL_CompareCallback ))*(void**)(__base - 112))(__t__p0, __t__p1, __t__p2, __t__p3));\
+	})
+
+#define SDL_abs(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(int ))*(void**)(__base - 118))(__t__p0));\
+	})
+
+#define SDL_isdigit(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(int ))*(void**)(__base - 124))(__t__p0));\
+	})
+
+#define SDL_isspace(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(int ))*(void**)(__base - 130))(__t__p0));\
+	})
+
+#define SDL_toupper(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(int ))*(void**)(__base - 136))(__t__p0));\
+	})
+
+#define SDL_tolower(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(int ))*(void**)(__base - 142))(__t__p0));\
+	})
+
+#define SDL_memset(__p0, __p1, __p2) \
+	({ \
+		void * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		size_t  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void *(*)(void *, int , size_t ))*(void**)(__base - 148))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_memcpy(__p0, __p1, __p2) \
+	({ \
+		void * __t__p0 = __p0;\
+		const void * __t__p1 = __p1;\
+		size_t  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void *(*)(void *, const void *, size_t ))*(void**)(__base - 154))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_memmove(__p0, __p1, __p2) \
+	({ \
+		void * __t__p0 = __p0;\
+		const void * __t__p1 = __p1;\
+		size_t  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void *(*)(void *, const void *, size_t ))*(void**)(__base - 160))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_memcmp(__p0, __p1, __p2) \
+	({ \
+		const void * __t__p0 = __p0;\
+		const void * __t__p1 = __p1;\
+		size_t  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(const void *, const void *, size_t ))*(void**)(__base - 166))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_wcslen(__p0) \
+	({ \
+		const wchar_t * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((size_t (*)(const wchar_t *))*(void**)(__base - 172))(__t__p0));\
+	})
+
+#define SDL_wcslcpy(__p0, __p1, __p2) \
+	({ \
+		wchar_t * __t__p0 = __p0;\
+		const wchar_t * __t__p1 = __p1;\
+		size_t  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((size_t (*)(wchar_t *, const wchar_t *, size_t ))*(void**)(__base - 178))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_wcslcat(__p0, __p1, __p2) \
+	({ \
+		wchar_t * __t__p0 = __p0;\
+		const wchar_t * __t__p1 = __p1;\
+		size_t  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((size_t (*)(wchar_t *, const wchar_t *, size_t ))*(void**)(__base - 184))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_strlen(__p0) \
+	({ \
+		const char * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((size_t (*)(const char *))*(void**)(__base - 190))(__t__p0));\
+	})
+
+#define SDL_strlcpy(__p0, __p1, __p2) \
+	({ \
+		char * __t__p0 = __p0;\
+		const char * __t__p1 = __p1;\
+		size_t  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((size_t (*)(char *, const char *, size_t ))*(void**)(__base - 196))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_utf8strlcpy(__p0, __p1, __p2) \
+	({ \
+		char * __t__p0 = __p0;\
+		const char * __t__p1 = __p1;\
+		size_t  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((size_t (*)(char *, const char *, size_t ))*(void**)(__base - 202))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_strlcat(__p0, __p1, __p2) \
+	({ \
+		char * __t__p0 = __p0;\
+		const char * __t__p1 = __p1;\
+		size_t  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((size_t (*)(char *, const char *, size_t ))*(void**)(__base - 208))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_strdup(__p0) \
+	({ \
+		const char * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((char *(*)(const char *))*(void**)(__base - 214))(__t__p0));\
+	})
+
+#define SDL_strrev(__p0) \
+	({ \
+		char * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((char *(*)(char *))*(void**)(__base - 220))(__t__p0));\
+	})
+
+#define SDL_strupr(__p0) \
+	({ \
+		char * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((char *(*)(char *))*(void**)(__base - 226))(__t__p0));\
+	})
+
+#define SDL_strlwr(__p0) \
+	({ \
+		char * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((char *(*)(char *))*(void**)(__base - 232))(__t__p0));\
+	})
+
+#define SDL_strchr(__p0, __p1) \
+	({ \
+		const char * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((char *(*)(const char *, int ))*(void**)(__base - 238))(__t__p0, __t__p1));\
+	})
+
+#define SDL_strrchr(__p0, __p1) \
+	({ \
+		const char * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((char *(*)(const char *, int ))*(void**)(__base - 244))(__t__p0, __t__p1));\
+	})
+
+#define SDL_strstr(__p0, __p1) \
+	({ \
+		const char * __t__p0 = __p0;\
+		const char * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((char *(*)(const char *, const char *))*(void**)(__base - 250))(__t__p0, __t__p1));\
+	})
+
+#define SDL_itoa(__p0, __p1, __p2) \
+	({ \
+		int  __t__p0 = __p0;\
+		char * __t__p1 = __p1;\
+		int  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((char *(*)(int , char *, int ))*(void**)(__base - 256))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_uitoa(__p0, __p1, __p2) \
+	({ \
+		unsigned int  __t__p0 = __p0;\
+		char * __t__p1 = __p1;\
+		int  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((char *(*)(unsigned int , char *, int ))*(void**)(__base - 262))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_ltoa(__p0, __p1, __p2) \
+	({ \
+		long  __t__p0 = __p0;\
+		char * __t__p1 = __p1;\
+		int  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((char *(*)(long , char *, int ))*(void**)(__base - 268))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_ultoa(__p0, __p1, __p2) \
+	({ \
+		unsigned long  __t__p0 = __p0;\
+		char * __t__p1 = __p1;\
+		int  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((char *(*)(unsigned long , char *, int ))*(void**)(__base - 274))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_lltoa(__p0, __p1, __p2) \
+	({ \
+		Sint64  __t__p0 = __p0;\
+		char * __t__p1 = __p1;\
+		int  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((char *(*)(Sint64 , char *, int ))*(void**)(__base - 280))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_ulltoa(__p0, __p1, __p2) \
+	({ \
+		Uint64  __t__p0 = __p0;\
+		char * __t__p1 = __p1;\
+		int  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((char *(*)(Uint64 , char *, int ))*(void**)(__base - 286))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_atoi(__p0) \
+	({ \
+		const char * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(const char *))*(void**)(__base - 292))(__t__p0));\
+	})
+
+#define SDL_atof(__p0) \
+	({ \
+		const char * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((double (*)(const char *))*(void**)(__base - 298))(__t__p0));\
+	})
+
+#define SDL_strtol(__p0, __p1, __p2) \
+	({ \
+		const char * __t__p0 = __p0;\
+		char ** __t__p1 = __p1;\
+		int  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((long (*)(const char *, char **, int ))*(void**)(__base - 304))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_strtoul(__p0, __p1, __p2) \
+	({ \
+		const char * __t__p0 = __p0;\
+		char ** __t__p1 = __p1;\
+		int  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((unsigned long (*)(const char *, char **, int ))*(void**)(__base - 310))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_strtoll(__p0, __p1, __p2) \
+	({ \
+		const char * __t__p0 = __p0;\
+		char ** __t__p1 = __p1;\
+		int  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((Sint64 (*)(const char *, char **, int ))*(void**)(__base - 316))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_strtoull(__p0, __p1, __p2) \
+	({ \
+		const char * __t__p0 = __p0;\
+		char ** __t__p1 = __p1;\
+		int  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((Uint64 (*)(const char *, char **, int ))*(void**)(__base - 322))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_strtod(__p0, __p1) \
+	({ \
+		const char * __t__p0 = __p0;\
+		char ** __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((double (*)(const char *, char **))*(void**)(__base - 328))(__t__p0, __t__p1));\
+	})
+
+#define SDL_strcmp(__p0, __p1) \
+	({ \
+		const char * __t__p0 = __p0;\
+		const char * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(const char *, const char *))*(void**)(__base - 334))(__t__p0, __t__p1));\
+	})
+
+#define SDL_strncmp(__p0, __p1, __p2) \
+	({ \
+		const char * __t__p0 = __p0;\
+		const char * __t__p1 = __p1;\
+		size_t  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(const char *, const char *, size_t ))*(void**)(__base - 340))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_strcasecmp(__p0, __p1) \
+	({ \
+		const char * __t__p0 = __p0;\
+		const char * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(const char *, const char *))*(void**)(__base - 346))(__t__p0, __t__p1));\
+	})
+
+#define SDL_strncasecmp(__p0, __p1, __p2) \
+	({ \
+		const char * __t__p0 = __p0;\
+		const char * __t__p1 = __p1;\
+		size_t  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(const char *, const char *, size_t ))*(void**)(__base - 352))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_vsscanf(__p0, __p1, __p2) \
+	({ \
+		const char * __t__p0 = __p0;\
+		const char * __t__p1 = __p1;\
+		va_list __t__p2;\
+		va_copy(__t__p2, __p2);\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(const char *, const char *, va_list ))*(void**)(__base - 358))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_vsnprintf(__p0, __p1, __p2, __p3) \
+	({ \
+		char * __t__p0 = __p0;\
+		size_t  __t__p1 = __p1;\
+		const char * __t__p2 = __p2;\
+		va_list __t__p3;\
+		va_copy(__t__p3, __p3);\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(char *, size_t , const char *, va_list ))*(void**)(__base - 364))(__t__p0, __t__p1, __t__p2, __t__p3));\
+	})
+
+#define SDL_acos(__p0) \
+	({ \
+		double  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((double (*)(double ))*(void**)(__base - 370))(__t__p0));\
+	})
+
+#define SDL_asin(__p0) \
+	({ \
+		double  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((double (*)(double ))*(void**)(__base - 376))(__t__p0));\
+	})
+
+#define SDL_atan(__p0) \
+	({ \
+		double  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((double (*)(double ))*(void**)(__base - 382))(__t__p0));\
+	})
+
+#define SDL_atan2(__p0, __p1) \
+	({ \
+		double  __t__p0 = __p0;\
+		double  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((double (*)(double , double ))*(void**)(__base - 388))(__t__p0, __t__p1));\
+	})
+
+#define SDL_ceil(__p0) \
+	({ \
+		double  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((double (*)(double ))*(void**)(__base - 394))(__t__p0));\
+	})
+
+#define SDL_copysign(__p0, __p1) \
+	({ \
+		double  __t__p0 = __p0;\
+		double  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((double (*)(double , double ))*(void**)(__base - 400))(__t__p0, __t__p1));\
+	})
+
+#define SDL_cos(__p0) \
+	({ \
+		double  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((double (*)(double ))*(void**)(__base - 406))(__t__p0));\
+	})
+
+#define SDL_cosf(__p0) \
+	({ \
+		float  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((float (*)(float ))*(void**)(__base - 412))(__t__p0));\
+	})
+
+#define SDL_fabs(__p0) \
+	({ \
+		double  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((double (*)(double ))*(void**)(__base - 418))(__t__p0));\
+	})
+
+#define SDL_floor(__p0) \
+	({ \
+		double  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((double (*)(double ))*(void**)(__base - 424))(__t__p0));\
+	})
+
+#define SDL_log(__p0) \
+	({ \
+		double  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((double (*)(double ))*(void**)(__base - 430))(__t__p0));\
+	})
+
+#define SDL_pow(__p0, __p1) \
+	({ \
+		double  __t__p0 = __p0;\
+		double  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((double (*)(double , double ))*(void**)(__base - 436))(__t__p0, __t__p1));\
+	})
+
+#define SDL_scalbn(__p0, __p1) \
+	({ \
+		double  __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((double (*)(double , int ))*(void**)(__base - 442))(__t__p0, __t__p1));\
+	})
+
+#define SDL_sin(__p0) \
+	({ \
+		double  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((double (*)(double ))*(void**)(__base - 448))(__t__p0));\
+	})
+
+#define SDL_sinf(__p0) \
+	({ \
+		float  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((float (*)(float ))*(void**)(__base - 454))(__t__p0));\
+	})
+
+#define SDL_sqrt(__p0) \
+	({ \
+		double  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((double (*)(double ))*(void**)(__base - 460))(__t__p0));\
+	})
+
+#define SDL_iconv_open(__p0, __p1) \
+	({ \
+		const char * __t__p0 = __p0;\
+		const char * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_iconv_t (*)(const char *, const char *))*(void**)(__base - 466))(__t__p0, __t__p1));\
+	})
+
+#define SDL_iconv_close(__p0) \
+	({ \
+		SDL_iconv_t  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_iconv_t ))*(void**)(__base - 472))(__t__p0));\
+	})
+
+#define SDL_iconv(__p0, __p1, __p2, __p3, __p4) \
+	({ \
+		SDL_iconv_t  __t__p0 = __p0;\
+		const char ** __t__p1 = __p1;\
+		size_t * __t__p2 = __p2;\
+		char ** __t__p3 = __p3;\
+		size_t * __t__p4 = __p4;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((size_t (*)(SDL_iconv_t , const char **, size_t *, char **, size_t *))*(void**)(__base - 478))(__t__p0, __t__p1, __t__p2, __t__p3, __t__p4));\
+	})
+
+#define SDL_iconv_string(__p0, __p1, __p2, __p3) \
+	({ \
+		const char * __t__p0 = __p0;\
+		const char * __t__p1 = __p1;\
+		const char * __t__p2 = __p2;\
+		size_t  __t__p3 = __p3;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((char *(*)(const char *, const char *, const char *, size_t ))*(void**)(__base - 484))(__t__p0, __t__p1, __t__p2, __t__p3));\
+	})
+
+#define SDL_ReportAssertion(__p0, __p1, __p2, __p3) \
+	({ \
+		SDL_AssertData * __t__p0 = __p0;\
+		const char * __t__p1 = __p1;\
+		const char * __t__p2 = __p2;\
+		int  __t__p3 = __p3;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_AssertData (*)(SDL_AssertData *, const char *, const char *, int ))*(void**)(__base - 490))(__t__p0, __t__p1, __t__p2, __t__p3));\
+	})
+
+#define SDL_SetAssertionHandler(__p0, __p1) \
+	({ \
+		SDL_AssertionHandler  __t__p0 = __p0;\
+		void * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_AssertionHandler , void *))*(void**)(__base - 496))(__t__p0, __t__p1));\
+	})
+
+#define SDL_GetDefaultAssertionHandler() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_AssertionHandler (*)(void))*(void**)(__base - 502))());\
+	})
+
+#define SDL_GetAssertionHandler(__p0) \
+	({ \
+		void ** __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_AssertionHandler (*)(void **))*(void**)(__base - 508))(__t__p0));\
+	})
+
+#define SDL_GetAssertionReport() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((const SDL_AssertData *(*)(void))*(void**)(__base - 514))());\
+	})
+
+#define SDL_ResetAssertionReport() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(void))*(void**)(__base - 520))());\
+	})
+
+#define SDL_AtomicTryLock(__p0) \
+	({ \
+		SDL_SpinLock * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(SDL_SpinLock *))*(void**)(__base - 526))(__t__p0));\
+	})
+
+#define SDL_AtomicLock(__p0) \
+	({ \
+		SDL_SpinLock * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_SpinLock *))*(void**)(__base - 532))(__t__p0));\
+	})
+
+#define SDL_AtomicUnlock(__p0) \
+	({ \
+		SDL_SpinLock * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_SpinLock *))*(void**)(__base - 538))(__t__p0));\
+	})
+
+#define SDL_AtomicCAS(__p0, __p1, __p2) \
+	({ \
+		SDL_atomic_t * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		int  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(SDL_atomic_t *, int , int ))*(void**)(__base - 544))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_AtomicSet(__p0, __p1) \
+	({ \
+		SDL_atomic_t * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_atomic_t *, int ))*(void**)(__base - 550))(__t__p0, __t__p1));\
+	})
+
+#define SDL_AtomicGet(__p0) \
+	({ \
+		SDL_atomic_t * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_atomic_t *))*(void**)(__base - 556))(__t__p0));\
+	})
+
+#define SDL_AtomicAdd(__p0, __p1) \
+	({ \
+		SDL_atomic_t * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_atomic_t *, int ))*(void**)(__base - 562))(__t__p0, __t__p1));\
+	})
+
+#define SDL_AtomicCASPtr(__p0, __p1, __p2) \
+	({ \
+		void ** __t__p0 = __p0;\
+		void * __t__p1 = __p1;\
+		void * __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(void **, void *, void *))*(void**)(__base - 568))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_AtomicSetPtr(__p0, __p1) \
+	({ \
+		void ** __t__p0 = __p0;\
+		void * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void *(*)(void **, void *))*(void**)(__base - 574))(__t__p0, __t__p1));\
+	})
+
+#define SDL_AtomicGetPtr(__p0) \
+	({ \
+		void ** __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void *(*)(void **))*(void**)(__base - 580))(__t__p0));\
+	})
+
+#define SDL_GetNumAudioDrivers() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(void))*(void**)(__base - 586))());\
+	})
+
+#define SDL_GetAudioDriver(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((const char *(*)(int ))*(void**)(__base - 592))(__t__p0));\
+	})
+
+#define SDL_AudioInit(__p0) \
+	({ \
+		const char * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(const char *))*(void**)(__base - 598))(__t__p0));\
+	})
+
+#define SDL_AudioQuit() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(void))*(void**)(__base - 604))());\
+	})
+
+#define SDL_GetCurrentAudioDriver() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((const char *(*)(void))*(void**)(__base - 610))());\
+	})
+
+#define SDL_OpenAudio(__p0, __p1) \
+	({ \
+		SDL_AudioSpec * __t__p0 = __p0;\
+		SDL_AudioSpec * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_AudioSpec *, SDL_AudioSpec *))*(void**)(__base - 616))(__t__p0, __t__p1));\
+	})
+
+#define SDL_GetNumAudioDevices(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(int ))*(void**)(__base - 622))(__t__p0));\
+	})
+
+#define SDL_GetAudioDeviceName(__p0, __p1) \
+	({ \
+		int  __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((const char *(*)(int , int ))*(void**)(__base - 628))(__t__p0, __t__p1));\
+	})
+
+#define SDL_OpenAudioDevice(__p0, __p1, __p2, __p3, __p4) \
+	({ \
+		const char * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		const SDL_AudioSpec * __t__p2 = __p2;\
+		SDL_AudioSpec * __t__p3 = __p3;\
+		int  __t__p4 = __p4;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_AudioDeviceID (*)(const char *, int , const SDL_AudioSpec *, SDL_AudioSpec *, int ))*(void**)(__base - 634))(__t__p0, __t__p1, __t__p2, __t__p3, __t__p4));\
+	})
+
+#define SDL_GetAudioStatus() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_AudioStatus (*)(void))*(void**)(__base - 640))());\
+	})
+
+#define SDL_GetAudioDeviceStatus(__p0) \
+	({ \
+		SDL_AudioDeviceID  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_AudioStatus (*)(SDL_AudioDeviceID ))*(void**)(__base - 646))(__t__p0));\
+	})
+
+#define SDL_PauseAudio(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(int ))*(void**)(__base - 652))(__t__p0));\
+	})
+
+#define SDL_PauseAudioDevice(__p0, __p1) \
+	({ \
+		SDL_AudioDeviceID  __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_AudioDeviceID , int ))*(void**)(__base - 658))(__t__p0, __t__p1));\
+	})
+
+#define SDL_LoadWAV_RW(__p0, __p1, __p2, __p3, __p4) \
+	({ \
+		SDL_RWops * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		SDL_AudioSpec * __t__p2 = __p2;\
+		Uint8 ** __t__p3 = __p3;\
+		Uint32 * __t__p4 = __p4;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_AudioSpec *(*)(SDL_RWops *, int , SDL_AudioSpec *, Uint8 **, Uint32 *))*(void**)(__base - 664))(__t__p0, __t__p1, __t__p2, __t__p3, __t__p4));\
+	})
+
+#define SDL_FreeWAV(__p0) \
+	({ \
+		Uint8 * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(Uint8 *))*(void**)(__base - 670))(__t__p0));\
+	})
+
+#define SDL_BuildAudioCVT(__p0, __p1, __p2, __p3, __p4, __p5, __p6) \
+	({ \
+		SDL_AudioCVT * __t__p0 = __p0;\
+		SDL_AudioFormat  __t__p1 = __p1;\
+		Uint8  __t__p2 = __p2;\
+		int  __t__p3 = __p3;\
+		SDL_AudioFormat  __t__p4 = __p4;\
+		Uint8  __t__p5 = __p5;\
+		int  __t__p6 = __p6;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_AudioCVT *, SDL_AudioFormat , Uint8 , int , SDL_AudioFormat , Uint8 , int ))*(void**)(__base - 676))(__t__p0, __t__p1, __t__p2, __t__p3, __t__p4, __t__p5, __t__p6));\
+	})
+
+#define SDL_ConvertAudio(__p0) \
+	({ \
+		SDL_AudioCVT * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_AudioCVT *))*(void**)(__base - 682))(__t__p0));\
+	})
+
+#define SDL_MixAudio(__p0, __p1, __p2, __p3) \
+	({ \
+		Uint8 * __t__p0 = __p0;\
+		const Uint8 * __t__p1 = __p1;\
+		Uint32  __t__p2 = __p2;\
+		int  __t__p3 = __p3;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(Uint8 *, const Uint8 *, Uint32 , int ))*(void**)(__base - 688))(__t__p0, __t__p1, __t__p2, __t__p3));\
+	})
+
+#define SDL_MixAudioFormat(__p0, __p1, __p2, __p3, __p4) \
+	({ \
+		Uint8 * __t__p0 = __p0;\
+		const Uint8 * __t__p1 = __p1;\
+		SDL_AudioFormat  __t__p2 = __p2;\
+		Uint32  __t__p3 = __p3;\
+		int  __t__p4 = __p4;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(Uint8 *, const Uint8 *, SDL_AudioFormat , Uint32 , int ))*(void**)(__base - 694))(__t__p0, __t__p1, __t__p2, __t__p3, __t__p4));\
+	})
+
+#define SDL_LockAudio() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(void))*(void**)(__base - 700))());\
+	})
+
+#define SDL_LockAudioDevice(__p0) \
+	({ \
+		SDL_AudioDeviceID  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_AudioDeviceID ))*(void**)(__base - 706))(__t__p0));\
+	})
+
+#define SDL_UnlockAudio() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(void))*(void**)(__base - 712))());\
+	})
+
+#define SDL_UnlockAudioDevice(__p0) \
+	({ \
+		SDL_AudioDeviceID  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_AudioDeviceID ))*(void**)(__base - 718))(__t__p0));\
+	})
+
+#define SDL_CloseAudio() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(void))*(void**)(__base - 724))());\
+	})
+
+#define SDL_CloseAudioDevice(__p0) \
+	({ \
+		SDL_AudioDeviceID  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_AudioDeviceID ))*(void**)(__base - 730))(__t__p0));\
+	})
+
+#define SDL_SetClipboardText(__p0) \
+	({ \
+		const char * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(const char *))*(void**)(__base - 736))(__t__p0));\
+	})
+
+#define SDL_GetClipboardText() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((char *(*)(void))*(void**)(__base - 742))());\
+	})
+
+#define SDL_HasClipboardText() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(void))*(void**)(__base - 748))());\
+	})
+
+#define SDL_GetCPUCount() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(void))*(void**)(__base - 754))());\
+	})
+
+#define SDL_GetCPUCacheLineSize() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(void))*(void**)(__base - 760))());\
+	})
+
+#define SDL_HasRDTSC() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(void))*(void**)(__base - 766))());\
+	})
+
+#define SDL_HasAltiVec() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(void))*(void**)(__base - 772))());\
+	})
+
+#define SDL_HasMMX() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(void))*(void**)(__base - 778))());\
+	})
+
+#define SDL_Has3DNow() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(void))*(void**)(__base - 784))());\
+	})
+
+#define SDL_HasSSE() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(void))*(void**)(__base - 790))());\
+	})
+
+#define SDL_HasSSE2() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(void))*(void**)(__base - 796))());\
+	})
+
+#define SDL_HasSSE3() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(void))*(void**)(__base - 802))());\
+	})
+
+#define SDL_HasSSE41() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(void))*(void**)(__base - 808))());\
+	})
+
+#define SDL_HasSSE42() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(void))*(void**)(__base - 814))());\
+	})
+
+#define SDL_HasAVX() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(void))*(void**)(__base - 820))());\
+	})
+
+#define SDL_GetSystemRAM() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(void))*(void**)(__base - 826))());\
+	})
+
+#define SDL_GetError() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((const char *(*)(void))*(void**)(__base - 832))());\
+	})
+
+#define SDL_ClearError() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(void))*(void**)(__base - 838))());\
+	})
+
+#define SDL_Error(__p0) \
+	({ \
+		SDL_errorcode  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_errorcode ))*(void**)(__base - 844))(__t__p0));\
+	})
+
+#define SDL_PumpEvents() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(void))*(void**)(__base - 850))());\
+	})
+
+#define SDL_PeepEvents(__p0, __p1, __p2, __p3, __p4) \
+	({ \
+		SDL_Event * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		SDL_eventaction  __t__p2 = __p2;\
+		Uint32  __t__p3 = __p3;\
+		Uint32  __t__p4 = __p4;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Event *, int , SDL_eventaction , Uint32 , Uint32 ))*(void**)(__base - 856))(__t__p0, __t__p1, __t__p2, __t__p3, __t__p4));\
+	})
+
+#define SDL_HasEvent(__p0) \
+	({ \
+		Uint32  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(Uint32 ))*(void**)(__base - 862))(__t__p0));\
+	})
+
+#define SDL_HasEvents(__p0, __p1) \
+	({ \
+		Uint32  __t__p0 = __p0;\
+		Uint32  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(Uint32 , Uint32 ))*(void**)(__base - 868))(__t__p0, __t__p1));\
+	})
+
+#define SDL_FlushEvent(__p0) \
+	({ \
+		Uint32  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(Uint32 ))*(void**)(__base - 874))(__t__p0));\
+	})
+
+#define SDL_FlushEvents(__p0, __p1) \
+	({ \
+		Uint32  __t__p0 = __p0;\
+		Uint32  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(Uint32 , Uint32 ))*(void**)(__base - 880))(__t__p0, __t__p1));\
+	})
+
+#define SDL_PollEvent(__p0) \
+	({ \
+		SDL_Event * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Event *))*(void**)(__base - 886))(__t__p0));\
+	})
+
+#define SDL_WaitEvent(__p0) \
+	({ \
+		SDL_Event * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Event *))*(void**)(__base - 892))(__t__p0));\
+	})
+
+#define SDL_WaitEventTimeout(__p0, __p1) \
+	({ \
+		SDL_Event * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Event *, int ))*(void**)(__base - 898))(__t__p0, __t__p1));\
+	})
+
+#define SDL_PushEvent(__p0) \
+	({ \
+		SDL_Event * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Event *))*(void**)(__base - 904))(__t__p0));\
+	})
+
+#define SDL_SetEventFilter(__p0, __p1) \
+	({ \
+		SDL_EventFilter  __t__p0 = __p0;\
+		void * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_EventFilter , void *))*(void**)(__base - 910))(__t__p0, __t__p1));\
+	})
+
+#define SDL_GetEventFilter(__p0, __p1) \
+	({ \
+		SDL_EventFilter * __t__p0 = __p0;\
+		void ** __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(SDL_EventFilter *, void **))*(void**)(__base - 916))(__t__p0, __t__p1));\
+	})
+
+#define SDL_AddEventWatch(__p0, __p1) \
+	({ \
+		SDL_EventFilter  __t__p0 = __p0;\
+		void * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_EventFilter , void *))*(void**)(__base - 922))(__t__p0, __t__p1));\
+	})
+
+#define SDL_DelEventWatch(__p0, __p1) \
+	({ \
+		SDL_EventFilter  __t__p0 = __p0;\
+		void * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_EventFilter , void *))*(void**)(__base - 928))(__t__p0, __t__p1));\
+	})
+
+#define SDL_FilterEvents(__p0, __p1) \
+	({ \
+		SDL_EventFilter  __t__p0 = __p0;\
+		void * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_EventFilter , void *))*(void**)(__base - 934))(__t__p0, __t__p1));\
+	})
+
+#define SDL_EventState(__p0, __p1) \
+	({ \
+		Uint32  __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((Uint8 (*)(Uint32 , int ))*(void**)(__base - 940))(__t__p0, __t__p1));\
+	})
+
+#define SDL_RegisterEvents(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((Uint32 (*)(int ))*(void**)(__base - 946))(__t__p0));\
+	})
+
+#define SDL_GetBasePath() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((char *(*)(void))*(void**)(__base - 952))());\
+	})
+
+#define SDL_GetPrefPath(__p0, __p1) \
+	({ \
+		const char * __t__p0 = __p0;\
+		const char * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((char *(*)(const char *, const char *))*(void**)(__base - 958))(__t__p0, __t__p1));\
+	})
+
+#define SDL_NumJoysticks() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(void))*(void**)(__base - 964))());\
+	})
+
+#define SDL_JoystickNameForIndex(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((const char *(*)(int ))*(void**)(__base - 970))(__t__p0));\
+	})
+
+#define SDL_JoystickOpen(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_Joystick *(*)(int ))*(void**)(__base - 976))(__t__p0));\
+	})
+
+#define SDL_JoystickName(__p0) \
+	({ \
+		SDL_Joystick * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((const char *(*)(SDL_Joystick *))*(void**)(__base - 982))(__t__p0));\
+	})
+
+#define SDL_JoystickGetDeviceGUID(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_JoystickGUID (*)(int ))*(void**)(__base - 988))(__t__p0));\
+	})
+
+#define SDL_JoystickGetGUID(__p0) \
+	({ \
+		SDL_Joystick * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_JoystickGUID (*)(SDL_Joystick *))*(void**)(__base - 994))(__t__p0));\
+	})
+
+#define SDL_JoystickGetGUIDString(__p0, __p1, __p2) \
+	({ \
+		SDL_JoystickGUID  __t__p0 = __p0;\
+		char * __t__p1 = __p1;\
+		int  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_JoystickGUID , char *, int ))*(void**)(__base - 1000))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_JoystickGetGUIDFromString(__p0) \
+	({ \
+		const char * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_JoystickGUID (*)(const char *))*(void**)(__base - 1006))(__t__p0));\
+	})
+
+#define SDL_JoystickGetAttached(__p0) \
+	({ \
+		SDL_Joystick * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(SDL_Joystick *))*(void**)(__base - 1012))(__t__p0));\
+	})
+
+#define SDL_JoystickInstanceID(__p0) \
+	({ \
+		SDL_Joystick * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_JoystickID (*)(SDL_Joystick *))*(void**)(__base - 1018))(__t__p0));\
+	})
+
+#define SDL_JoystickNumAxes(__p0) \
+	({ \
+		SDL_Joystick * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Joystick *))*(void**)(__base - 1024))(__t__p0));\
+	})
+
+#define SDL_JoystickNumBalls(__p0) \
+	({ \
+		SDL_Joystick * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Joystick *))*(void**)(__base - 1030))(__t__p0));\
+	})
+
+#define SDL_JoystickNumHats(__p0) \
+	({ \
+		SDL_Joystick * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Joystick *))*(void**)(__base - 1036))(__t__p0));\
+	})
+
+#define SDL_JoystickNumButtons(__p0) \
+	({ \
+		SDL_Joystick * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Joystick *))*(void**)(__base - 1042))(__t__p0));\
+	})
+
+#define SDL_JoystickUpdate() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(void))*(void**)(__base - 1048))());\
+	})
+
+#define SDL_JoystickEventState(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(int ))*(void**)(__base - 1054))(__t__p0));\
+	})
+
+#define SDL_JoystickGetAxis(__p0, __p1) \
+	({ \
+		SDL_Joystick * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((Sint16 (*)(SDL_Joystick *, int ))*(void**)(__base - 1060))(__t__p0, __t__p1));\
+	})
+
+#define SDL_JoystickGetHat(__p0, __p1) \
+	({ \
+		SDL_Joystick * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((Uint8 (*)(SDL_Joystick *, int ))*(void**)(__base - 1066))(__t__p0, __t__p1));\
+	})
+
+#define SDL_JoystickGetBall(__p0, __p1, __p2, __p3) \
+	({ \
+		SDL_Joystick * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		int * __t__p2 = __p2;\
+		int * __t__p3 = __p3;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Joystick *, int , int *, int *))*(void**)(__base - 1072))(__t__p0, __t__p1, __t__p2, __t__p3));\
+	})
+
+#define SDL_JoystickGetButton(__p0, __p1) \
+	({ \
+		SDL_Joystick * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((Uint8 (*)(SDL_Joystick *, int ))*(void**)(__base - 1078))(__t__p0, __t__p1));\
+	})
+
+#define SDL_JoystickClose(__p0) \
+	({ \
+		SDL_Joystick * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_Joystick *))*(void**)(__base - 1084))(__t__p0));\
+	})
+
+#define SDL_GameControllerAddMappingsFromRW(__p0, __p1) \
+	({ \
+		SDL_RWops * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_RWops *, int ))*(void**)(__base - 1090))(__t__p0, __t__p1));\
+	})
+
+#define SDL_GameControllerAddMapping(__p0) \
+	({ \
+		const char * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(const char *))*(void**)(__base - 1096))(__t__p0));\
+	})
+
+#define SDL_GameControllerMappingForGUID(__p0) \
+	({ \
+		SDL_JoystickGUID  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((char *(*)(SDL_JoystickGUID ))*(void**)(__base - 1102))(__t__p0));\
+	})
+
+#define SDL_GameControllerMapping(__p0) \
+	({ \
+		SDL_GameController * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((char *(*)(SDL_GameController *))*(void**)(__base - 1108))(__t__p0));\
+	})
+
+#define SDL_IsGameController(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(int ))*(void**)(__base - 1114))(__t__p0));\
+	})
+
+#define SDL_GameControllerNameForIndex(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((const char *(*)(int ))*(void**)(__base - 1120))(__t__p0));\
+	})
+
+#define SDL_GameControllerOpen(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_GameController *(*)(int ))*(void**)(__base - 1126))(__t__p0));\
+	})
+
+#define SDL_GameControllerName(__p0) \
+	({ \
+		SDL_GameController * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((const char *(*)(SDL_GameController *))*(void**)(__base - 1132))(__t__p0));\
+	})
+
+#define SDL_GameControllerGetAttached(__p0) \
+	({ \
+		SDL_GameController * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(SDL_GameController *))*(void**)(__base - 1138))(__t__p0));\
+	})
+
+#define SDL_GameControllerGetJoystick(__p0) \
+	({ \
+		SDL_GameController * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_Joystick *(*)(SDL_GameController *))*(void**)(__base - 1144))(__t__p0));\
+	})
+
+#define SDL_GameControllerEventState(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(int ))*(void**)(__base - 1150))(__t__p0));\
+	})
+
+#define SDL_GameControllerUpdate() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(void))*(void**)(__base - 1156))());\
+	})
+
+#define SDL_GameControllerGetAxisFromString(__p0) \
+	({ \
+		const char * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_GameControllerAxis (*)(const char *))*(void**)(__base - 1162))(__t__p0));\
+	})
+
+#define SDL_GameControllerGetStringForAxis(__p0) \
+	({ \
+		SDL_GameControllerAxis  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((const char *(*)(SDL_GameControllerAxis ))*(void**)(__base - 1168))(__t__p0));\
+	})
+
+#define SDL_GameControllerGetBindForAxis(__p0, __p1) \
+	({ \
+		SDL_GameController * __t__p0 = __p0;\
+		SDL_GameControllerAxis  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_GameControllerButtonBind (*)(SDL_GameController *, SDL_GameControllerAxis ))*(void**)(__base - 1174))(__t__p0, __t__p1));\
+	})
+
+#define SDL_GameControllerGetAxis(__p0, __p1) \
+	({ \
+		SDL_GameController * __t__p0 = __p0;\
+		SDL_GameControllerAxis  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((Sint16 (*)(SDL_GameController *, SDL_GameControllerAxis ))*(void**)(__base - 1180))(__t__p0, __t__p1));\
+	})
+
+#define SDL_GameControllerGetButtonFromString(__p0) \
+	({ \
+		const char * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_GameControllerButton (*)(const char *))*(void**)(__base - 1186))(__t__p0));\
+	})
+
+#define SDL_GameControllerGetStringForButton(__p0) \
+	({ \
+		SDL_GameControllerButton  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((const char *(*)(SDL_GameControllerButton ))*(void**)(__base - 1192))(__t__p0));\
+	})
+
+#define SDL_GameControllerGetBindForButton(__p0, __p1) \
+	({ \
+		SDL_GameController * __t__p0 = __p0;\
+		SDL_GameControllerButton  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_GameControllerButtonBind (*)(SDL_GameController *, SDL_GameControllerButton ))*(void**)(__base - 1198))(__t__p0, __t__p1));\
+	})
+
+#define SDL_GameControllerGetButton(__p0, __p1) \
+	({ \
+		SDL_GameController * __t__p0 = __p0;\
+		SDL_GameControllerButton  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((Uint8 (*)(SDL_GameController *, SDL_GameControllerButton ))*(void**)(__base - 1204))(__t__p0, __t__p1));\
+	})
+
+#define SDL_GameControllerClose(__p0) \
+	({ \
+		SDL_GameController * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_GameController *))*(void**)(__base - 1210))(__t__p0));\
+	})
+
+#define SDL_NumHaptics() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(void))*(void**)(__base - 3748))());\
+	})
+
+#define SDL_HapticName(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((const char *(*)(int ))*(void**)(__base - 3754))(__t__p0));\
+	})
+
+#define SDL_HapticOpen(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_Haptic *(*)(int ))*(void**)(__base - 3760))(__t__p0));\
+	})
+
+#define SDL_HapticOpened(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(int ))*(void**)(__base - 3766))(__t__p0));\
+	})
+
+#define SDL_HapticIndex(__p0) \
+	({ \
+		SDL_Haptic * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Haptic *))*(void**)(__base - 3772))(__t__p0));\
+	})
+
+#define SDL_MouseIsHaptic() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(void))*(void**)(__base - 3778))());\
+	})
+
+#define SDL_HapticOpenFromMouse() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_Haptic *(*)(void))*(void**)(__base - 3784))());\
+	})
+
+#define SDL_JoystickIsHaptic(__p0) \
+	({ \
+		SDL_Joystick * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Joystick *))*(void**)(__base - 3790))(__t__p0));\
+	})
+
+#define SDL_HapticOpenFromJoystick(__p0) \
+	({ \
+		SDL_Joystick * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_Haptic *(*)(SDL_Joystick *))*(void**)(__base - 3796))(__t__p0));\
+	})
+
+#define SDL_HapticClose(__p0) \
+	({ \
+		SDL_Haptic * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_Haptic *))*(void**)(__base - 3802))(__t__p0));\
+	})
+
+#define SDL_HapticNumEffects(__p0) \
+	({ \
+		SDL_Haptic * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Haptic *))*(void**)(__base - 3808))(__t__p0));\
+	})
+
+#define SDL_HapticNumEffectsPlaying(__p0) \
+	({ \
+		SDL_Haptic * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Haptic *))*(void**)(__base - 3814))(__t__p0));\
+	})
+
+#define SDL_HapticQuery(__p0) \
+	({ \
+		SDL_Haptic * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((unsigned int (*)(SDL_Haptic *))*(void**)(__base - 3820))(__t__p0));\
+	})
+
+#define SDL_HapticNumAxes(__p0) \
+	({ \
+		SDL_Haptic * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Haptic *))*(void**)(__base - 3826))(__t__p0));\
+	})
+
+#define SDL_HapticEffectSupported(__p0, __p1) \
+	({ \
+		SDL_Haptic * __t__p0 = __p0;\
+		SDL_HapticEffect * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Haptic *, SDL_HapticEffect *))*(void**)(__base - 3832))(__t__p0, __t__p1));\
+	})
+
+#define SDL_HapticNewEffect(__p0, __p1) \
+	({ \
+		SDL_Haptic * __t__p0 = __p0;\
+		SDL_HapticEffect * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Haptic *, SDL_HapticEffect *))*(void**)(__base - 3838))(__t__p0, __t__p1));\
+	})
+
+#define SDL_HapticUpdateEffect(__p0, __p1, __p2) \
+	({ \
+		SDL_Haptic * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		SDL_HapticEffect * __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Haptic *, int , SDL_HapticEffect *))*(void**)(__base - 3844))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_HapticRunEffect(__p0, __p1, __p2) \
+	({ \
+		SDL_Haptic * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		Uint32  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Haptic *, int , Uint32 ))*(void**)(__base - 3850))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_HapticStopEffect(__p0, __p1) \
+	({ \
+		SDL_Haptic * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Haptic *, int ))*(void**)(__base - 3856))(__t__p0, __t__p1));\
+	})
+
+#define SDL_HapticDestroyEffect(__p0, __p1) \
+	({ \
+		SDL_Haptic * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_Haptic *, int ))*(void**)(__base - 3862))(__t__p0, __t__p1));\
+	})
+
+#define SDL_HapticGetEffectStatus(__p0, __p1) \
+	({ \
+		SDL_Haptic * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Haptic *, int ))*(void**)(__base - 3868))(__t__p0, __t__p1));\
+	})
+
+#define SDL_HapticSetGain(__p0, __p1) \
+	({ \
+		SDL_Haptic * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Haptic *, int ))*(void**)(__base - 3874))(__t__p0, __t__p1));\
+	})
+
+#define SDL_HapticSetAutocenter(__p0, __p1) \
+	({ \
+		SDL_Haptic * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Haptic *, int ))*(void**)(__base - 3880))(__t__p0, __t__p1));\
+	})
+
+#define SDL_HapticPause(__p0) \
+	({ \
+		SDL_Haptic * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Haptic *))*(void**)(__base - 3886))(__t__p0));\
+	})
+
+#define SDL_HapticUnpause(__p0) \
+	({ \
+		SDL_Haptic * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Haptic *))*(void**)(__base - 3892))(__t__p0));\
+	})
+
+#define SDL_HapticStopAll(__p0) \
+	({ \
+		SDL_Haptic * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Haptic *))*(void**)(__base - 3898))(__t__p0));\
+	})
+
+#define SDL_HapticRumbleSupported(__p0) \
+	({ \
+		SDL_Haptic * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Haptic *))*(void**)(__base - 3904))(__t__p0));\
+	})
+
+#define SDL_HapticRumbleInit(__p0) \
+	({ \
+		SDL_Haptic * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Haptic *))*(void**)(__base - 3910))(__t__p0));\
+	})
+
+#define SDL_HapticRumblePlay(__p0, __p1, __p2) \
+	({ \
+		SDL_Haptic * __t__p0 = __p0;\
+		float  __t__p1 = __p1;\
+		Uint32  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Haptic *, float , Uint32 ))*(void**)(__base - 3916))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_HapticRumbleStop(__p0) \
+	({ \
+		SDL_Haptic * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Haptic *))*(void**)(__base - 3922))(__t__p0));\
+	})
+
+#define SDL_SetHintWithPriority(__p0, __p1, __p2) \
+	({ \
+		const char * __t__p0 = __p0;\
+		const char * __t__p1 = __p1;\
+		SDL_HintPriority  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(const char *, const char *, SDL_HintPriority ))*(void**)(__base - 1216))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_SetHint(__p0, __p1) \
+	({ \
+		const char * __t__p0 = __p0;\
+		const char * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(const char *, const char *))*(void**)(__base - 1222))(__t__p0, __t__p1));\
+	})
+
+#define SDL_GetHint(__p0) \
+	({ \
+		const char * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((const char *(*)(const char *))*(void**)(__base - 1228))(__t__p0));\
+	})
+
+#define SDL_AddHintCallback(__p0, __p1, __p2) \
+	({ \
+		const char * __t__p0 = __p0;\
+		SDL_HintCallback  __t__p1 = __p1;\
+		void * __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(const char *, SDL_HintCallback , void *))*(void**)(__base - 1234))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_DelHintCallback(__p0, __p1, __p2) \
+	({ \
+		const char * __t__p0 = __p0;\
+		SDL_HintCallback  __t__p1 = __p1;\
+		void * __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(const char *, SDL_HintCallback , void *))*(void**)(__base - 1240))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_ClearHints() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(void))*(void**)(__base - 1246))());\
+	})
+
+#define SDL_LoadObject(__p0) \
+	({ \
+		const char * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void *(*)(const char *))*(void**)(__base - 1252))(__t__p0));\
+	})
+
+#define SDL_LoadFunction(__p0, __p1) \
+	({ \
+		void * __t__p0 = __p0;\
+		const char * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void *(*)(void *, const char *))*(void**)(__base - 1258))(__t__p0, __t__p1));\
+	})
+
+#define SDL_UnloadObject(__p0) \
+	({ \
+		void * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(void *))*(void**)(__base - 1264))(__t__p0));\
+	})
+
+#define SDL_LogSetAllPriority(__p0) \
+	({ \
+		SDL_LogPriority  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_LogPriority ))*(void**)(__base - 1270))(__t__p0));\
+	})
+
+#define SDL_LogSetPriority(__p0, __p1) \
+	({ \
+		int  __t__p0 = __p0;\
+		SDL_LogPriority  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(int , SDL_LogPriority ))*(void**)(__base - 1276))(__t__p0, __t__p1));\
+	})
+
+#define SDL_LogGetPriority(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_LogPriority (*)(int ))*(void**)(__base - 1282))(__t__p0));\
+	})
+
+#define SDL_LogResetPriorities() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(void))*(void**)(__base - 1288))());\
+	})
+
+#define SDL_LogMessageV(__p0, __p1, __p2, __p3) \
+	({ \
+		int  __t__p0 = __p0;\
+		SDL_LogPriority  __t__p1 = __p1;\
+		const char * __t__p2 = __p2;\
+		va_list __t__p3;\
+		va_copy(__t__p3, __p3);\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(int , SDL_LogPriority , const char *, va_list ))*(void**)(__base - 1294))(__t__p0, __t__p1, __t__p2, __t__p3));\
+	})
+
+#define SDL_LogGetOutputFunction(__p0, __p1) \
+	({ \
+		SDL_LogOutputFunction * __t__p0 = __p0;\
+		void ** __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_LogOutputFunction *, void **))*(void**)(__base - 1300))(__t__p0, __t__p1));\
+	})
+
+#define SDL_LogSetOutputFunction(__p0, __p1) \
+	({ \
+		SDL_LogOutputFunction  __t__p0 = __p0;\
+		void * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_LogOutputFunction , void *))*(void**)(__base - 1306))(__t__p0, __t__p1));\
+	})
+
+#define SDL_ShowMessageBox(__p0, __p1) \
+	({ \
+		const SDL_MessageBoxData * __t__p0 = __p0;\
+		int * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(const SDL_MessageBoxData *, int *))*(void**)(__base - 1312))(__t__p0, __t__p1));\
+	})
+
+#define SDL_ShowSimpleMessageBox(__p0, __p1, __p2, __p3) \
+	({ \
+		Uint32  __t__p0 = __p0;\
+		const char * __t__p1 = __p1;\
+		const char * __t__p2 = __p2;\
+		SDL_Window * __t__p3 = __p3;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(Uint32 , const char *, const char *, SDL_Window *))*(void**)(__base - 1318))(__t__p0, __t__p1, __t__p2, __t__p3));\
+	})
+
+#define SDL_CreateMutex() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_mutex *(*)(void))*(void**)(__base - 1324))());\
+	})
+
+#define SDL_LockMutex(__p0) \
+	({ \
+		SDL_mutex * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_mutex *))*(void**)(__base - 1330))(__t__p0));\
+	})
+
+#define SDL_TryLockMutex(__p0) \
+	({ \
+		SDL_mutex * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_mutex *))*(void**)(__base - 1336))(__t__p0));\
+	})
+
+#define SDL_UnlockMutex(__p0) \
+	({ \
+		SDL_mutex * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_mutex *))*(void**)(__base - 1342))(__t__p0));\
+	})
+
+#define SDL_DestroyMutex(__p0) \
+	({ \
+		SDL_mutex * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_mutex *))*(void**)(__base - 1348))(__t__p0));\
+	})
+
+#define SDL_CreateSemaphore(__p0) \
+	({ \
+		Uint32  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_sem *(*)(Uint32 ))*(void**)(__base - 1354))(__t__p0));\
+	})
+
+#define SDL_DestroySemaphore(__p0) \
+	({ \
+		SDL_sem * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_sem *))*(void**)(__base - 1360))(__t__p0));\
+	})
+
+#define SDL_SemWait(__p0) \
+	({ \
+		SDL_sem * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_sem *))*(void**)(__base - 1366))(__t__p0));\
+	})
+
+#define SDL_SemTryWait(__p0) \
+	({ \
+		SDL_sem * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_sem *))*(void**)(__base - 1372))(__t__p0));\
+	})
+
+#define SDL_SemWaitTimeout(__p0, __p1) \
+	({ \
+		SDL_sem * __t__p0 = __p0;\
+		Uint32  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_sem *, Uint32 ))*(void**)(__base - 1378))(__t__p0, __t__p1));\
+	})
+
+#define SDL_SemPost(__p0) \
+	({ \
+		SDL_sem * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_sem *))*(void**)(__base - 1384))(__t__p0));\
+	})
+
+#define SDL_SemValue(__p0) \
+	({ \
+		SDL_sem * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((Uint32 (*)(SDL_sem *))*(void**)(__base - 1390))(__t__p0));\
+	})
+
+#define SDL_CreateCond() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_cond *(*)(void))*(void**)(__base - 1396))());\
+	})
+
+#define SDL_DestroyCond(__p0) \
+	({ \
+		SDL_cond * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_cond *))*(void**)(__base - 1402))(__t__p0));\
+	})
+
+#define SDL_CondSignal(__p0) \
+	({ \
+		SDL_cond * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_cond *))*(void**)(__base - 1408))(__t__p0));\
+	})
+
+#define SDL_CondBroadcast(__p0) \
+	({ \
+		SDL_cond * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_cond *))*(void**)(__base - 1414))(__t__p0));\
+	})
+
+#define SDL_CondWait(__p0, __p1) \
+	({ \
+		SDL_cond * __t__p0 = __p0;\
+		SDL_mutex * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_cond *, SDL_mutex *))*(void**)(__base - 1420))(__t__p0, __t__p1));\
+	})
+
+#define SDL_CondWaitTimeout(__p0, __p1, __p2) \
+	({ \
+		SDL_cond * __t__p0 = __p0;\
+		SDL_mutex * __t__p1 = __p1;\
+		Uint32  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_cond *, SDL_mutex *, Uint32 ))*(void**)(__base - 1426))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_GetPowerInfo(__p0, __p1) \
+	({ \
+		int * __t__p0 = __p0;\
+		int * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_PowerState (*)(int *, int *))*(void**)(__base - 1432))(__t__p0, __t__p1));\
+	})
+
+#define SDL_GetNumRenderDrivers() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(void))*(void**)(__base - 1438))());\
+	})
+
+#define SDL_GetRenderDriverInfo(__p0, __p1) \
+	({ \
+		int  __t__p0 = __p0;\
+		SDL_RendererInfo * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(int , SDL_RendererInfo *))*(void**)(__base - 1444))(__t__p0, __t__p1));\
+	})
+
+#define SDL_CreateWindowAndRenderer(__p0, __p1, __p2, __p3, __p4) \
+	({ \
+		int  __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		Uint32  __t__p2 = __p2;\
+		SDL_Window ** __t__p3 = __p3;\
+		SDL_Renderer ** __t__p4 = __p4;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(int , int , Uint32 , SDL_Window **, SDL_Renderer **))*(void**)(__base - 1450))(__t__p0, __t__p1, __t__p2, __t__p3, __t__p4));\
+	})
+
+#define SDL_CreateRenderer(__p0, __p1, __p2) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		Uint32  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_Renderer *(*)(SDL_Window *, int , Uint32 ))*(void**)(__base - 1456))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_CreateSoftwareRenderer(__p0) \
+	({ \
+		SDL_Surface * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_Renderer *(*)(SDL_Surface *))*(void**)(__base - 1462))(__t__p0));\
+	})
+
+#define SDL_GetRenderer(__p0) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_Renderer *(*)(SDL_Window *))*(void**)(__base - 1468))(__t__p0));\
+	})
+
+#define SDL_GetRendererInfo(__p0, __p1) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		SDL_RendererInfo * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Renderer *, SDL_RendererInfo *))*(void**)(__base - 1474))(__t__p0, __t__p1));\
+	})
+
+#define SDL_GetRendererOutputSize(__p0, __p1, __p2) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		int * __t__p1 = __p1;\
+		int * __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Renderer *, int *, int *))*(void**)(__base - 1480))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_CreateTexture(__p0, __p1, __p2, __p3, __p4) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		Uint32  __t__p1 = __p1;\
+		int  __t__p2 = __p2;\
+		int  __t__p3 = __p3;\
+		int  __t__p4 = __p4;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_Texture *(*)(SDL_Renderer *, Uint32 , int , int , int ))*(void**)(__base - 1486))(__t__p0, __t__p1, __t__p2, __t__p3, __t__p4));\
+	})
+
+#define SDL_CreateTextureFromSurface(__p0, __p1) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		SDL_Surface * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_Texture *(*)(SDL_Renderer *, SDL_Surface *))*(void**)(__base - 1492))(__t__p0, __t__p1));\
+	})
+
+#define SDL_QueryTexture(__p0, __p1, __p2, __p3, __p4) \
+	({ \
+		SDL_Texture * __t__p0 = __p0;\
+		Uint32 * __t__p1 = __p1;\
+		int * __t__p2 = __p2;\
+		int * __t__p3 = __p3;\
+		int * __t__p4 = __p4;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Texture *, Uint32 *, int *, int *, int *))*(void**)(__base - 1498))(__t__p0, __t__p1, __t__p2, __t__p3, __t__p4));\
+	})
+
+#define SDL_SetTextureColorMod(__p0, __p1, __p2, __p3) \
+	({ \
+		SDL_Texture * __t__p0 = __p0;\
+		Uint8  __t__p1 = __p1;\
+		Uint8  __t__p2 = __p2;\
+		Uint8  __t__p3 = __p3;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Texture *, Uint8 , Uint8 , Uint8 ))*(void**)(__base - 1504))(__t__p0, __t__p1, __t__p2, __t__p3));\
+	})
+
+#define SDL_GetTextureColorMod(__p0, __p1, __p2, __p3) \
+	({ \
+		SDL_Texture * __t__p0 = __p0;\
+		Uint8 * __t__p1 = __p1;\
+		Uint8 * __t__p2 = __p2;\
+		Uint8 * __t__p3 = __p3;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Texture *, Uint8 *, Uint8 *, Uint8 *))*(void**)(__base - 1510))(__t__p0, __t__p1, __t__p2, __t__p3));\
+	})
+
+#define SDL_SetTextureAlphaMod(__p0, __p1) \
+	({ \
+		SDL_Texture * __t__p0 = __p0;\
+		Uint8  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Texture *, Uint8 ))*(void**)(__base - 1516))(__t__p0, __t__p1));\
+	})
+
+#define SDL_GetTextureAlphaMod(__p0, __p1) \
+	({ \
+		SDL_Texture * __t__p0 = __p0;\
+		Uint8 * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Texture *, Uint8 *))*(void**)(__base - 1522))(__t__p0, __t__p1));\
+	})
+
+#define SDL_SetTextureBlendMode(__p0, __p1) \
+	({ \
+		SDL_Texture * __t__p0 = __p0;\
+		SDL_BlendMode  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Texture *, SDL_BlendMode ))*(void**)(__base - 1528))(__t__p0, __t__p1));\
+	})
+
+#define SDL_GetTextureBlendMode(__p0, __p1) \
+	({ \
+		SDL_Texture * __t__p0 = __p0;\
+		SDL_BlendMode * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Texture *, SDL_BlendMode *))*(void**)(__base - 1534))(__t__p0, __t__p1));\
+	})
+
+#define SDL_UpdateTexture(__p0, __p1, __p2, __p3) \
+	({ \
+		SDL_Texture * __t__p0 = __p0;\
+		const SDL_Rect * __t__p1 = __p1;\
+		const void * __t__p2 = __p2;\
+		int  __t__p3 = __p3;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Texture *, const SDL_Rect *, const void *, int ))*(void**)(__base - 1540))(__t__p0, __t__p1, __t__p2, __t__p3));\
+	})
+
+#define SDL_UpdateYUVTexture(__p0, __p1, __p2, __p3, __p4, __p5, __p6, __p7) \
+	({ \
+		SDL_Texture * __t__p0 = __p0;\
+		const SDL_Rect * __t__p1 = __p1;\
+		const Uint8 * __t__p2 = __p2;\
+		int  __t__p3 = __p3;\
+		const Uint8 * __t__p4 = __p4;\
+		int  __t__p5 = __p5;\
+		const Uint8 * __t__p6 = __p6;\
+		int  __t__p7 = __p7;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Texture *, const SDL_Rect *, const Uint8 *, int , const Uint8 *, int , const Uint8 *, int ))*(void**)(__base - 1546))(__t__p0, __t__p1, __t__p2, __t__p3, __t__p4, __t__p5, __t__p6, __t__p7));\
+	})
+
+#define SDL_LockTexture(__p0, __p1, __p2, __p3) \
+	({ \
+		SDL_Texture * __t__p0 = __p0;\
+		const SDL_Rect * __t__p1 = __p1;\
+		void ** __t__p2 = __p2;\
+		int * __t__p3 = __p3;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Texture *, const SDL_Rect *, void **, int *))*(void**)(__base - 1552))(__t__p0, __t__p1, __t__p2, __t__p3));\
+	})
+
+#define SDL_UnlockTexture(__p0) \
+	({ \
+		SDL_Texture * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_Texture *))*(void**)(__base - 1558))(__t__p0));\
+	})
+
+#define SDL_RenderTargetSupported(__p0) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(SDL_Renderer *))*(void**)(__base - 1564))(__t__p0));\
+	})
+
+#define SDL_SetRenderTarget(__p0, __p1) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		SDL_Texture * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Renderer *, SDL_Texture *))*(void**)(__base - 1570))(__t__p0, __t__p1));\
+	})
+
+#define SDL_GetRenderTarget(__p0) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_Texture *(*)(SDL_Renderer *))*(void**)(__base - 1576))(__t__p0));\
+	})
+
+#define SDL_RenderSetLogicalSize(__p0, __p1, __p2) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		int  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Renderer *, int , int ))*(void**)(__base - 1582))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_RenderGetLogicalSize(__p0, __p1, __p2) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		int * __t__p1 = __p1;\
+		int * __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_Renderer *, int *, int *))*(void**)(__base - 1588))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_RenderSetViewport(__p0, __p1) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		const SDL_Rect * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Renderer *, const SDL_Rect *))*(void**)(__base - 1594))(__t__p0, __t__p1));\
+	})
+
+#define SDL_RenderGetViewport(__p0, __p1) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		SDL_Rect * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_Renderer *, SDL_Rect *))*(void**)(__base - 1600))(__t__p0, __t__p1));\
+	})
+
+#define SDL_RenderSetClipRect(__p0, __p1) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		const SDL_Rect * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Renderer *, const SDL_Rect *))*(void**)(__base - 1606))(__t__p0, __t__p1));\
+	})
+
+#define SDL_RenderGetClipRect(__p0, __p1) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		SDL_Rect * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_Renderer *, SDL_Rect *))*(void**)(__base - 1612))(__t__p0, __t__p1));\
+	})
+
+#define SDL_RenderSetScale(__p0, __p1, __p2) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		float  __t__p1 = __p1;\
+		float  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Renderer *, float , float ))*(void**)(__base - 1618))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_RenderGetScale(__p0, __p1, __p2) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		float * __t__p1 = __p1;\
+		float * __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_Renderer *, float *, float *))*(void**)(__base - 1624))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_SetRenderDrawColor(__p0, __p1, __p2, __p3, __p4) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		Uint8  __t__p1 = __p1;\
+		Uint8  __t__p2 = __p2;\
+		Uint8  __t__p3 = __p3;\
+		Uint8  __t__p4 = __p4;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Renderer *, Uint8 , Uint8 , Uint8 , Uint8 ))*(void**)(__base - 1630))(__t__p0, __t__p1, __t__p2, __t__p3, __t__p4));\
+	})
+
+#define SDL_GetRenderDrawColor(__p0, __p1, __p2, __p3, __p4) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		Uint8 * __t__p1 = __p1;\
+		Uint8 * __t__p2 = __p2;\
+		Uint8 * __t__p3 = __p3;\
+		Uint8 * __t__p4 = __p4;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Renderer *, Uint8 *, Uint8 *, Uint8 *, Uint8 *))*(void**)(__base - 1636))(__t__p0, __t__p1, __t__p2, __t__p3, __t__p4));\
+	})
+
+#define SDL_SetRenderDrawBlendMode(__p0, __p1) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		SDL_BlendMode  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Renderer *, SDL_BlendMode ))*(void**)(__base - 1642))(__t__p0, __t__p1));\
+	})
+
+#define SDL_GetRenderDrawBlendMode(__p0, __p1) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		SDL_BlendMode * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Renderer *, SDL_BlendMode *))*(void**)(__base - 1648))(__t__p0, __t__p1));\
+	})
+
+#define SDL_RenderClear(__p0) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Renderer *))*(void**)(__base - 1654))(__t__p0));\
+	})
+
+#define SDL_RenderDrawPoint(__p0, __p1, __p2) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		int  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Renderer *, int , int ))*(void**)(__base - 1660))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_RenderDrawPoints(__p0, __p1, __p2) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		const SDL_Point * __t__p1 = __p1;\
+		int  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Renderer *, const SDL_Point *, int ))*(void**)(__base - 1666))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_RenderDrawLine(__p0, __p1, __p2, __p3, __p4) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		int  __t__p2 = __p2;\
+		int  __t__p3 = __p3;\
+		int  __t__p4 = __p4;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Renderer *, int , int , int , int ))*(void**)(__base - 1672))(__t__p0, __t__p1, __t__p2, __t__p3, __t__p4));\
+	})
+
+#define SDL_RenderDrawLines(__p0, __p1, __p2) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		const SDL_Point * __t__p1 = __p1;\
+		int  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Renderer *, const SDL_Point *, int ))*(void**)(__base - 1678))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_RenderDrawRect(__p0, __p1) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		const SDL_Rect * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Renderer *, const SDL_Rect *))*(void**)(__base - 1684))(__t__p0, __t__p1));\
+	})
+
+#define SDL_RenderDrawRects(__p0, __p1, __p2) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		const SDL_Rect * __t__p1 = __p1;\
+		int  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Renderer *, const SDL_Rect *, int ))*(void**)(__base - 1690))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_RenderFillRect(__p0, __p1) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		const SDL_Rect * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Renderer *, const SDL_Rect *))*(void**)(__base - 1696))(__t__p0, __t__p1));\
+	})
+
+#define SDL_RenderFillRects(__p0, __p1, __p2) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		const SDL_Rect * __t__p1 = __p1;\
+		int  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Renderer *, const SDL_Rect *, int ))*(void**)(__base - 1702))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_RenderCopy(__p0, __p1, __p2, __p3) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		SDL_Texture * __t__p1 = __p1;\
+		const SDL_Rect * __t__p2 = __p2;\
+		const SDL_Rect * __t__p3 = __p3;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Renderer *, SDL_Texture *, const SDL_Rect *, const SDL_Rect *))*(void**)(__base - 1708))(__t__p0, __t__p1, __t__p2, __t__p3));\
+	})
+
+#define SDL_RenderCopyEx(__p0, __p1, __p2, __p3, __p4, __p5, __p6) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		SDL_Texture * __t__p1 = __p1;\
+		const SDL_Rect * __t__p2 = __p2;\
+		const SDL_Rect * __t__p3 = __p3;\
+		const double  __t__p4 = __p4;\
+		const SDL_Point * __t__p5 = __p5;\
+		const SDL_RendererFlip  __t__p6 = __p6;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Renderer *, SDL_Texture *, const SDL_Rect *, const SDL_Rect *, const double , const SDL_Point *, const SDL_RendererFlip ))*(void**)(__base - 1714))(__t__p0, __t__p1, __t__p2, __t__p3, __t__p4, __t__p5, __t__p6));\
+	})
+
+#define SDL_RenderReadPixels(__p0, __p1, __p2, __p3, __p4) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		const SDL_Rect * __t__p1 = __p1;\
+		Uint32  __t__p2 = __p2;\
+		void * __t__p3 = __p3;\
+		int  __t__p4 = __p4;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Renderer *, const SDL_Rect *, Uint32 , void *, int ))*(void**)(__base - 1720))(__t__p0, __t__p1, __t__p2, __t__p3, __t__p4));\
+	})
+
+#define SDL_RenderPresent(__p0) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_Renderer *))*(void**)(__base - 1726))(__t__p0));\
+	})
+
+#define SDL_DestroyTexture(__p0) \
+	({ \
+		SDL_Texture * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_Texture *))*(void**)(__base - 1732))(__t__p0));\
+	})
+
+#define SDL_DestroyRenderer(__p0) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_Renderer *))*(void**)(__base - 1738))(__t__p0));\
+	})
+
+#define SDL_GL_BindTexture(__p0, __p1, __p2) \
+	({ \
+		SDL_Texture * __t__p0 = __p0;\
+		float * __t__p1 = __p1;\
+		float * __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Texture *, float *, float *))*(void**)(__base - 1744))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_GL_UnbindTexture(__p0) \
+	({ \
+		SDL_Texture * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Texture *))*(void**)(__base - 1750))(__t__p0));\
+	})
+
+#define SDL_RWFromFile(__p0, __p1) \
+	({ \
+		const char * __t__p0 = __p0;\
+		const char * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_RWops *(*)(const char *, const char *))*(void**)(__base - 1756))(__t__p0, __t__p1));\
+	})
+
+#define SDL_RWFromMem(__p0, __p1) \
+	({ \
+		void * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_RWops *(*)(void *, int ))*(void**)(__base - 1768))(__t__p0, __t__p1));\
+	})
+
+#define SDL_RWFromConstMem(__p0, __p1) \
+	({ \
+		const void * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_RWops *(*)(const void *, int ))*(void**)(__base - 1774))(__t__p0, __t__p1));\
+	})
+
+#define SDL_AllocRW() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_RWops *(*)(void))*(void**)(__base - 1780))());\
+	})
+
+#define SDL_FreeRW(__p0) \
+	({ \
+		SDL_RWops * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_RWops *))*(void**)(__base - 1786))(__t__p0));\
+	})
+
+#define SDL_ReadU8(__p0) \
+	({ \
+		SDL_RWops * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((Uint8 (*)(SDL_RWops *))*(void**)(__base - 1792))(__t__p0));\
+	})
+
+#define SDL_ReadLE16(__p0) \
+	({ \
+		SDL_RWops * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((Uint16 (*)(SDL_RWops *))*(void**)(__base - 1798))(__t__p0));\
+	})
+
+#define SDL_ReadBE16(__p0) \
+	({ \
+		SDL_RWops * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((Uint16 (*)(SDL_RWops *))*(void**)(__base - 1804))(__t__p0));\
+	})
+
+#define SDL_ReadLE32(__p0) \
+	({ \
+		SDL_RWops * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((Uint32 (*)(SDL_RWops *))*(void**)(__base - 1810))(__t__p0));\
+	})
+
+#define SDL_ReadBE32(__p0) \
+	({ \
+		SDL_RWops * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((Uint32 (*)(SDL_RWops *))*(void**)(__base - 1816))(__t__p0));\
+	})
+
+#define SDL_ReadLE64(__p0) \
+	({ \
+		SDL_RWops * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((Uint64 (*)(SDL_RWops *))*(void**)(__base - 1822))(__t__p0));\
+	})
+
+#define SDL_ReadBE64(__p0) \
+	({ \
+		SDL_RWops * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((Uint64 (*)(SDL_RWops *))*(void**)(__base - 1828))(__t__p0));\
+	})
+
+#define SDL_WriteU8(__p0, __p1) \
+	({ \
+		SDL_RWops * __t__p0 = __p0;\
+		Uint8  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((size_t (*)(SDL_RWops *, Uint8 ))*(void**)(__base - 1834))(__t__p0, __t__p1));\
+	})
+
+#define SDL_WriteLE16(__p0, __p1) \
+	({ \
+		SDL_RWops * __t__p0 = __p0;\
+		Uint16  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((size_t (*)(SDL_RWops *, Uint16 ))*(void**)(__base - 1840))(__t__p0, __t__p1));\
+	})
+
+#define SDL_WriteBE16(__p0, __p1) \
+	({ \
+		SDL_RWops * __t__p0 = __p0;\
+		Uint16  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((size_t (*)(SDL_RWops *, Uint16 ))*(void**)(__base - 1846))(__t__p0, __t__p1));\
+	})
+
+#define SDL_WriteLE32(__p0, __p1) \
+	({ \
+		SDL_RWops * __t__p0 = __p0;\
+		Uint32  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((size_t (*)(SDL_RWops *, Uint32 ))*(void**)(__base - 1852))(__t__p0, __t__p1));\
+	})
+
+#define SDL_WriteBE32(__p0, __p1) \
+	({ \
+		SDL_RWops * __t__p0 = __p0;\
+		Uint32  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((size_t (*)(SDL_RWops *, Uint32 ))*(void**)(__base - 1858))(__t__p0, __t__p1));\
+	})
+
+#define SDL_WriteLE64(__p0, __p1) \
+	({ \
+		SDL_RWops * __t__p0 = __p0;\
+		Uint64  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((size_t (*)(SDL_RWops *, Uint64 ))*(void**)(__base - 1864))(__t__p0, __t__p1));\
+	})
+
+#define SDL_WriteBE64(__p0, __p1) \
+	({ \
+		SDL_RWops * __t__p0 = __p0;\
+		Uint64  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((size_t (*)(SDL_RWops *, Uint64 ))*(void**)(__base - 1870))(__t__p0, __t__p1));\
+	})
+
+#define SDL_CreateThread(__p0, __p1, __p2) \
+	({ \
+		SDL_ThreadFunction  __t__p0 = __p0;\
+		const char * __t__p1 = __p1;\
+		void * __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_Thread *(*)(SDL_ThreadFunction , const char *, void *))*(void**)(__base - 1876))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_GetThreadName(__p0) \
+	({ \
+		SDL_Thread * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((const char *(*)(SDL_Thread *))*(void**)(__base - 1882))(__t__p0));\
+	})
+
+#define SDL_ThreadID() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_threadID (*)(void))*(void**)(__base - 1888))());\
+	})
+
+#define SDL_GetThreadID(__p0) \
+	({ \
+		SDL_Thread * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_threadID (*)(SDL_Thread *))*(void**)(__base - 1894))(__t__p0));\
+	})
+
+#define SDL_SetThreadPriority(__p0) \
+	({ \
+		SDL_ThreadPriority  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_ThreadPriority ))*(void**)(__base - 1900))(__t__p0));\
+	})
+
+#define SDL_WaitThread(__p0, __p1) \
+	({ \
+		SDL_Thread * __t__p0 = __p0;\
+		int * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_Thread *, int *))*(void**)(__base - 1906))(__t__p0, __t__p1));\
+	})
+
+#define SDL_DetachThread(__p0) \
+	({ \
+		SDL_Thread * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_Thread *))*(void**)(__base - 1912))(__t__p0));\
+	})
+
+#define SDL_TLSCreate() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_TLSID (*)(void))*(void**)(__base - 1918))());\
+	})
+
+#define SDL_TLSGet(__p0) \
+	({ \
+		SDL_TLSID  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void *(*)(SDL_TLSID ))*(void**)(__base - 1924))(__t__p0));\
+	})
+
+#define SDL_TLSSet(__p0, __p1, __p2) \
+	({ \
+		SDL_TLSID  __t__p0 = __p0;\
+		const void * __t__p1 = __p1;\
+		SDL_TLSDestructorCallback  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_TLSID , const void *, SDL_TLSDestructorCallback ))*(void**)(__base - 1930))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_GetTicks() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((Uint32 (*)(void))*(void**)(__base - 1936))());\
+	})
+
+#define SDL_GetPerformanceCounter() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((Uint64 (*)(void))*(void**)(__base - 1942))());\
+	})
+
+#define SDL_GetPerformanceFrequency() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((Uint64 (*)(void))*(void**)(__base - 1948))());\
+	})
+
+#define SDL_Delay(__p0) \
+	({ \
+		Uint32  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(Uint32 ))*(void**)(__base - 1954))(__t__p0));\
+	})
+
+#define SDL_AddTimer(__p0, __p1, __p2) \
+	({ \
+		Uint32  __t__p0 = __p0;\
+		SDL_TimerCallback  __t__p1 = __p1;\
+		void * __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_TimerID (*)(Uint32 , SDL_TimerCallback , void *))*(void**)(__base - 1960))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_RemoveTimer(__p0) \
+	({ \
+		SDL_TimerID  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(SDL_TimerID ))*(void**)(__base - 1966))(__t__p0));\
+	})
+
+#define SDL_GetVersion(__p0) \
+	({ \
+		SDL_version * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_version *))*(void**)(__base - 1972))(__t__p0));\
+	})
+
+#define SDL_GetRevision() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((const char *(*)(void))*(void**)(__base - 1978))());\
+	})
+
+#define SDL_GetRevisionNumber() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(void))*(void**)(__base - 1984))());\
+	})
+
+#define SDL_GetNumVideoDrivers() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(void))*(void**)(__base - 1990))());\
+	})
+
+#define SDL_GetVideoDriver(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((const char *(*)(int ))*(void**)(__base - 1996))(__t__p0));\
+	})
+
+#define SDL_VideoInit(__p0) \
+	({ \
+		const char * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(const char *))*(void**)(__base - 2002))(__t__p0));\
+	})
+
+#define SDL_VideoQuit() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(void))*(void**)(__base - 2008))());\
+	})
+
+#define SDL_GetCurrentVideoDriver() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((const char *(*)(void))*(void**)(__base - 2014))());\
+	})
+
+#define SDL_GetNumVideoDisplays() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(void))*(void**)(__base - 2020))());\
+	})
+
+#define SDL_GetDisplayName(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((const char *(*)(int ))*(void**)(__base - 2026))(__t__p0));\
+	})
+
+#define SDL_GetDisplayBounds(__p0, __p1) \
+	({ \
+		int  __t__p0 = __p0;\
+		SDL_Rect * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(int , SDL_Rect *))*(void**)(__base - 2032))(__t__p0, __t__p1));\
+	})
+
+#define SDL_GetNumDisplayModes(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(int ))*(void**)(__base - 2038))(__t__p0));\
+	})
+
+#define SDL_GetDisplayMode(__p0, __p1, __p2) \
+	({ \
+		int  __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		SDL_DisplayMode * __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(int , int , SDL_DisplayMode *))*(void**)(__base - 2044))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_GetDesktopDisplayMode(__p0, __p1) \
+	({ \
+		int  __t__p0 = __p0;\
+		SDL_DisplayMode * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(int , SDL_DisplayMode *))*(void**)(__base - 2050))(__t__p0, __t__p1));\
+	})
+
+#define SDL_GetCurrentDisplayMode(__p0, __p1) \
+	({ \
+		int  __t__p0 = __p0;\
+		SDL_DisplayMode * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(int , SDL_DisplayMode *))*(void**)(__base - 2056))(__t__p0, __t__p1));\
+	})
+
+#define SDL_GetClosestDisplayMode(__p0, __p1, __p2) \
+	({ \
+		int  __t__p0 = __p0;\
+		const SDL_DisplayMode * __t__p1 = __p1;\
+		SDL_DisplayMode * __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_DisplayMode *(*)(int , const SDL_DisplayMode *, SDL_DisplayMode *))*(void**)(__base - 2062))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_GetWindowDisplayIndex(__p0) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Window *))*(void**)(__base - 2068))(__t__p0));\
+	})
+
+#define SDL_SetWindowDisplayMode(__p0, __p1) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		const SDL_DisplayMode * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Window *, const SDL_DisplayMode *))*(void**)(__base - 2074))(__t__p0, __t__p1));\
+	})
+
+#define SDL_GetWindowDisplayMode(__p0, __p1) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		SDL_DisplayMode * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Window *, SDL_DisplayMode *))*(void**)(__base - 2080))(__t__p0, __t__p1));\
+	})
+
+#define SDL_GetWindowPixelFormat(__p0) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((Uint32 (*)(SDL_Window *))*(void**)(__base - 2086))(__t__p0));\
+	})
+
+#define SDL_CreateWindow(__p0, __p1, __p2, __p3, __p4, __p5) \
+	({ \
+		const char * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		int  __t__p2 = __p2;\
+		int  __t__p3 = __p3;\
+		int  __t__p4 = __p4;\
+		Uint32  __t__p5 = __p5;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_Window *(*)(const char *, int , int , int , int , Uint32 ))*(void**)(__base - 2092))(__t__p0, __t__p1, __t__p2, __t__p3, __t__p4, __t__p5));\
+	})
+
+#define SDL_CreateWindowFrom(__p0) \
+	({ \
+		const void * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_Window *(*)(const void *))*(void**)(__base - 2098))(__t__p0));\
+	})
+
+#define SDL_GetWindowID(__p0) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((Uint32 (*)(SDL_Window *))*(void**)(__base - 2104))(__t__p0));\
+	})
+
+#define SDL_GetWindowFromID(__p0) \
+	({ \
+		Uint32  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_Window *(*)(Uint32 ))*(void**)(__base - 2110))(__t__p0));\
+	})
+
+#define SDL_GetWindowFlags(__p0) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((Uint32 (*)(SDL_Window *))*(void**)(__base - 2116))(__t__p0));\
+	})
+
+#define SDL_SetWindowTitle(__p0, __p1) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		const char * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_Window *, const char *))*(void**)(__base - 2122))(__t__p0, __t__p1));\
+	})
+
+#define SDL_GetWindowTitle(__p0) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((const char *(*)(SDL_Window *))*(void**)(__base - 2128))(__t__p0));\
+	})
+
+#define SDL_SetWindowIcon(__p0, __p1) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		SDL_Surface * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_Window *, SDL_Surface *))*(void**)(__base - 2134))(__t__p0, __t__p1));\
+	})
+
+#define SDL_SetWindowData(__p0, __p1, __p2) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		const char * __t__p1 = __p1;\
+		void * __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void *(*)(SDL_Window *, const char *, void *))*(void**)(__base - 2140))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_GetWindowData(__p0, __p1) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		const char * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void *(*)(SDL_Window *, const char *))*(void**)(__base - 2146))(__t__p0, __t__p1));\
+	})
+
+#define SDL_SetWindowPosition(__p0, __p1, __p2) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		int  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_Window *, int , int ))*(void**)(__base - 2152))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_GetWindowPosition(__p0, __p1, __p2) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		int * __t__p1 = __p1;\
+		int * __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_Window *, int *, int *))*(void**)(__base - 2158))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_SetWindowSize(__p0, __p1, __p2) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		int  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_Window *, int , int ))*(void**)(__base - 2164))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_GetWindowSize(__p0, __p1, __p2) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		int * __t__p1 = __p1;\
+		int * __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_Window *, int *, int *))*(void**)(__base - 2170))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_SetWindowMinimumSize(__p0, __p1, __p2) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		int  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_Window *, int , int ))*(void**)(__base - 2176))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_GetWindowMinimumSize(__p0, __p1, __p2) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		int * __t__p1 = __p1;\
+		int * __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_Window *, int *, int *))*(void**)(__base - 2182))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_SetWindowMaximumSize(__p0, __p1, __p2) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		int  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_Window *, int , int ))*(void**)(__base - 2188))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_GetWindowMaximumSize(__p0, __p1, __p2) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		int * __t__p1 = __p1;\
+		int * __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_Window *, int *, int *))*(void**)(__base - 2194))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_SetWindowBordered(__p0, __p1) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		SDL_bool  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_Window *, SDL_bool ))*(void**)(__base - 2200))(__t__p0, __t__p1));\
+	})
+
+#define SDL_ShowWindow(__p0) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_Window *))*(void**)(__base - 2206))(__t__p0));\
+	})
+
+#define SDL_HideWindow(__p0) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_Window *))*(void**)(__base - 2212))(__t__p0));\
+	})
+
+#define SDL_RaiseWindow(__p0) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_Window *))*(void**)(__base - 2218))(__t__p0));\
+	})
+
+#define SDL_MaximizeWindow(__p0) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_Window *))*(void**)(__base - 2224))(__t__p0));\
+	})
+
+#define SDL_MinimizeWindow(__p0) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_Window *))*(void**)(__base - 2230))(__t__p0));\
+	})
+
+#define SDL_RestoreWindow(__p0) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_Window *))*(void**)(__base - 2236))(__t__p0));\
+	})
+
+#define SDL_SetWindowFullscreen(__p0, __p1) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		Uint32  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Window *, Uint32 ))*(void**)(__base - 2242))(__t__p0, __t__p1));\
+	})
+
+#define SDL_GetWindowSurface(__p0) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_Surface *(*)(SDL_Window *))*(void**)(__base - 2248))(__t__p0));\
+	})
+
+#define SDL_UpdateWindowSurface(__p0) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Window *))*(void**)(__base - 2254))(__t__p0));\
+	})
+
+#define SDL_UpdateWindowSurfaceRects(__p0, __p1, __p2) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		const SDL_Rect * __t__p1 = __p1;\
+		int  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Window *, const SDL_Rect *, int ))*(void**)(__base - 2260))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_SetWindowGrab(__p0, __p1) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		SDL_bool  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_Window *, SDL_bool ))*(void**)(__base - 2266))(__t__p0, __t__p1));\
+	})
+
+#define SDL_GetWindowGrab(__p0) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(SDL_Window *))*(void**)(__base - 2272))(__t__p0));\
+	})
+
+#define SDL_SetWindowBrightness(__p0, __p1) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		float  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Window *, float ))*(void**)(__base - 2278))(__t__p0, __t__p1));\
+	})
+
+#define SDL_GetWindowBrightness(__p0) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((float (*)(SDL_Window *))*(void**)(__base - 2284))(__t__p0));\
+	})
+
+#define SDL_SetWindowGammaRamp(__p0, __p1, __p2, __p3) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		const Uint16 * __t__p1 = __p1;\
+		const Uint16 * __t__p2 = __p2;\
+		const Uint16 * __t__p3 = __p3;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Window *, const Uint16 *, const Uint16 *, const Uint16 *))*(void**)(__base - 2290))(__t__p0, __t__p1, __t__p2, __t__p3));\
+	})
+
+#define SDL_GetWindowGammaRamp(__p0, __p1, __p2, __p3) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		Uint16 * __t__p1 = __p1;\
+		Uint16 * __t__p2 = __p2;\
+		Uint16 * __t__p3 = __p3;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Window *, Uint16 *, Uint16 *, Uint16 *))*(void**)(__base - 2296))(__t__p0, __t__p1, __t__p2, __t__p3));\
+	})
+
+#define SDL_DestroyWindow(__p0) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_Window *))*(void**)(__base - 2302))(__t__p0));\
+	})
+
+#define SDL_IsScreenSaverEnabled() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(void))*(void**)(__base - 2308))());\
+	})
+
+#define SDL_EnableScreenSaver() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(void))*(void**)(__base - 2314))());\
+	})
+
+#define SDL_DisableScreenSaver() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(void))*(void**)(__base - 2320))());\
+	})
+
+#define SDL_GetKeyboardFocus() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_Window *(*)(void))*(void**)(__base - 2326))());\
+	})
+
+#define SDL_GetKeyboardState(__p0) \
+	({ \
+		int * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((const Uint8 *(*)(int *))*(void**)(__base - 2332))(__t__p0));\
+	})
+
+#define SDL_GetModState() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_Keymod (*)(void))*(void**)(__base - 2338))());\
+	})
+
+#define SDL_SetModState(__p0) \
+	({ \
+		SDL_Keymod  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_Keymod ))*(void**)(__base - 2344))(__t__p0));\
+	})
+
+#define SDL_GetKeyFromScancode(__p0) \
+	({ \
+		SDL_Scancode  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_Keycode (*)(SDL_Scancode ))*(void**)(__base - 2350))(__t__p0));\
+	})
+
+#define SDL_GetScancodeFromKey(__p0) \
+	({ \
+		SDL_Keycode  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_Scancode (*)(SDL_Keycode ))*(void**)(__base - 2356))(__t__p0));\
+	})
+
+#define SDL_GetScancodeName(__p0) \
+	({ \
+		SDL_Scancode  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((const char *(*)(SDL_Scancode ))*(void**)(__base - 2362))(__t__p0));\
+	})
+
+#define SDL_GetScancodeFromName(__p0) \
+	({ \
+		const char * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_Scancode (*)(const char *))*(void**)(__base - 2368))(__t__p0));\
+	})
+
+#define SDL_GetKeyName(__p0) \
+	({ \
+		SDL_Keycode  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((const char *(*)(SDL_Keycode ))*(void**)(__base - 2374))(__t__p0));\
+	})
+
+#define SDL_GetKeyFromName(__p0) \
+	({ \
+		const char * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_Keycode (*)(const char *))*(void**)(__base - 2380))(__t__p0));\
+	})
+
+#define SDL_StartTextInput() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(void))*(void**)(__base - 2386))());\
+	})
+
+#define SDL_IsTextInputActive() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(void))*(void**)(__base - 2392))());\
+	})
+
+#define SDL_StopTextInput() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(void))*(void**)(__base - 2398))());\
+	})
+
+#define SDL_SetTextInputRect(__p0) \
+	({ \
+		const SDL_Rect * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(const SDL_Rect *))*(void**)(__base - 2404))(__t__p0));\
+	})
+
+#define SDL_HasScreenKeyboardSupport() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(void))*(void**)(__base - 2410))());\
+	})
+
+#define SDL_IsScreenKeyboardShown(__p0) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(SDL_Window *))*(void**)(__base - 2416))(__t__p0));\
+	})
+
+#define SDL_CreateRGBSurface(__p0, __p1, __p2, __p3, __p4, __p5, __p6, __p7) \
+	({ \
+		Uint32  __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		int  __t__p2 = __p2;\
+		int  __t__p3 = __p3;\
+		Uint32  __t__p4 = __p4;\
+		Uint32  __t__p5 = __p5;\
+		Uint32  __t__p6 = __p6;\
+		Uint32  __t__p7 = __p7;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_Surface *(*)(Uint32 , int , int , int , Uint32 , Uint32 , Uint32 , Uint32 ))*(void**)(__base - 2422))(__t__p0, __t__p1, __t__p2, __t__p3, __t__p4, __t__p5, __t__p6, __t__p7));\
+	})
+
+#define SDL_CreateRGBSurfaceFrom(__p0, __p1, __p2, __p3, __p4, __p5, __p6, __p7, __p8) \
+	({ \
+		void * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		int  __t__p2 = __p2;\
+		int  __t__p3 = __p3;\
+		int  __t__p4 = __p4;\
+		Uint32  __t__p5 = __p5;\
+		Uint32  __t__p6 = __p6;\
+		Uint32  __t__p7 = __p7;\
+		Uint32  __t__p8 = __p8;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_Surface *(*)(void *, int , int , int , int , Uint32 , Uint32 , Uint32 , Uint32 ))*(void**)(__base - 2428))(__t__p0, __t__p1, __t__p2, __t__p3, __t__p4, __t__p5, __t__p6, __t__p7, __t__p8));\
+	})
+
+#define SDL_FreeSurface(__p0) \
+	({ \
+		SDL_Surface * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_Surface *))*(void**)(__base - 2434))(__t__p0));\
+	})
+
+#define SDL_SetSurfacePalette(__p0, __p1) \
+	({ \
+		SDL_Surface * __t__p0 = __p0;\
+		SDL_Palette * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Surface *, SDL_Palette *))*(void**)(__base - 2440))(__t__p0, __t__p1));\
+	})
+
+#define SDL_LockSurface(__p0) \
+	({ \
+		SDL_Surface * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Surface *))*(void**)(__base - 2446))(__t__p0));\
+	})
+
+#define SDL_UnlockSurface(__p0) \
+	({ \
+		SDL_Surface * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_Surface *))*(void**)(__base - 2452))(__t__p0));\
+	})
+
+#define SDL_LoadBMP_RW(__p0, __p1) \
+	({ \
+		SDL_RWops * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_Surface *(*)(SDL_RWops *, int ))*(void**)(__base - 2458))(__t__p0, __t__p1));\
+	})
+
+#define SDL_SaveBMP_RW(__p0, __p1, __p2) \
+	({ \
+		SDL_Surface * __t__p0 = __p0;\
+		SDL_RWops * __t__p1 = __p1;\
+		int  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Surface *, SDL_RWops *, int ))*(void**)(__base - 2464))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_SetSurfaceRLE(__p0, __p1) \
+	({ \
+		SDL_Surface * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Surface *, int ))*(void**)(__base - 2470))(__t__p0, __t__p1));\
+	})
+
+#define SDL_SetColorKey(__p0, __p1, __p2) \
+	({ \
+		SDL_Surface * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		Uint32  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Surface *, int , Uint32 ))*(void**)(__base - 2476))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_GetColorKey(__p0, __p1) \
+	({ \
+		SDL_Surface * __t__p0 = __p0;\
+		Uint32 * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Surface *, Uint32 *))*(void**)(__base - 2482))(__t__p0, __t__p1));\
+	})
+
+#define SDL_SetSurfaceColorMod(__p0, __p1, __p2, __p3) \
+	({ \
+		SDL_Surface * __t__p0 = __p0;\
+		Uint8  __t__p1 = __p1;\
+		Uint8  __t__p2 = __p2;\
+		Uint8  __t__p3 = __p3;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Surface *, Uint8 , Uint8 , Uint8 ))*(void**)(__base - 2488))(__t__p0, __t__p1, __t__p2, __t__p3));\
+	})
+
+#define SDL_GetSurfaceColorMod(__p0, __p1, __p2, __p3) \
+	({ \
+		SDL_Surface * __t__p0 = __p0;\
+		Uint8 * __t__p1 = __p1;\
+		Uint8 * __t__p2 = __p2;\
+		Uint8 * __t__p3 = __p3;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Surface *, Uint8 *, Uint8 *, Uint8 *))*(void**)(__base - 2494))(__t__p0, __t__p1, __t__p2, __t__p3));\
+	})
+
+#define SDL_SetSurfaceAlphaMod(__p0, __p1) \
+	({ \
+		SDL_Surface * __t__p0 = __p0;\
+		Uint8  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Surface *, Uint8 ))*(void**)(__base - 2500))(__t__p0, __t__p1));\
+	})
+
+#define SDL_GetSurfaceAlphaMod(__p0, __p1) \
+	({ \
+		SDL_Surface * __t__p0 = __p0;\
+		Uint8 * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Surface *, Uint8 *))*(void**)(__base - 2506))(__t__p0, __t__p1));\
+	})
+
+#define SDL_SetSurfaceBlendMode(__p0, __p1) \
+	({ \
+		SDL_Surface * __t__p0 = __p0;\
+		SDL_BlendMode  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Surface *, SDL_BlendMode ))*(void**)(__base - 2512))(__t__p0, __t__p1));\
+	})
+
+#define SDL_GetSurfaceBlendMode(__p0, __p1) \
+	({ \
+		SDL_Surface * __t__p0 = __p0;\
+		SDL_BlendMode * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Surface *, SDL_BlendMode *))*(void**)(__base - 2518))(__t__p0, __t__p1));\
+	})
+
+#define SDL_SetClipRect(__p0, __p1) \
+	({ \
+		SDL_Surface * __t__p0 = __p0;\
+		const SDL_Rect * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(SDL_Surface *, const SDL_Rect *))*(void**)(__base - 2524))(__t__p0, __t__p1));\
+	})
+
+#define SDL_GetClipRect(__p0, __p1) \
+	({ \
+		SDL_Surface * __t__p0 = __p0;\
+		SDL_Rect * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_Surface *, SDL_Rect *))*(void**)(__base - 2530))(__t__p0, __t__p1));\
+	})
+
+#define SDL_ConvertSurface(__p0, __p1, __p2) \
+	({ \
+		SDL_Surface * __t__p0 = __p0;\
+		const SDL_PixelFormat * __t__p1 = __p1;\
+		Uint32  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_Surface *(*)(SDL_Surface *, const SDL_PixelFormat *, Uint32 ))*(void**)(__base - 2536))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_ConvertSurfaceFormat(__p0, __p1, __p2) \
+	({ \
+		SDL_Surface * __t__p0 = __p0;\
+		Uint32  __t__p1 = __p1;\
+		Uint32  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_Surface *(*)(SDL_Surface *, Uint32 , Uint32 ))*(void**)(__base - 2542))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_ConvertPixels(__p0, __p1, __p2, __p3, __p4, __p5, __p6, __p7) \
+	({ \
+		int  __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		Uint32  __t__p2 = __p2;\
+		const void * __t__p3 = __p3;\
+		int  __t__p4 = __p4;\
+		Uint32  __t__p5 = __p5;\
+		void * __t__p6 = __p6;\
+		int  __t__p7 = __p7;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(int , int , Uint32 , const void *, int , Uint32 , void *, int ))*(void**)(__base - 2548))(__t__p0, __t__p1, __t__p2, __t__p3, __t__p4, __t__p5, __t__p6, __t__p7));\
+	})
+
+#define SDL_FillRect(__p0, __p1, __p2) \
+	({ \
+		SDL_Surface * __t__p0 = __p0;\
+		const SDL_Rect * __t__p1 = __p1;\
+		Uint32  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Surface *, const SDL_Rect *, Uint32 ))*(void**)(__base - 2554))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_FillRects(__p0, __p1, __p2, __p3) \
+	({ \
+		SDL_Surface * __t__p0 = __p0;\
+		const SDL_Rect * __t__p1 = __p1;\
+		int  __t__p2 = __p2;\
+		Uint32  __t__p3 = __p3;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Surface *, const SDL_Rect *, int , Uint32 ))*(void**)(__base - 2560))(__t__p0, __t__p1, __t__p2, __t__p3));\
+	})
+
+#define SDL_UpperBlit(__p0, __p1, __p2, __p3) \
+	({ \
+		SDL_Surface * __t__p0 = __p0;\
+		const SDL_Rect * __t__p1 = __p1;\
+		SDL_Surface * __t__p2 = __p2;\
+		SDL_Rect * __t__p3 = __p3;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Surface *, const SDL_Rect *, SDL_Surface *, SDL_Rect *))*(void**)(__base - 2566))(__t__p0, __t__p1, __t__p2, __t__p3));\
+	})
+
+#define SDL_LowerBlit(__p0, __p1, __p2, __p3) \
+	({ \
+		SDL_Surface * __t__p0 = __p0;\
+		SDL_Rect * __t__p1 = __p1;\
+		SDL_Surface * __t__p2 = __p2;\
+		SDL_Rect * __t__p3 = __p3;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Surface *, SDL_Rect *, SDL_Surface *, SDL_Rect *))*(void**)(__base - 2572))(__t__p0, __t__p1, __t__p2, __t__p3));\
+	})
+
+#define SDL_SoftStretch(__p0, __p1, __p2, __p3) \
+	({ \
+		SDL_Surface * __t__p0 = __p0;\
+		const SDL_Rect * __t__p1 = __p1;\
+		SDL_Surface * __t__p2 = __p2;\
+		const SDL_Rect * __t__p3 = __p3;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Surface *, const SDL_Rect *, SDL_Surface *, const SDL_Rect *))*(void**)(__base - 2578))(__t__p0, __t__p1, __t__p2, __t__p3));\
+	})
+
+#define SDL_UpperBlitScaled(__p0, __p1, __p2, __p3) \
+	({ \
+		SDL_Surface * __t__p0 = __p0;\
+		const SDL_Rect * __t__p1 = __p1;\
+		SDL_Surface * __t__p2 = __p2;\
+		SDL_Rect * __t__p3 = __p3;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Surface *, const SDL_Rect *, SDL_Surface *, SDL_Rect *))*(void**)(__base - 2584))(__t__p0, __t__p1, __t__p2, __t__p3));\
+	})
+
+#define SDL_LowerBlitScaled(__p0, __p1, __p2, __p3) \
+	({ \
+		SDL_Surface * __t__p0 = __p0;\
+		SDL_Rect * __t__p1 = __p1;\
+		SDL_Surface * __t__p2 = __p2;\
+		SDL_Rect * __t__p3 = __p3;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Surface *, SDL_Rect *, SDL_Surface *, SDL_Rect *))*(void**)(__base - 2590))(__t__p0, __t__p1, __t__p2, __t__p3));\
+	})
+
+#define SDL_GetMouseFocus() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_Window *(*)(void))*(void**)(__base - 2596))());\
+	})
+
+#define SDL_GetMouseState(__p0, __p1) \
+	({ \
+		int * __t__p0 = __p0;\
+		int * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((Uint32 (*)(int *, int *))*(void**)(__base - 2602))(__t__p0, __t__p1));\
+	})
+
+#define SDL_GetRelativeMouseState(__p0, __p1) \
+	({ \
+		int * __t__p0 = __p0;\
+		int * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((Uint32 (*)(int *, int *))*(void**)(__base - 2608))(__t__p0, __t__p1));\
+	})
+
+#define SDL_WarpMouseInWindow(__p0, __p1, __p2) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		int  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_Window *, int , int ))*(void**)(__base - 2614))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_SetRelativeMouseMode(__p0) \
+	({ \
+		SDL_bool  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_bool ))*(void**)(__base - 2620))(__t__p0));\
+	})
+
+#define SDL_GetRelativeMouseMode() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(void))*(void**)(__base - 2626))());\
+	})
+
+#define SDL_CreateCursor(__p0, __p1, __p2, __p3, __p4, __p5) \
+	({ \
+		const Uint8 * __t__p0 = __p0;\
+		const Uint8 * __t__p1 = __p1;\
+		int  __t__p2 = __p2;\
+		int  __t__p3 = __p3;\
+		int  __t__p4 = __p4;\
+		int  __t__p5 = __p5;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_Cursor *(*)(const Uint8 *, const Uint8 *, int , int , int , int ))*(void**)(__base - 2632))(__t__p0, __t__p1, __t__p2, __t__p3, __t__p4, __t__p5));\
+	})
+
+#define SDL_CreateColorCursor(__p0, __p1, __p2) \
+	({ \
+		SDL_Surface * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		int  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_Cursor *(*)(SDL_Surface *, int , int ))*(void**)(__base - 2638))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_CreateSystemCursor(__p0) \
+	({ \
+		SDL_SystemCursor  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_Cursor *(*)(SDL_SystemCursor ))*(void**)(__base - 2644))(__t__p0));\
+	})
+
+#define SDL_SetCursor(__p0) \
+	({ \
+		SDL_Cursor * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_Cursor *))*(void**)(__base - 2650))(__t__p0));\
+	})
+
+#define SDL_GetCursor() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_Cursor *(*)(void))*(void**)(__base - 2656))());\
+	})
+
+#define SDL_GetDefaultCursor() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_Cursor *(*)(void))*(void**)(__base - 2662))());\
+	})
+
+#define SDL_FreeCursor(__p0) \
+	({ \
+		SDL_Cursor * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_Cursor *))*(void**)(__base - 2668))(__t__p0));\
+	})
+
+#define SDL_ShowCursor(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(int ))*(void**)(__base - 2674))(__t__p0));\
+	})
+
+#define SDL_GetPixelFormatName(__p0) \
+	({ \
+		Uint32  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((const char *(*)(Uint32 ))*(void**)(__base - 2680))(__t__p0));\
+	})
+
+#define SDL_PixelFormatEnumToMasks(__p0, __p1, __p2, __p3, __p4, __p5) \
+	({ \
+		Uint32  __t__p0 = __p0;\
+		int * __t__p1 = __p1;\
+		Uint32 * __t__p2 = __p2;\
+		Uint32 * __t__p3 = __p3;\
+		Uint32 * __t__p4 = __p4;\
+		Uint32 * __t__p5 = __p5;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(Uint32 , int *, Uint32 *, Uint32 *, Uint32 *, Uint32 *))*(void**)(__base - 2686))(__t__p0, __t__p1, __t__p2, __t__p3, __t__p4, __t__p5));\
+	})
+
+#define SDL_MasksToPixelFormatEnum(__p0, __p1, __p2, __p3, __p4) \
+	({ \
+		int  __t__p0 = __p0;\
+		Uint32  __t__p1 = __p1;\
+		Uint32  __t__p2 = __p2;\
+		Uint32  __t__p3 = __p3;\
+		Uint32  __t__p4 = __p4;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((Uint32 (*)(int , Uint32 , Uint32 , Uint32 , Uint32 ))*(void**)(__base - 2692))(__t__p0, __t__p1, __t__p2, __t__p3, __t__p4));\
+	})
+
+#define SDL_AllocFormat(__p0) \
+	({ \
+		Uint32  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_PixelFormat *(*)(Uint32 ))*(void**)(__base - 2698))(__t__p0));\
+	})
+
+#define SDL_FreeFormat(__p0) \
+	({ \
+		SDL_PixelFormat * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_PixelFormat *))*(void**)(__base - 2704))(__t__p0));\
+	})
+
+#define SDL_AllocPalette(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_Palette *(*)(int ))*(void**)(__base - 2710))(__t__p0));\
+	})
+
+#define SDL_SetPixelFormatPalette(__p0, __p1) \
+	({ \
+		SDL_PixelFormat * __t__p0 = __p0;\
+		SDL_Palette * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_PixelFormat *, SDL_Palette *))*(void**)(__base - 2716))(__t__p0, __t__p1));\
+	})
+
+#define SDL_SetPaletteColors(__p0, __p1, __p2, __p3) \
+	({ \
+		SDL_Palette * __t__p0 = __p0;\
+		const SDL_Color * __t__p1 = __p1;\
+		int  __t__p2 = __p2;\
+		int  __t__p3 = __p3;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Palette *, const SDL_Color *, int , int ))*(void**)(__base - 2722))(__t__p0, __t__p1, __t__p2, __t__p3));\
+	})
+
+#define SDL_FreePalette(__p0) \
+	({ \
+		SDL_Palette * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_Palette *))*(void**)(__base - 2728))(__t__p0));\
+	})
+
+#define SDL_MapRGB(__p0, __p1, __p2, __p3) \
+	({ \
+		const SDL_PixelFormat * __t__p0 = __p0;\
+		Uint8  __t__p1 = __p1;\
+		Uint8  __t__p2 = __p2;\
+		Uint8  __t__p3 = __p3;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((Uint32 (*)(const SDL_PixelFormat *, Uint8 , Uint8 , Uint8 ))*(void**)(__base - 2734))(__t__p0, __t__p1, __t__p2, __t__p3));\
+	})
+
+#define SDL_MapRGBA(__p0, __p1, __p2, __p3, __p4) \
+	({ \
+		const SDL_PixelFormat * __t__p0 = __p0;\
+		Uint8  __t__p1 = __p1;\
+		Uint8  __t__p2 = __p2;\
+		Uint8  __t__p3 = __p3;\
+		Uint8  __t__p4 = __p4;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((Uint32 (*)(const SDL_PixelFormat *, Uint8 , Uint8 , Uint8 , Uint8 ))*(void**)(__base - 2740))(__t__p0, __t__p1, __t__p2, __t__p3, __t__p4));\
+	})
+
+#define SDL_GetRGB(__p0, __p1, __p2, __p3, __p4) \
+	({ \
+		Uint32  __t__p0 = __p0;\
+		const SDL_PixelFormat * __t__p1 = __p1;\
+		Uint8 * __t__p2 = __p2;\
+		Uint8 * __t__p3 = __p3;\
+		Uint8 * __t__p4 = __p4;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(Uint32 , const SDL_PixelFormat *, Uint8 *, Uint8 *, Uint8 *))*(void**)(__base - 2746))(__t__p0, __t__p1, __t__p2, __t__p3, __t__p4));\
+	})
+
+#define SDL_GetRGBA(__p0, __p1, __p2, __p3, __p4, __p5) \
+	({ \
+		Uint32  __t__p0 = __p0;\
+		const SDL_PixelFormat * __t__p1 = __p1;\
+		Uint8 * __t__p2 = __p2;\
+		Uint8 * __t__p3 = __p3;\
+		Uint8 * __t__p4 = __p4;\
+		Uint8 * __t__p5 = __p5;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(Uint32 , const SDL_PixelFormat *, Uint8 *, Uint8 *, Uint8 *, Uint8 *))*(void**)(__base - 2752))(__t__p0, __t__p1, __t__p2, __t__p3, __t__p4, __t__p5));\
+	})
+
+#define SDL_CalculateGammaRamp(__p0, __p1) \
+	({ \
+		float  __t__p0 = __p0;\
+		Uint16 * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(float , Uint16 *))*(void**)(__base - 2758))(__t__p0, __t__p1));\
+	})
+
+#define SDL_HasIntersection(__p0, __p1) \
+	({ \
+		const SDL_Rect * __t__p0 = __p0;\
+		const SDL_Rect * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(const SDL_Rect *, const SDL_Rect *))*(void**)(__base - 2764))(__t__p0, __t__p1));\
+	})
+
+#define SDL_IntersectRect(__p0, __p1, __p2) \
+	({ \
+		const SDL_Rect * __t__p0 = __p0;\
+		const SDL_Rect * __t__p1 = __p1;\
+		SDL_Rect * __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(const SDL_Rect *, const SDL_Rect *, SDL_Rect *))*(void**)(__base - 2770))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_UnionRect(__p0, __p1, __p2) \
+	({ \
+		const SDL_Rect * __t__p0 = __p0;\
+		const SDL_Rect * __t__p1 = __p1;\
+		SDL_Rect * __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(const SDL_Rect *, const SDL_Rect *, SDL_Rect *))*(void**)(__base - 2776))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_EnclosePoints(__p0, __p1, __p2, __p3) \
+	({ \
+		const SDL_Point * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		const SDL_Rect * __t__p2 = __p2;\
+		SDL_Rect * __t__p3 = __p3;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(const SDL_Point *, int , const SDL_Rect *, SDL_Rect *))*(void**)(__base - 2782))(__t__p0, __t__p1, __t__p2, __t__p3));\
+	})
+
+#define SDL_IntersectRectAndLine(__p0, __p1, __p2, __p3, __p4) \
+	({ \
+		const SDL_Rect * __t__p0 = __p0;\
+		int * __t__p1 = __p1;\
+		int * __t__p2 = __p2;\
+		int * __t__p3 = __p3;\
+		int * __t__p4 = __p4;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(const SDL_Rect *, int *, int *, int *, int *))*(void**)(__base - 2788))(__t__p0, __t__p1, __t__p2, __t__p3, __t__p4));\
+	})
+
+#define SDL_GetWindowWMInfo(__p0, __p1) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		SDL_SysWMinfo * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(SDL_Window *, SDL_SysWMinfo *))*(void**)(__base - 2794))(__t__p0, __t__p1));\
+	})
+
+#define SDL_RecordGesture(__p0) \
+	({ \
+		SDL_TouchID  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_TouchID ))*(void**)(__base - 2800))(__t__p0));\
+	})
+
+#define SDL_SaveAllDollarTemplates(__p0) \
+	({ \
+		SDL_RWops * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_RWops *))*(void**)(__base - 2806))(__t__p0));\
+	})
+
+#define SDL_SaveDollarTemplate(__p0, __p1) \
+	({ \
+		SDL_GestureID  __t__p0 = __p0;\
+		SDL_RWops * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_GestureID , SDL_RWops *))*(void**)(__base - 2812))(__t__p0, __t__p1));\
+	})
+
+#define SDL_LoadDollarTemplates(__p0, __p1) \
+	({ \
+		SDL_TouchID  __t__p0 = __p0;\
+		SDL_RWops * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_TouchID , SDL_RWops *))*(void**)(__base - 2818))(__t__p0, __t__p1));\
+	})
+
+#define SDL_CreateShapedWindow(__p0, __p1, __p2, __p3, __p4, __p5) \
+	({ \
+		const char * __t__p0 = __p0;\
+		unsigned int  __t__p1 = __p1;\
+		unsigned int  __t__p2 = __p2;\
+		unsigned int  __t__p3 = __p3;\
+		unsigned int  __t__p4 = __p4;\
+		Uint32  __t__p5 = __p5;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_Window *(*)(const char *, unsigned int , unsigned int , unsigned int , unsigned int , Uint32 ))*(void**)(__base - 2824))(__t__p0, __t__p1, __t__p2, __t__p3, __t__p4, __t__p5));\
+	})
+
+#define SDL_IsShapedWindow(__p0) \
+	({ \
+		const SDL_Window * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(const SDL_Window *))*(void**)(__base - 2830))(__t__p0));\
+	})
+
+#define SDL_SetWindowShape(__p0, __p1, __p2) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		SDL_Surface * __t__p1 = __p1;\
+		SDL_WindowShapeMode * __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Window *, SDL_Surface *, SDL_WindowShapeMode *))*(void**)(__base - 2836))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_GetShapedWindowMode(__p0, __p1) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		SDL_WindowShapeMode * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Window *, SDL_WindowShapeMode *))*(void**)(__base - 2842))(__t__p0, __t__p1));\
+	})
+
+#define SDL_GL_LoadLibrary(__p0) \
+	({ \
+		const char * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(const char *))*(void**)(__base - 3652))(__t__p0));\
+	})
+
+#define SDL_GL_UnloadLibrary() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(void))*(void**)(__base - 3664))());\
+	})
+
+#define SDL_GL_ExtensionSupported(__p0) \
+	({ \
+		const char * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(const char *))*(void**)(__base - 3670))(__t__p0));\
+	})
+
+#define SDL_GL_ResetAttributes() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(void))*(void**)(__base - 3676))());\
+	})
+
+#define SDL_GL_SetAttribute(__p0, __p1) \
+	({ \
+		SDL_GLattr  __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_GLattr , int ))*(void**)(__base - 3682))(__t__p0, __t__p1));\
+	})
+
+#define SDL_GL_GetAttribute(__p0, __p1) \
+	({ \
+		SDL_GLattr  __t__p0 = __p0;\
+		int * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_GLattr , int *))*(void**)(__base - 3688))(__t__p0, __t__p1));\
+	})
+
+#define SDL_GL_CreateContext(__p0) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_GLContext (*)(SDL_Window *))*(void**)(__base - 3694))(__t__p0));\
+	})
+
+#define SDL_GL_MakeCurrent(__p0, __p1) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		SDL_GLContext  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Window *, SDL_GLContext ))*(void**)(__base - 3700))(__t__p0, __t__p1));\
+	})
+
+#define SDL_GL_GetCurrentWindow() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_Window *(*)(void))*(void**)(__base - 3706))());\
+	})
+
+#define SDL_GL_GetCurrentContext() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_GLContext (*)(void))*(void**)(__base - 3712))());\
+	})
+
+#define SDL_GL_GetDrawableSize(__p0, __p1, __p2) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		int * __t__p1 = __p1;\
+		int * __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_Window *, int *, int *))*(void**)(__base - 3718))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_GL_SetSwapInterval(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(int ))*(void**)(__base - 3724))(__t__p0));\
+	})
+
+#define SDL_GL_GetSwapInterval() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(void))*(void**)(__base - 3730))());\
+	})
+
+#define SDL_GL_SwapWindow(__p0) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_Window *))*(void**)(__base - 3736))(__t__p0));\
+	})
+
+#define SDL_GL_DeleteContext(__p0) \
+	({ \
+		SDL_GLContext  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_GLContext ))*(void**)(__base - 3742))(__t__p0));\
+	})
+
+#define SDL_sqrtf(__p0) \
+	({ \
+		float  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((float (*)(float ))*(void**)(__base - 2932))(__t__p0));\
+	})
+
+#define SDL_tan(__p0) \
+	({ \
+		double  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((double (*)(double ))*(void**)(__base - 2938))(__t__p0));\
+	})
+
+#define SDL_tanf(__p0) \
+	({ \
+		float  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((float (*)(float ))*(void**)(__base - 2944))(__t__p0));\
+	})
+
+#define SDL_QueueAudio(__p0, __p1, __p2) \
+	({ \
+		SDL_AudioDeviceID  __t__p0 = __p0;\
+		const void * __t__p1 = __p1;\
+		Uint32  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_AudioDeviceID , const void *, Uint32 ))*(void**)(__base - 2914))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_GetQueuedAudioSize(__p0) \
+	({ \
+		SDL_AudioDeviceID  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((Uint32 (*)(SDL_AudioDeviceID ))*(void**)(__base - 2920))(__t__p0));\
+	})
+
+#define SDL_ClearQueuedAudio(__p0) \
+	({ \
+		SDL_AudioDeviceID  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_AudioDeviceID ))*(void**)(__base - 2926))(__t__p0));\
+	})
+
+#define SDL_HasAVX2() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(void))*(void**)(__base - 2908))());\
+	})
+
+#define SDL_JoystickFromInstanceID(__p0) \
+	({ \
+		SDL_JoystickID  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_Joystick *(*)(SDL_JoystickID ))*(void**)(__base - 2902))(__t__p0));\
+	})
+
+#define SDL_JoystickCurrentPowerLevel(__p0) \
+	({ \
+		SDL_Joystick * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_JoystickPowerLevel (*)(SDL_Joystick *))*(void**)(__base - 2896))(__t__p0));\
+	})
+
+#define SDL_GameControllerFromInstanceID(__p0) \
+	({ \
+		SDL_JoystickID  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_GameController (*)(SDL_JoystickID ))*(void**)(__base - 2890))(__t__p0));\
+	})
+
+#define SDL_RenderIsClipEnabled(__p0) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(SDL_Renderer *))*(void**)(__base - 2884))(__t__p0));\
+	})
+
+#define SDL_GetDisplayDPI(__p0, __p1, __p2, __p3) \
+	({ \
+		int  __t__p0 = __p0;\
+		float * __t__p1 = __p1;\
+		float * __t__p2 = __p2;\
+		float * __t__p3 = __p3;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(int , float *, float *, float *))*(void**)(__base - 2878))(__t__p0, __t__p1, __t__p2, __t__p3));\
+	})
+
+#define SDL_SetWindowHitTest(__p0, __p1, __p2) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		SDL_HitTest  __t__p1 = __p1;\
+		void * __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Window *, SDL_HitTest , void *))*(void**)(__base - 2866))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_GetGrabbedWindow() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_Window *(*)(void))*(void**)(__base - 2872))());\
+	})
+
+#define SDL_WarpMouseGlobal(__p0, __p1) \
+	({ \
+		int  __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(int , int ))*(void**)(__base - 2854))(__t__p0, __t__p1));\
+	})
+
+#define SDL_CaptureMouse(__p0) \
+	({ \
+		SDL_bool  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_bool ))*(void**)(__base - 2848))(__t__p0));\
+	})
+
+#define SDL_GetGlobalMouseState(__p0, __p1) \
+	({ \
+		int * __t__p0 = __p0;\
+		int * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((Uint32 (*)(int *, int *))*(void**)(__base - 2860))(__t__p0, __t__p1));\
+	})
+
+#define SDL_MemoryBarrierReleaseFunction() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(void))*(void**)(__base - 2950))());\
+	})
+
+#define SDL_MemoryBarrierAcquireFunction() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(void))*(void**)(__base - 2956))());\
+	})
+
+#define SDL_DequeueAudio(__p0, __p1, __p2) \
+	({ \
+		SDL_AudioDeviceID  __t__p0 = __p0;\
+		void * __t__p1 = __p1;\
+		Uint32  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((Uint32 (*)(SDL_AudioDeviceID , void *, Uint32 ))*(void**)(__base - 2962))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_ComposeCustomBlendMode(__p0, __p1, __p2, __p3, __p4, __p5) \
+	({ \
+		SDL_BlendFactor  __t__p0 = __p0;\
+		SDL_BlendFactor  __t__p1 = __p1;\
+		SDL_BlendOperation  __t__p2 = __p2;\
+		SDL_BlendFactor  __t__p3 = __p3;\
+		SDL_BlendFactor  __t__p4 = __p4;\
+		SDL_BlendOperation  __t__p5 = __p5;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_BlendMode (*)(SDL_BlendFactor , SDL_BlendFactor , SDL_BlendOperation , SDL_BlendFactor , SDL_BlendFactor , SDL_BlendOperation ))*(void**)(__base - 2968))(__t__p0, __t__p1, __t__p2, __t__p3, __t__p4, __t__p5));\
+	})
+
+#define SDL_HasNEON() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(void))*(void**)(__base - 2974))());\
+	})
+
+#define SDL_GameControllerNumMappings() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(void))*(void**)(__base - 2980))());\
+	})
+
+#define SDL_GameControllerMappingForIndex(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((char *(*)(int ))*(void**)(__base - 2986))(__t__p0));\
+	})
+
+#define SDL_GameControllerGetVendor(__p0) \
+	({ \
+		SDL_GameController * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((Uint16 (*)(SDL_GameController *))*(void**)(__base - 2992))(__t__p0));\
+	})
+
+#define SDL_GameControllerGetProduct(__p0) \
+	({ \
+		SDL_GameController * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((Uint16 (*)(SDL_GameController *))*(void**)(__base - 2998))(__t__p0));\
+	})
+
+#define SDL_GameControllerGetProductVersion(__p0) \
+	({ \
+		SDL_GameController * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((Uint16 (*)(SDL_GameController *))*(void**)(__base - 3004))(__t__p0));\
+	})
+
+#define SDL_GetHintBoolean(__p0, __p1) \
+	({ \
+		const char * __t__p0 = __p0;\
+		SDL_bool  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(const char *, SDL_bool ))*(void**)(__base - 3010))(__t__p0, __t__p1));\
+	})
+
+#define SDL_JoystickGetDeviceVendor(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((Uint16 (*)(int ))*(void**)(__base - 3016))(__t__p0));\
+	})
+
+#define SDL_JoystickGetDeviceProduct(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((Uint16 (*)(int ))*(void**)(__base - 3022))(__t__p0));\
+	})
+
+#define SDL_JoystickGetDeviceProductVersion(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((Uint16 (*)(int ))*(void**)(__base - 3028))(__t__p0));\
+	})
+
+#define SDL_JoystickGetDeviceType(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_JoystickType (*)(int ))*(void**)(__base - 3034))(__t__p0));\
+	})
+
+#define SDL_JoystickGetDeviceInstanceID(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_JoystickID (*)(int ))*(void**)(__base - 3040))(__t__p0));\
+	})
+
+#define SDL_JoystickGetVendor(__p0) \
+	({ \
+		SDL_Joystick * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((Uint16 (*)(SDL_Joystick *))*(void**)(__base - 3046))(__t__p0));\
+	})
+
+#define SDL_JoystickGetProduct(__p0) \
+	({ \
+		SDL_Joystick * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((Uint16 (*)(SDL_Joystick *))*(void**)(__base - 3052))(__t__p0));\
+	})
+
+#define SDL_JoystickGetProductVersion(__p0) \
+	({ \
+		SDL_Joystick * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((Uint16 (*)(SDL_Joystick *))*(void**)(__base - 3058))(__t__p0));\
+	})
+
+#define SDL_JoystickGetType(__p0) \
+	({ \
+		SDL_Joystick * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_JoystickType (*)(SDL_Joystick *))*(void**)(__base - 3064))(__t__p0));\
+	})
+
+#define SDL_JoystickGetAxisInitialState(__p0, __p1, __p2) \
+	({ \
+		SDL_Joystick * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		Sint16 * __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(SDL_Joystick *, int , Sint16 *))*(void**)(__base - 3070))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_GetDisplayUsableBounds(__p0, __p1) \
+	({ \
+		int  __t__p0 = __p0;\
+		SDL_Rect * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(int , SDL_Rect *))*(void**)(__base - 3076))(__t__p0, __t__p1));\
+	})
+
+#define SDL_GetWindowBordersSize(__p0, __p1, __p2, __p3, __p4) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		int * __t__p1 = __p1;\
+		int * __t__p2 = __p2;\
+		int * __t__p3 = __p3;\
+		int * __t__p4 = __p4;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Window *, int *, int *, int *, int *))*(void**)(__base - 3082))(__t__p0, __t__p1, __t__p2, __t__p3, __t__p4));\
+	})
+
+#define SDL_SetWindowResizable(__p0, __p1) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		SDL_bool  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_Window *, SDL_bool ))*(void**)(__base - 3088))(__t__p0, __t__p1));\
+	})
+
+#define SDL_SetWindowOpacity(__p0, __p1) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		float  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Window *, float ))*(void**)(__base - 3094))(__t__p0, __t__p1));\
+	})
+
+#define SDL_GetWindowOpacity(__p0, __p1) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		float * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Window *, float *))*(void**)(__base - 3100))(__t__p0, __t__p1));\
+	})
+
+#define SDL_SetWindowModalFor(__p0, __p1) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		SDL_Window * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Window *, SDL_Window *))*(void**)(__base - 3106))(__t__p0, __t__p1));\
+	})
+
+#define SDL_SetWindowInputFocus(__p0) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Window *))*(void**)(__base - 3112))(__t__p0));\
+	})
+
+#define SDL_CreateRGBSurfaceWithFormat(__p0, __p1, __p2, __p3, __p4) \
+	({ \
+		Uint32  __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		int  __t__p2 = __p2;\
+		int  __t__p3 = __p3;\
+		Uint32  __t__p4 = __p4;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_Surface *(*)(Uint32 , int , int , int , Uint32 ))*(void**)(__base - 3118))(__t__p0, __t__p1, __t__p2, __t__p3, __t__p4));\
+	})
+
+#define SDL_CreateRGBSurfaceWithFormatFrom(__p0, __p1, __p2, __p3, __p4, __p5) \
+	({ \
+		void * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		int  __t__p2 = __p2;\
+		int  __t__p3 = __p3;\
+		int  __t__p4 = __p4;\
+		Uint32  __t__p5 = __p5;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_Surface *(*)(void *, int , int , int , int , Uint32 ))*(void**)(__base - 3124))(__t__p0, __t__p1, __t__p2, __t__p3, __t__p4, __t__p5));\
+	})
+
+#define SDL_DuplicateSurface(__p0) \
+	({ \
+		SDL_Surface * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_Surface *(*)(SDL_Surface *))*(void**)(__base - 3130))(__t__p0));\
+	})
+
+#define SDL_wcscmp(__p0, __p1) \
+	({ \
+		const wchar_t * __t__p0 = __p0;\
+		const wchar_t * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(const wchar_t *, const wchar_t *))*(void**)(__base - 3136))(__t__p0, __t__p1));\
+	})
+
+#define SDL_utf8strlen(__p0) \
+	({ \
+		const char * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((size_t (*)(const char *))*(void**)(__base - 3142))(__t__p0));\
+	})
+
+#define SDL_LoadFile_RW(__p0, __p1, __p2) \
+	({ \
+		SDL_RWops * __t__p0 = __p0;\
+		size_t * __t__p1 = __p1;\
+		int  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void *(*)(SDL_RWops *, size_t *, int ))*(void**)(__base - 3148))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_RenderSetIntegerScale(__p0, __p1) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		SDL_bool  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Renderer *, SDL_bool ))*(void**)(__base - 3154))(__t__p0, __t__p1));\
+	})
+
+#define SDL_RenderGetIntegerScale(__p0) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(SDL_Renderer *))*(void**)(__base - 3160))(__t__p0));\
+	})
+
+#define SDL_LockJoysticks() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(void))*(void**)(__base - 3208))());\
+	})
+
+#define SDL_UnlockJoysticks() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(void))*(void**)(__base - 3214))());\
+	})
+
+#define SDL_NewAudioStream(__p0, __p1, __p2, __p3, __p4) \
+	({ \
+		const SDL_AudioFormat  __t__p0 = __p0;\
+		const Uint8  __t__p1 = __p1;\
+		const SDL_AudioFormat  __t__p2 = __p2;\
+		const Uint8  __t__p3 = __p3;\
+		const int  __t__p4 = __p4;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_AudioStream *(*)(const SDL_AudioFormat , const Uint8 , const SDL_AudioFormat , const Uint8 , const int ))*(void**)(__base - 3166))(__t__p0, __t__p1, __t__p2, __t__p3, __t__p4));\
+	})
+
+#define SDL_AudioStreamPut(__p0, __p1, __p2) \
+	({ \
+		SDL_AudioStream * __t__p0 = __p0;\
+		const void * __t__p1 = __p1;\
+		int  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_AudioStream *, const void *, int ))*(void**)(__base - 3172))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_AudioStreamGet(__p0, __p1, __p2) \
+	({ \
+		SDL_AudioStream * __t__p0 = __p0;\
+		void * __t__p1 = __p1;\
+		int  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_AudioStream *, void *, int ))*(void**)(__base - 3178))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_AudioStreamAvailable(__p0) \
+	({ \
+		SDL_AudioStream * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_AudioStream *))*(void**)(__base - 3184))(__t__p0));\
+	})
+
+#define SDL_AudioStreamFlush(__p0) \
+	({ \
+		SDL_AudioStream * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_AudioStream *))*(void**)(__base - 3190))(__t__p0));\
+	})
+
+#define SDL_AudioStreamClear(__p0) \
+	({ \
+		SDL_AudioStream * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_AudioStream *))*(void**)(__base - 3196))(__t__p0));\
+	})
+
+#define SDL_FreeAudioStream(__p0) \
+	({ \
+		SDL_AudioStream * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_AudioStream *))*(void**)(__base - 3202))(__t__p0));\
+	})
+
+#define SDL_GetMemoryFunctions(__p0, __p1, __p2, __p3) \
+	({ \
+		SDL_malloc_func * __t__p0 = __p0;\
+		SDL_calloc_func * __t__p1 = __p1;\
+		SDL_realloc_func * __t__p2 = __p2;\
+		SDL_free_func * __t__p3 = __p3;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_malloc_func *, SDL_calloc_func *, SDL_realloc_func *, SDL_free_func *))*(void**)(__base - 3220))(__t__p0, __t__p1, __t__p2, __t__p3));\
+	})
+
+#define SDL_SetMemoryFunctions(__p0, __p1, __p2, __p3) \
+	({ \
+		SDL_malloc_func  __t__p0 = __p0;\
+		SDL_calloc_func  __t__p1 = __p1;\
+		SDL_realloc_func  __t__p2 = __p2;\
+		SDL_free_func  __t__p3 = __p3;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_malloc_func , SDL_calloc_func , SDL_realloc_func , SDL_free_func ))*(void**)(__base - 3226))(__t__p0, __t__p1, __t__p2, __t__p3));\
+	})
+
+#define SDL_GetNumAllocations() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(void))*(void**)(__base - 3232))());\
+	})
+
+#define SDL_RenderGetMetalLayer(__p0) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void *(*)(SDL_Renderer *))*(void**)(__base - 3238))(__t__p0));\
+	})
+
+#define SDL_RenderGetMetalCommandEncoder(__p0) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void *(*)(SDL_Renderer *))*(void**)(__base - 3244))(__t__p0));\
+	})
+
+#define SDL_acosf(__p0) \
+	({ \
+		float  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((float (*)(float ))*(void**)(__base - 3250))(__t__p0));\
+	})
+
+#define SDL_asinf(__p0) \
+	({ \
+		float  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((float (*)(float ))*(void**)(__base - 3256))(__t__p0));\
+	})
+
+#define SDL_atanf(__p0) \
+	({ \
+		float  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((float (*)(float ))*(void**)(__base - 3262))(__t__p0));\
+	})
+
+#define SDL_atan2f(__p0, __p1) \
+	({ \
+		float  __t__p0 = __p0;\
+		float  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((float (*)(float , float ))*(void**)(__base - 3268))(__t__p0, __t__p1));\
+	})
+
+#define SDL_ceilf(__p0) \
+	({ \
+		float  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((float (*)(float ))*(void**)(__base - 3274))(__t__p0));\
+	})
+
+#define SDL_copysignf(__p0, __p1) \
+	({ \
+		float  __t__p0 = __p0;\
+		float  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((float (*)(float , float ))*(void**)(__base - 3280))(__t__p0, __t__p1));\
+	})
+
+#define SDL_fabsf(__p0) \
+	({ \
+		float  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((float (*)(float ))*(void**)(__base - 3286))(__t__p0));\
+	})
+
+#define SDL_floorf(__p0) \
+	({ \
+		float  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((float (*)(float ))*(void**)(__base - 3292))(__t__p0));\
+	})
+
+#define SDL_fmod(__p0, __p1) \
+	({ \
+		double  __t__p0 = __p0;\
+		double  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((double (*)(double , double ))*(void**)(__base - 3298))(__t__p0, __t__p1));\
+	})
+
+#define SDL_fmodf(__p0, __p1) \
+	({ \
+		float  __t__p0 = __p0;\
+		float  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((float (*)(float , float ))*(void**)(__base - 3304))(__t__p0, __t__p1));\
+	})
+
+#define SDL_logf(__p0) \
+	({ \
+		float  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((float (*)(float ))*(void**)(__base - 3310))(__t__p0));\
+	})
+
+#define SDL_log10(__p0) \
+	({ \
+		double  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((double (*)(double ))*(void**)(__base - 3316))(__t__p0));\
+	})
+
+#define SDL_log10f(__p0) \
+	({ \
+		float  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((float (*)(float ))*(void**)(__base - 3322))(__t__p0));\
+	})
+
+#define SDL_powf(__p0, __p1) \
+	({ \
+		float  __t__p0 = __p0;\
+		float  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((float (*)(float , float ))*(void**)(__base - 3328))(__t__p0, __t__p1));\
+	})
+
+#define SDL_scalbnf(__p0, __p1) \
+	({ \
+		float  __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((float (*)(float , int ))*(void**)(__base - 3334))(__t__p0, __t__p1));\
+	})
+
+#define SDL_SetYUVConversionMode(__p0) \
+	({ \
+		SDL_YUV_CONVERSION_MODE  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_YUV_CONVERSION_MODE ))*(void**)(__base - 3340))(__t__p0));\
+	})
+
+#define SDL_GetYUVConversionMode() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_YUV_CONVERSION_MODE (*)(void))*(void**)(__base - 3346))());\
+	})
+
+#define SDL_GetYUVConversionModeForResolution(__p0, __p1) \
+	({ \
+		int  __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_YUV_CONVERSION_MODE (*)(int , int ))*(void**)(__base - 3352))(__t__p0, __t__p1));\
+	})
+
+#define SDL_HasAVX512F() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(void))*(void**)(__base - 3358))());\
+	})
+
+#define SDL_GameControllerMappingForDeviceIndex(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((char *(*)(int ))*(void**)(__base - 3364))(__t__p0));\
+	})
+
+#define SDL_GameControllerGetPlayerIndex(__p0) \
+	({ \
+		SDL_GameController * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_GameController *))*(void**)(__base - 3370))(__t__p0));\
+	})
+
+#define SDL_GameControllerRumble(__p0, __p1, __p2, __p3) \
+	({ \
+		SDL_GameController * __t__p0 = __p0;\
+		Uint16  __t__p1 = __p1;\
+		Uint16  __t__p2 = __p2;\
+		Uint32  __t__p3 = __p3;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_GameController *, Uint16 , Uint16 , Uint32 ))*(void**)(__base - 3376))(__t__p0, __t__p1, __t__p2, __t__p3));\
+	})
+
+#define SDL_JoystickGetDevicePlayerIndex(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(int ))*(void**)(__base - 3382))(__t__p0));\
+	})
+
+#define SDL_JoystickGetPlayerIndex(__p0) \
+	({ \
+		SDL_Joystick * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Joystick *))*(void**)(__base - 3388))(__t__p0));\
+	})
+
+#define SDL_JoystickRumble(__p0, __p1, __p2, __p3) \
+	({ \
+		SDL_Joystick * __t__p0 = __p0;\
+		Uint16  __t__p1 = __p1;\
+		Uint16  __t__p2 = __p2;\
+		Uint32  __t__p3 = __p3;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Joystick *, Uint16 , Uint16 , Uint32 ))*(void**)(__base - 3394))(__t__p0, __t__p1, __t__p2, __t__p3));\
+	})
+
+#define SDL_wcsdup(__p0) \
+	({ \
+		const wchar_t * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((wchar_t *(*)(const wchar_t *))*(void**)(__base - 3400))(__t__p0));\
+	})
+
+#define SDL_exp(__p0) \
+	({ \
+		double  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((double (*)(double ))*(void**)(__base - 3406))(__t__p0));\
+	})
+
+#define SDL_expf(__p0) \
+	({ \
+		float  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((float (*)(float ))*(void**)(__base - 3412))(__t__p0));\
+	})
+
+#define SDL_HasColorKey(__p0) \
+	({ \
+		SDL_Surface * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(SDL_Surface *))*(void**)(__base - 3418))(__t__p0));\
+	})
+
+#define SDL_IsTablet() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(void))*(void**)(__base - 3424))());\
+	})
+
+#define SDL_CreateThreadWithStackSize(__p0, __p1, __p2, __p3) \
+	({ \
+		SDL_ThreadFunction  __t__p0 = __p0;\
+		const char * __t__p1 = __p1;\
+		const size_t  __t__p2 = __p2;\
+		void * __t__p3 = __p3;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_Thread *(*)(SDL_ThreadFunction , const char *, const size_t , void *))*(void**)(__base - 3430))(__t__p0, __t__p1, __t__p2, __t__p3));\
+	})
+
+#define SDL_GetDisplayOrientation(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_DisplayOrientation (*)(int ))*(void**)(__base - 3436))(__t__p0));\
+	})
+
+#define SDL_SIMDGetAlignment() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((size_t (*)(void))*(void**)(__base - 3442))());\
+	})
+
+#define SDL_SIMDAlloc(__p0) \
+	({ \
+		const size_t  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void *(*)(const size_t ))*(void**)(__base - 3448))(__t__p0));\
+	})
+
+#define SDL_SIMDFree(__p0) \
+	({ \
+		void * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(void *))*(void**)(__base - 3454))(__t__p0));\
+	})
+
+#define SDL_RenderDrawPointF(__p0, __p1, __p2) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		float  __t__p1 = __p1;\
+		float  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Renderer *, float , float ))*(void**)(__base - 3460))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_RenderDrawPointsF(__p0, __p1, __p2) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		const SDL_FPoint * __t__p1 = __p1;\
+		int  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Renderer *, const SDL_FPoint *, int ))*(void**)(__base - 3466))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_RenderDrawLineF(__p0, __p1, __p2, __p3, __p4) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		float  __t__p1 = __p1;\
+		float  __t__p2 = __p2;\
+		float  __t__p3 = __p3;\
+		float  __t__p4 = __p4;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Renderer *, float , float , float , float ))*(void**)(__base - 3472))(__t__p0, __t__p1, __t__p2, __t__p3, __t__p4));\
+	})
+
+#define SDL_RenderDrawLinesF(__p0, __p1, __p2) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		const SDL_FPoint * __t__p1 = __p1;\
+		int  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Renderer *, const SDL_FPoint *, int ))*(void**)(__base - 3478))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_RenderDrawRectF(__p0, __p1) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		const SDL_FRect * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Renderer *, const SDL_FRect *))*(void**)(__base - 3484))(__t__p0, __t__p1));\
+	})
+
+#define SDL_RenderDrawRectsF(__p0, __p1, __p2) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		const SDL_FRect * __t__p1 = __p1;\
+		int  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Renderer *, const SDL_FRect *, int ))*(void**)(__base - 3490))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_RenderFillRectF(__p0, __p1) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		const SDL_FRect * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Renderer *, const SDL_FRect *))*(void**)(__base - 3496))(__t__p0, __t__p1));\
+	})
+
+#define SDL_RenderFillRectsF(__p0, __p1, __p2) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		const SDL_FRect * __t__p1 = __p1;\
+		int  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Renderer *, const SDL_FRect *, int ))*(void**)(__base - 3502))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_RenderCopyF(__p0, __p1, __p2, __p3) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		SDL_Texture * __t__p1 = __p1;\
+		const SDL_Rect * __t__p2 = __p2;\
+		const SDL_FRect * __t__p3 = __p3;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Renderer *, SDL_Texture *, const SDL_Rect *, const SDL_FRect *))*(void**)(__base - 3508))(__t__p0, __t__p1, __t__p2, __t__p3));\
+	})
+
+#define SDL_RenderCopyExF(__p0, __p1, __p2, __p3, __p4, __p5, __p6) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		SDL_Texture * __t__p1 = __p1;\
+		const SDL_Rect * __t__p2 = __p2;\
+		const SDL_FRect * __t__p3 = __p3;\
+		const double  __t__p4 = __p4;\
+		const SDL_FPoint * __t__p5 = __p5;\
+		const SDL_RendererFlip  __t__p6 = __p6;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Renderer *, SDL_Texture *, const SDL_Rect *, const SDL_FRect *, const double , const SDL_FPoint *, const SDL_RendererFlip ))*(void**)(__base - 3514))(__t__p0, __t__p1, __t__p2, __t__p3, __t__p4, __t__p5, __t__p6));\
+	})
+
+#define SDL_RenderFlush(__p0) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Renderer *))*(void**)(__base - 3520))(__t__p0));\
+	})
+
+#define SDL_RWsize(__p0) \
+	({ \
+		SDL_RWops * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((Sint64 (*)(SDL_RWops *))*(void**)(__base - 3526))(__t__p0));\
+	})
+
+#define SDL_RWseek(__p0, __p1, __p2) \
+	({ \
+		SDL_RWops * __t__p0 = __p0;\
+		Sint64  __t__p1 = __p1;\
+		int  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((Sint64 (*)(SDL_RWops *, Sint64 , int ))*(void**)(__base - 3532))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_RWtell(__p0) \
+	({ \
+		SDL_RWops * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((Sint64 (*)(SDL_RWops *))*(void**)(__base - 3538))(__t__p0));\
+	})
+
+#define SDL_RWread(__p0, __p1, __p2, __p3) \
+	({ \
+		SDL_RWops * __t__p0 = __p0;\
+		void * __t__p1 = __p1;\
+		size_t  __t__p2 = __p2;\
+		size_t  __t__p3 = __p3;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((size_t (*)(SDL_RWops *, void *, size_t , size_t ))*(void**)(__base - 3544))(__t__p0, __t__p1, __t__p2, __t__p3));\
+	})
+
+#define SDL_RWwrite(__p0, __p1, __p2, __p3) \
+	({ \
+		SDL_RWops * __t__p0 = __p0;\
+		const void * __t__p1 = __p1;\
+		size_t  __t__p2 = __p2;\
+		size_t  __t__p3 = __p3;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((size_t (*)(SDL_RWops *, const void *, size_t , size_t ))*(void**)(__base - 3550))(__t__p0, __t__p1, __t__p2, __t__p3));\
+	})
+
+#define SDL_RWclose(__p0) \
+	({ \
+		SDL_RWops * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_RWops *))*(void**)(__base - 3556))(__t__p0));\
+	})
+
+#define SDL_LoadFile(__p0, __p1) \
+	({ \
+		const char * __t__p0 = __p0;\
+		size_t * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void *(*)(const char *, size_t *))*(void**)(__base - 3562))(__t__p0, __t__p1));\
+	})
+
+#define SDL_GetTouchDeviceType(__p0) \
+	({ \
+		SDL_TouchID  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_TouchDeviceType (*)(SDL_TouchID ))*(void**)(__base - 3568))(__t__p0));\
+	})
+
+#define SDL_HasARMSIMD() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(void))*(void**)(__base - 3574))());\
+	})
+
+#define SDL_GameControllerTypeForIndex(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_GameControllerType (*)(int ))*(void**)(__base - 3580))(__t__p0));\
+	})
+
+#define SDL_GameControllerFromPlayerIndex(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_GameController *(*)(int ))*(void**)(__base - 3586))(__t__p0));\
+	})
+
+#define SDL_GameControllerGetType(__p0) \
+	({ \
+		SDL_GameController * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_GameControllerType (*)(SDL_GameController *))*(void**)(__base - 3592))(__t__p0));\
+	})
+
+#define SDL_GameControllerSetPlayerIndex(__p0, __p1) \
+	({ \
+		SDL_GameController * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_GameController *, int ))*(void**)(__base - 3598))(__t__p0, __t__p1));\
+	})
+
+#define SDL_JoystickFromPlayerIndex(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_Joystick *(*)(int ))*(void**)(__base - 3604))(__t__p0));\
+	})
+
+#define SDL_JoystickSetPlayerIndex(__p0, __p1) \
+	({ \
+		SDL_Joystick * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_Joystick *(*)(SDL_Joystick *, int ))*(void**)(__base - 3610))(__t__p0, __t__p1));\
+	})
+
+#define SDL_SetTextureScaleMode(__p0, __p1) \
+	({ \
+		SDL_Texture * __t__p0 = __p0;\
+		SDL_ScaleMode  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Texture *, SDL_ScaleMode ))*(void**)(__base - 3616))(__t__p0, __t__p1));\
+	})
+
+#define SDL_GetTextureScaleMode(__p0, __p1) \
+	({ \
+		SDL_Texture * __t__p0 = __p0;\
+		SDL_ScaleMode * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Texture *, SDL_ScaleMode *))*(void**)(__base - 3622))(__t__p0, __t__p1));\
+	})
+
+#define SDL_LockTextureToSurface(__p0, __p1, __p2) \
+	({ \
+		SDL_Texture * __t__p0 = __p0;\
+		const SDL_Rect * __t__p1 = __p1;\
+		SDL_Surface ** __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Texture *, const SDL_Rect *, SDL_Surface **))*(void**)(__base - 3628))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_wcsstr(__p0, __p1) \
+	({ \
+		const wchar_t * __t__p0 = __p0;\
+		const wchar_t * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((wchar_t *(*)(const wchar_t *, const wchar_t *))*(void**)(__base - 3634))(__t__p0, __t__p1));\
+	})
+
+#define SDL_wcsncmp(__p0, __p1, __p2) \
+	({ \
+		const wchar_t * __t__p0 = __p0;\
+		const wchar_t * __t__p1 = __p1;\
+		size_t  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(const wchar_t *, const wchar_t *, size_t ))*(void**)(__base - 3640))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_strtokr(__p0, __p1, __p2) \
+	({ \
+		char * __t__p0 = __p0;\
+		const char * __t__p1 = __p1;\
+		char ** __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((char *(*)(char *, const char *, char **))*(void**)(__base - 3646))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_isupper(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(int ))*(void**)(__base - 3928))(__t__p0));\
+	})
+
+#define SDL_islower(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(int ))*(void**)(__base - 3934))(__t__p0));\
+	})
+
+#define SDL_JoystickAttachVirtual(__p0, __p1, __p2, __p3) \
+	({ \
+		SDL_JoystickType  __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		int  __t__p2 = __p2;\
+		int  __t__p3 = __p3;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_JoystickType , int , int , int ))*(void**)(__base - 3940))(__t__p0, __t__p1, __t__p2, __t__p3));\
+	})
+
+#define SDL_JoystickDetachVirtual(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(int ))*(void**)(__base - 3946))(__t__p0));\
+	})
+
+#define SDL_JoystickIsVirtual(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(int ))*(void**)(__base - 3952))(__t__p0));\
+	})
+
+#define SDL_JoystickSetVirtualAxis(__p0, __p1, __p2) \
+	({ \
+		SDL_Joystick * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		Sint16  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Joystick *, int , Sint16 ))*(void**)(__base - 3958))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_JoystickSetVirtualButton(__p0, __p1, __p2) \
+	({ \
+		SDL_Joystick * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		Uint8  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Joystick *, int , Uint8 ))*(void**)(__base - 3964))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_JoystickSetVirtualHat(__p0, __p1, __p2) \
+	({ \
+		SDL_Joystick * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		Uint8  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Joystick *, int , Uint8 ))*(void**)(__base - 3970))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_GetErrorMsg(__p0, __p1) \
+	({ \
+		char * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((char *(*)(char *, int ))*(void**)(__base - 3976))(__t__p0, __t__p1));\
+	})
+
+#define SDL_LockSensors() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(void))*(void**)(__base - 3982))());\
+	})
+
+#define SDL_UnlockSensors() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(void))*(void**)(__base - 3988))());\
+	})
+
+#define SDL_Metal_GetLayer(__p0) \
+	({ \
+		SDL_MetalView  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void *(*)(SDL_MetalView ))*(void**)(__base - 3994))(__t__p0));\
+	})
+
+#define SDL_Metal_GetDrawableSize(__p0, __p1, __p2) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		int * __t__p1 = __p1;\
+		int * __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_Window *, int *, int *))*(void**)(__base - 4000))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_trunc(__p0) \
+	({ \
+		double  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((double (*)(double ))*(void**)(__base - 4006))(__t__p0));\
+	})
+
+#define SDL_truncf(__p0) \
+	({ \
+		float  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((float (*)(float ))*(void**)(__base - 4012))(__t__p0));\
+	})
+
+#define SDL_GetPreferredLocales() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_Locale *(*)(void))*(void**)(__base - 4018))());\
+	})
+
+#define SDL_SIMDRealloc(__p0, __p1) \
+	({ \
+		void * __t__p0 = __p0;\
+		const size_t  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void *(*)(void *, const size_t ))*(void**)(__base - 4024))(__t__p0, __t__p1));\
+	})
+
+#define SDL_OpenURL(__p0) \
+	({ \
+		const char * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(const char *))*(void**)(__base - 4030))(__t__p0));\
+	})
+
+#define SDL_HasSurfaceRLE(__p0) \
+	({ \
+		SDL_Surface * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(SDL_Surface *))*(void**)(__base - 4036))(__t__p0));\
+	})
+
+#define SDL_GameControllerHasLED(__p0) \
+	({ \
+		SDL_GameController * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(SDL_GameController *))*(void**)(__base - 4042))(__t__p0));\
+	})
+
+#define SDL_GameControllerSetLED(__p0, __p1, __p2, __p3) \
+	({ \
+		SDL_GameController * __t__p0 = __p0;\
+		Uint8  __t__p1 = __p1;\
+		Uint8  __t__p2 = __p2;\
+		Uint8  __t__p3 = __p3;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_GameController *, Uint8 , Uint8 , Uint8 ))*(void**)(__base - 4048))(__t__p0, __t__p1, __t__p2, __t__p3));\
+	})
+
+#define SDL_JoystickHasLED(__p0) \
+	({ \
+		SDL_Joystick * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(SDL_Joystick *))*(void**)(__base - 4054))(__t__p0));\
+	})
+
+#define SDL_JoystickSetLED(__p0, __p1, __p2, __p3) \
+	({ \
+		SDL_Joystick * __t__p0 = __p0;\
+		Uint8  __t__p1 = __p1;\
+		Uint8  __t__p2 = __p2;\
+		Uint8  __t__p3 = __p3;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Joystick *, Uint8 , Uint8 , Uint8 ))*(void**)(__base - 4060))(__t__p0, __t__p1, __t__p2, __t__p3));\
+	})
+
+#define SDL_GameControllerRumbleTriggers(__p0, __p1, __p2, __p3) \
+	({ \
+		SDL_GameController * __t__p0 = __p0;\
+		Uint16  __t__p1 = __p1;\
+		Uint16  __t__p2 = __p2;\
+		Uint32  __t__p3 = __p3;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_GameController *, Uint16 , Uint16 , Uint32 ))*(void**)(__base - 4066))(__t__p0, __t__p1, __t__p2, __t__p3));\
+	})
+
+#define SDL_JoystickRumbleTriggers(__p0, __p1, __p2, __p3) \
+	({ \
+		SDL_Joystick * __t__p0 = __p0;\
+		Uint16  __t__p1 = __p1;\
+		Uint16  __t__p2 = __p2;\
+		Uint32  __t__p3 = __p3;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Joystick *, Uint16 , Uint16 , Uint32 ))*(void**)(__base - 4072))(__t__p0, __t__p1, __t__p2, __t__p3));\
+	})
+
+#define SDL_GameControllerHasAxis(__p0, __p1) \
+	({ \
+		SDL_GameController * __t__p0 = __p0;\
+		SDL_GameControllerAxis  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(SDL_GameController *, SDL_GameControllerAxis ))*(void**)(__base - 4078))(__t__p0, __t__p1));\
+	})
+
+#define SDL_GameControllerHasButton(__p0, __p1) \
+	({ \
+		SDL_GameController * __t__p0 = __p0;\
+		SDL_GameControllerButton  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(SDL_GameController *, SDL_GameControllerButton ))*(void**)(__base - 4084))(__t__p0, __t__p1));\
+	})
+
+#define SDL_GameControllerGetNumTouchpads(__p0) \
+	({ \
+		SDL_GameController * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_GameController *))*(void**)(__base - 4090))(__t__p0));\
+	})
+
+#define SDL_GameControllerGetNumTouchpadFingers(__p0, __p1) \
+	({ \
+		SDL_GameController * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_GameController *, int ))*(void**)(__base - 4096))(__t__p0, __t__p1));\
+	})
+
+#define SDL_GameControllerGetTouchpadFinger(__p0, __p1, __p2, __p3, __p4, __p5, __p6) \
+	({ \
+		SDL_GameController * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		int  __t__p2 = __p2;\
+		Uint8 * __t__p3 = __p3;\
+		float * __t__p4 = __p4;\
+		float * __t__p5 = __p5;\
+		float * __t__p6 = __p6;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_GameController *, int , int , Uint8 *, float *, float *, float *))*(void**)(__base - 4102))(__t__p0, __t__p1, __t__p2, __t__p3, __t__p4, __t__p5, __t__p6));\
+	})
+
+#define SDL_GetNumTouchDevices() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(void))*(void**)(__base - 4108))());\
+	})
+
+#define SDL_GetTouchDevice(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_TouchID (*)(int ))*(void**)(__base - 4114))(__t__p0));\
+	})
+
+#define SDL_GetNumTouchFingers(__p0) \
+	({ \
+		SDL_TouchID  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_TouchID ))*(void**)(__base - 4120))(__t__p0));\
+	})
+
+#define SDL_GetTouchFinger(__p0, __p1) \
+	({ \
+		SDL_TouchID  __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_Finger *(*)(SDL_TouchID , int ))*(void**)(__base - 4126))(__t__p0, __t__p1));\
+	})
+
+#define SDL_crc32(__p0, __p1, __p2) \
+	({ \
+		Uint32  __t__p0 = __p0;\
+		const void * __t__p1 = __p1;\
+		size_t  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((Uint32 (*)(Uint32 , const void *, size_t ))*(void**)(__base - 4132))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_GameControllerGetSerial(__p0) \
+	({ \
+		SDL_GameController * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((const char *(*)(SDL_GameController *))*(void**)(__base - 4138))(__t__p0));\
+	})
+
+#define SDL_JoystickGetSerial(__p0) \
+	({ \
+		SDL_Joystick * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((const char *(*)(SDL_Joystick *))*(void**)(__base - 4144))(__t__p0));\
+	})
+
+#define SDL_GameControllerHasSensor(__p0, __p1) \
+	({ \
+		SDL_GameController * __t__p0 = __p0;\
+		SDL_SensorType  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(SDL_GameController *, SDL_SensorType ))*(void**)(__base - 4150))(__t__p0, __t__p1));\
+	})
+
+#define SDL_GameControllerSetSensorEnabled(__p0, __p1, __p2) \
+	({ \
+		SDL_GameController * __t__p0 = __p0;\
+		SDL_SensorType  __t__p1 = __p1;\
+		SDL_bool  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_GameController *, SDL_SensorType , SDL_bool ))*(void**)(__base - 4156))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_GameControllerIsSensorEnabled(__p0, __p1) \
+	({ \
+		SDL_GameController * __t__p0 = __p0;\
+		SDL_SensorType  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(SDL_GameController *, SDL_SensorType ))*(void**)(__base - 4162))(__t__p0, __t__p1));\
+	})
+
+#define SDL_GameControllerGetSensorData(__p0, __p1, __p2, __p3) \
+	({ \
+		SDL_GameController * __t__p0 = __p0;\
+		SDL_SensorType  __t__p1 = __p1;\
+		float * __t__p2 = __p2;\
+		int  __t__p3 = __p3;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_GameController *, SDL_SensorType , float *, int ))*(void**)(__base - 4168))(__t__p0, __t__p1, __t__p2, __t__p3));\
+	})
+
+#define SDL_wcscasecmp(__p0, __p1) \
+	({ \
+		const wchar_t * __t__p0 = __p0;\
+		const wchar_t * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(const wchar_t *, const wchar_t *))*(void**)(__base - 4174))(__t__p0, __t__p1));\
+	})
+
+#define SDL_wcsncasecmp(__p0, __p1, __p2) \
+	({ \
+		const wchar_t * __t__p0 = __p0;\
+		const wchar_t * __t__p1 = __p1;\
+		size_t  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(const wchar_t *, const wchar_t *, size_t ))*(void**)(__base - 4180))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_CopyAndSwap16(__p0, __p1, __p2) \
+	({ \
+		APTR  __t__p0 = __p0;\
+		APTR  __t__p1 = __p1;\
+		LONG  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(APTR , APTR , LONG ))*(void**)(__base - 4186))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_CopyAndSwap32(__p0, __p1, __p2) \
+	({ \
+		APTR  __t__p0 = __p0;\
+		APTR  __t__p1 = __p1;\
+		LONG  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(APTR , APTR , LONG ))*(void**)(__base - 4192))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_UpdateNVTexture(__p0, __p1, __p2, __p3, __p4, __p5) \
+	({ \
+		SDL_Texture * __t__p0 = __p0;\
+		const SDL_Rect * __t__p1 = __p1;\
+		const Uint8 * __t__p2 = __p2;\
+		int  __t__p3 = __p3;\
+		const Uint8 * __t__p4 = __p4;\
+		int  __t__p5 = __p5;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Texture *, const SDL_Rect *, const Uint8 *, int , const Uint8 *, int ))*(void**)(__base - 4198))(__t__p0, __t__p1, __t__p2, __t__p3, __t__p4, __t__p5));\
+	})
+
+#define SDL_round(__p0) \
+	({ \
+		double  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((double (*)(double ))*(void**)(__base - 4204))(__t__p0));\
+	})
+
+#define SDL_roundf(__p0) \
+	({ \
+		float  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((float (*)(float ))*(void**)(__base - 4210))(__t__p0));\
+	})
+
+#define SDL_lround(__p0) \
+	({ \
+		double  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((long (*)(double ))*(void**)(__base - 4216))(__t__p0));\
+	})
+
+#define SDL_lroundf(__p0) \
+	({ \
+		float  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((long (*)(float ))*(void**)(__base - 4222))(__t__p0));\
+	})
+
+#define SDL_SoftStretchLinear(__p0, __p1, __p2, __p3) \
+	({ \
+		SDL_Surface * __t__p0 = __p0;\
+		const SDL_Rect * __t__p1 = __p1;\
+		SDL_Surface * __t__p2 = __p2;\
+		const SDL_Rect * __t__p3 = __p3;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Surface *, const SDL_Rect *, SDL_Surface *, const SDL_Rect *))*(void**)(__base - 4228))(__t__p0, __t__p1, __t__p2, __t__p3));\
+	})
+
+#define SDL_SetWindowKeyboardGrab(__p0, __p1) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		SDL_bool  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_Window *, SDL_bool ))*(void**)(__base - 4234))(__t__p0, __t__p1));\
+	})
+
+#define SDL_SetWindowMouseGrab(__p0, __p1) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		SDL_bool  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_Window *, SDL_bool ))*(void**)(__base - 4240))(__t__p0, __t__p1));\
+	})
+
+#define SDL_GetWindowKeyboardGrab(__p0) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(SDL_Window *))*(void**)(__base - 4246))(__t__p0));\
+	})
+
+#define SDL_GetWindowMouseGrab(__p0) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(SDL_Window *))*(void**)(__base - 4252))(__t__p0));\
+	})
+
+#define SDL_isalpha(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(int ))*(void**)(__base - 4258))(__t__p0));\
+	})
+
+#define SDL_isalnum(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(int ))*(void**)(__base - 4264))(__t__p0));\
+	})
+
+#define SDL_isblank(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(int ))*(void**)(__base - 4270))(__t__p0));\
+	})
+
+#define SDL_iscntrl(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(int ))*(void**)(__base - 4276))(__t__p0));\
+	})
+
+#define SDL_isxdigit(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(int ))*(void**)(__base - 4282))(__t__p0));\
+	})
+
+#define SDL_ispunct(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(int ))*(void**)(__base - 4288))(__t__p0));\
+	})
+
+#define SDL_isprint(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(int ))*(void**)(__base - 4294))(__t__p0));\
+	})
+
+#define SDL_isgraph(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(int ))*(void**)(__base - 4300))(__t__p0));\
+	})
+
+#define SDL_GetAudioDeviceSpec(__p0, __p1, __p2) \
+	({ \
+		int  __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		SDL_AudioSpec * __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(int , int , SDL_AudioSpec *))*(void**)(__base - 4306))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_TLSCleanup() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(void))*(void**)(__base - 4312))());\
+	})
+
+#define SDL_SetWindowAlwaysOnTop(__p0, __p1) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		SDL_bool  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_Window *, SDL_bool ))*(void**)(__base - 4318))(__t__p0, __t__p1));\
+	})
+
+#define SDL_FlashWindow(__p0, __p1) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		SDL_FlashOperation  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Window *, SDL_FlashOperation ))*(void**)(__base - 4324))(__t__p0, __t__p1));\
+	})
+
+#define SDL_GameControllerSendEffect(__p0, __p1, __p2) \
+	({ \
+		SDL_GameController * __t__p0 = __p0;\
+		const void * __t__p1 = __p1;\
+		int  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_GameController *, const void *, int ))*(void**)(__base - 4330))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_JoystickSendEffect(__p0, __p1, __p2) \
+	({ \
+		SDL_Joystick * __t__p0 = __p0;\
+		const void * __t__p1 = __p1;\
+		int  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Joystick *, const void *, int ))*(void**)(__base - 4336))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_GameControllerGetSensorDataRate(__p0, __p1) \
+	({ \
+		SDL_GameController * __t__p0 = __p0;\
+		SDL_SensorType  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((float (*)(SDL_GameController *, SDL_SensorType ))*(void**)(__base - 4342))(__t__p0, __t__p1));\
+	})
+
+#define SDL_SetTextureUserData(__p0, __p1) \
+	({ \
+		SDL_Texture * __t__p0 = __p0;\
+		void * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Texture *, void *))*(void**)(__base - 4348))(__t__p0, __t__p1));\
+	})
+
+#define SDL_GetTextureUserData(__p0) \
+	({ \
+		SDL_Texture * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void *(*)(SDL_Texture *))*(void**)(__base - 4354))(__t__p0));\
+	})
+
+#define SDL_RenderGeometry(__p0, __p1, __p2, __p3, __p4, __p5) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		SDL_Texture * __t__p1 = __p1;\
+		const SDL_Vertex * __t__p2 = __p2;\
+		int  __t__p3 = __p3;\
+		const int * __t__p4 = __p4;\
+		int  __t__p5 = __p5;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Renderer *, SDL_Texture *, const SDL_Vertex *, int , const int *, int ))*(void**)(__base - 4360))(__t__p0, __t__p1, __t__p2, __t__p3, __t__p4, __t__p5));\
+	})
+
+#define SDL_RenderGeometryRaw(__p0, __p1, __p2, __p3, __p4, __p5, __p6, __p7, __p8, __p9, __p10, __p11) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		SDL_Texture * __t__p1 = __p1;\
+		const float * __t__p2 = __p2;\
+		int  __t__p3 = __p3;\
+		const int * __t__p4 = __p4;\
+		int  __t__p5 = __p5;\
+		const float * __t__p6 = __p6;\
+		int  __t__p7 = __p7;\
+		int  __t__p8 = __p8;\
+		const void * __t__p9 = __p9;\
+		int  __t__p10 = __p10;\
+		int  __t__p11 = __p11;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Renderer *, SDL_Texture *, const float *, int , const int *, int , const float *, int , int , const void *, int , int ))*(void**)(__base - 4366))(__t__p0, __t__p1, __t__p2, __t__p3, __t__p4, __t__p5, __t__p6, __t__p7, __t__p8, __t__p9, __t__p10, __t__p11));\
+	})
+
+#define SDL_RenderSetVSync(__p0, __p1) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Renderer *, int ))*(void**)(__base - 4372))(__t__p0, __t__p1));\
+	})
+
+#define SDL_vasprintf(__p0, __p1, __p2) \
+	({ \
+		char ** __t__p0 = __p0;\
+		const char * __t__p1 = __p1;\
+		va_list __t__p2;\
+		va_copy(__t__p2, __p2);\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(char **, const char *, va_list ))*(void**)(__base - 4378))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_GetWindowICCProfile(__p0, __p1) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		size_t * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void *(*)(SDL_Window *, size_t *))*(void**)(__base - 4384))(__t__p0, __t__p1));\
+	})
+
+#define SDL_GetTicks64() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((Uint64 (*)(void))*(void**)(__base - 4390))());\
+	})
+
+#define SDL_GameControllerGetAppleSFSymbolsNameForButton(__p0, __p1) \
+	({ \
+		SDL_GameController * __t__p0 = __p0;\
+		SDL_GameControllerButton  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((const char *(*)(SDL_GameController *, SDL_GameControllerButton ))*(void**)(__base - 4396))(__t__p0, __t__p1));\
+	})
+
+#define SDL_GameControllerGetAppleSFSymbolsNameForAxis(__p0, __p1) \
+	({ \
+		SDL_GameController * __t__p0 = __p0;\
+		SDL_GameControllerAxis  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((const char *(*)(SDL_GameController *, SDL_GameControllerAxis ))*(void**)(__base - 4402))(__t__p0, __t__p1));\
+	})
+
+#define SDL_hid_init() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(void))*(void**)(__base - 4408))());\
+	})
+
+#define SDL_hid_exit() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(void))*(void**)(__base - 4414))());\
+	})
+
+#define SDL_hid_device_change_count() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((Uint32 (*)(void))*(void**)(__base - 4420))());\
+	})
+
+#define SDL_hid_enumerate(__p0, __p1) \
+	({ \
+		unsigned short  __t__p0 = __p0;\
+		unsigned short  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_hid_device_info *(*)(unsigned short , unsigned short ))*(void**)(__base - 4426))(__t__p0, __t__p1));\
+	})
+
+#define SDL_hid_free_enumeration(__p0) \
+	({ \
+		SDL_hid_device_info * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_hid_device_info *))*(void**)(__base - 4432))(__t__p0));\
+	})
+
+#define SDL_hid_open(__p0, __p1, __p2) \
+	({ \
+		unsigned short  __t__p0 = __p0;\
+		unsigned short  __t__p1 = __p1;\
+		const wchar_t * __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_hid_device *(*)(unsigned short , unsigned short , const wchar_t *))*(void**)(__base - 4438))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_hid_open_path(__p0, __p1) \
+	({ \
+		const char * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_hid_device *(*)(const char *, int ))*(void**)(__base - 4444))(__t__p0, __t__p1));\
+	})
+
+#define SDL_hid_write(__p0, __p1, __p2) \
+	({ \
+		SDL_hid_device * __t__p0 = __p0;\
+		const unsigned char * __t__p1 = __p1;\
+		size_t  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_hid_device *, const unsigned char *, size_t ))*(void**)(__base - 4450))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_hid_read_timeout(__p0, __p1, __p2, __p3) \
+	({ \
+		SDL_hid_device * __t__p0 = __p0;\
+		unsigned char * __t__p1 = __p1;\
+		size_t  __t__p2 = __p2;\
+		int  __t__p3 = __p3;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_hid_device *, unsigned char *, size_t , int ))*(void**)(__base - 4456))(__t__p0, __t__p1, __t__p2, __t__p3));\
+	})
+
+#define SDL_hid_read(__p0, __p1, __p2) \
+	({ \
+		SDL_hid_device * __t__p0 = __p0;\
+		unsigned char * __t__p1 = __p1;\
+		size_t  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_hid_device *, unsigned char *, size_t ))*(void**)(__base - 4462))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_hid_set_nonblocking(__p0, __p1) \
+	({ \
+		SDL_hid_device * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_hid_device *, int ))*(void**)(__base - 4468))(__t__p0, __t__p1));\
+	})
+
+#define SDL_hid_send_feature_report(__p0, __p1, __p2) \
+	({ \
+		SDL_hid_device * __t__p0 = __p0;\
+		const unsigned char * __t__p1 = __p1;\
+		size_t  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_hid_device *, const unsigned char *, size_t ))*(void**)(__base - 4474))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_hid_get_feature_report(__p0, __p1, __p2) \
+	({ \
+		SDL_hid_device * __t__p0 = __p0;\
+		unsigned char * __t__p1 = __p1;\
+		size_t  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_hid_device *, unsigned char *, size_t ))*(void**)(__base - 4480))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_hid_close(__p0) \
+	({ \
+		SDL_hid_device * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_hid_device *))*(void**)(__base - 4486))(__t__p0));\
+	})
+
+#define SDL_hid_get_manufacturer_string(__p0, __p1, __p2) \
+	({ \
+		SDL_hid_device * __t__p0 = __p0;\
+		wchar_t * __t__p1 = __p1;\
+		size_t  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_hid_device *, wchar_t *, size_t ))*(void**)(__base - 4492))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_hid_get_product_string(__p0, __p1, __p2) \
+	({ \
+		SDL_hid_device * __t__p0 = __p0;\
+		wchar_t * __t__p1 = __p1;\
+		size_t  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_hid_device *, wchar_t *, size_t ))*(void**)(__base - 4498))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_hid_get_serial_number_string(__p0, __p1, __p2) \
+	({ \
+		SDL_hid_device * __t__p0 = __p0;\
+		wchar_t * __t__p1 = __p1;\
+		size_t  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_hid_device *, wchar_t *, size_t ))*(void**)(__base - 4504))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_hid_get_indexed_string(__p0, __p1, __p2, __p3) \
+	({ \
+		SDL_hid_device * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		wchar_t * __t__p2 = __p2;\
+		size_t  __t__p3 = __p3;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_hid_device *, int , wchar_t *, size_t ))*(void**)(__base - 4510))(__t__p0, __t__p1, __t__p2, __t__p3));\
+	})
+
+#define SDL_SetWindowMouseRect(__p0, __p1) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		const SDL_Rect * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Window *, const SDL_Rect *))*(void**)(__base - 4516))(__t__p0, __t__p1));\
+	})
+
+#define SDL_GetWindowMouseRect(__p0) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((const SDL_Rect *(*)(SDL_Window *))*(void**)(__base - 4522))(__t__p0));\
+	})
+
+#define SDL_RenderWindowToLogical(__p0, __p1, __p2, __p3, __p4) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		int  __t__p2 = __p2;\
+		float * __t__p3 = __p3;\
+		float * __t__p4 = __p4;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_Renderer *, int , int , float *, float *))*(void**)(__base - 4528))(__t__p0, __t__p1, __t__p2, __t__p3, __t__p4));\
+	})
+
+#define SDL_RenderLogicalToWindow(__p0, __p1, __p2, __p3, __p4) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		float  __t__p1 = __p1;\
+		float  __t__p2 = __p2;\
+		int * __t__p3 = __p3;\
+		int * __t__p4 = __p4;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_Renderer *, float , float , int *, int *))*(void**)(__base - 4534))(__t__p0, __t__p1, __t__p2, __t__p3, __t__p4));\
+	})
+
+#define SDL_JoystickHasRumble(__p0) \
+	({ \
+		SDL_Joystick * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(SDL_Joystick *))*(void**)(__base - 4540))(__t__p0));\
+	})
+
+#define SDL_JoystickHasRumbleTriggers(__p0) \
+	({ \
+		SDL_Joystick * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(SDL_Joystick *))*(void**)(__base - 4546))(__t__p0));\
+	})
+
+#define SDL_GameControllerHasRumble(__p0) \
+	({ \
+		SDL_GameController * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(SDL_GameController *))*(void**)(__base - 4552))(__t__p0));\
+	})
+
+#define SDL_GameControllerHasRumbleTriggers(__p0) \
+	({ \
+		SDL_GameController * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(SDL_GameController *))*(void**)(__base - 4558))(__t__p0));\
+	})
+
+#define SDL_hid_ble_scan(__p0) \
+	({ \
+		SDL_bool  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_bool ))*(void**)(__base - 4564))(__t__p0));\
+	})
+
+#define SDL_PremultiplyAlpha(__p0, __p1, __p2, __p3, __p4, __p5, __p6, __p7) \
+	({ \
+		int  __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		Uint32  __t__p2 = __p2;\
+		const void * __t__p3 = __p3;\
+		int  __t__p4 = __p4;\
+		Uint32  __t__p5 = __p5;\
+		void * __t__p6 = __p6;\
+		int  __t__p7 = __p7;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(int , int , Uint32 , const void *, int , Uint32 , void *, int ))*(void**)(__base - 4570))(__t__p0, __t__p1, __t__p2, __t__p3, __t__p4, __t__p5, __t__p6, __t__p7));\
+	})
+
+#define SDL_getenv(__p0) \
+	({ \
+		const char * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((char *(*)(const char *))*(void**)(__base - 4576))(__t__p0));\
+	})
+
+#define SDL_setenv(__p0, __p1, __p2) \
+	({ \
+		const char * __t__p0 = __p0;\
+		const char * __t__p1 = __p1;\
+		int  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(const char *, const char *, int ))*(void**)(__base - 4582))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_GetTouchName(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((const char *(*)(int ))*(void**)(__base - 4588))(__t__p0));\
+	})
+
+#define SDL_ClearComposition() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(void))*(void**)(__base - 4594))());\
+	})
+
+#define SDL_IsTextInputShown() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(void))*(void**)(__base - 4600))());\
+	})
+
+#define SDL_HasIntersectionF(__p0, __p1) \
+	({ \
+		const SDL_FRect * __t__p0 = __p0;\
+		const SDL_FRect * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(const SDL_FRect *, const SDL_FRect *))*(void**)(__base - 4606))(__t__p0, __t__p1));\
+	})
+
+#define SDL_IntersectFRect(__p0, __p1, __p2) \
+	({ \
+		const SDL_FRect * __t__p0 = __p0;\
+		const SDL_FRect * __t__p1 = __p1;\
+		SDL_FRect * __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(const SDL_FRect *, const SDL_FRect *, SDL_FRect *))*(void**)(__base - 4612))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_UnionFRect(__p0, __p1, __p2) \
+	({ \
+		const SDL_FRect * __t__p0 = __p0;\
+		const SDL_FRect * __t__p1 = __p1;\
+		SDL_FRect * __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(const SDL_FRect *, const SDL_FRect *, SDL_FRect *))*(void**)(__base - 4618))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_EncloseFPoints(__p0, __p1, __p2, __p3) \
+	({ \
+		const SDL_FPoint * __t__p0 = __p0;\
+		int  __t__p1 = __p1;\
+		const SDL_FRect * __t__p2 = __p2;\
+		SDL_FRect * __t__p3 = __p3;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(const SDL_FPoint *, int , const SDL_FRect *, SDL_FRect *))*(void**)(__base - 4624))(__t__p0, __t__p1, __t__p2, __t__p3));\
+	})
+
+#define SDL_IntersectFRectAndLine(__p0, __p1, __p2, __p3, __p4) \
+	({ \
+		const SDL_FRect * __t__p0 = __p0;\
+		float * __t__p1 = __p1;\
+		float * __t__p2 = __p2;\
+		float * __t__p3 = __p3;\
+		float * __t__p4 = __p4;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(const SDL_FRect *, float *, float *, float *, float *))*(void**)(__base - 4630))(__t__p0, __t__p1, __t__p2, __t__p3, __t__p4));\
+	})
+
+#define SDL_RenderGetWindow(__p0) \
+	({ \
+		SDL_Renderer * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_Window *(*)(SDL_Renderer *))*(void**)(__base - 4636))(__t__p0));\
+	})
+
+#define SDL_bsearch(__p0, __p1, __p2, __p3, __p4) \
+	({ \
+		const void * __t__p0 = __p0;\
+		const void * __t__p1 = __p1;\
+		size_t  __t__p2 = __p2;\
+		size_t  __t__p3 = __p3;\
+		SDL_CompareCallback  __t__p4 = __p4;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void *(*)(const void *, const void *, size_t , size_t , SDL_CompareCallback ))*(void**)(__base - 4642))(__t__p0, __t__p1, __t__p2, __t__p3, __t__p4));\
+	})
+
+#define SDL_GameControllerPathForIndex(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((const char *(*)(int ))*(void**)(__base - 4648))(__t__p0));\
+	})
+
+#define SDL_GameControllerPath(__p0) \
+	({ \
+		SDL_GameController * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((const char *(*)(SDL_GameController *))*(void**)(__base - 4654))(__t__p0));\
+	})
+
+#define SDL_JoystickPathForIndex(__p0) \
+	({ \
+		int  __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((const char *(*)(int ))*(void**)(__base - 4660))(__t__p0));\
+	})
+
+#define SDL_JoystickPath(__p0) \
+	({ \
+		SDL_Joystick * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((const char *(*)(SDL_Joystick *))*(void**)(__base - 4666))(__t__p0));\
+	})
+
+#define SDL_JoystickAttachVirtualEx(__p0) \
+	({ \
+		const SDL_VirtualJoystickDesc * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(const SDL_VirtualJoystickDesc *))*(void**)(__base - 4672))(__t__p0));\
+	})
+
+#define SDL_HasLSX() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(void))*(void**)(__base - 4678))());\
+	})
+
+#define SDL_HasLASX() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(void))*(void**)(__base - 4684))());\
+	})
+
+#define SDL_GameControllerGetFirmwareVersion(__p0) \
+	({ \
+		SDL_GameController * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((Uint16 (*)(SDL_GameController *))*(void**)(__base - 4690))(__t__p0));\
+	})
+
+#define SDL_GUIDToString(__p0, __p1, __p2) \
+	({ \
+		SDL_GUID  __t__p0 = __p0;\
+		char * __t__p1 = __p1;\
+		int  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_GUID , char *, int ))*(void**)(__base - 4696))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_GUIDFromString(__p0) \
+	({ \
+		const char * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_GUID (*)(const char *))*(void**)(__base - 4702))(__t__p0));\
+	})
+
+#define SDL_JoystickGetFirmwareVersion(__p0) \
+	({ \
+		SDL_Joystick * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((Uint16 (*)(SDL_Joystick *))*(void**)(__base - 4708))(__t__p0));\
+	})
+
+#define SDL_GetOriginalMemoryFunctions(__p0, __p1, __p2, __p3) \
+	({ \
+		SDL_malloc_func * __t__p0 = __p0;\
+		SDL_calloc_func * __t__p1 = __p1;\
+		SDL_realloc_func * __t__p2 = __p2;\
+		SDL_free_func * __t__p3 = __p3;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_malloc_func *, SDL_calloc_func *, SDL_realloc_func *, SDL_free_func *))*(void**)(__base - 4714))(__t__p0, __t__p1, __t__p2, __t__p3));\
+	})
+
+#define SDL_ResetKeyboard() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(void))*(void**)(__base - 4720))());\
+	})
+
+#define SDL_GetPointDisplayIndex(__p0) \
+	({ \
+		const SDL_Point * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(const SDL_Point *))*(void**)(__base - 4726))(__t__p0));\
+	})
+
+#define SDL_GetRectDisplayIndex(__p0) \
+	({ \
+		const SDL_Rect * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(const SDL_Rect *))*(void**)(__base - 4732))(__t__p0));\
+	})
+
+#define SDL_ResetHint(__p0) \
+	({ \
+		const char * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(const char *))*(void**)(__base - 4738))(__t__p0));\
+	})
+
+#define SDL_crc16(__p0, __p1, __p2) \
+	({ \
+		Uint16  __t__p0 = __p0;\
+		const void * __t__p1 = __p1;\
+		size_t  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((Uint16 (*)(Uint16 , const void *, size_t ))*(void**)(__base - 4744))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_GetDefaultAudioInfo(__p0, __p1, __p2) \
+	({ \
+		char ** __t__p0 = __p0;\
+		SDL_AudioSpec * __t__p1 = __p1;\
+		int  __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(char **, SDL_AudioSpec *, int ))*(void**)(__base - 4750))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_GetWindowSizeInPixels(__p0, __p1, __p2) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		int * __t__p1 = __p1;\
+		int * __t__p2 = __p2;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_Window *, int *, int *))*(void**)(__base - 4756))(__t__p0, __t__p1, __t__p2));\
+	})
+
+#define SDL_GetJoystickGUIDInfo(__p0, __p1, __p2, __p3, __p4) \
+	({ \
+		SDL_JoystickGUID  __t__p0 = __p0;\
+		Uint16 * __t__p1 = __p1;\
+		Uint16 * __t__p2 = __p2;\
+		Uint16 * __t__p3 = __p3;\
+		Uint16 * __t__p4 = __p4;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(SDL_JoystickGUID , Uint16 *, Uint16 *, Uint16 *, Uint16 *))*(void**)(__base - 4762))(__t__p0, __t__p1, __t__p2, __t__p3, __t__p4));\
+	})
+
+#define SDL_SetPrimarySelectionText(__p0) \
+	({ \
+		const char * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(const char *))*(void**)(__base - 4768))(__t__p0));\
+	})
+
+#define SDL_GetPrimarySelectionText() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((char *(*)(void))*(void**)(__base - 4774))());\
+	})
+
+#define SDL_HasPrimarySelectionText() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(void))*(void**)(__base - 4780))());\
+	})
+
+#define SDL_ResetHints() \
+	({ \
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((void (*)(void))*(void**)(__base - 4786))());\
+	})
+
+#define SDL_strcasestr(__p0, __p1) \
+	({ \
+		const char * __t__p0 = __p0;\
+		const char * __t__p1 = __p1;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((char *(*)(const char *, const char *))*(void**)(__base - 4792))(__t__p0, __t__p1));\
+	})
+
+#define SDL_HasWindowSurface(__p0) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((SDL_bool (*)(SDL_Window *))*(void**)(__base - 4798))(__t__p0));\
+	})
+
+#define SDL_DestroyWindowSurface(__p0) \
+	({ \
+		SDL_Window * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((int (*)(SDL_Window *))*(void**)(__base - 4804))(__t__p0));\
+	})
+
+#define SDL_GameControllerGetSteamHandle(__p0) \
+	({ \
+		SDL_GameController * __t__p0 = __p0;\
+		long __base = (long)(SDL2_BASE_NAME);\
+		__asm volatile("mr 12,%0": :"r"(__base):"r12");\
+		(((Uint64 (*)(SDL_GameController *))*(void**)(__base - 4810))(__t__p0));\
+	})
+
+#endif /* !_PPCINLINE_SDL2_H */
diff -ruN SDL2-2.32.8/src/core/morphos/sdk/proto/sdl2.h SDL2-2.32.8.aros/src/core/morphos/sdk/proto/sdl2.h
--- SDL2-2.32.8/src/core/morphos/sdk/proto/sdl2.h	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/core/morphos/sdk/proto/sdl2.h	2025-07-27 14:24:13.208841322 +0000
@@ -0,0 +1,33 @@
+/* Automatically generated header! Do not edit! */
+
+#ifndef PROTO_SDL2_H
+#define PROTO_SDL2_H
+
+#ifndef __NOLIBBASE__
+extern struct Library *
+#ifdef __CONSTLIBBASEDECL__
+__CONSTLIBBASEDECL__
+#endif /* __CONSTLIBBASEDECL__ */
+SDL2Base;
+#endif /* !__NOLIBBASE__ */
+
+#include <clib/sdl2_protos.h>
+
+#ifdef __GNUC__
+#ifdef __PPC__
+#ifndef _NO_PPCINLINE
+#include <ppcinline/sdl2.h>
+#endif /* _NO_PPCINLINE */
+#else
+#ifndef _NO_INLINE
+#include <inline/sdl2.h>
+#endif /* _NO_INLINE */
+#endif /* __PPC__ */
+#elif defined(__VBCC__)
+#include <inline/sdl2_protos.h>
+#else
+#include <pragmas/sdl2_pragmas.h>
+#endif /* __GNUC__ */
+
+#endif /* !PROTO_SDL2_H */
+
diff -ruN SDL2-2.32.8/src/core/morphos/SDL_cpu.c SDL2-2.32.8.aros/src/core/morphos/SDL_cpu.c
--- SDL2-2.32.8/src/core/morphos/SDL_cpu.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/core/morphos/SDL_cpu.c	2025-07-27 14:24:13.216841322 +0000
@@ -0,0 +1,263 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2022 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#include "SDL_stdinc.h"
+
+#include <exec/types.h>
+
+#include "SDL_library.h"
+
+#if HAVE_ALTIVEC_H
+#include <hardware/vector.h>
+#endif
+
+void copy_and_swap16_generic(APTR src, APTR dst, LONG size);
+asm(
+"	.section \".text\"\n"
+"	.align 2\n"
+"	.type copy_and_swap16_generic,@function\n"
+"	.globl copy_and_swap16_generic\n"
+"copy_and_swap16_generic:\n"
+"	li     0,0\n"
+"	andi.  9,4,3\n"
+"	dcbt   0,3\n"
+"	li     11,32\n"
+"	addi   4,4,-2\n"
+"	beq    .was_even\n"
+"	lhbrx  7,3,0\n"
+"	addi   5,5,-1\n"
+"	addi   3,3,2\n"
+"	sthu   7,2(4)\n"
+".was_even:\n"
+"	cmpwi  5,7\n"
+"	li     10,4\n"
+"	ble   .tailcopy\n"
+"	addi   4,4,-2\n"
+".loop:\n"
+"	lwbrx  6,3,0\n"
+"	addi   5,5,-8\n"
+"	dcbt   11,3\n"
+"	lwbrx  7,3,10\n"
+"	cmpwi  5,7\n"
+"	rlwimi 6,6,16,0,31\n"
+"	addi   3,3,8\n"
+"	rlwimi 7,7,16,0,31\n"
+"	lwbrx  8,3,0\n"
+"	stw    6,4(4)\n"
+"	lwbrx  9,3,10\n"
+"	rlwimi 8,8,16,0,31\n"
+"	stw    7,8(4)\n"
+"	stw    8,12(4)\n"
+"	rlwimi 9,9,16,0,31\n"
+"	addi   3,3,8\n"
+"	stwu   9,16(4)\n"
+"	bgt    .loop\n"
+"	addi   4,4,2\n"
+".tailcopy:\n"
+"	cmpwi  5,0\n"
+"	subf   0,4,3\n"
+"	mtctr  5\n"
+"	bclr   4,1\n"
+".tail:\n"
+"	lhbrx  6,4,0\n"
+"	sthu   6,2(4)\n"
+"	bdnz   .tail\n"
+"	blr\n"
+);
+
+void copy_and_swap32_generic(APTR src, APTR dst, LONG size);
+asm(
+"	.section \".text\"\n"
+"	.align 2\n"
+"	.type copy_and_swap32_generic,@function\n"
+"	.globl copy_and_swap32_generic\n"
+"copy_and_swap32_generic:\n"
+"	li     0,0\n"
+"	andi.  9,4,3\n"
+"	dcbt   0,3\n"
+"	li     11,32\n"
+"	addi   4,4,-4\n"
+"	beq    .was_even4\n"
+"	lwbrx  7,3,0\n"
+"	addi   5,5,-1\n"
+"	addi   3,3,4\n"
+"	stwu   7,4(4)\n"
+".was_even4:\n"
+"	cmpwi  5,3\n"
+"	li     10,4\n"
+"	ble   .tailcopy4\n"
+"	addi   4,4,-4\n"
+".loop4:\n"
+"	lwbrx  6,3,0\n"		/* 0(r3) */
+"	addi   5,5,-4\n"
+"	dcbt   11,3\n"
+"	lwbrx  7,3,10\n"		/* 4(r3) */
+"	addi   3,3,8\n"
+"	cmpwi  5,7\n"
+"	lwbrx  8,3,0\n"
+"	stw    6,4(4)\n"
+"	lwbrx  9,3,10\n"
+"	stw    7,8(4)\n"
+"	stw    8,12(4)\n"
+"	addi   3,3,8\n"
+"	stwu   9,16(4)\n"
+"	bgt    .loop4\n"
+"	addi   4,4,4\n"
+".tailcopy4:\n"
+"	cmpwi  5,0\n"
+"	subf   0,4,3\n"
+"	mtctr  5\n"
+"	bclr   4,1\n"
+".tail4:\n"
+"	lwbrx  6,4,0\n"
+"	stwu   6,4(4)\n"
+"	bdnz   .tail4\n"
+"	blr\n"
+);
+
+/* AltiVec routines written by Grzegorz Kraszewski
+ *
+ * Length is given in pixels (number of M68k UWORDs to swap)
+ */
+
+void SDL_CopyAndSwap16(APTR srcx, APTR destx, LONG units)
+{
+	#if HAVE_ALTIVEC_H
+	if (HasAltiVec && units >= 32)
+	{
+		IPTR p1, p2;
+
+		/* Test if the same alignment and not an odd address */
+
+		p1 = (IPTR)srcx & 0xf;
+		p2 = (IPTR)destx & 0xf;
+
+		if (p1 == p2 && (!p1 || ((!(p1 & 1)) && units >= 40)))
+		{
+			VECTOR_UBYTE pr = (VECTOR_UBYTE)vec_rl((VECTOR_UWORD)vec_lvsl(0, (short*)NULL), vec_splat_u16(8));	//(VECTOR_UBYTE)VEC_VALUE(0x01, 0x00, 0x03, 0x02, 0x05, 0x04, 0x07, 0x06, 0x09, 0x08, 0x0B, 0x0A, 0x0D, 0x0C, 0x0F, 0x0E);
+			VECTOR_UBYTE lda, ldb, ldc, ldd;
+			VECTOR_UBYTE *src;
+			VECTOR_UBYTE *dest;
+
+			if (p1)
+			{
+				/* Was not aligned to 16 bytes, copy few bytes first... */
+
+				ULONG pix = (16 - p1) / 2;
+
+				copy_and_swap16_generic(srcx, destx, pix);
+
+				units -= pix;
+				srcx    = (APTR)((IPTR)srcx + pix * 2);
+				destx   = (APTR)((IPTR)destx + pix * 2);
+			}
+
+			src = (VECTOR_UBYTE*)srcx;
+			dest = (VECTOR_UBYTE*)destx;
+
+			do
+			{
+				vec_dstt(src + 8, VEC_DST_BLOCKS(320, 1, 320), 0);
+				lda = *src++;
+				ldb = *src++;
+				units -= 32;
+				ldc = *src++;
+				*dest++ = vec_perm(lda, lda, pr);
+				ldd = *src++;
+				*dest++ = vec_perm(ldb, ldb, pr);
+				*dest++ = vec_perm(ldc, ldc, pr);
+				*dest++ = vec_perm(ldd, ldd, pr);
+			} while (units >= 32);
+
+			srcx = src;
+			destx = dest;
+		}
+	}
+	#endif
+
+	if (units > 0)
+	{
+		copy_and_swap16_generic(srcx, destx, units);
+	}
+}
+
+void SDL_CopyAndSwap32(APTR srcx, APTR destx, LONG units)
+{
+	#if HAVE_ALTIVEC_H
+
+	if (units >= 32 && HasAltiVec)
+	{
+		IPTR p1, p2;
+
+		/* Test if the same alignment and not an odd address */
+
+		p1 = (IPTR)srcx & 0xf;
+		p2 = (IPTR)destx & 0xf;
+
+		if (p1 == p2 && (!p1 || ((!(p1 & 3)) && units >= 40)))
+		{
+			VECTOR_UBYTE pr = vec_xor(vec_lvsl(0, (short*)NULL), vec_splat_u8(3));
+			VECTOR_UBYTE lda, ldb, ldc, ldd;
+			VECTOR_UBYTE *src;
+			VECTOR_UBYTE *dest;
+
+			if (p1)
+			{
+				/* Was not aligned to 16 bytes, copy few bytes first... */
+
+				ULONG pix = (16 - p1) / 4;
+
+				copy_and_swap32_generic(srcx, destx, pix);
+
+				units -= pix;
+				srcx    = (APTR)((IPTR)srcx + pix * 4);
+				destx   = (APTR)((IPTR)destx + pix * 4);
+			}
+
+			src = (VECTOR_UBYTE*)srcx;
+			dest = (VECTOR_UBYTE*)destx;
+
+			do
+			{
+				vec_dstt(src + 8, VEC_DST_BLOCKS(320, 1, 320), 0);
+				lda = *src++;
+				ldb = *src++;
+				units -= 16;
+				ldc = *src++;
+				*dest++ = vec_perm(lda, lda, pr);
+				ldd = *src++;
+				*dest++ = vec_perm(ldb, ldb, pr);
+				*dest++ = vec_perm(ldc, ldc, pr);
+				*dest++ = vec_perm(ldd, ldd, pr);
+			} while (units >= 16);
+
+			srcx = src;
+			destx = dest;
+		}
+	}
+	#endif
+
+	if (units > 0)
+	{
+		copy_and_swap32_generic(srcx, destx, units);
+	}
+}
diff -ruN SDL2-2.32.8/src/core/morphos/SDL_cpu.h SDL2-2.32.8.aros/src/core/morphos/SDL_cpu.h
--- SDL2-2.32.8/src/core/morphos/SDL_cpu.h	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/core/morphos/SDL_cpu.h	2025-07-27 14:24:13.224841322 +0000
@@ -0,0 +1,34 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2020 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#ifndef SDL_CORE_MORPHOS_CPU_H
+#define SDL_CORE_MORPHOS_CPU_H
+
+#include "../../SDL_internal.h"
+
+#ifndef EXEC_TYPES_H
+#include <exec/types.h>
+#endif
+
+extern void SDL_CopyAndSwap16(APTR srcx, APTR destx, LONG units);
+extern void SDL_CopyAndSwap32(APTR srcx, APTR destx, LONG units);
+
+#endif /* SDL_CORE_MORPHOS_CPU_H */
diff -ruN SDL2-2.32.8/src/core/morphos/SDL_library.c SDL2-2.32.8.aros/src/core/morphos/SDL_library.c
--- SDL2-2.32.8/src/core/morphos/SDL_library.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/core/morphos/SDL_library.c	2025-07-27 14:24:13.228841322 +0000
@@ -0,0 +1,516 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2022 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#include <stddef.h>
+#include <stdlib.h>
+
+#include <libraries/gadtools.h>
+#include <proto/intuition.h>
+
+#include <devices/timer.h>
+#include <exec/execbase.h>
+#include <exec/resident.h>
+#include <exec/system.h>
+#include <proto/exec.h>
+#include <proto/gadtools.h>
+
+#include "SDL_mosversion.h"
+#include "SDL_library.h"
+#include "SDL_startup.h"
+
+STATIC CONST TEXT __TEXTSEGMENT__ verstring[] = VERSTAG;
+STATIC CONST TEXT libname[] = "sdl2.library";
+
+struct SDL_Library   *GlobalBase = NULL;
+
+struct ExecBase      *SysBase = NULL;
+struct DosLibrary    *DOSBase = NULL;
+struct IntuitionBase *IntuitionBase = NULL;
+struct GfxBase       *GfxBase = NULL;
+struct Library       *UtilityBase = NULL;
+struct Library       *CyberGfxBase = NULL;
+struct Library       *KeymapBase = NULL;
+struct Library       *WorkbenchBase = NULL;
+struct Library       *IconBase = NULL;
+struct Library       *MUIMasterBase = NULL;
+struct Library       *CxBase = NULL;
+struct Library       *ScreenNotifyBase = NULL;
+struct Library       *TimerBase = NULL;
+struct Library       *LocaleBase = NULL;
+struct Library       *SensorsBase = NULL;
+struct Library       *IFFParseBase = NULL;
+struct Library       *CharsetsBase = NULL;
+struct Library       *IConvBase = NULL;
+struct Library       *ThreadPoolBase = NULL;
+struct Library       *DynLoadBase = NULL;
+struct Library       *OpenURLBase = NULL;
+struct Library       *GadToolsBase = NULL;
+// struct Library		*LowLevelBase = NULL;
+
+struct timerequest   GlobalTimeReq;
+
+u_int32_t DataL1LineSize = 0;
+BYTE HasAltiVec = 0;
+
+/**********************************************************************
+	LIB_Reserved
+**********************************************************************/
+
+STATIC ULONG LIB_Reserved(void)
+{
+	return 0;
+}
+
+/**********************************************************************
+	comp_ctdt
+
+	Sort constructors/destructors
+**********************************************************************/
+
+STATIC int comp_ctdt(struct CTDT *a, struct CTDT *b)
+{
+	if (a->priority == b->priority)
+		return (0);
+	if ((unsigned long)a->priority < (unsigned long) b->priority)
+		return (-1);
+
+	return (1);
+}
+
+STATIC VOID sort_ctdt(struct SDL_Library *LibBase)
+{
+	extern struct CTDT __ctdtlist;
+	struct CTDT *ctdtlist = &__ctdtlist;
+
+	struct HunkSegment *seg = (struct HunkSegment *)(((unsigned int)ctdtlist) - sizeof(struct HunkSegment));
+	struct CTDT *_last_ctdt = (struct CTDT *)(((unsigned int)seg) + seg->Size);
+
+	qsort((struct CTDT *)ctdtlist, _last_ctdt - ctdtlist, sizeof(*ctdtlist), (int (*)(const void *, const void *))comp_ctdt);
+
+	LibBase->ctdtlist = ctdtlist;
+	LibBase->last_ctdt = _last_ctdt;
+}
+
+/**********************************************************************
+	init_system
+**********************************************************************/
+
+STATIC void init_system(struct SDL_Library *LibBase, struct ExecBase *SysBase)
+{
+	u_int32_t value;
+
+	NewGetSystemAttrsA(&value, sizeof(value), SYSTEMINFOTYPE_PPC_DCACHEL1LINESIZE, NULL);
+
+	if (value < 32)
+		value = 32;
+
+	DataL1LineSize = value;
+
+	ULONG Altivec = 0;
+	if (NewGetSystemAttrsA(&Altivec,sizeof(Altivec),SYSTEMINFOTYPE_PPC_ALTIVEC,NULL))
+    {
+		if (Altivec)
+		{
+			HasAltiVec = 1;
+		}
+	}
+}
+
+/**********************************************************************
+	init_libs
+**********************************************************************/
+
+static int init_libs(struct SDL_Library *base, struct ExecBase *SysBase)
+{
+	if ((GfxBase = base->MyGfxBase = (APTR)OpenLibrary("graphics.library", 39)) != NULL)
+	if ((DOSBase = base->MyDOSBase = (APTR)OpenLibrary("dos.library", 36)) != NULL)
+	if ((IntuitionBase = base->MyIntuiBase = (APTR)OpenLibrary("intuition.library", 39)) != NULL)
+	if ((UtilityBase = OpenLibrary("utility.library", 36)) != NULL)
+	if (OpenDevice("timer.device", UNIT_MICROHZ, &GlobalTimeReq.tr_node, 0) == 0)
+	{
+		TimerBase = (struct Library *)GlobalTimeReq.tr_node.io_Device;
+
+		sort_ctdt(base);
+		init_system(base, SysBase);
+
+		return 1;
+	}
+
+	return 0;
+}
+
+/**********************************************************************
+	data relocs
+**********************************************************************/
+
+#define R13_OFFSET 0x8000
+
+extern int __datadata_relocs(void);
+
+STATIC __inline int __dbsize(void)
+{
+	extern APTR __sdata_size, __sbss_size;
+	STATIC CONST ULONG size[] =
+	{
+		(ULONG)&__sdata_size, (ULONG)&__sbss_size
+	};
+	return size[0] + size[1];
+}
+
+/**********************************************************************
+	LIB_Init
+**********************************************************************/
+
+struct Library	*LIB_Init(struct SDL_Library *LibBase, BPTR SegList, struct ExecBase *sysBase)
+{
+	register char *r13;
+
+   GlobalBase = LibBase;
+	SysBase = sysBase;
+
+	LibBase->Library.lib_Node.ln_Pri = -5;
+#ifndef __MORPHOS__
+	LibBase->Library.lib_Revision = COMPILE_REVISION;
+#endif
+
+	asm volatile ("lis %0,__r13_init@ha; addi %0,%0,__r13_init@l" : "=r" (r13));
+
+	LibBase->SegList   = SegList;
+	LibBase->DataSeg   = r13 - R13_OFFSET;
+	LibBase->DataSize  = __dbsize();
+	LibBase->Parent    = NULL;
+	LibBase->MySysBase = sysBase;
+
+	NEWLIST(&LibBase->TaskContext.TaskList);
+
+	InitSemaphore(&LibBase->Semaphore);
+
+	if (init_libs(LibBase, sysBase) == 0)
+	{
+		FreeMem((APTR)((ULONG)(LibBase) - (ULONG)(LibBase->Library.lib_NegSize)), LibBase->Library.lib_NegSize + LibBase->Library.lib_PosSize);
+		LibBase	= NULL;
+	}
+
+	return (struct Library *)LibBase;
+}
+
+/**********************************************************************
+	DeleteLib
+**********************************************************************/
+
+static BPTR DeleteLib(struct SDL_Library *LibBase, struct ExecBase *SysBase)
+{
+	BPTR SegList = 0;
+
+	if (LibBase->Library.lib_OpenCnt == 0)
+	{
+		CloseLibrary((struct Library *)LibBase->MyGfxBase);
+		CloseLibrary((struct Library *)LibBase->MyDOSBase);
+		CloseLibrary((struct Library *)LibBase->MyIntuiBase);
+		CloseLibrary(UtilityBase);
+		CloseDevice(&GlobalTimeReq.tr_node);
+
+		SegList = LibBase->SegList;
+
+		REMOVE(&LibBase->Library.lib_Node);
+		FreeMem((APTR)((ULONG)(LibBase) - (ULONG)(LibBase->Library.lib_NegSize)), LibBase->Library.lib_NegSize + LibBase->Library.lib_PosSize);
+	}
+
+	return SegList;
+}
+
+/**********************************************************************
+	UserLibClose
+**********************************************************************/
+
+static void UserLibClose(struct SDL_Library *LibBase, struct ExecBase *SysBase)
+{
+	CloseLibrary(LibBase->MyCyberGfxBase);
+	CloseLibrary(LibBase->MyKeymapBase);
+	CloseLibrary(LibBase->MyWorkbenchBase);
+	CloseLibrary(LibBase->MyIconBase);
+	CloseLibrary(LibBase->MyMUIMasterBase);
+	CloseLibrary(LibBase->MyCxBase);
+	CloseLibrary(LibBase->MyScreenNotifyBase);
+	CloseLibrary(LocaleBase);
+	CloseLibrary(SensorsBase);
+	CloseLibrary(IFFParseBase);
+	CloseLibrary(CharsetsBase);
+	CloseLibrary(IConvBase);
+	CloseLibrary(ThreadPoolBase);
+	CloseLibrary(DynLoadBase);
+	CloseLibrary(OpenURLBase);
+	CloseLibrary(GadToolsBase);
+	
+	CyberGfxBase     = LibBase->MyCyberGfxBase     = NULL;
+	KeymapBase       = LibBase->MyKeymapBase       = NULL;
+	WorkbenchBase    = LibBase->MyWorkbenchBase    = NULL;
+	IconBase         = LibBase->MyIconBase         = NULL;
+    MUIMasterBase    = LibBase->MyMUIMasterBase    = NULL;
+	CxBase           = LibBase->MyCxBase           = NULL;
+	ScreenNotifyBase = LibBase->MyScreenNotifyBase = NULL;
+
+	LocaleBase = NULL;
+	SensorsBase = NULL;
+	IFFParseBase = NULL;
+	CharsetsBase = NULL;
+	IConvBase = NULL;
+	ThreadPoolBase = NULL;
+	DynLoadBase = NULL;
+	OpenURLBase = NULL;
+	GadToolsBase = NULL;
+}
+
+/**********************************************************************
+	LIB_Expunge
+**********************************************************************/
+
+BPTR LIB_Expunge(void)
+{
+	struct SDL_Library *LibBase = (struct SDL_Library *)REG_A6;
+	LibBase->Library.lib_Flags |= LIBF_DELEXP;
+	return DeleteLib(LibBase, LibBase->MySysBase);
+}
+
+/**********************************************************************
+	LIB_Close
+*********************************************************************/
+
+BPTR LIB_Close(void)
+{
+	struct SDL_Library *LibBase = (struct SDL_Library *)REG_A6;
+	struct ExecBase *SysBase = LibBase->MySysBase;
+	BPTR SegList = 0;
+
+	if (LibBase->Parent)
+	{
+		struct SDL_Library *ChildBase = LibBase;
+
+		if ((--ChildBase->Library.lib_OpenCnt) > 0)
+			return 0;
+
+		LibBase = ChildBase->Parent;
+
+		REMOVE(&ChildBase->TaskContext.TaskNode.Node);
+
+		MOS_Cleanup(ChildBase);
+		FreeVecTaskPooled((APTR)((ULONG)(ChildBase) - (ULONG)(ChildBase->Library.lib_NegSize)));
+	}
+
+	ObtainSemaphore(&LibBase->Semaphore);
+
+	LibBase->Library.lib_OpenCnt--;
+
+	if (LibBase->Library.lib_OpenCnt == 0)
+	{
+		LibBase->Alloc = 0;
+		UserLibClose(LibBase, SysBase);
+	}
+
+	ReleaseSemaphore(&LibBase->Semaphore);
+
+	if (LibBase->Library.lib_Flags & LIBF_DELEXP)
+		SegList	= DeleteLib(LibBase, SysBase);
+
+	return SegList;
+}
+
+/**********************************************************************
+	LIB_Open
+**********************************************************************/
+
+struct Library *LIB_Open(void)
+{
+	struct SDL_Library *LibBase = (struct SDL_Library *)REG_A6;
+	struct SDL_Library	*newbase, *childbase;
+	struct ExecBase *SysBase = LibBase->MySysBase;
+	struct Task *MyTask = SysBase->ThisTask;
+	struct TaskNode *ChildNode;
+	ULONG MyBaseSize;
+
+	/* Has this task already opened a child? */
+	ForeachNode(&LibBase->TaskContext.TaskList, ChildNode)
+	{
+		if (ChildNode->Task == MyTask)
+		{
+			/* Yep, return it */
+			childbase = (APTR)(((ULONG)ChildNode) - offsetof(struct SDL_Library, TaskContext.TaskNode.Node));
+			childbase->Library.lib_Flags &= ~LIBF_DELEXP;
+			childbase->Library.lib_OpenCnt++;
+
+			return(&childbase->Library);
+		}
+	}
+
+	childbase  = NULL;
+	MyBaseSize = LibBase->Library.lib_NegSize + LibBase->Library.lib_PosSize;
+	LibBase->Library.lib_Flags &= ~LIBF_DELEXP;
+	LibBase->Library.lib_OpenCnt++;
+
+	ObtainSemaphore(&LibBase->Semaphore);
+
+	if (LibBase->Alloc == 0)
+	{
+		if (((IntuitionBase    = LibBase->MyIntuiBase        = (APTR)OpenLibrary("intuition.library"    , 39)) != NULL)
+		 && ((CyberGfxBase     = LibBase->MyCyberGfxBase     = (APTR)OpenLibrary("cybergraphics.library", 40)) != NULL)
+		 && ((KeymapBase       = LibBase->MyKeymapBase       = (APTR)OpenLibrary("keymap.library"       , 36)) != NULL)
+		 && ((WorkbenchBase    = LibBase->MyWorkbenchBase    = (APTR)OpenLibrary("workbench.library"    ,  0)) != NULL)
+		 && ((IconBase         = LibBase->MyIconBase         = (APTR)OpenLibrary("icon.library"         ,  0)) != NULL)
+		 && ((MUIMasterBase    = LibBase->MyMUIMasterBase    = (APTR)OpenLibrary("muimaster.library"    , 19)) != NULL)
+		 && ((CxBase           = LibBase->MyCxBase           = (APTR)OpenLibrary("commodities.library"  , 37)) != NULL)
+		 && ((ScreenNotifyBase = LibBase->MyScreenNotifyBase = (APTR)OpenLibrary("screennotify.library" ,  0)) != NULL)
+		 && ((LocaleBase       =                                     OpenLibrary("locale.library"       ,  0)) != NULL)
+		 && ((SensorsBase      =                                     OpenLibrary("sensors.library"      , 53)) != NULL)
+		 && ((IFFParseBase     =                                     OpenLibrary("iffparse.library"     ,  0)) != NULL)
+		 && ((CharsetsBase     =                                     OpenLibrary("charsets.library"     , 53)) != NULL)
+		 && ((IConvBase        =                                     OpenLibrary("iconv.library"        ,  0)) != NULL)
+		 && ((ThreadPoolBase   =                                     OpenLibrary("threadpool.library"   , 53)) != NULL)
+         && ((DynLoadBase      =                                     OpenLibrary("dynload.library"      ,  0)) != NULL)
+		 && ((GadToolsBase	   =									 OpenLibrary("gadtools.library"		,  0)) != NULL)
+		 && ((OpenURLBase 	   = 									 OpenLibrary("openurl.library"		,  0)) != NULL))
+		{
+			LibBase->Alloc = 1;
+		}
+		else
+		{
+			goto error;
+		}
+	}
+
+	if ((newbase = AllocVecTaskPooled(MyBaseSize + LibBase->DataSize + 15)) != NULL)
+	{
+		CopyMem((APTR)((ULONG)LibBase - (ULONG)LibBase->Library.lib_NegSize), newbase, MyBaseSize);
+
+		childbase = (APTR)((ULONG)newbase + (ULONG)LibBase->Library.lib_NegSize);
+
+		if (LibBase->DataSize)
+		{
+			char *orig   = LibBase->DataSeg;
+			LONG *relocs = (LONG *) __datadata_relocs;
+			int mem = ((int)newbase + MyBaseSize + 15) & (unsigned int) ~15;
+
+			CopyMem(orig, (char *)mem, LibBase->DataSize);
+
+			if (relocs[0] > 0)
+			{
+				int i, num_relocs = relocs[0];
+
+				for (i = 0, relocs++; i < num_relocs; ++i, ++relocs)
+				{
+					*(long *)(mem + *relocs) -= (int)orig - mem;
+				}
+			}
+
+			childbase->DataSeg = (char *)mem + R13_OFFSET;
+
+			if (MOS_Startup(childbase) == 0)
+			{
+				MOS_Cleanup(childbase);
+				FreeVecTaskPooled(newbase);
+				childbase = 0;
+				goto error;
+			}
+		}
+
+		childbase->Parent = LibBase;
+		childbase->Library.lib_OpenCnt = 1;
+
+		/* Register which task opened this child */
+		childbase->TaskContext.TaskNode.Task = MyTask;
+		ADDTAIL(&LibBase->TaskContext.TaskList, &childbase->TaskContext.TaskNode.Node);
+	}
+	else
+	{
+error:
+		LibBase->Library.lib_OpenCnt--;
+
+		if (LibBase->Library.lib_OpenCnt == 0)
+		{
+			LibBase->Alloc	= 0;
+			UserLibClose(LibBase, SysBase);
+		}
+	}
+
+	ReleaseSemaphore(&LibBase->Semaphore);
+
+	return (struct Library *)childbase;
+}
+
+/**********************************************************************
+	Library data
+**********************************************************************/
+
+#include "SDL_stubs.h"
+
+extern void LIB_InitTGL();
+extern void LIB_InitTGL2();
+extern void LIB_SetExitPointer();
+extern void LIB_SDL_VSetError();
+
+static const APTR FuncTable[] =
+{
+	(APTR)FUNCARRAY_BEGIN,
+	(APTR)FUNCARRAY_32BIT_NATIVE, 
+
+	(APTR)LIB_Open,
+	(APTR)LIB_Close,
+	(APTR)LIB_Expunge,
+	(APTR)LIB_Reserved,
+	(APTR)-1,
+
+	(APTR)FUNCARRAY_32BIT_SYSTEMV,
+
+	(APTR)LIB_InitTGL,
+	(APTR)LIB_SetExitPointer,
+	(APTR)LIB_SDL_VSetError,
+
+	#define GENERATE_POINTERS
+	#include "SDL_stubs.h"
+
+	(APTR)-1,
+	(APTR)FUNCARRAY_END
+};
+
+static const size_t InitTable[] =
+{
+	sizeof(struct SDL_Library),
+	(size_t)FuncTable,
+	0,
+	(size_t)LIB_Init
+};
+
+const struct Resident __TEXTSEGMENT__ RomTag =
+{
+	RTC_MATCHWORD,
+	(struct Resident *)&RomTag,
+	(struct Resident *)&RomTag+1,
+	RTF_AUTOINIT | RTF_PPC | RTF_EXTENDED,
+	VERSION,
+	NT_LIBRARY,
+	0,
+	(char *)libname,
+	(char *)&verstring[7],
+	(APTR)&InitTable[0],
+	REVISION, NULL
+};
+
+CONST ULONG __abox__ = 1;
+__asm("\n.section \".ctdt\",\"a\",@progbits\n__ctdtlist:\n.long -1,-1\n");
diff -ruN SDL2-2.32.8/src/core/morphos/SDL_library.h SDL2-2.32.8.aros/src/core/morphos/SDL_library.h
--- SDL2-2.32.8/src/core/morphos/SDL_library.h	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/core/morphos/SDL_library.h	2025-07-27 14:24:13.236841322 +0000
@@ -0,0 +1,103 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2022 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#ifndef SDL_CORE_MORPHOS_LIBRARY_H
+#define SDL_CORE_MORPHOS_LIBRARY_H
+
+#include "../../SDL_internal.h"
+
+#ifndef DOS_DOS_H
+#include <dos/dos.h>
+#endif
+
+#ifndef EXEC_LIBRARIES_H
+#include <exec/libraries.h>
+#endif
+
+#ifndef EXEC_SEMAPHORES_H
+#include <exec/semaphores.h>
+#endif
+
+#define SAVEDS __saveds
+
+#if defined(__PPC__)
+#define __TEXTSEGMENT__ __attribute__((section(".text")))
+#endif
+
+struct CTDT
+{
+	int	(*fp)(void);
+	long	priority;
+};
+
+struct HunkSegment
+{
+	unsigned int Size;
+	struct HunkSegment *Next;
+};
+
+struct TaskNode
+{
+	struct MinNode Node;
+	struct Task *Task;
+};
+
+struct SDL_Library
+{
+	struct Library Library;
+	UWORD          Alloc;
+	APTR           DataSeg;	   /* DON'T CHANGE POSITION */
+
+	ULONG                  DataSize;
+	struct SDL_Library    *Parent;
+	BPTR                   SegList;
+	struct ExecBase       *MySysBase;
+	struct DosLibrary     *MyDOSBase;
+	struct IntuitionBase  *MyIntuiBase;
+	struct GfxBase        *MyGfxBase;
+	struct Library        *MyCyberGfxBase;
+	struct Library        *MyKeymapBase;
+	struct Library        *MyWorkbenchBase;
+	struct Library        *MyIconBase;
+	struct Library        *MyMUIMasterBase;
+	struct Library        *MyCxBase;
+	struct Library        *MyScreenNotifyBase;
+	APTR                   tglcontext;
+	struct Library       **MyTinyGLBase;
+	void                 **MyGLContext;
+	unsigned int		 (*MyGetMaximumContextVersion)(struct Library *TinGLBase);
+
+	union
+	{
+		struct MinList TaskList;
+		struct TaskNode TaskNode;
+	} TaskContext;
+
+	// library management
+
+	struct SignalSemaphore Semaphore;
+	APTR ctdtlist;
+	APTR last_ctdt;
+};
+
+extern BYTE HasAltiVec;
+
+#endif /* SDL_CORE_MORPHOS_LIBRARY_H */
diff -ruN SDL2-2.32.8/src/core/morphos/SDL_misc.c SDL2-2.32.8.aros/src/core/morphos/SDL_misc.c
--- SDL2-2.32.8/src/core/morphos/SDL_misc.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/core/morphos/SDL_misc.c	2025-07-27 14:24:13.244841322 +0000
@@ -0,0 +1,109 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2022 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#include "SDL_stdinc.h"
+
+#include <string.h>
+#include <sys/types.h>
+
+#if !defined(__AROS__)
+#include <proto/charsets.h>
+#else
+#include <exec/types.h>
+#endif
+
+char *
+MOS_ConvertText(const char *src, LONG srcmib, LONG dstmib)
+{
+	char *dst = NULL;
+#if !defined(__AROS__)
+	size_t dstlen, tags[] = { CST_GetDestBytes, (size_t)&dstlen, TAG_DONE };
+
+	ConvertTagList((APTR)src, -1, NULL, -1, srcmib, dstmib, (struct TagItem *)&tags);
+
+	dstlen += 1;
+	dst = SDL_malloc(dstlen);
+
+	if (dst)
+		ConvertTagList((APTR)src, -1, dst, dstlen, srcmib, dstmib, NULL);
+#endif
+	return dst;
+}
+
+char *
+MOS_ConvertPath(const char *fn)
+{
+	CONST_STRPTR src = fn;
+	ULONG flen = strlen(fn);
+	BOOL colon = FALSE;
+	char *dst, *path = SDL_malloc(flen + 2 + 128);
+
+	dst = path;
+
+	if (*src == '/')
+	{
+		/* really depends on filesystem layout, hope for the best */
+		colon	= 1;
+		src++;
+	}
+
+	while ((size_t)src < (size_t)(fn + flen))
+	{
+		const char *end = strchr(src, '/');
+		int len;
+
+		if(!end)
+			end = fn + flen; /* last component */
+
+		len = (size_t)end - (size_t)src;
+
+		if(len == 0 || (len == 1 && src[0] == '.'))
+		{
+			/* remove repeated slashes and . */
+		}
+		else
+		{
+			if (len == 1 && colon)
+			{
+				*dst++ = ':';
+				colon  = FALSE;
+			}
+			else if (len == 2 && src[0] == '.' && src[1] == '.')
+			{
+				/* replace .. with the empty string */
+			}
+			else
+			{
+				bcopy((void *)src, (void *)dst, len);
+				dst += len;
+			}
+
+			if(end < fn + flen)
+				*dst++ = '/';
+		}
+
+		src = end + 1;
+	}
+
+	*dst++ = '\0';
+	return path;
+}
diff -ruN SDL2-2.32.8/src/core/morphos/SDL_misc.h SDL2-2.32.8.aros/src/core/morphos/SDL_misc.h
--- SDL2-2.32.8/src/core/morphos/SDL_misc.h	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/core/morphos/SDL_misc.h	2025-07-27 14:24:13.248841322 +0000
@@ -0,0 +1,34 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2022 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#ifndef SDL_CORE_MORPHOS_MISC_H
+#define SDL_CORE_MORPHOS_MISC_H
+
+#include "../../SDL_internal.h"
+
+#ifndef EXEC_TYPES_H
+#include <exec/types.h>
+#endif
+
+extern char *MOS_ConvertText(const char *src, LONG srcmib, LONG dstmib);
+extern char *MOS_ConvertPath(const char *fn);
+
+#endif /* SDL_CORE_MORPHOS_MISC_H */
diff -ruN SDL2-2.32.8/src/core/morphos/SDL_mosversion.h SDL2-2.32.8.aros/src/core/morphos/SDL_mosversion.h
--- SDL2-2.32.8/src/core/morphos/SDL_mosversion.h	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/core/morphos/SDL_mosversion.h	2025-07-27 14:24:13.256841322 +0000
@@ -0,0 +1,5 @@
+#define	str(s) #s
+#define 	xstr(s) str(s)
+#define	VERSION		53
+#define	REVISION	21
+#define	VERSTAG	"\0$VER: sdl2.library " xstr(VERSION) "." xstr(REVISION) " (" __AMIGADATE__ ")  Bruno Peloille, Szilard Biro, Ilkka Lehtoranta"
diff -ruN SDL2-2.32.8/src/core/morphos/SDL_startup.c SDL2-2.32.8.aros/src/core/morphos/SDL_startup.c
--- SDL2-2.32.8/src/core/morphos/SDL_startup.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/core/morphos/SDL_startup.c	2025-07-27 14:24:13.264841322 +0000
@@ -0,0 +1,143 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2022 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#define USE_INLINE_STDARG
+
+#include <libraries/threadpool.h>
+#include <proto/threadpool.h>
+
+#include "SDL_library.h"
+
+/*********************************************************************/
+struct SDL_Library *SDL2Base;
+struct Library *TinyGLBase;
+	
+int ThisRequiresConstructorHandling = 0;
+
+/* This function must preserve all registers except r13 */
+asm
+("\n"
+"	.section \".text\"\n"
+"	.align 2\n"
+"	.type __restore_r13, @function\n"
+"__restore_r13:\n"
+"	lwz 13, 36(3)\n"
+"	blr\n"
+"__end__restore_r13:\n"
+"	.size __restore_r13, __end__restore_r13 - __restore_r13\n"
+);
+
+APTR threadpool;
+APTR libnix_mempool;
+
+/**********************************************************************
+	Startup/Cleanup
+**********************************************************************/
+
+int SAVEDS MOS_Startup(struct SDL_Library *LibBase)
+{
+	struct CTDT *ctdt = LibBase->ctdtlist, *last_ctdt = LibBase->last_ctdt;
+
+	SDL2Base = (struct SDL_Library*)&LibBase->Library;
+	
+	threadpool = CreateThreadPoolTags(32768, THREADPOOL_Name, (size_t)"SDL2", THREADPOOL_DataSegment, (size_t)LibBase->DataSeg, TAG_DONE);
+
+	if (threadpool == NULL)
+		return 0;
+
+	// Run constructors
+	while (ctdt < last_ctdt)
+	{
+		if (ctdt->priority >= 0)
+		{
+			if (ctdt->fp() != 0)
+				return 0;
+		}
+
+		ctdt++;
+	}
+
+	return 1;
+}
+
+VOID SAVEDS MOS_Cleanup(struct SDL_Library *LibBase)
+{
+	extern void SDL_Quit_REAL();
+	struct CTDT *ctdt = LibBase->ctdtlist, *last_ctdt = LibBase->last_ctdt;
+
+	SDL_Quit_REAL();
+
+	if (threadpool)
+		DeleteThreadPool(threadpool);
+
+	// Run destructors
+	while (ctdt < last_ctdt)
+	{
+		if (ctdt->priority < 0)
+		{
+			if (ctdt->fp != (int (*)(void)) -1)
+			{
+				ctdt->fp();
+			}
+		}
+
+		ctdt++;
+	}
+}
+
+/**********************************************************************
+	Library setup
+**********************************************************************/
+
+void (*morphos_exit)(int exitcode);
+
+void __saveds LIB_SetExitPointer(struct SDL_Library *base, void (*exitfunc)(int))
+{
+	morphos_exit = exitfunc;
+}
+
+/**********************************************************************
+	LIB_InitTGL
+
+	Called from auto-open library only
+**********************************************************************/
+
+VOID LIB_InitTGL(struct SDL_Library *base, void **glc, struct Library **tgl)
+{
+	if (base->MyTinyGLBase == NULL)
+	{
+		base->MyTinyGLBase = tgl;
+		base->MyGLContext  = glc;
+	}
+}
+
+VOID LIB_InitTGL2(struct SDL_Library *base, void **glc, struct Library **tgl, unsigned int (*getmaximumcontextversion)(struct Library *TinyGLBase))
+{
+	if (base->MyTinyGLBase == NULL)
+	{
+		base->MyTinyGLBase = tgl;
+		base->MyGLContext = glc;
+		base->MyGetMaximumContextVersion = getmaximumcontextversion;
+	}
+}
+
+
+void __chkabort(void) { }
diff -ruN SDL2-2.32.8/src/core/morphos/SDL_startup.h SDL2-2.32.8.aros/src/core/morphos/SDL_startup.h
--- SDL2-2.32.8/src/core/morphos/SDL_startup.h	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/core/morphos/SDL_startup.h	2025-07-27 14:24:13.268841322 +0000
@@ -0,0 +1,28 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2022 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#ifndef SDL_CORE_MORPHOS_STARTUP_H
+#define SDL_CORE_MORPHOS_STARTUP_H
+
+extern int MOS_Startup(struct SDL_Library *LibBase);
+extern VOID MOS_Cleanup(struct SDL_Library *LibBase);
+
+#endif /* SDL_CORE_MORPHOS_STARTUP_H */
diff -ruN SDL2-2.32.8/src/core/morphos/SDL_stubs.c SDL2-2.32.8.aros/src/core/morphos/SDL_stubs.c
--- SDL2-2.32.8/src/core/morphos/SDL_stubs.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/core/morphos/SDL_stubs.c	2025-07-27 14:24:13.276841322 +0000
@@ -0,0 +1,120 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2022 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#include <stdarg.h>
+
+#define GENERATE_STUBS
+#define SDL_CopyAndSwap16_REAL SDL_CopyAndSwap16
+#define SDL_CopyAndSwap32_REAL SDL_CopyAndSwap32
+#if !defined(SDL_SENSOR_DISABLED)
+int __saveds SDL_LockSensors(void) { return 0;}
+int __saveds SDL_UnlockSensors(void) { return 0;}
+#define SDL_LockSensors_REAL SDL_LockSensors
+#define SDL_UnlockSensors_REAL SDL_UnlockSensors
+#endif
+#if !defined(SDL_LOADSO_DISABLED)
+int __saveds SDL_LoadObject(void) { return 0;}
+int __saveds SDL_LoadFunction(void) { return 0;}
+int __saveds SDL_UnloadObject(void) { return 0;}
+#define SDL_LoadObject_REAL SDL_LoadObject
+#define SDL_LoadFunction_REAL SDL_LoadFunction
+#define SDL_UnloadObject_REAL SDL_UnloadObject
+#endif
+#if !defined(SDL_HIDAPIC_DISABLED)
+int __saveds SDL_hid_dummy(void) { return 0;}
+#define SDL_hid_ble_scan_REAL SDL_hid_dummy
+#define SDL_hid_get_indexed_string_REAL SDL_hid_dummy
+#define SDL_hid_get_serial_number_string_REAL SDL_hid_dummy
+#define SDL_hid_get_product_string_REAL SDL_hid_dummy
+#define SDL_hid_get_manufacturer_string_REAL SDL_hid_dummy
+#define SDL_hid_close_REAL SDL_hid_dummy
+#define SDL_hid_get_feature_report_REAL SDL_hid_dummy
+#define SDL_hid_send_feature_report_REAL SDL_hid_dummy
+#define SDL_hid_set_nonblocking_REAL SDL_hid_dummy
+#define SDL_hid_read_REAL SDL_hid_dummy
+#define SDL_hid_read_timeout_REAL SDL_hid_dummy
+#define SDL_hid_write_REAL SDL_hid_dummy
+#define SDL_hid_open_path_REAL SDL_hid_dummy
+#define SDL_hid_open_REAL SDL_hid_dummy
+#define SDL_hid_free_enumeration_REAL SDL_hid_dummy
+#define SDL_hid_enumerate_REAL SDL_hid_dummy
+#define SDL_hid_device_change_count_REAL SDL_hid_dummy
+#define SDL_hid_exit_REAL SDL_hid_dummy
+#define SDL_hid_init_REAL SDL_hid_dummy
+#endif
+#if !defined(SDL_HAPTIC_DISABLED)
+int __saveds SDL_HapticDummy(void) { return 0;}
+#define SDL_NumHaptics_REAL SDL_HapticDummy
+#define SDL_HapticName_REAL SDL_HapticDummy
+#define SDL_HapticOpen_REAL SDL_HapticDummy
+#define SDL_HapticOpened_REAL SDL_HapticDummy
+#define SDL_HapticIndex_REAL SDL_HapticDummy
+#define SDL_MouseIsHaptic_REAL SDL_HapticDummy
+#define SDL_HapticOpenFromMouse_REAL SDL_HapticDummy
+#define SDL_JoystickIsHaptic_REAL SDL_HapticDummy
+#define SDL_HapticOpenFromJoystick_REAL SDL_HapticDummy
+#define SDL_HapticClose_REAL SDL_HapticDummy
+#define SDL_HapticNumEffects_REAL SDL_HapticDummy
+#define SDL_HapticNumEffectsPlaying_REAL SDL_HapticDummy
+#define SDL_HapticQuery_REAL SDL_HapticDummy
+#define SDL_HapticNumAxes_REAL SDL_HapticDummy
+#define SDL_HapticEffectSupported_REAL SDL_HapticDummy
+#define SDL_HapticNewEffect_REAL SDL_HapticDummy
+#define SDL_HapticUpdateEffect_REAL SDL_HapticDummy
+#define SDL_HapticRunEffect_REAL SDL_HapticDummy
+#define SDL_HapticStopEffect_REAL SDL_HapticDummy
+#define SDL_HapticDestroyEffect_REAL SDL_HapticDummy
+#define SDL_HapticGetEffectStatus_REAL SDL_HapticDummy
+#define SDL_HapticSetGain_REAL SDL_HapticDummy
+#define SDL_HapticRumbleStop_REAL SDL_HapticDummy
+#define SDL_HapticRumblePlay_REAL SDL_HapticDummy
+#define SDL_HapticRumbleInit_REAL SDL_HapticDummy
+#define SDL_HapticRumbleSupported_REAL SDL_HapticDummy
+#define SDL_HapticStopAll_REAL SDL_HapticDummy
+#define SDL_HapticSetAutocenter_REAL SDL_HapticDummy
+#define SDL_HapticPause_REAL SDL_HapticDummy
+#define SDL_HapticUnpause_REAL SDL_HapticDummy
+#endif
+
+#include "SDL_stubs.h"
+
+/*********************************************************************/
+
+/* This function must preserve all registers except r13 */
+#if 1
+asm
+("\n"
+"	.section \".text\"\n"
+"	.align 2\n"
+"	.type __restore_r13, @function\n"
+"__restore_r13:\n"
+"	lwz 13, 36(12)\n"
+"	blr\n"
+"__end__restore_r13:\n"
+"	.size __restore_r13, __end__restore_r13 - __restore_r13\n"
+);
+#endif
+
+int __saveds LIB_SDL_VSetError(const char *fmt, va_list ap)
+{
+	extern int SDL_VSetError(const char *fmt, va_list ap);
+	return SDL_VSetError(fmt, ap);
+}
diff -ruN SDL2-2.32.8/src/core/morphos/SDL_stubs.h SDL2-2.32.8.aros/src/core/morphos/SDL_stubs.h
--- SDL2-2.32.8/src/core/morphos/SDL_stubs.h	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/core/morphos/SDL_stubs.h	2025-07-27 14:24:13.284841322 +0000
@@ -0,0 +1,902 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2022 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#undef STUB
+
+#if defined(GENERATE_STUBS)
+#define STUB(name) extern int name##_REAL(); int __saveds LIB_##name() { return name##_REAL(); }
+#elif defined(GENERATE_POINTERS)
+#define STUB(name) (APTR)&LIB_##name ,
+#else
+#define STUB(name) extern int LIB_##name();
+#endif
+
+	STUB(SDL_GetPlatform)
+
+	STUB(SDL_Init)
+	STUB(SDL_InitSubSystem)
+	STUB(SDL_QuitSubSystem)
+	STUB(SDL_WasInit)
+	STUB(SDL_Quit)
+	STUB(SDL_SetMainReady)
+
+	STUB(SDL_malloc)
+	STUB(SDL_calloc)
+	STUB(SDL_realloc)
+	STUB(SDL_free)
+	STUB(SDL_qsort)
+	STUB(SDL_abs)
+
+	STUB(SDL_isdigit)
+	STUB(SDL_isspace)
+	STUB(SDL_toupper)
+	STUB(SDL_tolower)
+
+	STUB(SDL_memset)
+	STUB(SDL_memcpy)
+	STUB(SDL_memmove)
+	STUB(SDL_memcmp)
+
+	STUB(SDL_wcslen)
+	STUB(SDL_wcslcpy)
+	STUB(SDL_wcslcat)
+
+	STUB(SDL_strlen)
+	STUB(SDL_strlcpy)
+	STUB(SDL_utf8strlcpy)
+	STUB(SDL_strlcat)
+	STUB(SDL_strdup)
+	STUB(SDL_strrev)
+	STUB(SDL_strupr)
+	STUB(SDL_strlwr)
+	STUB(SDL_strchr)
+	STUB(SDL_strrchr)
+	STUB(SDL_strstr)
+
+	STUB(SDL_itoa)
+	STUB(SDL_uitoa)
+	STUB(SDL_ltoa)
+	STUB(SDL_ultoa)
+	STUB(SDL_lltoa)
+	STUB(SDL_ulltoa)
+
+	STUB(SDL_atoi)
+	STUB(SDL_atof)
+	STUB(SDL_strtol)
+	STUB(SDL_strtoul)
+	STUB(SDL_strtoll)
+	STUB(SDL_strtoull)
+	STUB(SDL_strtod)
+
+	STUB(SDL_strcmp)
+	STUB(SDL_strncmp)
+	STUB(SDL_strcasecmp)
+	STUB(SDL_strncasecmp)
+
+#if 0
+#warning Following calls are available in link lib only
+#warning sscanf(...)
+#warning snprintf(...)
+#warning SDL_SetError(const char *fmt, ...)
+#warning SDL_LogMessage(int category, SDL_LogPriority priority, const char *fmt, ...)
+#warning SDL_Log(const char *fmt, ...)
+#warning SDL_LogVerbose(int category, const char *fmt, ...)
+#warning SDL_LogDebug(int category, const char *fmt, ...)
+#warning SDL_LogInfo(int category, const char *fmt, ...)
+#warning SDL_LogWarn(int category, const char *fmt, ...)
+#warning SDL_LogError(int category, const char *fmt, ...)
+#warning SDL_LogCritical(int category, const char *fmt, ...)
+	STUB(SDL_SetError(const char *fmt, ...);
+#endif
+
+	STUB(SDL_vsscanf)
+	STUB(SDL_vsnprintf)
+	STUB(SDL_acos)
+	STUB(SDL_asin)
+	STUB(SDL_atan)
+	STUB(SDL_atan2)
+	STUB(SDL_ceil)
+	STUB(SDL_copysign)
+	STUB(SDL_cos)
+	STUB(SDL_cosf)
+	STUB(SDL_fabs)
+	STUB(SDL_floor)
+	STUB(SDL_log)
+	STUB(SDL_pow)
+	STUB(SDL_scalbn)
+	STUB(SDL_sin)
+	STUB(SDL_sinf)
+	STUB(SDL_sqrt)
+	STUB(SDL_iconv_open)
+	STUB(SDL_iconv_close)
+	STUB(SDL_iconv)
+	STUB(SDL_iconv_string)
+	STUB(SDL_ReportAssertion)
+	STUB(SDL_SetAssertionHandler)
+	STUB(SDL_GetDefaultAssertionHandler)
+	STUB(SDL_GetAssertionHandler)
+	STUB(SDL_GetAssertionReport)
+	STUB(SDL_ResetAssertionReport)
+	STUB(SDL_AtomicTryLock)
+	STUB(SDL_AtomicLock)
+	STUB(SDL_AtomicUnlock)
+	STUB(SDL_AtomicCAS)
+	STUB(SDL_AtomicSet)
+	STUB(SDL_AtomicGet)
+	STUB(SDL_AtomicAdd)
+	STUB(SDL_AtomicCASPtr)
+	STUB(SDL_AtomicSetPtr)
+	STUB(SDL_AtomicGetPtr)
+	STUB(SDL_GetNumAudioDrivers)
+	STUB(SDL_GetAudioDriver)
+	STUB(SDL_AudioInit)
+	STUB(SDL_AudioQuit)
+	STUB(SDL_GetCurrentAudioDriver)
+	STUB(SDL_OpenAudio)
+	STUB(SDL_GetNumAudioDevices)
+	STUB(SDL_GetAudioDeviceName)
+	STUB(SDL_OpenAudioDevice)
+	STUB(SDL_GetAudioStatus)
+	STUB(SDL_GetAudioDeviceStatus)
+	STUB(SDL_PauseAudio)
+	STUB(SDL_PauseAudioDevice)
+	STUB(SDL_LoadWAV_RW)
+	STUB(SDL_FreeWAV)
+	STUB(SDL_BuildAudioCVT)
+	STUB(SDL_ConvertAudio)
+	STUB(SDL_MixAudio)
+	STUB(SDL_MixAudioFormat)
+	STUB(SDL_LockAudio)
+	STUB(SDL_LockAudioDevice)
+	STUB(SDL_UnlockAudio)
+	STUB(SDL_UnlockAudioDevice)
+	STUB(SDL_CloseAudio)
+	STUB(SDL_CloseAudioDevice)
+	STUB(SDL_SetClipboardText)
+	STUB(SDL_GetClipboardText)
+	STUB(SDL_HasClipboardText)
+	STUB(SDL_GetCPUCount)
+	STUB(SDL_GetCPUCacheLineSize)
+	STUB(SDL_HasRDTSC)
+	STUB(SDL_HasAltiVec)
+	STUB(SDL_HasMMX)
+	STUB(SDL_Has3DNow)
+	STUB(SDL_HasSSE)
+	STUB(SDL_HasSSE2)
+	STUB(SDL_HasSSE3)
+	STUB(SDL_HasSSE41)
+	STUB(SDL_HasSSE42)
+	STUB(SDL_HasAVX)
+	STUB(SDL_GetSystemRAM)
+	STUB(SDL_GetError)
+	STUB(SDL_ClearError)
+	STUB(SDL_Error)
+	STUB(SDL_PumpEvents)
+	STUB(SDL_PeepEvents)
+	STUB(SDL_HasEvent)
+	STUB(SDL_HasEvents)
+	STUB(SDL_FlushEvent)
+	STUB(SDL_FlushEvents)
+	STUB(SDL_PollEvent)
+	STUB(SDL_WaitEvent)
+	STUB(SDL_WaitEventTimeout)
+	STUB(SDL_PushEvent)
+	STUB(SDL_SetEventFilter)
+	STUB(SDL_GetEventFilter)
+	STUB(SDL_AddEventWatch)
+	STUB(SDL_DelEventWatch)
+	STUB(SDL_FilterEvents)
+	STUB(SDL_EventState)
+	STUB(SDL_RegisterEvents)
+	STUB(SDL_GetBasePath)
+	STUB(SDL_GetPrefPath)
+	STUB(SDL_NumJoysticks)
+	STUB(SDL_JoystickNameForIndex)
+	STUB(SDL_JoystickOpen)
+	STUB(SDL_JoystickName)
+	STUB(SDL_JoystickGetDeviceGUID)
+	STUB(SDL_JoystickGetGUID)
+	STUB(SDL_JoystickGetGUIDString)
+	STUB(SDL_JoystickGetGUIDFromString)
+	STUB(SDL_JoystickGetAttached)
+	STUB(SDL_JoystickInstanceID)
+	STUB(SDL_JoystickNumAxes)
+	STUB(SDL_JoystickNumBalls)
+	STUB(SDL_JoystickNumHats)
+	STUB(SDL_JoystickNumButtons)
+	STUB(SDL_JoystickUpdate)
+	STUB(SDL_JoystickEventState)
+	STUB(SDL_JoystickGetAxis)
+	STUB(SDL_JoystickGetHat)
+	STUB(SDL_JoystickGetBall)
+	STUB(SDL_JoystickGetButton)
+	STUB(SDL_JoystickClose)
+	STUB(SDL_GameControllerAddMappingsFromRW)
+	STUB(SDL_GameControllerAddMapping)
+	STUB(SDL_GameControllerMappingForGUID)
+	STUB(SDL_GameControllerMapping)
+	STUB(SDL_IsGameController)
+	STUB(SDL_GameControllerNameForIndex)
+	STUB(SDL_GameControllerOpen)
+	STUB(SDL_GameControllerName)
+	STUB(SDL_GameControllerGetAttached)
+	STUB(SDL_GameControllerGetJoystick)
+	STUB(SDL_GameControllerEventState)
+	STUB(SDL_GameControllerUpdate)
+	STUB(SDL_GameControllerGetAxisFromString)
+	STUB(SDL_GameControllerGetStringForAxis)
+	STUB(SDL_GameControllerGetBindForAxis)
+	STUB(SDL_GameControllerGetAxis)
+	STUB(SDL_GameControllerGetButtonFromString)
+	STUB(SDL_GameControllerGetStringForButton)
+	STUB(SDL_GameControllerGetBindForButton)
+	STUB(SDL_GameControllerGetButton)
+	STUB(SDL_GameControllerClose)
+
+	STUB(SDL_SetHintWithPriority)
+	STUB(SDL_SetHint)
+	STUB(SDL_GetHint)
+	STUB(SDL_AddHintCallback)
+	STUB(SDL_DelHintCallback)
+	STUB(SDL_ClearHints)
+	STUB(SDL_LoadObject)
+	STUB(SDL_LoadFunction)
+	STUB(SDL_UnloadObject)
+	STUB(SDL_LogSetAllPriority)
+	STUB(SDL_LogSetPriority)
+	STUB(SDL_LogGetPriority)
+	STUB(SDL_LogResetPriorities)
+	STUB(SDL_LogMessageV)
+	STUB(SDL_LogGetOutputFunction)
+	STUB(SDL_LogSetOutputFunction)
+	STUB(SDL_ShowMessageBox)
+	STUB(SDL_ShowSimpleMessageBox)
+	STUB(SDL_CreateMutex)
+	STUB(SDL_LockMutex)
+	STUB(SDL_TryLockMutex)
+	STUB(SDL_UnlockMutex)
+	STUB(SDL_DestroyMutex)
+	STUB(SDL_CreateSemaphore)
+	STUB(SDL_DestroySemaphore)
+	STUB(SDL_SemWait)
+	STUB(SDL_SemTryWait)
+	STUB(SDL_SemWaitTimeout)
+	STUB(SDL_SemPost)
+	STUB(SDL_SemValue)
+	STUB(SDL_CreateCond)
+	STUB(SDL_DestroyCond)
+	STUB(SDL_CondSignal)
+	STUB(SDL_CondBroadcast)
+	STUB(SDL_CondWait)
+	STUB(SDL_CondWaitTimeout)
+	STUB(SDL_GetPowerInfo)
+	STUB(SDL_GetNumRenderDrivers)
+	STUB(SDL_GetRenderDriverInfo)
+	STUB(SDL_CreateWindowAndRenderer)
+	STUB(SDL_CreateRenderer)
+	STUB(SDL_CreateSoftwareRenderer)
+	STUB(SDL_GetRenderer)
+	STUB(SDL_GetRendererInfo)
+	STUB(SDL_GetRendererOutputSize)
+	STUB(SDL_CreateTexture)
+	STUB(SDL_CreateTextureFromSurface)
+	STUB(SDL_QueryTexture)
+	STUB(SDL_SetTextureColorMod)
+	STUB(SDL_GetTextureColorMod)
+	STUB(SDL_SetTextureAlphaMod)
+	STUB(SDL_GetTextureAlphaMod)
+	STUB(SDL_SetTextureBlendMode)
+	STUB(SDL_GetTextureBlendMode)
+	STUB(SDL_UpdateTexture)
+	STUB(SDL_UpdateYUVTexture)
+	STUB(SDL_LockTexture)
+	STUB(SDL_UnlockTexture)
+	STUB(SDL_RenderTargetSupported)
+	STUB(SDL_SetRenderTarget)
+	STUB(SDL_GetRenderTarget)
+	STUB(SDL_RenderSetLogicalSize)
+	STUB(SDL_RenderGetLogicalSize)
+	STUB(SDL_RenderSetViewport)
+	STUB(SDL_RenderGetViewport)
+	STUB(SDL_RenderSetClipRect)
+	STUB(SDL_RenderGetClipRect)
+	STUB(SDL_RenderSetScale)
+	STUB(SDL_RenderGetScale)
+	STUB(SDL_SetRenderDrawColor)
+	STUB(SDL_GetRenderDrawColor)
+	STUB(SDL_SetRenderDrawBlendMode)
+	STUB(SDL_GetRenderDrawBlendMode)
+	STUB(SDL_RenderClear)
+	STUB(SDL_RenderDrawPoint)
+	STUB(SDL_RenderDrawPoints)
+	STUB(SDL_RenderDrawLine)
+	STUB(SDL_RenderDrawLines)
+	STUB(SDL_RenderDrawRect)
+	STUB(SDL_RenderDrawRects)
+	STUB(SDL_RenderFillRect)
+	STUB(SDL_RenderFillRects)
+	STUB(SDL_RenderCopy)
+	STUB(SDL_RenderCopyEx)
+	STUB(SDL_RenderReadPixels)
+	STUB(SDL_RenderPresent)
+	STUB(SDL_DestroyTexture)
+	STUB(SDL_DestroyRenderer)
+	STUB(SDL_GL_BindTexture)
+	STUB(SDL_GL_UnbindTexture)
+	STUB(SDL_RWFromFile)
+	STUB(SDL_RWFromFP_clib)
+	STUB(SDL_RWFromMem)
+	STUB(SDL_RWFromConstMem)
+	STUB(SDL_AllocRW)
+	STUB(SDL_FreeRW)
+	STUB(SDL_ReadU8)
+	STUB(SDL_ReadLE16)
+	STUB(SDL_ReadBE16)
+	STUB(SDL_ReadLE32)
+	STUB(SDL_ReadBE32)
+	STUB(SDL_ReadLE64)
+	STUB(SDL_ReadBE64)
+	STUB(SDL_WriteU8)
+	STUB(SDL_WriteLE16)
+	STUB(SDL_WriteBE16)
+	STUB(SDL_WriteLE32)
+	STUB(SDL_WriteBE32)
+	STUB(SDL_WriteLE64)
+	STUB(SDL_WriteBE64)
+	STUB(SDL_CreateThread)
+	STUB(SDL_GetThreadName)
+	STUB(SDL_ThreadID)
+	STUB(SDL_GetThreadID)
+	STUB(SDL_SetThreadPriority)
+	STUB(SDL_WaitThread)
+	STUB(SDL_DetachThread)
+	STUB(SDL_TLSCreate)
+	STUB(SDL_TLSGet)
+	STUB(SDL_TLSSet)
+	STUB(SDL_GetTicks)
+	STUB(SDL_GetPerformanceCounter)
+	STUB(SDL_GetPerformanceFrequency)
+	STUB(SDL_Delay)
+	STUB(SDL_AddTimer)
+	STUB(SDL_RemoveTimer)
+	STUB(SDL_GetVersion)
+	STUB(SDL_GetRevision)
+	STUB(SDL_GetRevisionNumber)
+	STUB(SDL_GetNumVideoDrivers)
+	STUB(SDL_GetVideoDriver)
+	STUB(SDL_VideoInit)
+	STUB(SDL_VideoQuit)
+	STUB(SDL_GetCurrentVideoDriver)
+	STUB(SDL_GetNumVideoDisplays)
+	STUB(SDL_GetDisplayName)
+	STUB(SDL_GetDisplayBounds)
+	STUB(SDL_GetNumDisplayModes)
+	STUB(SDL_GetDisplayMode)
+	STUB(SDL_GetDesktopDisplayMode)
+	STUB(SDL_GetCurrentDisplayMode)
+	STUB(SDL_GetClosestDisplayMode)
+	STUB(SDL_GetWindowDisplayIndex)
+	STUB(SDL_SetWindowDisplayMode)
+	STUB(SDL_GetWindowDisplayMode)
+	STUB(SDL_GetWindowPixelFormat)
+	STUB(SDL_CreateWindow)
+	STUB(SDL_CreateWindowFrom)
+	STUB(SDL_GetWindowID)
+	STUB(SDL_GetWindowFromID)
+	STUB(SDL_GetWindowFlags)
+	STUB(SDL_SetWindowTitle)
+	STUB(SDL_GetWindowTitle)
+	STUB(SDL_SetWindowIcon)
+	STUB(SDL_SetWindowData)
+	STUB(SDL_GetWindowData)
+	STUB(SDL_SetWindowPosition)
+	STUB(SDL_GetWindowPosition)
+	STUB(SDL_SetWindowSize)
+	STUB(SDL_GetWindowSize)
+	STUB(SDL_SetWindowMinimumSize)
+	STUB(SDL_GetWindowMinimumSize)
+	STUB(SDL_SetWindowMaximumSize)
+	STUB(SDL_GetWindowMaximumSize)
+	STUB(SDL_SetWindowBordered)
+	STUB(SDL_ShowWindow)
+	STUB(SDL_HideWindow)
+	STUB(SDL_RaiseWindow)
+	STUB(SDL_MaximizeWindow)
+	STUB(SDL_MinimizeWindow)
+	STUB(SDL_RestoreWindow)
+	STUB(SDL_SetWindowFullscreen)
+	STUB(SDL_GetWindowSurface)
+	STUB(SDL_UpdateWindowSurface)
+	STUB(SDL_UpdateWindowSurfaceRects)
+	STUB(SDL_SetWindowGrab)
+	STUB(SDL_GetWindowGrab)
+	STUB(SDL_SetWindowBrightness)
+	STUB(SDL_GetWindowBrightness)
+	STUB(SDL_SetWindowGammaRamp)
+	STUB(SDL_GetWindowGammaRamp)
+	STUB(SDL_DestroyWindow)
+	STUB(SDL_IsScreenSaverEnabled)
+	STUB(SDL_EnableScreenSaver)
+	STUB(SDL_DisableScreenSaver)
+
+	STUB(SDL_GetKeyboardFocus)
+	STUB(SDL_GetKeyboardState)
+	STUB(SDL_GetModState)
+	STUB(SDL_SetModState)
+	STUB(SDL_GetKeyFromScancode)
+	STUB(SDL_GetScancodeFromKey)
+	STUB(SDL_GetScancodeName)
+	STUB(SDL_GetScancodeFromName)
+	STUB(SDL_GetKeyName)
+	STUB(SDL_GetKeyFromName)
+	STUB(SDL_StartTextInput)
+	STUB(SDL_IsTextInputActive)
+	STUB(SDL_StopTextInput)
+	STUB(SDL_SetTextInputRect)
+	STUB(SDL_HasScreenKeyboardSupport)
+	STUB(SDL_IsScreenKeyboardShown)
+
+	STUB(SDL_CreateRGBSurface)
+#if defined(GENERATE_STUBS)
+	extern void *SDL_CreateRGBSurfaceFrom_REAL(void *a, int b, int c, int d, int e, int f, int g, int h, int i);
+	void * __saveds LIB_SDL_CreateRGBSurfaceFrom(void *a, int b, int c, int d, int e, int f, int g, int h, int i)
+	{
+		return SDL_CreateRGBSurfaceFrom_REAL(a, b, c, d, e, f, g, h, i);
+	}
+#else
+	STUB(SDL_CreateRGBSurfaceFrom)
+#endif
+	STUB(SDL_FreeSurface)
+	STUB(SDL_SetSurfacePalette)
+	STUB(SDL_LockSurface)
+	STUB(SDL_UnlockSurface)
+	STUB(SDL_LoadBMP_RW)
+	STUB(SDL_SaveBMP_RW)
+	STUB(SDL_SetSurfaceRLE)
+	STUB(SDL_SetColorKey)
+	STUB(SDL_GetColorKey)
+	STUB(SDL_SetSurfaceColorMod)
+	STUB(SDL_GetSurfaceColorMod)
+	STUB(SDL_SetSurfaceAlphaMod)
+	STUB(SDL_GetSurfaceAlphaMod)
+	STUB(SDL_SetSurfaceBlendMode)
+	STUB(SDL_GetSurfaceBlendMode)
+	STUB(SDL_SetClipRect)
+	STUB(SDL_GetClipRect)
+	STUB(SDL_ConvertSurface)
+	STUB(SDL_ConvertSurfaceFormat)
+	STUB(SDL_ConvertPixels)
+	STUB(SDL_FillRect)
+	STUB(SDL_FillRects)
+	STUB(SDL_UpperBlit)
+	STUB(SDL_LowerBlit)
+	STUB(SDL_SoftStretch)
+	STUB(SDL_UpperBlitScaled)
+	STUB(SDL_LowerBlitScaled)
+
+	STUB(SDL_GetMouseFocus)
+	STUB(SDL_GetMouseState)
+	STUB(SDL_GetRelativeMouseState)
+	STUB(SDL_WarpMouseInWindow)
+	STUB(SDL_SetRelativeMouseMode)
+	STUB(SDL_GetRelativeMouseMode)
+	STUB(SDL_CreateCursor)
+	STUB(SDL_CreateColorCursor)
+	STUB(SDL_CreateSystemCursor)
+	STUB(SDL_SetCursor)
+	STUB(SDL_GetCursor)
+	STUB(SDL_GetDefaultCursor)
+	STUB(SDL_FreeCursor)
+	STUB(SDL_ShowCursor)
+
+	STUB(SDL_GetPixelFormatName)
+	STUB(SDL_PixelFormatEnumToMasks)
+	STUB(SDL_MasksToPixelFormatEnum)
+	STUB(SDL_AllocFormat)
+	STUB(SDL_FreeFormat)
+	STUB(SDL_AllocPalette)
+	STUB(SDL_SetPixelFormatPalette)
+	STUB(SDL_SetPaletteColors)
+	STUB(SDL_FreePalette)
+	STUB(SDL_MapRGB)
+	STUB(SDL_MapRGBA)
+	STUB(SDL_GetRGB)
+	STUB(SDL_GetRGBA)
+	STUB(SDL_CalculateGammaRamp)
+
+	STUB(SDL_HasIntersection)
+	STUB(SDL_IntersectRect)
+	STUB(SDL_UnionRect)
+	STUB(SDL_EnclosePoints)
+	STUB(SDL_IntersectRectAndLine)
+
+	STUB(SDL_GetWindowWMInfo)
+
+	STUB(SDL_RecordGesture)
+	STUB(SDL_SaveAllDollarTemplates)
+	STUB(SDL_SaveDollarTemplate)
+	STUB(SDL_LoadDollarTemplates)
+
+	STUB(SDL_CreateShapedWindow)
+	STUB(SDL_IsShapedWindow)
+	STUB(SDL_SetWindowShape)
+	STUB(SDL_GetShapedWindowMode)
+
+	STUB(SDL_CaptureMouse)
+	STUB(SDL_WarpMouseGlobal)
+	STUB(SDL_GetGlobalMouseState)
+	STUB(SDL_SetWindowHitTest)
+	STUB(SDL_GetGrabbedWindow)
+	STUB(SDL_GetDisplayDPI)
+	STUB(SDL_RenderIsClipEnabled)
+	STUB(SDL_GameControllerFromInstanceID)
+	STUB(SDL_JoystickCurrentPowerLevel)
+	STUB(SDL_JoystickFromInstanceID)
+	STUB(SDL_HasAVX2)
+	STUB(SDL_QueueAudio)
+	STUB(SDL_GetQueuedAudioSize)
+	STUB(SDL_ClearQueuedAudio)
+	STUB(SDL_sqrtf)
+	STUB(SDL_tan)
+	STUB(SDL_tanf)
+
+	STUB(SDL_MemoryBarrierReleaseFunction)
+	STUB(SDL_MemoryBarrierAcquireFunction)
+	STUB(SDL_DequeueAudio)
+	STUB(SDL_ComposeCustomBlendMode)
+	STUB(SDL_HasNEON)
+	STUB(SDL_GameControllerNumMappings)
+	STUB(SDL_GameControllerMappingForIndex)
+	STUB(SDL_GameControllerGetVendor)
+	STUB(SDL_GameControllerGetProduct)
+	STUB(SDL_GameControllerGetProductVersion)
+	STUB(SDL_GetHintBoolean)
+	STUB(SDL_JoystickGetDeviceVendor)
+	STUB(SDL_JoystickGetDeviceProduct)
+	STUB(SDL_JoystickGetDeviceProductVersion)
+	STUB(SDL_JoystickGetDeviceType)
+	STUB(SDL_JoystickGetDeviceInstanceID)
+	STUB(SDL_JoystickGetVendor)
+	STUB(SDL_JoystickGetProduct)
+	STUB(SDL_JoystickGetProductVersion)
+	STUB(SDL_JoystickGetType)
+	STUB(SDL_JoystickGetAxisInitialState)
+	STUB(SDL_GetDisplayUsableBounds)
+	STUB(SDL_GetWindowBordersSize)
+	STUB(SDL_SetWindowResizable)
+	STUB(SDL_SetWindowOpacity)
+	STUB(SDL_GetWindowOpacity)
+	STUB(SDL_SetWindowModalFor)
+	STUB(SDL_SetWindowInputFocus)
+	STUB(SDL_CreateRGBSurfaceWithFormat)
+	STUB(SDL_CreateRGBSurfaceWithFormatFrom)
+	STUB(SDL_DuplicateSurface)
+	STUB(SDL_wcscmp)
+	STUB(SDL_utf8strlen)
+	STUB(SDL_LoadFile_RW)
+	STUB(SDL_RenderSetIntegerScale)
+	STUB(SDL_RenderGetIntegerScale)
+	
+	STUB(SDL_NewAudioStream)
+	STUB(SDL_AudioStreamPut)
+	STUB(SDL_AudioStreamGet)
+	STUB(SDL_AudioStreamAvailable)
+	STUB(SDL_AudioStreamFlush)
+	STUB(SDL_AudioStreamClear)
+	STUB(SDL_FreeAudioStream)
+	STUB(SDL_LockJoysticks)
+	STUB(SDL_UnlockJoysticks)
+	
+	STUB(SDL_GetMemoryFunctions)
+	STUB(SDL_SetMemoryFunctions)
+	STUB(SDL_GetNumAllocations)
+	
+	STUB(SDL_RenderGetMetalLayer)
+	STUB(SDL_RenderGetMetalCommandEncoder)
+	STUB(SDL_acosf)
+	STUB(SDL_asinf)
+	STUB(SDL_atanf)
+	STUB(SDL_atan2f)
+	STUB(SDL_ceilf)
+	STUB(SDL_copysignf)
+	STUB(SDL_fabsf)
+	STUB(SDL_floorf)
+	STUB(SDL_fmod)
+	STUB(SDL_fmodf)
+	STUB(SDL_logf)
+	STUB(SDL_log10)
+	STUB(SDL_log10f)
+	STUB(SDL_powf)
+	STUB(SDL_scalbnf)
+	STUB(SDL_SetYUVConversionMode)
+	STUB(SDL_GetYUVConversionMode)
+	STUB(SDL_GetYUVConversionModeForResolution)
+	
+	STUB(SDL_HasAVX512F)
+	STUB(SDL_GameControllerMappingForDeviceIndex)
+	STUB(SDL_GameControllerGetPlayerIndex)
+	STUB(SDL_GameControllerRumble)
+	STUB(SDL_JoystickGetDevicePlayerIndex)
+	STUB(SDL_JoystickGetPlayerIndex)
+	STUB(SDL_JoystickRumble)
+	STUB(SDL_wcsdup)
+	STUB(SDL_exp)
+	STUB(SDL_expf)
+	STUB(SDL_HasColorKey)
+	STUB(SDL_IsTablet)
+	STUB(SDL_CreateThreadWithStackSize)
+	STUB(SDL_GetDisplayOrientation)
+	
+	STUB(SDL_SIMDGetAlignment)
+	STUB(SDL_SIMDAlloc)
+	STUB(SDL_SIMDFree)
+	STUB(SDL_RenderDrawPointF)
+	STUB(SDL_RenderDrawPointsF)
+	STUB(SDL_RenderDrawLineF)
+	STUB(SDL_RenderDrawLinesF)
+	STUB(SDL_RenderDrawRectF)
+	STUB(SDL_RenderDrawRectsF)
+	STUB(SDL_RenderFillRectF)
+	STUB(SDL_RenderFillRectsF)
+	STUB(SDL_RenderCopyF)
+	STUB(SDL_RenderCopyExF)
+	STUB(SDL_RenderFlush)
+	STUB(SDL_RWsize)
+	STUB(SDL_RWseek)
+	STUB(SDL_RWtell)
+	STUB(SDL_RWread)
+	STUB(SDL_RWwrite)
+	STUB(SDL_RWclose)
+	STUB(SDL_LoadFile)
+	STUB(SDL_GetTouchDeviceType)
+
+	STUB(SDL_HasARMSIMD)
+	STUB(SDL_GameControllerTypeForIndex)
+	STUB(SDL_GameControllerFromPlayerIndex)
+	STUB(SDL_GameControllerGetType)
+	STUB(SDL_GameControllerSetPlayerIndex)
+	STUB(SDL_JoystickFromPlayerIndex)
+	STUB(SDL_JoystickSetPlayerIndex)
+	STUB(SDL_SetTextureScaleMode)
+	STUB(SDL_GetTextureScaleMode)
+	STUB(SDL_LockTextureToSurface)
+	STUB(SDL_wcsstr)
+	STUB(SDL_wcsncmp)
+	STUB(SDL_strtokr)
+
+	STUB(SDL_GL_LoadLibrary)
+	STUB(SDL_GL_GetProcAddress)
+	STUB(SDL_GL_UnloadLibrary)
+	STUB(SDL_GL_ExtensionSupported)
+	STUB(SDL_GL_ResetAttributes)
+	STUB(SDL_GL_SetAttribute)
+	STUB(SDL_GL_GetAttribute)
+	STUB(SDL_GL_CreateContext)
+	STUB(SDL_GL_MakeCurrent)
+	STUB(SDL_GL_GetCurrentWindow)
+	STUB(SDL_GL_GetCurrentContext)
+	STUB(SDL_GL_GetDrawableSize)
+	STUB(SDL_GL_SetSwapInterval)
+	STUB(SDL_GL_GetSwapInterval)
+	STUB(SDL_GL_SwapWindow)
+	STUB(SDL_GL_DeleteContext)
+
+	/* Haptic */
+	STUB(SDL_NumHaptics)
+	STUB(SDL_HapticName)
+	STUB(SDL_HapticOpen)
+	STUB(SDL_HapticOpened)
+	STUB(SDL_HapticIndex)
+	STUB(SDL_MouseIsHaptic)
+	STUB(SDL_HapticOpenFromMouse)
+	STUB(SDL_JoystickIsHaptic)
+	STUB(SDL_HapticOpenFromJoystick)
+	STUB(SDL_HapticClose)
+	STUB(SDL_HapticNumEffects)
+	STUB(SDL_HapticNumEffectsPlaying)
+	STUB(SDL_HapticQuery)
+	STUB(SDL_HapticNumAxes)
+	STUB(SDL_HapticEffectSupported)
+	STUB(SDL_HapticNewEffect)
+	STUB(SDL_HapticUpdateEffect)
+	STUB(SDL_HapticRunEffect)
+	STUB(SDL_HapticStopEffect)
+	STUB(SDL_HapticDestroyEffect)
+	STUB(SDL_HapticGetEffectStatus)
+	STUB(SDL_HapticSetGain)
+	STUB(SDL_HapticSetAutocenter)
+	STUB(SDL_HapticPause)
+	STUB(SDL_HapticUnpause)
+	STUB(SDL_HapticStopAll)
+	STUB(SDL_HapticRumbleSupported)
+	STUB(SDL_HapticRumbleInit)
+	STUB(SDL_HapticRumblePlay)
+	STUB(SDL_HapticRumbleStop)
+	
+	STUB(SDL_isupper)
+	STUB(SDL_islower)
+	STUB(SDL_JoystickAttachVirtual)
+	STUB(SDL_JoystickDetachVirtual)
+	STUB(SDL_JoystickIsVirtual)
+	STUB(SDL_JoystickSetVirtualAxis)
+	STUB(SDL_JoystickSetVirtualButton)
+	STUB(SDL_JoystickSetVirtualHat)
+	STUB(SDL_GetErrorMsg)
+	STUB(SDL_LockSensors)
+	STUB(SDL_UnlockSensors)
+	STUB(SDL_Metal_GetLayer)
+	STUB(SDL_Metal_GetDrawableSize)
+	STUB(SDL_trunc)
+	STUB(SDL_truncf)
+	STUB(SDL_GetPreferredLocales)
+	STUB(SDL_SIMDRealloc)
+	STUB(SDL_OpenURL)
+	STUB(SDL_HasSurfaceRLE)
+	STUB(SDL_GameControllerHasLED)
+	STUB(SDL_GameControllerSetLED)
+	STUB(SDL_JoystickHasLED)
+	STUB(SDL_JoystickSetLED)
+	STUB(SDL_GameControllerRumbleTriggers)
+	STUB(SDL_JoystickRumbleTriggers)
+	STUB(SDL_GameControllerHasAxis)
+	STUB(SDL_GameControllerHasButton)
+	STUB(SDL_GameControllerGetNumTouchpads)
+	STUB(SDL_GameControllerGetNumTouchpadFingers)
+	STUB(SDL_GameControllerGetTouchpadFinger)
+	STUB(SDL_GetNumTouchDevices)
+	STUB(SDL_GetTouchDevice)
+	STUB(SDL_GetNumTouchFingers)
+	STUB(SDL_GetTouchFinger)
+	STUB(SDL_crc32)
+	STUB(SDL_GameControllerGetSerial)
+	STUB(SDL_JoystickGetSerial)
+	STUB(SDL_GameControllerHasSensor)
+	STUB(SDL_GameControllerSetSensorEnabled)
+	STUB(SDL_GameControllerIsSensorEnabled)
+	STUB(SDL_GameControllerGetSensorData)
+	STUB(SDL_wcscasecmp)
+	STUB(SDL_wcsncasecmp)
+		
+	STUB(SDL_CopyAndSwap16)
+	STUB(SDL_CopyAndSwap32)
+	
+	STUB(SDL_UpdateNVTexture)
+	STUB(SDL_round)
+	STUB(SDL_roundf)
+	STUB(SDL_lround)
+	STUB(SDL_lroundf)
+	STUB(SDL_SoftStretchLinear)
+	STUB(SDL_SetWindowKeyboardGrab)
+	STUB(SDL_SetWindowMouseGrab)
+	STUB(SDL_GetWindowKeyboardGrab)
+	STUB(SDL_GetWindowMouseGrab)
+	STUB(SDL_isalpha)
+	STUB(SDL_isalnum)
+	STUB(SDL_isblank)
+	STUB(SDL_iscntrl)
+	STUB(SDL_isxdigit)
+	STUB(SDL_ispunct)
+	STUB(SDL_isprint)
+	STUB(SDL_isgraph)
+	STUB(SDL_GetAudioDeviceSpec)
+	STUB(SDL_TLSCleanup)
+	STUB(SDL_SetWindowAlwaysOnTop)
+	STUB(SDL_FlashWindow)
+	STUB(SDL_GameControllerSendEffect)
+	STUB(SDL_JoystickSendEffect)
+	STUB(SDL_GameControllerGetSensorDataRate)
+	
+	STUB(SDL_SetTextureUserData)
+	STUB(SDL_GetTextureUserData)
+	STUB(SDL_RenderGeometry)
+#if defined(GENERATE_STUBS)
+	extern void *SDL_RenderGeometryRaw_REAL(void *a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k, int l);
+	void * __saveds LIB_SDL_RenderGeometryRaw(void *a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k, int l)
+	{
+		return SDL_RenderGeometryRaw_REAL(a, b, c, d, e, f, g, h, i, j, k, l);
+	}
+#else
+	STUB(SDL_RenderGeometryRaw)
+#endif
+	STUB(SDL_RenderSetVSync)
+	STUB(SDL_vasprintf)
+	STUB(SDL_GetWindowICCProfile)
+	STUB(SDL_GetTicks64)
+	STUB(SDL_GameControllerGetAppleSFSymbolsNameForButton)
+	STUB(SDL_GameControllerGetAppleSFSymbolsNameForAxis)
+	STUB(SDL_hid_init)
+	STUB(SDL_hid_exit)
+	STUB(SDL_hid_device_change_count)
+	STUB(SDL_hid_enumerate)
+	STUB(SDL_hid_free_enumeration)
+	STUB(SDL_hid_open)
+	STUB(SDL_hid_open_path)
+	STUB(SDL_hid_write)
+	STUB(SDL_hid_read_timeout)
+	STUB(SDL_hid_read)
+	STUB(SDL_hid_set_nonblocking)
+	STUB(SDL_hid_send_feature_report)
+	STUB(SDL_hid_get_feature_report)
+	STUB(SDL_hid_close)
+	STUB(SDL_hid_get_manufacturer_string)
+	STUB(SDL_hid_get_product_string)
+	STUB(SDL_hid_get_serial_number_string)
+	STUB(SDL_hid_get_indexed_string)
+	STUB(SDL_SetWindowMouseRect)
+	STUB(SDL_GetWindowMouseRect)
+	STUB(SDL_RenderWindowToLogical)
+	STUB(SDL_RenderLogicalToWindow)
+	STUB(SDL_JoystickHasRumble)
+	STUB(SDL_JoystickHasRumbleTriggers)
+	STUB(SDL_GameControllerHasRumble)
+	STUB(SDL_GameControllerHasRumbleTriggers)
+	STUB(SDL_hid_ble_scan)
+	STUB(SDL_PremultiplyAlpha)
+	STUB(SDL_getenv)
+	STUB(SDL_setenv)
+
+	STUB(SDL_GetTouchName)
+	STUB(SDL_ClearComposition)
+	STUB(SDL_IsTextInputShown)
+	STUB(SDL_HasIntersectionF)
+	STUB(SDL_IntersectFRect)
+	STUB(SDL_UnionFRect)
+	STUB(SDL_EncloseFPoints)
+	STUB(SDL_IntersectFRectAndLine)
+	STUB(SDL_RenderGetWindow)
+	// 2.24.0
+	STUB(SDL_bsearch)
+	STUB(SDL_GameControllerPathForIndex)
+	STUB(SDL_GameControllerPath)
+	STUB(SDL_JoystickPathForIndex)
+	STUB(SDL_JoystickPath)
+	STUB(SDL_JoystickAttachVirtualEx)
+	STUB(SDL_HasLSX)
+	STUB(SDL_HasLASX)
+	STUB(SDL_GameControllerGetFirmwareVersion)
+	STUB(SDL_GUIDToString)
+	STUB(SDL_GUIDFromString)
+	STUB(SDL_JoystickGetFirmwareVersion)
+	STUB(SDL_GetOriginalMemoryFunctions)
+	STUB(SDL_ResetKeyboard)	
+	STUB(SDL_GetPointDisplayIndex)
+	STUB(SDL_GetRectDisplayIndex)
+	STUB(SDL_ResetHint)
+	STUB(SDL_crc16)
+	STUB(SDL_GetDefaultAudioInfo)
+	// 2.26.0
+	STUB(SDL_GetWindowSizeInPixels)
+	STUB(SDL_GetJoystickGUIDInfo)
+	STUB(SDL_SetPrimarySelectionText)
+	STUB(SDL_GetPrimarySelectionText)
+	STUB(SDL_HasPrimarySelectionText)
+	STUB(SDL_ResetHints)
+	STUB(SDL_strcasestr)
+	// 2.28.0
+	STUB(SDL_HasWindowSurface)
+	STUB(SDL_DestroyWindowSurface)
+	//
+	STUB(SDL_GameControllerGetSteamHandle)
+
+	// sdl2.library 53.17++
+#if defined(GENERATE_POINTERS)
+	(APTR)&LIB_InitTGL2,
+#endif
\ No newline at end of file
diff -ruN SDL2-2.32.8/src/cpuinfo/SDL_cpuinfo.c SDL2-2.32.8.aros/src/cpuinfo/SDL_cpuinfo.c
--- SDL2-2.32.8/src/cpuinfo/SDL_cpuinfo.c	2025-05-08 20:10:28.000000000 +0000
+++ SDL2-2.32.8.aros/src/cpuinfo/SDL_cpuinfo.c	2025-07-27 14:24:13.612841324 +0000
@@ -62,6 +62,13 @@
 #include <setjmp.h>
 #endif
 
+#ifdef __MORPHOS__
+#include <stdlib.h>
+#include <exec/execbase.h>
+#include <exec/system.h>
+#include <proto/exec.h>
+#endif
+
 #if defined(__QNXNTO__)
 #include <sys/syspage.h>
 #endif
@@ -131,7 +138,7 @@
     !((defined(__MACOSX__) && (defined(__ppc__) || defined(__ppc64__))) || (defined(__OpenBSD__) && defined(__powerpc__))) && \
     !(defined(__FreeBSD__) && defined(__powerpc__)) && \
     !(defined(__LINUX__) && defined(__powerpc__) && defined(HAVE_GETAUXVAL)) && \
-    defined(SDL_ALTIVEC_BLITTERS) && defined(HAVE_SETJMP)
+    defined(SDL_ALTIVEC_BLITTERS) && defined(HAVE_SETJMP) && !defined(__MORPHOS__)
 /* This is the brute force way of detecting instruction sets...
    the idea is borrowed from the libmpeg2 library - thanks!
  */
@@ -355,6 +362,13 @@
     if (0 == error) {
         altivec = (hasVectorUnit != 0);
     }
+#elif defined(__MORPHOS__)
+    ULONG has_altivec;
+    if (NewGetSystemAttrs(&has_altivec, sizeof(has_altivec), SYSTEMINFOTYPE_PPC_ALTIVEC, TAG_DONE))
+    {
+      if (has_altivec)
+        altivec = 1;
+    }
 #elif defined(__FreeBSD__) && defined(__powerpc__)
     unsigned long cpufeatures = 0;
     elf_aux_info(AT_HWCAP, &cpufeatures, sizeof(cpufeatures));
@@ -699,6 +713,9 @@
                             &SDL_CPUCount, sizeof(SDL_CPUCount) );
         }
 #endif
+#ifdef __MORPHOS__
+	NewGetSystemAttrs(&SDL_CPUCount, sizeof(SDL_CPUCount), SYSTEMINFOTYPE_CPUCOUNT, TAG_DONE);
+#endif
 #endif
         /* There has to be at least 1, right? :) */
         if (SDL_CPUCount <= 0) {
@@ -934,6 +951,9 @@
         }
 #elif defined(__FreeBSD__) && defined(CACHE_LINE_SIZE)
         cacheline_size = CACHE_LINE_SIZE;
+#elif __MORPHOS__
+        extern u_int32_t DataL1LineSize;
+        cacheline_size = DataL1LineSize;
 #endif
     }
     return cacheline_size;
@@ -1156,6 +1176,11 @@
             }
         }
 #endif
+#ifdef __MORPHOS__
+        if (SDL_SystemRAM <= 0) {
+            SDL_SystemRAM = AvailMem(MEMF_TOTAL) / (1024 * 1024);
+        }
+#endif
 #ifdef __VITA__
         if (SDL_SystemRAM <= 0) {
             /* Vita has 512MiB on SoC, that's split into 256MiB(+109MiB in extended memory mode) for app
diff -ruN SDL2-2.32.8/src/dynapi/SDL_dynapi.h SDL2-2.32.8.aros/src/dynapi/SDL_dynapi.h
--- SDL2-2.32.8/src/dynapi/SDL_dynapi.h	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/src/dynapi/SDL_dynapi.h	2025-07-28 12:54:16.736849927 +0000
@@ -69,6 +69,8 @@
 #define SDL_DYNAMIC_API 0 /* devkitARM doesn't support dynamic linking */
 #elif defined(DYNAPI_NEEDS_DLOPEN) && !defined(HAVE_DLOPEN)
 #define SDL_DYNAMIC_API 0 /* we need dlopen(), but don't have it.... */
+#elif defined(__AROS__)
+#define SDL_DYNAMIC_API 0
 #endif
 
 /* everyone else. This is where we turn on the API if nothing forced it off. */
diff -ruN SDL2-2.32.8/src/events/scancodes_morphos.h SDL2-2.32.8.aros/src/events/scancodes_morphos.h
--- SDL2-2.32.8/src/events/scancodes_morphos.h	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/events/scancodes_morphos.h	2025-07-27 14:24:13.720841324 +0000
@@ -0,0 +1,144 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../include/SDL_scancode.h"
+
+/* Amiga virtual key code to SDL_Keycode mapping table
+   Sources:
+   - AmigaOS wiki
+*/
+/* *INDENT-OFF* */
+static SDL_Scancode const morphos_scancode_table[] = {
+    /*  0 */    SDL_SCANCODE_GRAVE,
+    /*  1 */    SDL_SCANCODE_1,
+    /*  2 */    SDL_SCANCODE_2,
+    /*  3 */    SDL_SCANCODE_3,
+    /*  4 */    SDL_SCANCODE_4,
+    /*  5 */    SDL_SCANCODE_5,
+    /*  6 */    SDL_SCANCODE_6,
+    /*  7 */    SDL_SCANCODE_7,
+    /*  8 */    SDL_SCANCODE_8,
+    /*  9 */     SDL_SCANCODE_9,
+    /*  10 */    SDL_SCANCODE_0,
+    /*  11 */    SDL_SCANCODE_MINUS,
+    /*  12 */    SDL_SCANCODE_EQUALS,
+    /*  13 */    SDL_SCANCODE_BACKSLASH,
+    /*  14 */    SDL_SCANCODE_INTERNATIONAL3,
+    /*  15 */    SDL_SCANCODE_KP_0,
+    /*  16 */    SDL_SCANCODE_Q,
+    /*  17 */    SDL_SCANCODE_W,
+    /*  18 */    SDL_SCANCODE_E,
+    /*  19 */    SDL_SCANCODE_R,
+    /*  20 */    SDL_SCANCODE_T,
+    /*  21 */    SDL_SCANCODE_Y,
+    /*  22 */    SDL_SCANCODE_U,
+    /*  23 */    SDL_SCANCODE_I,
+    /*  24 */    SDL_SCANCODE_O,
+    /*  25 */    SDL_SCANCODE_P,
+    /*  26 */    SDL_SCANCODE_LEFTBRACKET,
+    /*  27 */    SDL_SCANCODE_RIGHTBRACKET,
+    /*  28 */    SDL_SCANCODE_UNKNOWN,
+    /*  29 */    SDL_SCANCODE_KP_1,
+    /*  30 */    SDL_SCANCODE_KP_2,
+    /*  31 */    SDL_SCANCODE_KP_3,
+    /*  32 */    SDL_SCANCODE_A,
+    /*  33 */    SDL_SCANCODE_S,
+    /*  34 */    SDL_SCANCODE_D,
+    /*  35 */    SDL_SCANCODE_F,
+    /*  36 */    SDL_SCANCODE_G,
+    /*  37 */    SDL_SCANCODE_H,
+    /*  38 */    SDL_SCANCODE_J,
+    /*  39 */    SDL_SCANCODE_K,
+    /*  40 */    SDL_SCANCODE_L,
+    /*  41 */    SDL_SCANCODE_SEMICOLON,
+    /*  42 */    SDL_SCANCODE_APOSTROPHE,
+    /*  43 */    SDL_SCANCODE_INTERNATIONAL1,
+    /*  44 */    SDL_SCANCODE_UNKNOWN,
+    /*  45 */    SDL_SCANCODE_KP_4,
+    /*  46 */    SDL_SCANCODE_KP_5,
+    /*  47 */    SDL_SCANCODE_KP_6,
+    /*  48 */    SDL_SCANCODE_INTERNATIONAL2,
+    /*  49 */    SDL_SCANCODE_Z,
+    /*  50 */    SDL_SCANCODE_X,
+    /*  51 */    SDL_SCANCODE_C,
+    /*  52 */    SDL_SCANCODE_V,
+    /*  53 */    SDL_SCANCODE_B,
+    /*  54 */    SDL_SCANCODE_N,
+    /*  55 */    SDL_SCANCODE_M,
+    /*  56 */    SDL_SCANCODE_COMMA,
+    /*  57 */    SDL_SCANCODE_PERIOD,
+    /*  58 */    SDL_SCANCODE_SLASH,
+    /*  59 */    SDL_SCANCODE_UNKNOWN, // or SDL_SCANCODE_INTERNATIONAL1,
+    /*  60 */    SDL_SCANCODE_KP_PERIOD,
+    /*  61 */    SDL_SCANCODE_KP_7,
+    /*  62 */    SDL_SCANCODE_KP_8,
+    /*  63 */    SDL_SCANCODE_KP_9,
+    /*  64 */    SDL_SCANCODE_SPACE,
+    /*  65 */    SDL_SCANCODE_BACKSPACE,
+    /*  66 */    SDL_SCANCODE_TAB,
+    /*  67 */    SDL_SCANCODE_KP_ENTER,
+    /*  68 */    SDL_SCANCODE_RETURN,
+    /*  69 */    SDL_SCANCODE_ESCAPE,
+    /*  70 */    SDL_SCANCODE_DELETE,
+    /*  71 */    SDL_SCANCODE_INSERT,
+    /*  72 */    SDL_SCANCODE_PAGEUP,
+    /*  73 */    SDL_SCANCODE_PAGEDOWN,
+    /*  74 */    SDL_SCANCODE_KP_MINUS,
+    /*  75 */    SDL_SCANCODE_F11,
+    /*  76 */    SDL_SCANCODE_UP,
+    /*  77 */    SDL_SCANCODE_DOWN,
+    /*  78 */    SDL_SCANCODE_RIGHT,
+    /*  79 */    SDL_SCANCODE_LEFT,
+    /*  80 */    SDL_SCANCODE_F1,
+    /*  81 */    SDL_SCANCODE_F2,
+    /*  82 */    SDL_SCANCODE_F3,
+    /*  83 */    SDL_SCANCODE_F4,
+    /*  84 */    SDL_SCANCODE_F5,
+    /*  85 */    SDL_SCANCODE_F6,
+    /*  86 */    SDL_SCANCODE_F7,
+    /*  87 */    SDL_SCANCODE_F8,
+    /*  88 */    SDL_SCANCODE_F9,
+    /*  89 */    SDL_SCANCODE_F10,
+    /*  90 */    SDL_SCANCODE_KP_LEFTPAREN,
+    /*  91 */    SDL_SCANCODE_KP_RIGHTPAREN,
+    /*  92 */    SDL_SCANCODE_KP_DIVIDE,
+    /*  93 */    SDL_SCANCODE_KP_MULTIPLY,
+    /*  94 */    SDL_SCANCODE_KP_PLUS,
+    /*  95 */    SDL_SCANCODE_SCROLLLOCK, // or SDL_SCANCODE_HELP,
+    /*  96 */    SDL_SCANCODE_LSHIFT,
+    /*  97 */    SDL_SCANCODE_RSHIFT,
+    /*  98 */    SDL_SCANCODE_CAPSLOCK,
+    /*  99 */    SDL_SCANCODE_LCTRL,
+    /*  100 */    SDL_SCANCODE_LALT,
+    /*  101 */    SDL_SCANCODE_RALT,
+    /*  102 */    SDL_SCANCODE_LGUI,
+    /*  103 */    SDL_SCANCODE_RGUI,
+    /*  104 */    SDL_SCANCODE_UNKNOWN,
+    /*  105 */    SDL_SCANCODE_UNKNOWN,
+    /*  106 */    SDL_SCANCODE_UNKNOWN,
+    /*  107 */    SDL_SCANCODE_MENU,
+    /*  108 */    SDL_SCANCODE_KP_PERIOD,
+    /*  109 */    SDL_SCANCODE_PRINTSCREEN,
+    /*  110 */    SDL_SCANCODE_PAUSE,
+    /*  111 */    SDL_SCANCODE_F12,
+    /*  112 */    SDL_SCANCODE_HOME,
+    /*  113 */    SDL_SCANCODE_END,
+};
+/* *INDENT-ON* */
diff -ruN SDL2-2.32.8/src/file/SDL_rwops.c SDL2-2.32.8.aros/src/file/SDL_rwops.c
--- SDL2-2.32.8/src/file/SDL_rwops.c	2025-01-28 07:47:10.000000000 +0000
+++ SDL2-2.32.8.aros/src/file/SDL_rwops.c	2025-07-28 14:28:59.234760705 +0000
@@ -67,6 +67,33 @@
 #include "nacl_io/nacl_io.h"
 #endif
 
+#ifdef __AROS__
+#include "../core/morphos/SDL_misc.h"
+#include <proto/dos.h>
+#endif
+
+#ifdef __MORPHOS__
+#include "../core/morphos/SDL_library.h"
+#include "../core/morphos/SDL_misc.h"
+#include <proto/dos.h>
+
+#undef SDLCALL
+#define SDLCALL __saveds
+
+/* This function must preserve all registers except r13 */
+asm
+("\n"
+"	.section \".text\"\n"
+"	.align 2\n"
+"	.type __restore_r13, @function\n"
+"__restore_r13:\n"
+"	lwz 13, 24(3)\n"
+"	blr\n"
+"__end__restore_r13:\n"
+"	.size __restore_r13, __end__restore_r13 - __restore_r13\n"
+);
+#endif
+
 #if defined(__WIN32__) || defined(__GDK__)
 
 /* Functions to read/write Win32 API file pointers */
@@ -311,7 +338,226 @@
 }
 #endif /* defined(__WIN32__) || defined(__GDK__) */
 
-#ifdef HAVE_STDIO_H
+#if defined(__MORPHOS__) || defined(__AROS__)
+static int
+amigaos_file_open(SDL_RWops *context, const char *filename, const char *mode)
+{
+    int flag_r, flag_w, flag_p, flag_a;
+    int rc = -1;
+
+    /* "r" = reading, file must exist */
+    /* "w" = writing, truncate existing, file may not exist */
+    /* "r+"= reading or writing, file must exist            */
+    /* "a" = writing, append file may not exist             */
+    /* "a+"= append + read, file may not exist              */
+    /* "w+" = read, write, truncate. file may not exist    */
+
+    flag_r = strchr(mode, 'r') ? 1 : 0;
+    flag_w = strchr(mode, 'w') ? 1 : 0;
+    flag_p = strchr(mode, '+') ? 1 : 0;
+    flag_a = strchr(mode, 'a') ? 1 : 0;
+
+    if (flag_r || flag_w || flag_a)
+    {
+        size_t mode = MODE_OLDFILE;
+        BPTR fh;
+
+        if (flag_a)
+        {
+            mode = MODE_READWRITE;
+        }
+        else if (flag_w)
+        {
+            mode = MODE_NEWFILE;
+        }
+
+        fh = Open(filename, mode);
+
+        context->hidden.amigaosio.Writable = (flag_w || flag_a || flag_p) ? 1 : 0;
+        context->hidden.amigaosio.Readable = (flag_r || flag_p) ? 1 : 0;
+
+        context->hidden.amigaosio.autoclose = 1;
+        context->hidden.amigaosio.AMIGAOSIO_BPTR = fh;
+
+        if (fh)
+        {
+            rc = 0;
+
+            context->hidden.amigaosio.AppendMode = 0;
+            context->hidden.amigaosio.NoSeek = 0;
+            context->hidden.amigaosio.IsAtEnd = 0;
+
+            if (flag_a)
+            {
+                context->hidden.amigaosio.AppendMode = 1;
+
+                if (!flag_p)
+                {
+                    context->hidden.amigaosio.NoSeek = 1;
+                    context->hidden.amigaosio.IsAtEnd = 1;
+                    Seek(fh, 0, OFFSET_END);
+                }
+            }
+        }
+    }
+
+    return rc;
+}
+
+static Sint64 SDLCALL
+amigaos_file_size(SDL_RWops * context)
+{
+    struct FileInfoBlock fib;
+
+#if defined(__MORPHOS__)
+    if (ExamineFH64(context->hidden.amigaosio.fp.dos, &fib, TAG_DONE))
+        return fib.fib_Size64;
+#else
+    if (ExamineFH(context->hidden.amigaosio.AMIGAOSIO_BPTR, &fib))
+        return fib.fib_Size;
+#endif
+
+    return -1;
+}
+
+static Sint64 SDLCALL
+amigaos_file_seek(SDL_RWops *context, Sint64 offset, int whence)
+{
+    Sint64 rc = -1;
+
+    if (!context->hidden.amigaosio.NoSeek)
+    {
+        LONG how = OFFSET_BEGINNING;
+
+        switch (whence)
+        {
+			case RW_SEEK_SET: how = OFFSET_BEGINNING; break;
+            case RW_SEEK_CUR: how = OFFSET_CURRENT; break;
+            case RW_SEEK_END: how = OFFSET_END; break;
+
+			default: return SDL_SetError("Unknown value for 'whence'");
+        }
+
+        context->hidden.amigaosio.IsAtEnd = 0;
+
+#if defined(__MORPHOS__)
+        if (Seek64(context->hidden.amigaosio.fp.dos, offset, how) == -1)
+#else
+        if (Seek(context->hidden.amigaosio.AMIGAOSIO_BPTR, offset, how) == -1)
+#endif
+        {
+            SDL_Error(SDL_EFSEEK);
+        }
+        else
+        {
+            if (how == OFFSET_END && offset == 0)
+                context->hidden.amigaosio.IsAtEnd = 1;
+
+#if defined(__MORPHOS__)
+            rc = Seek64(context->hidden.amigaosio.fp.dos, 0, OFFSET_CURRENT);
+#else
+            rc = Seek(context->hidden.amigaosio.AMIGAOSIO_BPTR, 0, OFFSET_CURRENT);
+#endif
+        }
+    }
+
+    return rc;
+}
+
+static size_t SDLCALL
+amigaos_file_read(SDL_RWops *context, void *ptr, size_t size, size_t maxnum)
+{
+    size_t rsize = size * maxnum, result;
+
+    if (context->hidden.amigaosio.Readable)
+    {
+        if ((result = Read(context->hidden.amigaosio.AMIGAOSIO_BPTR, ptr, rsize)) != rsize)
+        {
+            SDL_Error(SDL_EFWRITE);
+        }
+    }
+    else
+    {
+        result = 0;
+    }
+
+    return result / size;
+}
+
+static size_t SDLCALL
+amigaos_file_write(SDL_RWops *context, const void *ptr, size_t size, size_t num)
+{
+    size_t wnum = 0;
+    //D("[%s]\n", __FUNCTION__);
+
+    if (context->hidden.amigaosio.Writable)
+    {
+        size_t wsize, result;
+
+        if (context->hidden.amigaosio.AppendMode && !context->hidden.amigaosio.IsAtEnd)
+        {
+            if (Seek(context->hidden.amigaosio.AMIGAOSIO_BPTR, 0, OFFSET_END) == -1)
+            {
+                SDL_Error(SDL_EFWRITE);
+                return 0;
+            }
+
+            context->hidden.amigaosio.IsAtEnd = 1;
+        }
+
+        wsize = size * num;
+
+        if ((result = Write(context->hidden.amigaosio.AMIGAOSIO_BPTR, (APTR)ptr, wsize)) != wsize)
+        {
+            SDL_Error(SDL_EFWRITE);
+        }
+
+        wnum = result / size;
+    }
+
+    return wnum;
+}
+
+static int SDLCALL
+amigaos_file_close(SDL_RWops *context)
+{
+    if (context->hidden.amigaosio.fp.dos != 0)
+    {
+        if (context->hidden.amigaosio.autoclose) {
+            Close(context->hidden.amigaosio.AMIGAOSIO_BPTR);
+        }
+
+        SDL_FreeRW(context);
+    }
+
+    return(0);
+}
+
+SDL_RWops * SDL_RWFromFP_clib(void *fp,
+                             int autoclose,
+                             Sint64 (*size)(struct SDL_RWops *),
+                             Sint64 (*seek)(struct SDL_RWops *, Sint64, int),
+                             size_t (*read)(struct SDL_RWops *, void *, size_t, size_t),
+                             size_t (*write)(struct SDL_RWops *, const void *, size_t, size_t),
+                             int (*close)(struct SDL_RWops *))
+{
+    SDL_RWops *rwops;
+    D("[%s]\n", __FUNCTION__);
+
+    rwops = SDL_AllocRW();
+    if ( rwops != NULL ) {
+        rwops->size = size;
+        rwops->seek = seek;
+        rwops->read = read;
+        rwops->write = write;
+        rwops->close = close;
+        rwops->type = SDL_RWOPS_STDFILE;
+        rwops->hidden.amigaosio.fp.libc = fp;
+        rwops->hidden.amigaosio.autoclose = autoclose;
+    }
+    return(rwops);
+}
+#elif defined(HAVE_STDIO_H)
 
 #ifdef HAVE_FOPEN64
 #define fopen fopen64
@@ -528,7 +774,8 @@
 
 /* Functions to create SDL_RWops structures from various data sources */
 
-#if defined(HAVE_STDIO_H) && !(defined(__WIN32__) || defined(__GDK__))
+#if !defined(__MORPHOS__) && !defined(__AROS__) && \
+      defined(HAVE_STDIO_H) && !(defined(__WIN32__) || defined(__GDK__))
 static SDL_bool IsRegularFileOrPipe(FILE *f)
 {
     #ifdef __WINRT__
@@ -624,6 +871,32 @@
     rwops->write = windows_file_write;
     rwops->close = windows_file_close;
     rwops->type = SDL_RWOPS_WINFILE;
+#elif defined(__MORPHOS__) || defined(__AROS__)
+    rwops = SDL_AllocRW();
+    if (!rwops)
+        return NULL; /* SDL_SetError already setup by SDL_AllocRW() */
+
+    rwops->size  = amigaos_file_size;
+    rwops->seek  = amigaos_file_seek;
+    rwops->read  = amigaos_file_read;
+    rwops->write = amigaos_file_write;
+    rwops->close = amigaos_file_close;
+    rwops->type = SDL_RWOPS_MORPHOSFILE;
+
+    char *mpath = MOS_ConvertPath(file);
+    int rc = -1;
+
+    if (mpath)
+    {
+        rc = amigaos_file_open(rwops,file,mode);
+        SDL_free(mpath);
+    }
+
+    if (rc < 0)
+    {
+        SDL_FreeRW(rwops);
+        return NULL;
+    }
 #elif defined(HAVE_STDIO_H)
     {
 #if defined(__APPLE__) && !defined(SDL_FILE_DISABLED) // TODO: add dummy?
@@ -653,7 +926,7 @@
     return rwops;
 }
 
-#ifdef HAVE_STDIO_H
+#if defined(HAVE_STDIO_H) && !defined(__MORPHOS__) && !defined(__AROS__)
 SDL_RWops *SDL_RWFromFP(FILE * fp, SDL_bool autoclose)
 {
     SDL_RWops *rwops = NULL;
@@ -741,6 +1014,10 @@
     if (!area) {
         SDL_OutOfMemory();
     } else {
+#if defined(__MORPHOS__)
+        register APTR DataSeg __asm("r13");
+        area->r13 = DataSeg;
+#endif
         area->type = SDL_RWOPS_UNKNOWN;
     }
     return area;
diff -ruN SDL2-2.32.8/src/filesystem/morphos/SDL_sysfilesystem.c SDL2-2.32.8.aros/src/filesystem/morphos/SDL_sysfilesystem.c
--- SDL2-2.32.8/src/filesystem/morphos/SDL_sysfilesystem.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/filesystem/morphos/SDL_sysfilesystem.c	2025-07-27 14:24:14.020841326 +0000
@@ -0,0 +1,153 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2020 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifdef SDL_FILESYSTEM_MORPHOS
+
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+/* System dependent filesystem routines                                */
+
+#include "SDL_error.h"
+#include "SDL_filesystem.h"
+
+#include "../../core/morphos/SDL_misc.h"
+
+#if !defined(__AROS__)
+#include <libraries/charsets.h>
+#endif
+#include <proto/dos.h>
+
+char *
+SDL_GetBasePath(void)
+{
+	BPTR lock = Lock("PROGDIR:", ACCESS_READ);
+	char *path = NULL;
+
+	D("[%s]\n", __FUNCTION__);
+
+	if (lock)
+	{
+		size_t len = 128;
+
+		for (;;)
+		{
+			char *tmp = SDL_malloc(len);
+
+			if (NameFromLock(lock, tmp, len))
+			{
+#if !defined(__AROS__)
+				path = MOS_ConvertText(tmp, MIBENUM_SYSTEM, MIBENUM_UTF_8);
+#endif
+				SDL_free(tmp);
+				break;
+			}
+
+			SDL_free(tmp);
+
+			len *= 2;
+
+			if (IoErr() != ERROR_LINE_TOO_LONG)
+				break;
+		}
+
+		UnLock(lock);
+	}
+
+	return path;
+}
+
+static char *
+SDL_RemoveInvalidChars(const char *src)
+{
+	if (src)
+	{
+		char *s = SDL_strdup(src);
+		char *p = s;
+
+		if (s)
+		{
+			char c;
+
+			while ((c = *p))
+			{
+				if (c == '/' || c == ':')
+					*p = ' ';
+
+				p++;
+			}
+		}
+
+		return s;
+	} else
+		return NULL;
+}
+
+char *
+SDL_GetPrefPath(const char *org, const char *app)
+{
+	char *p1 = SDL_RemoveInvalidChars(org);
+	char *path = NULL;
+	char *p2 = SDL_RemoveInvalidChars(app);
+
+	int len = sizeof("ENVARC:");
+	if (p1) len += SDL_strlen(p1) + 1;
+	if (p2) len += SDL_strlen(p2) + 1;
+	char *tmp = SDL_malloc(len);
+	
+	if (tmp)
+	{
+		BPTR lock;
+
+		strcpy(tmp, "ENVARC:");
+		if (p1) {
+			AddPart(tmp, p1, len);
+			if ((lock = CreateDir(tmp)))
+				UnLock(lock);
+
+		}
+		if (p2)
+		{
+			AddPart(tmp, p2, len);
+			if ((lock = CreateDir(tmp)))
+				UnLock(lock);
+		}
+		
+#if !defined(__AROS__)
+		path = MOS_ConvertText(tmp, MIBENUM_SYSTEM, MIBENUM_UTF_8);
+#endif
+
+		SDL_free(tmp);
+		
+	} else {
+		
+		SDL_OutOfMemory();
+		return NULL;
+	}
+
+	if (p2) SDL_free(p2);
+	if (p1) SDL_free(p1);
+
+	return path;
+}
+
+#endif /* SDL_FILESYSTEM_MORPHOS */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff -ruN SDL2-2.32.8/src/joystick/morphos/SDL_sysjoystick.c SDL2-2.32.8.aros/src/joystick/morphos/SDL_sysjoystick.c
--- SDL2-2.32.8/src/joystick/morphos/SDL_sysjoystick.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/joystick/morphos/SDL_sysjoystick.c	2025-07-27 14:24:15.220841332 +0000
@@ -0,0 +1,508 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#include "SDL_sysjoystick_c.h"
+
+#ifdef SDL_JOYSTICK_MORPHOS
+
+#include "../SDL_sysjoystick.h"
+#include "../SDL_joystick_c.h"
+#include "SDL_endian.h"
+#include "SDL_joystick.h"
+
+#include <exec/execbase.h>
+#include <libraries/sensors.h>
+#include <libraries/sensors_hid.h>
+#define USE_INLINE_STDARG
+#include <proto/sensors.h>
+#undef USE_INLINE_STDARG
+
+// SDL2 deadzone is around 409, we need 1638
+#define DEADZONE_MIN (-0.05)
+#define DEADZONE_MAX (0.05)
+
+#define JOYSTICK_MIN -1.0
+#define JOYSTICK_MAX 1.0
+
+#define CLAMP(val) \
+			(((val) <= (DEADZONE_MAX) && (val) >= (DEADZONE_MIN)) ? (0) : \
+			((val) > (JOYSTICK_MAX)) ? (JOYSTICK_MAX) : (((val) < (JOYSTICK_MIN)) ? (JOYSTICK_MIN) : (val)))
+
+APTR sensorlist;
+APTR JoySensor[MAX_JOYSTICKS];
+int joystick_count;
+
+static int MORPHOS_JoystickInit(void)
+{
+	int rc = 0;
+
+	APTR sensor = NULL;
+	ULONG device_index = 0;
+
+	D("[%s] Obtain sensor list...\n", __FUNCTION__);
+	sensorlist = ObtainSensorsListTags(SENSORS_Class, SensorClass_HID, TAG_DONE);
+	while ((sensor = NextSensor(sensor, sensorlist, NULL)) && device_index < MAX_JOYSTICKS)
+	{
+		JoySensor[device_index++] = sensor;
+	}
+
+	D("[%s] Found %ld joysticks...\n", __FUNCTION__, device_index);
+	joystick_count = device_index;
+	
+	return rc;
+}
+
+static int MORPHOS_JoystickGetCount(void)
+{
+	return joystick_count;
+}
+
+static void MORPHOS_JoystickDetect(void)
+{
+}
+
+static const char *MORPHOS_JoystickGetDeviceName(int device_index)
+{
+	APTR sensor = JoySensor[device_index];
+	const char *name = NULL;
+	GetSensorAttrTags(sensor, SENSORS_HID_Name, (IPTR)&name, TAG_DONE);
+	return name;
+}
+
+static const char *MORPHOS_JoystickGetDevicePath(int device_index)
+{
+    return NULL;
+}
+
+static int MORPHOS_JoystickGetDeviceSteamVirtualGamepadSlot(int device_index)
+{
+    return -1;
+}
+
+static int MORPHOS_JoystickGetDevicePlayerIndex(int device_index)
+{
+    return device_index;
+}
+
+static void MORPHOS_JoystickSetDevicePlayerIndex(int device_index, int player_index)
+{
+}
+
+
+static SDL_JoystickGUID MORPHOS_JoystickGetDeviceGUID(int device_index)
+{
+	SDL_JoystickGUID guid;
+	APTR sensor = JoySensor[device_index];
+	Uint16 *guid16 = (Uint16 *)guid.data;
+	const char *name = NULL;
+
+	ULONG product, vendor;
+	
+	GetSensorAttrTags(sensor,
+			SENSORS_HID_Name, (IPTR)&name,
+			SENSORS_HID_Product, (IPTR)&product,
+			SENSORS_HID_Vendor, (IPTR)&vendor,
+			TAG_DONE);
+
+	SDL_zero(guid);
+	SDL_memset(guid.data, 0, sizeof(guid.data));
+
+	*guid16++ = SDL_SwapLE16(SDL_HARDWARE_BUS_USB);
+    *guid16++ = 0;
+
+    if (vendor && product)
+	{
+        *guid16++ = SDL_SwapLE16(vendor);
+        *guid16++ = 0;
+        *guid16++ = SDL_SwapLE16(product);
+        *guid16++ = 0;
+        *guid16++ = 0;
+        *guid16++ = 0;
+    } 
+	else
+	{
+        SDL_strlcpy((char*)guid16, name, sizeof(guid.data) - 4);
+    }
+	
+	return guid;
+}
+
+static SDL_JoystickID MORPHOS_JoystickGetDeviceInstanceID(int device_index)
+{
+	return device_index;
+}
+
+static int MORPHOS_JoystickOpen(SDL_Joystick *joystick, int device_index)
+{
+	D("[%s]\n", __FUNCTION__);
+	APTR sensor = JoySensor[device_index];
+	int rc = -1;
+
+	if (sensor) {
+		size_t buttons = 0, naxes = 0, nhats = 0, nsticks = 0, nrumbles=0;
+		CONST_STRPTR name = "<unknown>";
+		struct joystick_hwdata *hwdata = SDL_calloc(device_index + 1, sizeof(*hwdata));
+		if (!hwdata) {
+			return SDL_OutOfMemory();
+		}
+		hwdata->main_sensor = sensor;
+
+		hwdata->child_sensors = ObtainSensorsListTags(
+			SENSORS_Parent, (IPTR)hwdata->main_sensor,
+			SENSORS_Class, SensorClass_HID,
+			TAG_DONE);
+
+		sensor = NULL;
+		while ((sensor = NextSensor(sensor, hwdata->child_sensors, NULL))) 
+		{
+			ULONG type = SensorType_HIDInput_Unknown/*, Limb, color, id*/;
+			/*GetSensorAttrTags(sensor, 
+								SENSORS_HIDInput_ID, (IPTR)&id, 
+								SENSORS_HIDInput_Name, (IPTR)&name, 
+								SENSORS_HIDInput_Limb, (IPTR)&Limb, 
+								SENSORS_HIDInput_Color, (IPTR)&color, 
+								TAG_DONE);
+			D("[%s] sensor id: %d name: %s Limb:%d LimbName:%s color:%d\n", __FUNCTION__, id, name, Limb, color);	*/
+			
+			if (GetSensorAttrTags(sensor, SENSORS_Type, (IPTR)&type, TAG_DONE))
+			{
+				switch (type) 
+				{
+					case SensorType_HIDInput_Trigger:
+						if (buttons < MAX_BUTTONS) 
+						{
+							hwdata->button[buttons++] = sensor;
+						}
+						break;
+					case SensorType_HIDInput_Stick:
+						if (nhats < MAX_HATS)
+						{
+							hwdata->hat[nhats++] = sensor;
+						}
+						break;
+					case SensorType_HIDInput_Analog:
+					case SensorType_HIDInput_AnalogStick:
+					case SensorType_HIDInput_3DStick:
+						if (nsticks < MAX_STICKS) 
+						{
+							hwdata->stick[nsticks] = sensor;
+							hwdata->stickType[nsticks] = type;
+							nsticks++;
+							if (type == SensorType_HIDInput_AnalogStick)
+								naxes += 2;
+							else if (type == SensorType_HIDInput_3DStick)
+								naxes += 4;
+							else
+								naxes++;
+						}
+						break;
+					case SensorType_HIDInput_Rumble:
+						if (nrumbles < MAX_RUMBLE)
+						{
+							GetSensorAttrTags(sensor, SENSORS_HID_Name, (IPTR)&name, TAG_DONE);
+							hwdata->rumble[nrumbles] = sensor;
+							nrumbles++;
+						}
+						break;
+					case SensorType_HIDInput_Battery:
+						GetSensorAttrTags(sensor, SENSORS_HID_Name, (IPTR)&name, TAG_DONE);
+					    // Force "Xbox360 Controller" (WIRED) to use SDL_JOYSTICK_POWER_WIRED
+						if (strcmp((const char *)MORPHOS_JoystickGetDeviceName(device_index),(const char *)"Xbox360 Controller") == 0)
+						{
+							SDL_PrivateJoystickBatteryLevel(joystick, SDL_JOYSTICK_POWER_WIRED);  
+							hwdata->battery = NULL;
+						} else {							
+							hwdata->battery = sensor;
+						}
+						break;
+					case SensorType_HIDInput_Knob:
+						GetSensorAttrTags(sensor, SENSORS_HID_Name, (IPTR)&name, TAG_DONE);
+						break;
+					case SensorType_HIDInput_Wheel:
+						GetSensorAttrTags(sensor, SENSORS_HID_Name, (IPTR)&name, TAG_DONE);
+						break;
+					default:
+						//D("[%s] unknown SensorType: %d\n", __FUNCTION__, type);
+						continue;
+				}
+			}
+		}
+
+		joystick->naxes = naxes;
+		joystick->nhats = nhats;
+		joystick->nbuttons = buttons;
+		hwdata->numSticks = nsticks;
+		hwdata->numRumbles = nrumbles;
+		joystick->hwdata = hwdata;
+		joystick->name = (char *)MORPHOS_JoystickGetDeviceName(device_index);
+		rc = 0;
+	} else {
+		SDL_SetError("Failed to open device");
+	}
+	return rc;
+}
+
+static int MORPHOS_JoystickRumble(SDL_Joystick * joystick, Uint16 low_frequency_rumble, Uint16 high_frequency_rumble, Uint32 msDuration)
+{
+	struct joystick_hwdata *hwdata = joystick->hwdata;
+	if (hwdata) 
+	{
+		if (hwdata->numRumbles)
+		{
+			//ULONG msDuration = SDL_MAX_RUMBLE_DURATION_MS;
+			
+			DOUBLE lpower=(DOUBLE)(low_frequency_rumble/65535), hpower=(DOUBLE)(high_frequency_rumble/65535);
+
+			D("[%s] SetSensorAttr lpower=%f - hpower=%f - duration=%d\n", __FUNCTION__,lpower, hpower, msDuration);
+
+			struct TagItem lfreq[] = {
+				{SENSORS_HIDInput_Rumble_Power, (IPTR)&lpower}, 
+				{SENSORS_HIDInput_Rumble_Duration, msDuration}, 
+				{TAG_DONE}
+			};
+			struct TagItem hfreq[] = {
+				{SENSORS_HIDInput_Rumble_Power, (IPTR)&hpower}, 
+				{SENSORS_HIDInput_Rumble_Duration, msDuration}, 
+				{TAG_DONE}	
+			};
+			
+			if (hwdata->rumble[0])
+				SetSensorAttr(hwdata->rumble[0], lfreq);
+			
+			if (hwdata->rumble[1])
+				SetSensorAttr(hwdata->rumble[1], hfreq);
+		} else {
+			return SDL_Unsupported();
+		}
+	}		
+    return 0;
+}
+
+static int MORPHOS_JoystickRumbleTriggers(SDL_Joystick *joystick, Uint16 left_rumble, Uint16 right_rumble)
+{
+    return SDL_Unsupported();
+}
+
+static Uint32 MORPHOS_JoystickGetCapabilities(SDL_Joystick *joystick)
+{
+    Uint32 result = 0;
+	struct joystick_hwdata *hwdata = joystick->hwdata;
+	if (hwdata) 
+	{
+		if (hwdata->numRumbles)
+		{
+        	result |= SDL_JOYCAP_RUMBLE;
+		}
+    }
+
+    return result;
+}
+
+static int MORPHOS_JoystickSetLED(SDL_Joystick *joystick, Uint8 red, Uint8 green, Uint8 blue)
+{
+    return SDL_Unsupported();
+}
+
+static int MORPHOS_JoystickSendEffect(SDL_Joystick *joystick, const void *data, int size)
+{
+    return SDL_Unsupported();
+}
+
+static int MORPHOS_JoystickSetSensorsEnabled(SDL_Joystick *joystick, SDL_bool enabled)
+{
+    return SDL_Unsupported();
+}
+
+static void MORPHOS_JoystickUpdate(SDL_Joystick *joystick)
+{
+	struct joystick_hwdata *hwdata = joystick->hwdata;
+	if (hwdata) 
+	{
+		int i, j;
+		Sint16 sval;
+		double btn_value, bt_value, x_value, y_value, z_value, ns_value, ew_value, z_rotation;
+
+		for (i = 0; i < joystick->nbuttons; i++) 
+		{
+			GetSensorAttrTags(hwdata->button[i], SENSORS_HIDInput_Value, (IPTR)&btn_value, TAG_DONE);
+			if ((joystick->buttons[i] && btn_value == 0.0) || (joystick->buttons[i] == 0 && btn_value > 0.0)) 
+			{
+				SDL_PrivateJoystickButton(joystick, i, btn_value == 0.0 ? 0 : 1);
+			}
+		}
+
+		for (i = 0; i < joystick->nhats; i++) 
+		{
+			GetSensorAttrTags(hwdata->hat[i],
+				SENSORS_HIDInput_EW_Value, (IPTR)&ew_value,
+				SENSORS_HIDInput_NS_Value, (IPTR)&ns_value,
+				TAG_DONE);
+			Uint8 value_hat = SDL_HAT_CENTERED;
+			if (ns_value >= 1.0) {
+				value_hat |= SDL_HAT_DOWN;
+			} else if (ns_value <= -1.0) {
+				value_hat |= SDL_HAT_UP;
+			}
+			if (ew_value >= 1.0) {
+				value_hat |= SDL_HAT_RIGHT;
+			} else if (ew_value <= -1.0) {
+				value_hat |= SDL_HAT_LEFT;
+			}
+			SDL_PrivateJoystickHat(joystick, i, value_hat);
+		}
+		
+		j = 0;
+		for (i = 0; i < hwdata->numSticks; i++) 
+		{
+			switch (hwdata->stickType[i]) 
+			{
+				case SensorType_HIDInput_3DStick:
+					GetSensorAttrTags(hwdata->stick[i],
+						SENSORS_HIDInput_X_Index, (IPTR)&x_value,
+						SENSORS_HIDInput_Y_Index, (IPTR)&y_value,
+						SENSORS_HIDInput_Z_Index, (IPTR)&z_value,
+						SENSORS_HIDInput_Z_Rotation, (IPTR)&z_rotation,
+						TAG_DONE);
+
+					sval = (Sint16)(CLAMP(x_value) * SDL_JOYSTICK_AXIS_MAX);
+					SDL_PrivateJoystickAxis(joystick, j, sval);
+
+					sval = (Sint16)(CLAMP(y_value) * SDL_JOYSTICK_AXIS_MAX);
+					SDL_PrivateJoystickAxis(joystick, j+1, sval);
+
+					sval = (Sint16)(CLAMP(z_value) * SDL_JOYSTICK_AXIS_MAX);
+					SDL_PrivateJoystickAxis(joystick, j+2, sval);
+
+					sval = (Sint16)(CLAMP(z_rotation) * SDL_JOYSTICK_AXIS_MAX);
+					SDL_PrivateJoystickAxis(joystick, j+3, sval);
+					
+					j += 4;
+					break;
+
+				case SensorType_HIDInput_Analog:
+					GetSensorAttrTags(hwdata->stick[i], SENSORS_HIDInput_Value, (IPTR)&btn_value, TAG_DONE);
+
+					sval = (Sint16)(btn_value * SDL_JOYSTICK_AXIS_MAX);
+					SDL_PrivateJoystickAxis(joystick, j, sval);
+
+					j++;
+					break;
+
+				case SensorType_HIDInput_AnalogStick:
+					GetSensorAttrTags(hwdata->stick[i],
+						SENSORS_HIDInput_EW_Value, (IPTR)&ew_value,
+						SENSORS_HIDInput_NS_Value, (IPTR)&ns_value,
+						TAG_DONE);
+
+					sval = (Sint16)(CLAMP(ew_value) * SDL_JOYSTICK_AXIS_MAX);
+					SDL_PrivateJoystickAxis(joystick, j, sval);
+
+					sval = (Sint16)(CLAMP(ns_value) * SDL_JOYSTICK_AXIS_MAX);
+					SDL_PrivateJoystickAxis(joystick, j+1, sval);
+
+					j += 2;
+					break;
+			}
+		}
+		
+		if (hwdata->battery) 
+		{
+			SDL_JoystickPowerLevel ePowerLevel = SDL_JOYSTICK_POWER_UNKNOWN;
+			GetSensorAttrTags(hwdata->battery,
+						SENSORS_HIDInput_Value, (IPTR)&bt_value,
+						TAG_DONE);
+			ULONG level = bt_value*100;
+			switch (level)
+			{
+			   case 0 ... 5:
+					ePowerLevel = SDL_JOYSTICK_POWER_EMPTY;
+					break;
+			   case 6 ... 20:
+				   ePowerLevel = SDL_JOYSTICK_POWER_LOW;
+					break;
+			   case 21 ... 70:
+					ePowerLevel = SDL_JOYSTICK_POWER_MEDIUM;
+					break;
+			   case 71 ... 100:
+					ePowerLevel = SDL_JOYSTICK_POWER_FULL;
+					break;
+			}
+			SDL_PrivateJoystickBatteryLevel(joystick, ePowerLevel);  
+		}
+	}
+}
+
+void MORPHOS_JoystickClose(SDL_Joystick *joystick)
+{
+	D("[%s]\n", __FUNCTION__);
+	struct joystick_hwdata *hwdata = joystick->hwdata;
+	if (hwdata) 
+	{
+		if (hwdata->child_sensors) 
+		{
+			ReleaseSensorsList(hwdata->child_sensors, NULL);
+			hwdata->child_sensors = NULL;
+		}
+		SDL_free(hwdata);
+		joystick->hwdata = NULL;
+	}
+}
+
+void MORPHOS_JoystickQuit(void)
+{
+	D("[%s]\n", __FUNCTION__);
+	if (sensorlist) {
+		ReleaseSensorsList(sensorlist, NULL);
+		sensorlist = NULL;
+	}
+}
+
+static SDL_bool MORPHOS_JoystickGetGamepadMapping(int device_index, SDL_GamepadMapping *out)
+{
+    return SDL_FALSE;
+}
+
+SDL_JoystickDriver SDL_MORPHOS_JoystickDriver =
+{
+    MORPHOS_JoystickInit,
+    MORPHOS_JoystickGetCount,
+    MORPHOS_JoystickDetect,
+    MORPHOS_JoystickGetDeviceName,
+	MORPHOS_JoystickGetDevicePath,
+	MORPHOS_JoystickGetDeviceSteamVirtualGamepadSlot,
+    MORPHOS_JoystickGetDevicePlayerIndex,
+    MORPHOS_JoystickSetDevicePlayerIndex,
+    MORPHOS_JoystickGetDeviceGUID,
+    MORPHOS_JoystickGetDeviceInstanceID,
+    MORPHOS_JoystickOpen,
+    MORPHOS_JoystickRumble,
+    MORPHOS_JoystickRumbleTriggers,
+    MORPHOS_JoystickGetCapabilities,
+    MORPHOS_JoystickSetLED,
+	MORPHOS_JoystickSendEffect,
+	MORPHOS_JoystickSetSensorsEnabled,
+    MORPHOS_JoystickUpdate,
+    MORPHOS_JoystickClose,
+    MORPHOS_JoystickQuit,
+	MORPHOS_JoystickGetGamepadMapping
+};
+
+#endif
diff -ruN SDL2-2.32.8/src/joystick/morphos/SDL_sysjoystick_c.h SDL2-2.32.8.aros/src/joystick/morphos/SDL_sysjoystick_c.h
--- SDL2-2.32.8/src/joystick/morphos/SDL_sysjoystick_c.h	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/joystick/morphos/SDL_sysjoystick_c.h	2025-07-27 14:24:15.224841332 +0000
@@ -0,0 +1,54 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2020 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#include "../../SDL_internal.h"
+
+#ifdef SDL_JOYSTICK_MORPHOS
+
+#include <exec/types.h>
+#include "SDL_joystick.h"
+
+#define MAX_JOYSTICKS 	32
+#define MAX_BUTTONS     16
+#define MAX_HATS        8
+#define MAX_STICKS      8
+#define MAX_RUMBLE		2
+
+struct joystick_hwdata
+{
+	APTR main_sensor; // Main HID sensor
+	APTR child_sensors; // List of specific sub-sensor entries
+	APTR button[MAX_BUTTONS]; // SensorType_HIDInput_Trigger
+	APTR hat[MAX_HATS]; // SensorType_HIDInput_Stick
+	APTR stick[MAX_STICKS]; // SensorType_HIDInput_Analog, SensorType_HIDInput_AnalogStick, SensorType_HIDInput_3DStick
+	APTR battery; 	// SensorType_HIDInput_Battery 
+	APTR rumble[MAX_RUMBLE]; // SensorType_HIDInput_Rumble
+
+	ULONG stickType[MAX_STICKS];
+	int numSticks;
+	int numRumbles;
+
+	// hot plug support
+	struct MsgPort *notifyPort;
+	APTR sensorsNotify;
+};
+
+#endif
\ No newline at end of file
diff -ruN SDL2-2.32.8/src/joystick/SDL_gamecontrollerdb.h SDL2-2.32.8.aros/src/joystick/SDL_gamecontrollerdb.h
--- SDL2-2.32.8/src/joystick/SDL_gamecontrollerdb.h	2025-01-18 15:07:12.000000000 +0000
+++ SDL2-2.32.8.aros/src/joystick/SDL_gamecontrollerdb.h	2025-07-27 14:24:15.440841333 +0000
@@ -997,6 +997,10 @@
 #ifdef SDL_JOYSTICK_VITA
     "0000000050535669746120436f6e7400,PSVita Controller,crc:d598,a:b2,b:b1,back:b10,dpdown:b6,dpleft:b7,dpright:b9,dpup:b8,leftshoulder:b4,leftstick:b14,lefttrigger:a4,leftx:a0,lefty:a1,rightshoulder:b5,rightstick:b15,righttrigger:a5,rightx:a2,righty:a3,start:b11,x:b3,y:b0,",
 #endif
+#ifdef  SDL_JOYSTICK_MORPHOS
+	  "030000004c050000c405000000000000,PlayStation 4 Dualshock Controller,platform:MorphOS,a:b6,b:b7,x:b4,y:b5,back:b3,start:b2,leftstick:b8,rightstick:b9,leftshoulder:b0,rightshoulder:b1,dpup:h0.1,dpdown:h0.4,dpleft:h0.8,dpright:h0.2,leftx:a0,lefty:a1,rightx:a2,righty:a3,lefttrigger:+a4,righttrigger:+a5,",
+	  "030000005e0400008e02000000000000,Xbox360 Controller,platform:MorphOS,a:b7,b:b8,x:b5,y:b6,back:b2,guide:b4,start:b3,leftstick:b9,rightstick:b10,leftshoulder:b0,rightshoulder:b1,dpup:h0.1,dpdown:h0.4,dpleft:h0.8,dpright:h0.2,leftx:a0,lefty:a1,rightx:a2,righty:a3,lefttrigger:+a4,righttrigger:+a5,",
+#endif
 #ifdef SDL_JOYSTICK_N3DS
     "000000004e696e74656e646f20334400,Nintendo 3DS,crc:3210,a:b0,b:b1,back:b2,dpdown:b7,dpleft:b5,dpright:b4,dpup:b6,leftshoulder:b9,lefttrigger:b14,leftx:a0,lefty:a1,rightshoulder:b8,righttrigger:b15,rightx:a2,righty:a3,start:b3,x:b10,y:b11,",
 #endif
diff -ruN SDL2-2.32.8/src/joystick/SDL_joystick.c SDL2-2.32.8.aros/src/joystick/SDL_joystick.c
--- SDL2-2.32.8/src/joystick/SDL_joystick.c	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/src/joystick/SDL_joystick.c	2025-07-27 14:24:15.444841333 +0000
@@ -100,6 +100,9 @@
 #ifdef SDL_JOYSTICK_VIRTUAL
     &SDL_VIRTUAL_JoystickDriver,
 #endif
+#ifdef SDL_JOYSTICK_MORPHOS
+    &SDL_MORPHOS_JoystickDriver,
+#endif
 #ifdef SDL_JOYSTICK_VITA
     &SDL_VITA_JoystickDriver,
 #endif
@@ -1413,7 +1416,11 @@
             /* Just update the expiration */
             retval = 0;
         } else {
+#ifdef __MORPHOS__
+            retval = joystick->driver->Rumble(joystick, low_frequency_rumble, high_frequency_rumble, duration_ms);
+#else
             retval = joystick->driver->Rumble(joystick, low_frequency_rumble, high_frequency_rumble);
+#endif
             if (retval == 0) {
                 joystick->rumble_resend = SDL_GetTicks() + SDL_RUMBLE_RESEND_MS;
                 if (joystick->rumble_resend == 0) {
@@ -2202,7 +2209,11 @@
 
         if (joystick->rumble_resend &&
             SDL_TICKS_PASSED(now, joystick->rumble_resend)) {
+#ifdef __MORPHOS__
+			joystick->driver->Rumble(joystick, joystick->low_frequency_rumble, joystick->high_frequency_rumble, 100/*duration_ms*/);
+#else
             joystick->driver->Rumble(joystick, joystick->low_frequency_rumble, joystick->high_frequency_rumble);
+#endif
             joystick->rumble_resend = now + SDL_RUMBLE_RESEND_MS;
             if (joystick->rumble_resend == 0) {
                 joystick->rumble_resend = 1;
diff -ruN SDL2-2.32.8/src/joystick/SDL_sysjoystick.h SDL2-2.32.8.aros/src/joystick/SDL_sysjoystick.h
--- SDL2-2.32.8/src/joystick/SDL_sysjoystick.h	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/src/joystick/SDL_sysjoystick.h	2025-07-27 14:24:15.472841333 +0000
@@ -191,7 +191,11 @@
     int (*Open)(SDL_Joystick *joystick, int device_index);
 
     /* Rumble functionality */
+#ifdef __MORPHOS__
+    int (*Rumble)(SDL_Joystick *joystick, Uint16 low_frequency_rumble, Uint16 high_frequency_rumble, Uint32 duration_ms);
+#else
     int (*Rumble)(SDL_Joystick *joystick, Uint16 low_frequency_rumble, Uint16 high_frequency_rumble);
+#endif
     int (*RumbleTriggers)(SDL_Joystick *joystick, Uint16 left_rumble, Uint16 right_rumble);
 
     /* Capability detection */
@@ -253,7 +257,9 @@
 extern SDL_JoystickDriver SDL_PSP_JoystickDriver;
 extern SDL_JoystickDriver SDL_VITA_JoystickDriver;
 extern SDL_JoystickDriver SDL_N3DS_JoystickDriver;
-
+#ifdef __MORPHOS__
+extern SDL_JoystickDriver SDL_MORPHOS_JoystickDriver;
+#endif
 /* Ends C function definitions when using C++ */
 #ifdef __cplusplus
 }
diff -ruN SDL2-2.32.8/src/locale/morphos/SDL_syslocale.c SDL2-2.32.8.aros/src/locale/morphos/SDL_syslocale.c
--- SDL2-2.32.8/src/locale/morphos/SDL_syslocale.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/locale/morphos/SDL_syslocale.c	2025-07-27 14:24:15.756841335 +0000
@@ -0,0 +1,101 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#if defined(__AROS__)
+#include <aros/debug.h>
+#endif
+
+#include "../../SDL_internal.h"
+#include "../SDL_syslocale.h"
+
+#include <proto/dos.h>
+#include <proto/utility.h>
+#include <libraries/iffparse.h>
+
+#if defined(__AROS__)
+#include <stdio.h>
+#endif
+
+struct loc
+{
+	const char *name;
+	const char *codeLang;
+};
+
+static const struct loc locs[] =
+{
+	{ "catal",		"ca_ES" }, 
+	{ "dansk",		"da_DK" },
+	{ "deutsch",	"de_DE" },
+	{ "english",	"en_GB" },
+	{ "espaol",	"es_ES" },
+	{ "franais",	"fr_FR" },
+	{ "greek",		"el_GR" },
+	{ "hrvatski",	"hr_HR" },
+	{ "italiano",	"it_IT" },
+	{ "magyar",		"hu_HU" },
+	{ "malti",		"mt_MT"	},
+	{ "nederlands",	"nl_NL" },
+	{ "norsk",		"nn_NO" },
+	{ "polski",		"pl_PL" },
+	{ "portugus",	"pt_PT" },
+	{ "shqipja"		"sq_AL" },
+	{ "suomi",		"fi_FI" },
+	{ "svenska",	"sv_SE" },
+	{ "trke",		"tr_TR" },
+	{ "etina",	"cs_CZ" },
+	{ "slenska", 	"is_IS" },  
+	{ NULL,			NULL } 
+};
+
+void
+SDL_SYS_GetPreferredLocales(char *buf, size_t buflen)
+{
+	D(bug("[SDL2] %s()\n", __func__));
+	
+	char language[80];
+	language[0] = '\0';
+	SDL_bool found = SDL_FALSE;
+
+	// check the LANGUAGE env variable
+	if (GetVar("LANGUAGE", language, sizeof(language), 0) > 0)
+	{
+		int i;
+		const struct loc *curLoc = NULL;
+
+		for(i=0;;i++)
+		{
+			curLoc = &locs[i];
+
+			if(Strnicmp(language, curLoc->name, sizeof(curLoc->name)) == 0)
+			{
+			  D("[%s] found language name for '%s'\n", __FUNCTION__, curLoc->codeLang);
+			  snprintf(buf, buflen, curLoc->codeLang);
+			  found = SDL_TRUE;
+			  break;
+			}
+		}
+
+	}
+	if (!found)
+		snprintf(buf, buflen, "en_GB");  
+
+}
diff -ruN SDL2-2.32.8/src/misc/morphos/SDL_sysurl.c SDL2-2.32.8.aros/src/misc/morphos/SDL_sysurl.c
--- SDL2-2.32.8/src/misc/morphos/SDL_sysurl.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/misc/morphos/SDL_sysurl.c	2025-07-27 14:24:16.128841337 +0000
@@ -0,0 +1,48 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#if defined(__AROS__)
+#include <aros/debug.h>
+#endif
+
+#include "../SDL_sysurl.h"
+#include "../../SDL_internal.h"
+
+#include <proto/openurl.h>
+
+int
+SDL_SYS_OpenURL(const char *url)
+{
+	static const struct TagItem URLTags[] = {{TAG_DONE, 0}};
+
+	D(bug("[SDL2:AHI] %s('%s')\n", __func__, url));
+
+	if (OpenURLBase) {
+		if(!URL_OpenA((STRPTR)url, (struct TagItem*) URLTags)) {
+			SDL_SetError("URL open failed");
+			return SDL_Unsupported();
+		}	
+	} else {
+		return SDL_Unsupported();
+	}
+    return 0;
+}
+
diff -ruN SDL2-2.32.8/src/power/morphos/SDL_syspower.c SDL2-2.32.8.aros/src/power/morphos/SDL_syspower.c
--- SDL2-2.32.8/src/power/morphos/SDL_syspower.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/power/morphos/SDL_syspower.c	2025-07-27 14:24:16.288841338 +0000
@@ -0,0 +1,97 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2021 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifndef SDL_POWER_DISABLED
+#ifdef SDL_POWER_MORPHOS
+
+#include <libraries/sensors.h>
+#include <proto/sensors.h>
+
+#include "SDL_power.h"
+
+SDL_bool
+SDL_GetPowerInfo_MorphOS(SDL_PowerState *state, int *seconds, int *percent)
+{
+	static const size_t battery_sensortags[] = { SENSORS_Type, SensorType_Battery, TAG_DONE };
+
+	APTR sensorlist = ObtainSensorsList((struct TagItem *)&battery_sensortags);
+	APTR sensor = NULL;
+	ssize_t maxcap = 0, totcap = 0, val, charging = 0, totsecs = 0;
+	SDL_PowerState st = SDL_POWERSTATE_NO_BATTERY;
+
+	while ((sensor = NextSensor(sensor, sensorlist, NULL))) {
+		ssize_t capacity, max_capacity, is_batt_present, is_batt_charging, secs_remaining;
+
+		struct TagItem battags[6] =
+		{
+			{ SENSORS_Battery_Capacity, (size_t)&capacity },
+			{ SENSORS_Battery_MaxCapacity, (size_t)&max_capacity },
+			{ SENSORS_Battery_Present, (size_t)&is_batt_present },
+			{ SENSORS_Battery_Charging, (size_t)&is_batt_charging },
+			{ SENSORS_Battery_Remaining, (size_t)&secs_remaining },
+			{ TAG_DONE }
+		};
+
+		if (GetSensorAttr(sensor, battags) >= 5 && is_batt_present) {
+			maxcap += max_capacity;
+			totcap += capacity;
+
+			if (secs_remaining != SENSORS_Battery_Remaining_Calculating)
+				totsecs += secs_remaining;
+
+			if (is_batt_charging && secs_remaining != SENSORS_Battery_Remaining_Charged)
+				charging++;
+		}
+	}
+
+	ReleaseSensorsList(sensorlist, NULL);
+
+	if (charging)
+	{
+		st = SDL_POWERSTATE_CHARGING;
+	}
+	else if (maxcap > 0)
+	{
+		if (totcap < maxcap)
+			st = SDL_POWERSTATE_ON_BATTERY;
+		else
+			st = SDL_POWERSTATE_CHARGED;
+	}
+
+	*state = st;
+	*seconds = totsecs == 0 ? -1 : totsecs;
+	val = -1;
+
+	if (maxcap > 0)
+	{
+		val = (totcap * 100) / maxcap;
+		val = val > 100 ? 100 : val;
+	}
+
+	*percent = val;
+
+	return SDL_TRUE;
+}
+
+#endif /* SDL_POWER_MORPHOS */
+#endif /* SDL_POWER_DISABLED */
+
diff -ruN SDL2-2.32.8/src/power/SDL_power.c SDL2-2.32.8.aros/src/power/SDL_power.c
--- SDL2-2.32.8/src/power/SDL_power.c	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/src/power/SDL_power.c	2025-07-27 14:24:16.384841338 +0000
@@ -78,7 +78,10 @@
 #ifdef SDL_POWER_EMSCRIPTEN /* handles Emscripten */
     SDL_GetPowerInfo_Emscripten,
 #endif
-
+#ifdef SDL_POWER_MORPHOS        /* handles MorphOS */
+    SDL_GetPowerInfo_MorphOS,
+#endif
+  
 #ifdef SDL_POWER_HARDWIRED
     SDL_GetPowerInfo_Hardwired,
 #endif
diff -ruN SDL2-2.32.8/src/power/SDL_syspower.h SDL2-2.32.8.aros/src/power/SDL_syspower.h
--- SDL2-2.32.8/src/power/SDL_syspower.h	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/src/power/SDL_syspower.h	2025-07-27 14:24:16.392841338 +0000
@@ -42,7 +42,9 @@
 SDL_bool SDL_GetPowerInfo_N3DS(SDL_PowerState *, int *, int *);
 SDL_bool SDL_GetPowerInfo_WinRT(SDL_PowerState *, int *, int *);
 SDL_bool SDL_GetPowerInfo_Emscripten(SDL_PowerState *, int *, int *);
-
+#ifdef SDL_POWER_MORPHOS
+SDL_bool SDL_GetPowerInfo_MorphOS(SDL_PowerState *, int *, int *);
+#endif
 /* this one is static in SDL_power.c */
 /* SDL_bool SDL_GetPowerInfo_Hardwired(SDL_PowerState *, int *, int *);*/
 
diff -ruN SDL2-2.32.8/src/render/opengl/SDL_render_gl.c SDL2-2.32.8.aros/src/render/opengl/SDL_render_gl.c
--- SDL2-2.32.8/src/render/opengl/SDL_render_gl.c	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/src/render/opengl/SDL_render_gl.c	2025-07-27 14:24:16.612841339 +0000
@@ -22,6 +22,9 @@
 
 #if SDL_VIDEO_RENDER_OGL
 #include "SDL_hints.h"
+#ifdef __MORPHOS__
+#define _NO_PPCINLINE
+#endif
 #include "../../video/SDL_sysvideo.h" /* For SDL_GL_SwapWindowWithResult */
 #include "SDL_opengl.h"
 #include "../SDL_sysrender.h"
@@ -1860,6 +1863,10 @@
         renderer->info.max_texture_height = value;
     }
 
+	//D("GL_ARB_texture_non_power_of_two: %s\n", data->GL_ARB_texture_non_power_of_two_supported ? "ENABLED" : "DISABLED");
+	//D("GL_ARB_texture_rectangle: %s\n", SDL_GL_ExtensionSupported("GL_ARB_texture_rectangle") ? "ENABLED" : "DISABLED");
+	//D("GL_EXT_texture_rectangle: %s\n", SDL_GL_ExtensionSupported("GL_EXT_texture_rectangle") ? "ENABLED" : "DISABLED");
+
     /* Check for multitexture support */
     if (SDL_GL_ExtensionSupported("GL_ARB_multitexture")) {
         data->glActiveTextureARB = (PFNGLACTIVETEXTUREARBPROC)SDL_GL_GetProcAddress("glActiveTextureARB");
@@ -1868,11 +1875,15 @@
             data->glGetIntegerv(GL_MAX_TEXTURE_UNITS_ARB, &data->num_texture_units);
         }
     }
+	//D("GL_ARB_multitexture_supported: %s\n", data->GL_ARB_multitexture_supported ? "ENABLED" : "DISABLED");
 
     /* Check for shader support */
     if (SDL_GetHintBoolean(SDL_HINT_RENDER_OPENGL_SHADERS, SDL_TRUE)) {
         data->shaders = GL_CreateShaderContext();
     }
+
+	D("OpenGL shaders: %s\n", data->shaders ? "ENABLED" : "DISABLED");
+
     SDL_LogInfo(SDL_LOG_CATEGORY_RENDER, "OpenGL shaders: %s",
                 data->shaders ? "ENABLED" : "DISABLED");
 #if SDL_HAVE_YUV
@@ -1913,6 +1924,8 @@
             SDL_GL_GetProcAddress("glCheckFramebufferStatusEXT");
         renderer->info.flags |= SDL_RENDERER_TARGETTEXTURE;
     }
+	D("GL_EXT_framebuffer_object: %s\n", data->GL_EXT_framebuffer_object_supported ? "ENABLED" : "DISABLED");
+
     data->framebuffers = NULL;
 
     /* Set up parameters for rendering */
diff -ruN SDL2-2.32.8/src/render/opengl/SDL_shaders_gl.c SDL2-2.32.8.aros/src/render/opengl/SDL_shaders_gl.c
--- SDL2-2.32.8/src/render/opengl/SDL_shaders_gl.c	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/src/render/opengl/SDL_shaders_gl.c	2025-07-27 14:24:16.620841339 +0000
@@ -23,6 +23,11 @@
 #if SDL_VIDEO_RENDER_OGL
 
 #include "SDL_stdinc.h"
+
+#ifdef __MORPHOS__
+#define _NO_PPCINLINE
+#endif
+
 #include "SDL_opengl.h"
 #include "SDL_video.h"
 #include "SDL_shaders_gl.h"
diff -ruN SDL2-2.32.8/src/SDL.c SDL2-2.32.8.aros/src/SDL.c
--- SDL2-2.32.8/src/SDL.c	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/src/SDL.c	2025-07-28 20:45:10.753574555 +0000
@@ -49,7 +49,6 @@
 #include "haptic/SDL_haptic_c.h"
 #include "joystick/SDL_joystick_c.h"
 #include "sensor/SDL_sensor_c.h"
-#include "thread/SDL_thread_c.h"
 
 /* Initialization/Cleanup routines */
 #ifndef SDL_TIMERS_DISABLED
@@ -101,6 +100,9 @@
     exit(exitcode);
 #elif defined(__HAIKU__)  /* Haiku has _Exit, but it's not marked noreturn. */
     _exit(exitcode);
+#elif defined(__MORPHOS__)
+    extern void (*morphos_exit)(int exitcode);
+    morphos_exit(exitcode);
 #elif defined(HAVE__EXIT) /* Upper case _Exit() */
     _Exit(exitcode);
 #else
@@ -114,7 +116,6 @@
 #else
 static SDL_bool SDL_MainIsReady = SDL_TRUE;
 #endif
-static SDL_bool SDL_main_thread_initialized = SDL_FALSE;
 static SDL_bool SDL_bInMainQuit = SDL_FALSE;
 static Uint8 SDL_SubsystemRefCount[32];
 
@@ -180,36 +181,6 @@
     SDL_MainIsReady = SDL_TRUE;
 }
 
-void SDL_InitMainThread(void)
-{
-    if (SDL_main_thread_initialized) {
-        return;
-    }
-
-    SDL_InitTLSData();
-#ifndef SDL_TIMERS_DISABLED
-    SDL_TicksInit();
-#endif
-    SDL_LogInit();
-
-    SDL_main_thread_initialized = SDL_TRUE;
-}
-
-static void SDL_QuitMainThread(void)
-{
-    if (!SDL_main_thread_initialized) {
-        return;
-    }
-
-    SDL_LogQuit();
-#ifndef SDL_TIMERS_DISABLED
-    SDL_TicksQuit();
-#endif
-    SDL_QuitTLSData();
-
-    SDL_main_thread_initialized = SDL_FALSE;
-}
-
 int SDL_InitSubSystem(Uint32 flags)
 {
     Uint32 flags_initialized = 0;
@@ -218,6 +189,8 @@
         return SDL_SetError("Application didn't initialize properly, did you include SDL_main.h in the file containing your main() function?");
     }
 
+    SDL_LogInit();
+
     /* Clear the error message */
     SDL_ClearError();
 
@@ -233,6 +206,10 @@
     }
 #endif
 
+#ifndef SDL_TIMERS_DISABLED
+    SDL_TicksInit();
+#endif
+
     /* Initialize the event subsystem */
     if (flags & SDL_INIT_EVENTS) {
 #ifndef SDL_EVENTS_DISABLED
@@ -374,7 +351,7 @@
         }
         SDL_PrivateSubsystemRefCountIncr(SDL_INIT_SENSOR);
         flags_initialized |= SDL_INIT_SENSOR;
-#else
+#elif !__MORPHOS__
         SDL_SetError("SDL not built with sensor support");
         goto quit_and_error;
 #endif
@@ -520,6 +497,10 @@
 #endif
     SDL_QuitSubSystem(SDL_INIT_EVERYTHING);
 
+#ifndef SDL_TIMERS_DISABLED
+    SDL_TicksQuit();
+#endif
+
 #ifdef SDL_USE_LIBDBUS
     SDL_DBus_Quit();
 #endif
@@ -527,12 +508,14 @@
     SDL_ClearHints();
     SDL_AssertionsQuit();
 
+    SDL_LogQuit();
+
     /* Now that every subsystem has been quit, we reset the subsystem refcount
      * and the list of initialized subsystems.
      */
     SDL_memset(SDL_SubsystemRefCount, 0x0, sizeof(SDL_SubsystemRefCount));
 
-    SDL_QuitMainThread();
+    SDL_TLSCleanup();
 
     SDL_bInMainQuit = SDL_FALSE;
 }
@@ -580,6 +563,8 @@
     return "AIX";
 #elif defined(__ANDROID__)
     return "Android";
+#elif defined(__AROS__)
+    return "AROS";
 #elif defined(__BSDI__)
     return "BSDI";
 #elif defined(__DREAMCAST__)
@@ -636,6 +621,8 @@
     return "PlayStation 2";
 #elif defined(__PSP__)
     return "PlayStation Portable";
+#elif defined(__MORPHOS__)
+    return "MorphOS";
 #elif defined(__VITA__)
     return "PlayStation Vita";
 #elif defined(__NGAGE__)
diff -ruN SDL2-2.32.8/src/SDL_error.c SDL2-2.32.8.aros/src/SDL_error.c
--- SDL2-2.32.8/src/SDL_error.c	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/src/SDL_error.c	2025-07-28 14:48:26.642876493 +0000
@@ -60,6 +60,43 @@
     return -1;
 }
 
+#ifdef __MORPHOS__
+int
+SDL_VSetError(const char *fmt, va_list ap)
+{
+	
+	/* Ignore call if invalid format pointer was passed */
+    if (fmt != NULL) {
+
+		va_list ap_copy;
+        int result;
+        SDL_error *error = SDL_GetErrBuf();
+
+        error->error = 1;  /* mark error as valid */
+        va_copy(ap_copy, ap);
+        result = SDL_vsnprintf(error->str, error->len, fmt, ap_copy);
+        va_end(ap_copy);
+        if (result >= 0 && (size_t)result >= error->len && error->realloc_func) {
+            size_t len = (size_t)result + 1;
+            char *str = (char *)error->realloc_func(error->str, len);
+            if (str) {
+                error->str = str;
+                error->len = len;
+                SDL_vsnprintf(error->str, error->len, fmt, ap);
+            }
+        }
+		
+        if (SDL_LogGetPriority(SDL_LOG_CATEGORY_ERROR) <= SDL_LOG_PRIORITY_DEBUG) {
+            /* If we are in debug mode, print out the error message */
+            SDL_LogDebug(SDL_LOG_CATEGORY_ERROR, "%s", error->str);
+        }
+    }
+
+    return -1;
+}
+#endif
+
+#if !defined(__AROS__) || defined(SDL2_AROS_SHARED)
 /* Available for backwards compatibility */
 const char *SDL_GetError(void)
 {
@@ -120,4 +157,6 @@
     return errstr;
 }
 
+#endif
+
 /* vi: set ts=4 sw=4 expandtab: */
diff -ruN SDL2-2.32.8/src/SDL_log.c SDL2-2.32.8.aros/src/SDL_log.c
--- SDL2-2.32.8/src/SDL_log.c	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/src/SDL_log.c	2025-07-28 15:51:50.239183490 +0000
@@ -40,6 +40,10 @@
 #include <android/log.h>
 #endif
 
+#if defined(__MORPHOS__) || defined(__AROS__)
+#include <proto/exec.h>
+#endif
+
 #include "stdlib/SDL_vacopy.h"
 
 /* The size of the stack buffer to use for rendering log messages. */
@@ -47,6 +51,7 @@
 
 #define DEFAULT_CATEGORY -1
 
+#if !defined(__AROS__) || defined(SDL2_AROS_SHARED)
 typedef struct SDL_LogLevel
 {
     int category;
@@ -296,6 +301,7 @@
     }
     SDL_forced_priority = SDL_FALSE;
 }
+#endif
 
 void SDL_Log(SDL_PRINTF_FORMAT_STRING const char *fmt, ...)
 {
@@ -369,6 +375,7 @@
     va_end(ap);
 }
 
+#if !defined(__AROS__) || defined(SDL2_AROS_SHARED)
 #ifdef __ANDROID__
 static const char *GetCategoryPrefix(int category)
 {
@@ -573,6 +580,10 @@
             (void)fclose(pFile);
         }
     }
+#elif defined(__MORPHOS__) || defined(__AROS__)
+	{
+    	NewRawDoFmt("%s: %s\n", (APTR)1, NULL, SDL_priority_prefixes[priority], message);
+	}
 #elif defined(__3DS__)
     {
         FILE *pFile;
@@ -607,5 +618,6 @@
     SDL_log_function = callback;
     SDL_log_userdata = userdata;
 }
+#endif
 
 /* vi: set ts=4 sw=4 expandtab: */
diff -ruN SDL2-2.32.8/src/stdlib/SDL_stdlib.c SDL2-2.32.8.aros/src/stdlib/SDL_stdlib.c
--- SDL2-2.32.8/src/stdlib/SDL_stdlib.c	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/src/stdlib/SDL_stdlib.c	2025-07-27 14:24:17.192841344 +0000
@@ -28,7 +28,9 @@
 /* This file contains portable stdlib functions for SDL */
 
 #include "SDL_stdinc.h"
+#if !defined(__AROS__)
 #include "../libm/math_libm.h"
+#endif
 
 double
 SDL_atan(double x)
diff -ruN SDL2-2.32.8/src/stdlib/SDL_string.c SDL2-2.32.8.aros/src/stdlib/SDL_string.c
--- SDL2-2.32.8/src/stdlib/SDL_string.c	2025-03-10 22:45:43.000000000 +0000
+++ SDL2-2.32.8.aros/src/stdlib/SDL_string.c	2025-07-28 14:40:07.194826335 +0000
@@ -54,22 +54,23 @@
     return 0;
 }
 
+#if !defined(__AROS__) || defined(SDL2_AROS_SHARED)
 #if !defined(HAVE_VSSCANF) || !defined(HAVE_STRTOL) || !defined(HAVE_STRTOUL) || !defined(HAVE_STRTOD)
 /**
- * Parses an unsigned long long and returns the unsigned value and sign bit.
+ * Parses an Uint64 and returns the unsigned value and sign bit.
  *
  * Positive values are clamped to ULLONG_MAX.
  * The result `value == 0 && negative` indicates negative overflow
  * and might need to be handled differently depending on whether a
  * signed or unsigned integer is being parsed.
  */
-static size_t SDL_ScanUnsignedLongLongInternal(const char *text, int count, int radix, unsigned long long *valuep, SDL_bool *negativep)
+static size_t SDL_ScanUnsignedLongLongInternal(const char *text, int count, int radix, Uint64 *valuep, SDL_bool *negativep)
 {
-    const unsigned long long ullong_max = ~0ULL;
+    const Uint64 ullong_max = ~0ULL;
 
     const char *text_start = text;
     const char *number_start = text_start;
-    unsigned long long value = 0;
+    Uint64 value = 0;
     SDL_bool negative = SDL_FALSE;
     SDL_bool overflow = SDL_FALSE;
 
@@ -92,7 +93,7 @@
         }
         number_start = text;
         do {
-            unsigned long long digit;
+            Uint64 digit;
             if (*text >= '0' && *text <= '9') {
                 digit = *text - '0';
             } else if (radix > 10) {
@@ -145,7 +146,7 @@
 static size_t SDL_ScanLong(const char *text, int count, int radix, long *valuep)
 {
     const unsigned long long_max = (~0UL) >> 1;
-    unsigned long long value;
+    Uint64 value;
     SDL_bool negative;
     size_t len = SDL_ScanUnsignedLongLongInternal(text, count, radix, &value, &negative);
     if (negative) {
@@ -167,7 +168,7 @@
 static size_t SDL_ScanUnsignedLong(const char *text, int count, int radix, unsigned long *valuep)
 {
     const unsigned long ulong_max = ~0UL;
-    unsigned long long value;
+    Uint64 value;
     SDL_bool negative;
     size_t len = SDL_ScanUnsignedLongLongInternal(text, count, radix, &value, &negative);
     if (negative) {
@@ -190,7 +191,7 @@
 static size_t SDL_ScanUintPtrT(const char *text, int radix, uintptr_t *valuep)
 {
     const uintptr_t uintptr_max = ~(uintptr_t)0;
-    unsigned long long value;
+    Uint64 value;
     SDL_bool negative;
     size_t len = SDL_ScanUnsignedLongLongInternal(text, 0, 16, &value, &negative);
     if (negative) {
@@ -212,12 +213,12 @@
 #if !defined(HAVE_VSSCANF) || !defined(HAVE_STRTOLL) || !defined(HAVE_STRTOULL)
 static size_t SDL_ScanLongLong(const char *text, int count, int radix, Sint64 *valuep)
 {
-    const unsigned long long llong_max = (~0ULL) >> 1;
-    unsigned long long value;
+    const Uint64 llong_max = (~0ULL) >> 1;
+    Uint64 value;
     SDL_bool negative;
     size_t len = SDL_ScanUnsignedLongLongInternal(text, count, radix, &value, &negative);
     if (negative) {
-        const unsigned long long abs_llong_min = llong_max + 1;
+        const Uint64 abs_llong_min = llong_max + 1;
         if (value == 0 || value > abs_llong_min) {
             value = 0ULL - abs_llong_min;
         } else {
@@ -234,7 +235,7 @@
 #if !defined(HAVE_VSSCANF) || !defined(HAVE_STRTOULL)
 static size_t SDL_ScanUnsignedLongLong(const char *text, int count, int radix, Uint64 *valuep)
 {
-    const unsigned long long ullong_max = ~0ULL;
+    const Uint64 ullong_max = ~0ULL;
     SDL_bool negative;
     size_t len = SDL_ScanUnsignedLongLongInternal(text, count, radix, valuep, &negative);
     if (negative) {
@@ -927,7 +928,7 @@
 #if defined(HAVE_STRTOLL)
     return strtoll(string, endp, base);
 #else
-    long long value = 0;
+    Sint64 value = 0;
     size_t len = SDL_ScanLongLong(string, 0, base, &value);
     if (endp) {
         *endp = (char *)string + len;
@@ -941,7 +942,7 @@
 #if defined(HAVE_STRTOULL)
     return strtoull(string, endp, base);
 #else
-    unsigned long long value = 0;
+    Uint64 value = 0;
     size_t len = SDL_ScanUnsignedLongLong(string, 0, base, &value);
     if (endp) {
         *endp = (char *)string + len;
@@ -1058,6 +1059,7 @@
     return result;
 #endif /* HAVE_STRNCASECMP */
 }
+#endif /* !__AROS__ */
 
 int SDL_sscanf(const char *text, SDL_SCANF_FORMAT_STRING const char *fmt, ...)
 {
@@ -1069,6 +1071,7 @@
     return rc;
 }
 
+#if !defined(__AROS__) || defined(SDL2_AROS_SHARED)
 #ifdef HAVE_VSSCANF
 int SDL_vsscanf(const char *text, const char *fmt, va_list ap)
 {
@@ -1470,6 +1473,7 @@
     return retval;
 }
 #endif /* HAVE_VSSCANF */
+#endif /* !__AROS__ */
 
 int SDL_snprintf(SDL_OUT_Z_CAP(maxlen) char *text, size_t maxlen, SDL_PRINTF_FORMAT_STRING const char *fmt, ...)
 {
@@ -1483,6 +1487,7 @@
     return retval;
 }
 
+#if !defined(__AROS__) || defined(SDL2_AROS_SHARED)
 #if defined(HAVE_LIBC) && defined(__WATCOMC__)
 /* _vsnprintf() doesn't ensure nul termination */
 int SDL_vsnprintf(SDL_OUT_Z_CAP(maxlen) char *text, size_t maxlen, const char *fmt, va_list ap)
@@ -1744,7 +1749,7 @@
         return SDL_PrintString(text, maxlen, info, NULL);
     }
 
-    SDL_ulltoa((unsigned long long)(uintptr_t)value, num, 16);
+    SDL_ulltoa((Uint64)(uintptr_t)value, num, 16);
     length = SDL_PrintString(text, maxlen, info, "0x");
     return length + SDL_PrintString(TEXT_AND_LEN_ARGS, info, num);
 }
@@ -1969,6 +1974,7 @@
 
 #undef TEXT_AND_LEN_ARGS
 #endif /* HAVE_VSNPRINTF */
+#endif /* !__AROS__ */
 
 int SDL_asprintf(char **strp, SDL_PRINTF_FORMAT_STRING const char *fmt, ...)
 {
@@ -1982,6 +1988,7 @@
     return retval;
 }
 
+#if !defined(__AROS__) || defined(SDL2_AROS_SHARED)
 int SDL_vasprintf(char **strp, const char *fmt, va_list ap)
 {
     int retval;
@@ -2026,3 +2033,4 @@
         }
     }
 }
+#endif
diff -ruN SDL2-2.32.8/src/thread/aros/SDL_sysmutex.c SDL2-2.32.8.aros/src/thread/aros/SDL_sysmutex.c
--- SDL2-2.32.8/src/thread/aros/SDL_sysmutex.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/thread/aros/SDL_sysmutex.c	2025-07-28 10:23:45.073287295 +0000
@@ -0,0 +1,104 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2021 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+/* An implementation of mutexes using semaphores */
+
+#include "SDL_thread.h"
+#include "SDL_systhread_c.h"
+
+#include <proto/exec.h>
+
+
+struct SDL_mutex
+{
+    struct SignalSemaphore sem;
+};
+
+/* Create a mutex */
+SDL_mutex *
+SDL_CreateMutex(void)
+{
+    SDL_mutex *mutex;
+
+    /* Allocate mutex memory */
+    mutex = (SDL_mutex *) SDL_malloc(sizeof(*mutex));
+    if (mutex) {
+        /* Create the mutex semaphore, with initial value 1 */
+        memset(&mutex->sem, 0, sizeof(mutex->sem));
+        InitSemaphore(&mutex->sem);
+    } else {
+        SDL_OutOfMemory();
+    }
+    return mutex;
+}
+
+/* Free the mutex */
+void
+SDL_DestroyMutex(SDL_mutex * mutex)
+{
+    if (mutex)
+        SDL_free(mutex);
+}
+
+/* Lock the mutex */
+int
+SDL_LockMutex(SDL_mutex * mutex)
+{
+#if SDL_THREADS_DISABLED
+    return 0;
+#else
+    if (mutex == NULL)
+        return SDL_SetError("Passed a NULL mutex");
+
+    ObtainSemaphore(&mutex->sem);
+    return 0;
+#endif /* SDL_THREADS_DISABLED */
+}
+
+/* try Lock the mutex */
+int
+SDL_TryLockMutex(SDL_mutex * mutex)
+{
+#if SDL_THREADS_DISABLED
+    return 0;
+#else
+    if (mutex == NULL)
+        return SDL_SetError("Passed a NULL mutex");
+
+    return AttemptSemaphore(&mutex->sem) ? 0 : SDL_MUTEX_TIMEDOUT;
+#endif /* SDL_THREADS_DISABLED */
+}
+
+/* Unlock the mutex */
+int
+SDL_mutexV(SDL_mutex * mutex)
+{
+#if SDL_THREADS_DISABLED
+    return 0;
+#else
+    if (mutex == NULL)
+        return SDL_SetError("Passed a NULL mutex");
+
+    ReleaseSemaphore(&mutex->sem);
+    return 0;
+#endif /* SDL_THREADS_DISABLED */
+}
diff -ruN SDL2-2.32.8/src/thread/aros/SDL_sysmutex_c.h SDL2-2.32.8.aros/src/thread/aros/SDL_sysmutex_c.h
--- SDL2-2.32.8/src/thread/aros/SDL_sysmutex_c.h	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/thread/aros/SDL_sysmutex_c.h	2025-07-27 14:24:17.416841400 +0000
@@ -0,0 +1,22 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+/* vi: set ts=4 sw=4 expandtab: */
diff -ruN SDL2-2.32.8/src/thread/aros/SDL_syssem.c SDL2-2.32.8.aros/src/thread/aros/SDL_syssem.c
--- SDL2-2.32.8/src/thread/aros/SDL_syssem.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/thread/aros/SDL_syssem.c	2025-07-27 14:24:17.420841400 +0000
@@ -0,0 +1,272 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2021 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+/* An implementation of semaphores using mutexes and condition variables */
+
+#include "SDL_timer.h"
+#include "SDL_thread.h"
+#include "SDL_systhread_c.h"
+
+#include <devices/timer.h>
+#include <dos/dos.h>
+#include <exec/execbase.h>
+#include <proto/exec.h>
+
+
+#if SDL_THREADS_DISABLED
+
+SDL_sem *
+SDL_CreateSemaphore(Uint32 initial_value)
+{
+    SDL_SetError("SDL not built with thread support");
+    return (SDL_sem *) 0;
+}
+
+void
+SDL_DestroySemaphore(SDL_sem * sem)
+{
+}
+
+int
+SDL_SemTryWait(SDL_sem * sem)
+{
+    return SDL_SetError("SDL not built with thread support");
+}
+
+int
+SDL_SemWaitTimeout(SDL_sem * sem, Uint32 timeout)
+{
+    return SDL_SetError("SDL not built with thread support");
+}
+
+int
+SDL_SemWait(SDL_sem * sem)
+{
+    return SDL_SetError("SDL not built with thread support");
+}
+
+Uint32
+SDL_SemValue(SDL_sem * sem)
+{
+    return 0;
+}
+
+int
+SDL_SemPost(SDL_sem * sem)
+{
+    return SDL_SetError("SDL not built with thread support");
+}
+
+#else
+
+struct waitnode
+{
+	struct Message msg;
+	struct MsgPort port;
+};
+
+struct SDL_semaphore
+{
+    Uint32 sem_value;
+    struct MinList waitlist;
+    struct SignalSemaphore sem;
+};
+
+extern void InitQPort(struct MsgPort *port);
+
+static
+void mywaitinit(struct timerequest *r, Uint32 timeout, struct waitnode *wn)
+{
+    extern struct timerequest GlobalTimeReq;
+    struct timerequest *req = &GlobalTimeReq;
+
+    r->tr_node.io_Message.mn_Node.ln_Type = NT_REPLYMSG;
+    r->tr_node.io_Message.mn_ReplyPort    = &wn->port;
+    r->tr_node.io_Device                  = req->tr_node.io_Device;
+    r->tr_node.io_Unit                    = req->tr_node.io_Unit;
+}
+
+SDL_sem *
+SDL_CreateSemaphore(Uint32 initial_value)
+{
+    SDL_sem *sem;
+
+    sem = (SDL_sem *) SDL_malloc(sizeof(*sem));
+    if (!sem) {
+        SDL_OutOfMemory();
+        return NULL;
+    }
+
+    sem->sem_value = initial_value;
+
+    NEWLIST(&sem->waitlist);
+    memset(&sem->sem, 0, sizeof(sem->sem));
+    InitSemaphore(&sem->sem);
+
+    return sem;
+}
+
+/* WARNING:
+   You cannot call this function when another thread is using the semaphore.
+*/
+void
+SDL_DestroySemaphore(SDL_sem * sem)
+{
+    if (sem) {
+        ObtainSemaphore(&sem->sem);
+
+        sem->sem_value = (Uint32)-1;
+
+        while (!IsListEmpty((struct List *) &sem->waitlist)) {
+            struct waitnode *wn;
+
+            for (wn = (struct waitnode *) sem->waitlist.mlh_Head; wn->msg.mn_Node.ln_Succ; wn = (struct waitnode *) wn->msg.mn_Node.ln_Succ)
+                ReplyMsg(&wn->msg);
+
+            if (SDL_SemWaitTimeout(sem, 10) < 0)
+                break;
+        }
+
+        ReleaseSemaphore(&sem->sem);
+
+        SDL_free(sem);
+    }
+}
+
+int
+SDL_SemTryWait(SDL_sem * sem)
+{
+    int retval = SDL_MUTEX_TIMEDOUT;
+
+    if (!sem)
+        return SDL_SetError("Passed a NULL semaphore");
+
+    if (sem->sem_value > 0) {
+        ObtainSemaphore(&sem->sem);
+
+        if (sem->sem_value > 0) {
+            --sem->sem_value;
+            retval = 0;
+        }
+
+        ReleaseSemaphore(&sem->sem);
+    }
+
+    return retval;
+}
+
+int
+SDL_SemWaitTimeout(SDL_sem * sem, Uint32 timeout)
+{
+    int retval = SDL_MUTEX_TIMEDOUT;
+    struct waitnode wn;
+
+    if (!sem)
+        return SDL_SetError("Passed a NULL semaphore");
+
+    /* Try semaphore */
+    ObtainSemaphore(&sem->sem);
+
+    if (sem->sem_value > 0) {
+        --sem->sem_value;
+        retval = 0;
+    }
+    else if (timeout > 0) {
+        InitQPort(&wn.port);
+        wn.msg.mn_Node.ln_Type = NT_MESSAGE;
+        wn.msg.mn_ReplyPort = &wn.port;
+        ADDTAIL(&sem->waitlist, &wn);
+    }
+
+    ReleaseSemaphore(&sem->sem);
+
+    /* Sem not available and we have timeout */
+    if (retval == SDL_MUTEX_TIMEDOUT && timeout > 0) {
+        struct timerequest req;
+        struct Message *msg;
+
+        mywaitinit(&req, timeout, &wn);
+
+        req.tr_node.io_Command = TR_ADDREQUEST;
+        req.tr_time.tv_secs  = timeout / 1000;
+        req.tr_time.tv_micro = (timeout % 1000) * 1000;
+        SendIO((struct IORequest *) &req);
+
+        msg = WaitPort(&wn.port);
+        retval = 0;
+
+        if (msg != &wn.msg) {
+            ObtainSemaphore(&sem->sem);
+            REMOVE(&wn);
+            retval = wn.msg.mn_Node.ln_Type == NT_REPLYMSG ?  0 : SDL_MUTEX_TIMEDOUT;
+            ReleaseSemaphore(&sem->sem);
+        }
+
+        AbortIO((struct IORequest *) &req);
+        WaitIO((struct IORequest *) &req);
+    }
+
+    return retval;
+}
+
+int
+SDL_SemWait(SDL_sem * sem)
+{
+    return SDL_SemWaitTimeout(sem, SDL_MUTEX_MAXWAIT);
+}
+
+Uint32
+SDL_SemValue(SDL_sem * sem)
+{
+    if (!sem) {
+        SDL_SetError("Passed a NULL semaphore");
+        return -1;
+    }
+
+    return sem->sem_value;
+}
+
+int
+SDL_SemPost(SDL_sem * sem)
+{
+    struct waitnode *wn;
+
+    if (!sem)
+        return SDL_SetError("Passed a NULL semaphore");
+
+    ObtainSemaphore(&sem->sem);
+
+    sem->sem_value++;
+
+   	/* Wake whatever task happens to be first in the waitlist */
+    if ((wn = (APTR)REMHEAD(&sem->waitlist))) {
+        sem->sem_value--;
+        ReplyMsg(&wn->msg);
+    }
+
+    ReleaseSemaphore(&sem->sem);
+
+    return 0;
+}
+
+#endif /* SDL_THREADS_DISABLED */
+/* vi: set ts=4 sw=4 expandtab: */
diff -ruN SDL2-2.32.8/src/thread/aros/SDL_systhread.c SDL2-2.32.8.aros/src/thread/aros/SDL_systhread.c
--- SDL2-2.32.8/src/thread/aros/SDL_systhread.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/thread/aros/SDL_systhread.c	2025-07-28 10:27:58.744712368 +0000
@@ -0,0 +1,105 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2021 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+/* Thread management routines for SDL2 */
+
+#include "SDL_thread.h"
+#include "../SDL_systhread.h"
+
+#include <exec/execbase.h>
+#include <proto/exec.h>
+#include <proto/dos.h>
+
+static void
+RunThread(APTR data, struct MsgPort *port)
+{
+	SDL_Thread *thread = data;
+	
+#if (0)
+	BPTR lock = thread->status;
+	thread->status = 0;
+	BPTR oldDir = CurrentDir(lock);
+#endif
+	SDL_RunThread(data);
+#if (0)
+	UnLock(CurrentDir(oldDir));
+#endif
+}
+
+int
+SDL_SYS_CreateThread(SDL_Thread * thread)
+{
+
+	return -1;
+}
+
+void
+SDL_SYS_SetupThread(const char *name)
+{
+	struct Task *t = SysBase->ThisTask;
+
+	t->tc_Node.ln_Name = (STRPTR)name;
+}
+
+SDL_threadID
+SDL_ThreadID(void)
+{
+	return 0;
+}
+
+int
+SDL_SYS_SetThreadPriority(SDL_ThreadPriority priority)
+{
+	ssize_t pri = 0;
+
+    switch (priority) {
+        case SDL_THREAD_PRIORITY_LOW:
+            pri = -1;
+            break;
+        case SDL_THREAD_PRIORITY_HIGH:
+            pri = 5;
+            break;
+        case SDL_THREAD_PRIORITY_TIME_CRITICAL:
+            pri = 10;
+            break;
+        default:
+            pri = 0;
+            break;
+    }
+	
+	SetTaskPri(SysBase->ThisTask, pri);
+	return 0;
+}
+
+void
+SDL_SYS_WaitThread(SDL_Thread * thread)
+{
+
+}
+
+void
+SDL_SYS_DetachThread(SDL_Thread * thread)
+{
+
+}
+
+/* vi: set ts=4 sw=4 expandtab: */
diff -ruN SDL2-2.32.8/src/thread/aros/SDL_systhread_c.h SDL2-2.32.8.aros/src/thread/aros/SDL_systhread_c.h
--- SDL2-2.32.8/src/thread/aros/SDL_systhread_c.h	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/thread/aros/SDL_systhread_c.h	2025-07-28 10:23:50.473360247 +0000
@@ -0,0 +1,23 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2021 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+typedef ssize_t SYS_ThreadHandle;
diff -ruN SDL2-2.32.8/src/thread/generic/SDL_systls.c SDL2-2.32.8.aros/src/thread/generic/SDL_systls.c
--- SDL2-2.32.8/src/thread/generic/SDL_systls.c	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/src/thread/generic/SDL_systls.c	2025-07-27 14:24:17.384841346 +0000
@@ -22,11 +22,6 @@
 #include "../../SDL_internal.h"
 #include "../SDL_thread_c.h"
 
-void SDL_SYS_InitTLSData(void)
-{
-    SDL_Generic_InitTLSData();
-}
-
 SDL_TLSData *SDL_SYS_GetTLSData(void)
 {
     return SDL_Generic_GetTLSData();
@@ -37,9 +32,4 @@
     return SDL_Generic_SetTLSData(data);
 }
 
-void SDL_SYS_QuitTLSData(void)
-{
-    SDL_Generic_QuitTLSData();
-}
-
 /* vi: set ts=4 sw=4 expandtab: */
diff -ruN SDL2-2.32.8/src/thread/morphos/SDL_syscond.c.old SDL2-2.32.8.aros/src/thread/morphos/SDL_syscond.c.old
--- SDL2-2.32.8/src/thread/morphos/SDL_syscond.c.old	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/thread/morphos/SDL_syscond.c.old	2025-07-27 14:24:17.400841347 +0000
@@ -0,0 +1,220 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2021 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+/* An implementation of condition variables using semaphores and mutexes */
+/*
+   This implementation borrows heavily from the BeOS condition variable
+   implementation, written by Christopher Tate and Owen Smith.  Thanks!
+ */
+
+#include "SDL_thread.h"
+
+struct SDL_cond
+{
+    SDL_mutex *lock;
+    int waiting;
+    int signals;
+    SDL_sem *wait_sem;
+    SDL_sem *wait_done;
+};
+
+/* Create a condition variable */
+SDL_cond *
+SDL_CreateCond(void)
+{
+    SDL_cond *cond;
+
+    cond = (SDL_cond *) SDL_malloc(sizeof(SDL_cond));
+    if (cond) {
+        cond->lock = SDL_CreateMutex();
+        cond->wait_sem = SDL_CreateSemaphore(0);
+        cond->wait_done = SDL_CreateSemaphore(0);
+        cond->waiting = cond->signals = 0;
+        if (!cond->lock || !cond->wait_sem || !cond->wait_done) {
+            SDL_DestroyCond(cond);
+            cond = NULL;
+        }
+    } else {
+        SDL_OutOfMemory();
+    }
+    return (cond);
+}
+
+/* Destroy a condition variable */
+void
+SDL_DestroyCond(SDL_cond * cond)
+{
+    if (cond) {
+        if (cond->wait_sem) {
+            SDL_DestroySemaphore(cond->wait_sem);
+        }
+        if (cond->wait_done) {
+            SDL_DestroySemaphore(cond->wait_done);
+        }
+        if (cond->lock) {
+            SDL_DestroyMutex(cond->lock);
+        }
+        SDL_free(cond);
+    }
+}
+
+/* Restart one of the threads that are waiting on the condition variable */
+int
+SDL_CondSignal(SDL_cond * cond)
+{
+    if (!cond) {
+        return SDL_SetError("Passed a NULL condition variable");
+    }
+
+    /* If there are waiting threads not already signalled, then
+       signal the condition and wait for the thread to respond.
+     */
+    SDL_LockMutex(cond->lock);
+    if (cond->waiting > cond->signals) {
+        ++cond->signals;
+        SDL_SemPost(cond->wait_sem);
+        SDL_UnlockMutex(cond->lock);
+        SDL_SemWait(cond->wait_done);
+    } else {
+        SDL_UnlockMutex(cond->lock);
+    }
+
+    return 0;
+}
+
+/* Restart all threads that are waiting on the condition variable */
+int
+SDL_CondBroadcast(SDL_cond * cond)
+{
+    if (!cond) {
+        return SDL_SetError("Passed a NULL condition variable");
+    }
+
+    /* If there are waiting threads not already signalled, then
+       signal the condition and wait for the thread to respond.
+     */
+    SDL_LockMutex(cond->lock);
+    if (cond->waiting > cond->signals) {
+        int i, num_waiting;
+
+        num_waiting = (cond->waiting - cond->signals);
+        cond->signals = cond->waiting;
+        for (i = 0; i < num_waiting; ++i) {
+            SDL_SemPost(cond->wait_sem);
+        }
+        /* Now all released threads are blocked here, waiting for us.
+           Collect them all (and win fabulous prizes!) :-)
+         */
+        SDL_UnlockMutex(cond->lock);
+        for (i = 0; i < num_waiting; ++i) {
+            SDL_SemWait(cond->wait_done);
+        }
+    } else {
+        SDL_UnlockMutex(cond->lock);
+    }
+
+    return 0;
+}
+
+/* Wait on the condition variable for at most 'ms' milliseconds.
+   The mutex must be locked before entering this function!
+   The mutex is unlocked during the wait, and locked again after the wait.
+
+Typical use:
+
+Thread A:
+    SDL_LockMutex(lock);
+    while ( ! condition ) {
+        SDL_CondWait(cond, lock);
+    }
+    SDL_UnlockMutex(lock);
+
+Thread B:
+    SDL_LockMutex(lock);
+    ...
+    condition = true;
+    ...
+    SDL_CondSignal(cond);
+    SDL_UnlockMutex(lock);
+ */
+int
+SDL_CondWaitTimeout(SDL_cond * cond, SDL_mutex * mutex, Uint32 ms)
+{
+    int retval;
+
+    if (!cond) {
+        return SDL_SetError("Passed a NULL condition variable");
+    }
+
+    /* Obtain the protection mutex, and increment the number of waiters.
+       This allows the signal mechanism to only perform a signal if there
+       are waiting threads.
+     */
+    SDL_LockMutex(cond->lock);
+    ++cond->waiting;
+    SDL_UnlockMutex(cond->lock);
+
+    /* Unlock the mutex, as is required by condition variable semantics */
+    SDL_UnlockMutex(mutex);
+
+    /* Wait for a signal */
+    if (ms == SDL_MUTEX_MAXWAIT) {
+        retval = SDL_SemWait(cond->wait_sem);
+    } else {
+        retval = SDL_SemWaitTimeout(cond->wait_sem, ms);
+    }
+
+    /* Let the signaler know we have completed the wait, otherwise
+       the signaler can race ahead and get the condition semaphore
+       if we are stopped between the mutex unlock and semaphore wait,
+       giving a deadlock.  See the following URL for details:
+       http://web.archive.org/web/20010914175514/http://www-classic.be.com/aboutbe/benewsletter/volume_III/Issue40.html#Workshop
+     */
+    SDL_LockMutex(cond->lock);
+    if (cond->signals > 0) {
+        /* If we timed out, we need to eat a condition signal */
+        if (retval > 0) {
+            SDL_SemWait(cond->wait_sem);
+        }
+        /* We always notify the signal thread that we are done */
+        SDL_SemPost(cond->wait_done);
+
+        /* Signal handshake complete */
+        --cond->signals;
+    }
+    --cond->waiting;
+    SDL_UnlockMutex(cond->lock);
+
+    /* Lock the mutex, as is required by condition variable semantics */
+    SDL_LockMutex(mutex);
+
+    return retval;
+}
+
+/* Wait on the condition variable forever */
+int
+SDL_CondWait(SDL_cond * cond, SDL_mutex * mutex)
+{
+    return SDL_CondWaitTimeout(cond, mutex, SDL_MUTEX_MAXWAIT);
+}
+
+/* vi: set ts=4 sw=4 expandtab: */
diff -ruN SDL2-2.32.8/src/thread/morphos/SDL_sysmutex.c SDL2-2.32.8.aros/src/thread/morphos/SDL_sysmutex.c
--- SDL2-2.32.8/src/thread/morphos/SDL_sysmutex.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/thread/morphos/SDL_sysmutex.c	2025-07-27 14:24:17.408841347 +0000
@@ -0,0 +1,106 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2021 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+/* An implementation of mutexes using semaphores */
+
+#include "SDL_thread.h"
+#include "SDL_systhread_c.h"
+
+#include <proto/exec.h>
+
+
+struct SDL_mutex
+{
+    struct SignalSemaphore sem;
+};
+
+/* Create a mutex */
+SDL_mutex *
+SDL_CreateMutex(void)
+{
+    SDL_mutex *mutex;
+
+    /* Allocate mutex memory */
+    mutex = (SDL_mutex *) SDL_malloc(sizeof(*mutex));
+    if (mutex) {
+        /* Create the mutex semaphore, with initial value 1 */
+        memset(&mutex->sem, 0, sizeof(mutex->sem));
+        InitSemaphore(&mutex->sem);
+    } else {
+        SDL_OutOfMemory();
+    }
+    return mutex;
+}
+
+/* Free the mutex */
+void
+SDL_DestroyMutex(SDL_mutex * mutex)
+{
+    if (mutex)
+        SDL_free(mutex);
+}
+
+/* Lock the mutex */
+int
+SDL_LockMutex(SDL_mutex * mutex)
+{
+#if SDL_THREADS_DISABLED
+    return 0;
+#else
+    if (mutex == NULL)
+        return SDL_SetError("Passed a NULL mutex");
+
+    ObtainSemaphore(&mutex->sem);
+    return 0;
+#endif /* SDL_THREADS_DISABLED */
+}
+
+/* try Lock the mutex */
+int
+SDL_TryLockMutex(SDL_mutex * mutex)
+{
+#if SDL_THREADS_DISABLED
+    return 0;
+#else
+    if (mutex == NULL)
+        return SDL_SetError("Passed a NULL mutex");
+
+    return AttemptSemaphore(&mutex->sem) ? 0 : SDL_MUTEX_TIMEDOUT;
+#endif /* SDL_THREADS_DISABLED */
+}
+
+/* Unlock the mutex */
+int
+SDL_mutexV(SDL_mutex * mutex)
+{
+#if SDL_THREADS_DISABLED
+    return 0;
+#else
+    if (mutex == NULL)
+        return SDL_SetError("Passed a NULL mutex");
+
+    ReleaseSemaphore(&mutex->sem);
+    return 0;
+#endif /* SDL_THREADS_DISABLED */
+}
+
+/* vi: set ts=4 sw=4 expandtab: */
diff -ruN SDL2-2.32.8/src/thread/morphos/SDL_sysmutex_c.h SDL2-2.32.8.aros/src/thread/morphos/SDL_sysmutex_c.h
--- SDL2-2.32.8/src/thread/morphos/SDL_sysmutex_c.h	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/thread/morphos/SDL_sysmutex_c.h	2025-07-27 14:24:17.416841347 +0000
@@ -0,0 +1,22 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+/* vi: set ts=4 sw=4 expandtab: */
diff -ruN SDL2-2.32.8/src/thread/morphos/SDL_syssem.c SDL2-2.32.8.aros/src/thread/morphos/SDL_syssem.c
--- SDL2-2.32.8/src/thread/morphos/SDL_syssem.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/thread/morphos/SDL_syssem.c	2025-07-27 14:24:17.420841347 +0000
@@ -0,0 +1,272 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2021 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+/* An implementation of semaphores using mutexes and condition variables */
+
+#include "SDL_timer.h"
+#include "SDL_thread.h"
+#include "SDL_systhread_c.h"
+
+#include <devices/timer.h>
+#include <dos/dos.h>
+#include <exec/execbase.h>
+#include <proto/exec.h>
+
+
+#if SDL_THREADS_DISABLED
+
+SDL_sem *
+SDL_CreateSemaphore(Uint32 initial_value)
+{
+    SDL_SetError("SDL not built with thread support");
+    return (SDL_sem *) 0;
+}
+
+void
+SDL_DestroySemaphore(SDL_sem * sem)
+{
+}
+
+int
+SDL_SemTryWait(SDL_sem * sem)
+{
+    return SDL_SetError("SDL not built with thread support");
+}
+
+int
+SDL_SemWaitTimeout(SDL_sem * sem, Uint32 timeout)
+{
+    return SDL_SetError("SDL not built with thread support");
+}
+
+int
+SDL_SemWait(SDL_sem * sem)
+{
+    return SDL_SetError("SDL not built with thread support");
+}
+
+Uint32
+SDL_SemValue(SDL_sem * sem)
+{
+    return 0;
+}
+
+int
+SDL_SemPost(SDL_sem * sem)
+{
+    return SDL_SetError("SDL not built with thread support");
+}
+
+#else
+
+struct waitnode
+{
+	struct Message msg;
+	struct MsgPort port;
+};
+
+struct SDL_semaphore
+{
+    Uint32 sem_value;
+    struct MinList waitlist;
+    struct SignalSemaphore sem;
+};
+
+extern void InitQPort(struct MsgPort *port);
+
+static
+void mywaitinit(struct timerequest *r, Uint32 timeout, struct waitnode *wn)
+{
+    extern struct timerequest GlobalTimeReq;
+    struct timerequest *req = &GlobalTimeReq;
+
+    r->tr_node.io_Message.mn_Node.ln_Type = NT_REPLYMSG;
+    r->tr_node.io_Message.mn_ReplyPort    = &wn->port;
+    r->tr_node.io_Device                  = req->tr_node.io_Device;
+    r->tr_node.io_Unit                    = req->tr_node.io_Unit;
+}
+
+SDL_sem *
+SDL_CreateSemaphore(Uint32 initial_value)
+{
+    SDL_sem *sem;
+
+    sem = (SDL_sem *) SDL_malloc(sizeof(*sem));
+    if (!sem) {
+        SDL_OutOfMemory();
+        return NULL;
+    }
+
+    sem->sem_value = initial_value;
+
+    NEWLIST(&sem->waitlist);
+    memset(&sem->sem, 0, sizeof(sem->sem));
+    InitSemaphore(&sem->sem);
+
+    return sem;
+}
+
+/* WARNING:
+   You cannot call this function when another thread is using the semaphore.
+*/
+void
+SDL_DestroySemaphore(SDL_sem * sem)
+{
+    if (sem) {
+        ObtainSemaphore(&sem->sem);
+
+        sem->sem_value = (Uint32)-1;
+
+        while (!IsListEmpty((struct List *) &sem->waitlist)) {
+            struct waitnode *wn;
+
+            for (wn = (struct waitnode *) sem->waitlist.mlh_Head; wn->msg.mn_Node.ln_Succ; wn = (struct waitnode *) wn->msg.mn_Node.ln_Succ)
+                ReplyMsg(&wn->msg);
+
+            if (SDL_SemWaitTimeout(sem, 10) < 0)
+                break;
+        }
+
+        ReleaseSemaphore(&sem->sem);
+
+        SDL_free(sem);
+    }
+}
+
+int
+SDL_SemTryWait(SDL_sem * sem)
+{
+    int retval = SDL_MUTEX_TIMEDOUT;
+
+    if (!sem)
+        return SDL_SetError("Passed a NULL semaphore");
+
+    if (sem->sem_value > 0) {
+        ObtainSemaphore(&sem->sem);
+
+        if (sem->sem_value > 0) {
+            --sem->sem_value;
+            retval = 0;
+        }
+
+        ReleaseSemaphore(&sem->sem);
+    }
+
+    return retval;
+}
+
+int
+SDL_SemWaitTimeout(SDL_sem * sem, Uint32 timeout)
+{
+    int retval = SDL_MUTEX_TIMEDOUT;
+    struct waitnode wn;
+
+    if (!sem)
+        return SDL_SetError("Passed a NULL semaphore");
+
+    /* Try semaphore */
+    ObtainSemaphore(&sem->sem);
+
+    if (sem->sem_value > 0) {
+        --sem->sem_value;
+        retval = 0;
+    }
+    else if (timeout > 0) {
+        InitQPort(&wn.port);
+        wn.msg.mn_Node.ln_Type = NT_MESSAGE;
+        wn.msg.mn_ReplyPort = &wn.port;
+        ADDTAIL(&sem->waitlist, &wn);
+    }
+
+    ReleaseSemaphore(&sem->sem);
+
+    /* Sem not available and we have timeout */
+    if (retval == SDL_MUTEX_TIMEDOUT && timeout > 0) {
+        struct timerequest req;
+        struct Message *msg;
+
+        mywaitinit(&req, timeout, &wn);
+
+        req.tr_node.io_Command = TR_ADDREQUEST;
+        req.tr_time.tv_secs  = timeout / 1000;
+        req.tr_time.tv_micro = (timeout % 1000) * 1000;
+        SendIO((struct IORequest *) &req);
+
+        msg = WaitPort(&wn.port);
+        retval = 0;
+
+        if (msg != &wn.msg) {
+            ObtainSemaphore(&sem->sem);
+            REMOVE(&wn);
+            retval = wn.msg.mn_Node.ln_Type == NT_REPLYMSG ?  0 : SDL_MUTEX_TIMEDOUT;
+            ReleaseSemaphore(&sem->sem);
+        }
+
+        AbortIO((struct IORequest *) &req);
+        WaitIO((struct IORequest *) &req);
+    }
+
+    return retval;
+}
+
+int
+SDL_SemWait(SDL_sem * sem)
+{
+    return SDL_SemWaitTimeout(sem, SDL_MUTEX_MAXWAIT);
+}
+
+Uint32
+SDL_SemValue(SDL_sem * sem)
+{
+    if (!sem) {
+        SDL_SetError("Passed a NULL semaphore");
+        return -1;
+    }
+
+    return sem->sem_value;
+}
+
+int
+SDL_SemPost(SDL_sem * sem)
+{
+    struct waitnode *wn;
+
+    if (!sem)
+        return SDL_SetError("Passed a NULL semaphore");
+
+    ObtainSemaphore(&sem->sem);
+
+    sem->sem_value++;
+
+   	/* Wake whatever task happens to be first in the waitlist */
+    if ((wn = (APTR)REMHEAD(&sem->waitlist))) {
+        sem->sem_value--;
+        ReplyMsg(&wn->msg);
+    }
+
+    ReleaseSemaphore(&sem->sem);
+
+    return 0;
+}
+
+#endif /* SDL_THREADS_DISABLED */
+/* vi: set ts=4 sw=4 expandtab: */
diff -ruN SDL2-2.32.8/src/thread/morphos/SDL_systhread.c SDL2-2.32.8.aros/src/thread/morphos/SDL_systhread.c
--- SDL2-2.32.8/src/thread/morphos/SDL_systhread.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/thread/morphos/SDL_systhread.c	2025-07-27 14:24:17.428841347 +0000
@@ -0,0 +1,104 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2021 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+/* Thread management routines for SDL */
+
+#include "SDL_thread.h"
+#include "../SDL_systhread.h"
+
+#include <exec/execbase.h>
+#include <proto/exec.h>
+#include <proto/dos.h>
+#include <proto/threadpool.h>
+
+extern APTR threadpool;
+
+static void
+RunThread(APTR data, struct MsgPort *port)
+{
+	SDL_Thread *thread = data;
+	
+	BPTR lock = thread->status;
+	thread->status = 0;
+	BPTR oldDir = CurrentDir(lock);
+	SDL_RunThread(data);
+	UnLock(CurrentDir(oldDir));
+}
+
+int
+SDL_SYS_CreateThread(SDL_Thread * thread)
+{
+	thread->status = Lock("", SHARED_LOCK);
+	thread->handle = QueueWorkItem(threadpool, (APTR)RunThread, thread);
+	return thread->handle == WORKITEM_INVALID ? -1 : 0;
+}
+
+void
+SDL_SYS_SetupThread(const char *name)
+{
+	struct Task *t = SysBase->ThisTask;
+	t->tc_Node.ln_Name = (STRPTR)name;
+}
+
+SDL_threadID
+SDL_ThreadID(void)
+{
+	return GetCurrentWorkItem(threadpool);
+}
+
+int
+SDL_SYS_SetThreadPriority(SDL_ThreadPriority priority)
+{
+	ssize_t pri = 0;
+
+    switch (priority) {
+        case SDL_THREAD_PRIORITY_LOW:
+            pri = -1;
+            break;
+        case SDL_THREAD_PRIORITY_HIGH:
+            pri = 5;
+            break;
+        case SDL_THREAD_PRIORITY_TIME_CRITICAL:
+            pri = 10;
+            break;
+        default:
+            pri = 0;
+            break;
+    }
+	
+	SetTaskPri(SysBase->ThisTask, pri);
+	return 0;
+}
+
+void
+SDL_SYS_WaitThread(SDL_Thread * thread)
+{
+	WaitWorkItem(threadpool, thread->handle);
+}
+
+void
+SDL_SYS_DetachThread(SDL_Thread * thread)
+{
+	thread->handle = WORKITEM_INVALID;
+}
+
+/* vi: set ts=4 sw=4 expandtab: */
diff -ruN SDL2-2.32.8/src/thread/morphos/SDL_systhread_c.h SDL2-2.32.8.aros/src/thread/morphos/SDL_systhread_c.h
--- SDL2-2.32.8/src/thread/morphos/SDL_systhread_c.h	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/thread/morphos/SDL_systhread_c.h	2025-07-27 14:24:17.432841347 +0000
@@ -0,0 +1,25 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2021 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+typedef ssize_t SYS_ThreadHandle;
+
+/* vi: set ts=4 sw=4 expandtab: */
diff -ruN SDL2-2.32.8/src/thread/morphos/SDL_systls.c.old SDL2-2.32.8.aros/src/thread/morphos/SDL_systls.c.old
--- SDL2-2.32.8/src/thread/morphos/SDL_systls.c.old	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/thread/morphos/SDL_systls.c.old	2025-07-27 14:24:17.440841347 +0000
@@ -0,0 +1,93 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2021 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#include "../../SDL_internal.h"
+
+#if SDL_THREAD_MORPHOS
+
+#include <exec/execbase.h>
+#include <proto/exec.h>
+#define AROS_ALMOST_COMPATIBLE 1
+#include <exec/lists.h>
+
+#include "../SDL_thread_c.h"
+#undef D
+#define D(fmt, ...) ({((STRPTR (*)(void *, CONST_STRPTR , APTR (*)(APTR, UBYTE), STRPTR , ...))*(void**)((long)(*((APTR *)4)) - 922))((void*)(*((APTR *)4)), fmt, (APTR)1, NULL, ##__VA_ARGS__);})
+
+#define TLS_MAGICID "SDL2TLS"
+
+struct tlsmagic
+{
+	UBYTE	magicid[sizeof(TLS_MAGICID)];
+	APTR	tlsptr;
+};
+
+SDL_TLSData *
+SDL_SYS_GetTLSData()
+{
+	struct MemList *ml;
+
+	ForeachNode(&SysBase->ThisTask->tc_MemEntry, ml) {
+		if (ml->ml_NumEntries == 1 &&
+		    ml->ml_Node.ln_Name == (char *) ml->ml_ME[0].me_Addr &&
+		    !strcmp(ml->ml_Node.ln_Name, TLS_MAGICID)) {
+			struct tlsmagic *tm = ml->ml_ME[0].me_Addr;
+			return tm->tlsptr;
+		}
+	}
+
+	return NULL;
+}
+
+static const struct MemList stml = {{0,0,0,0,0}, 1, {{{MEMF_ANY}, sizeof(struct tlsmagic)}}};
+
+int
+SDL_SYS_SetTLSData(SDL_TLSData *data)
+{
+	struct Task *t = SysBase->ThisTask;
+	struct MemList *ml;
+	struct tlsmagic *tm;
+
+	ForeachNode(&t->tc_MemEntry, ml) {
+		if (ml->ml_NumEntries == 1 &&
+		    ml->ml_Node.ln_Name == (char *) ml->ml_ME[0].me_Addr &&
+		    !strcmp(ml->ml_Node.ln_Name, TLS_MAGICID)) {
+			tm = ml->ml_ME[0].me_Addr;
+			tm->tlsptr = data;
+			return 0;
+		}
+	}
+
+	ml = AllocEntry((struct MemList *) &stml);
+	if ((ULONG) ml & 0x80000000)
+		return 1;
+
+	tm = ml->ml_ME[0].me_Addr;
+	ml->ml_Node.ln_Name = tm->magicid;
+	memcpy(tm->magicid, TLS_MAGICID, sizeof(TLS_MAGICID));
+	tm->tlsptr = data;
+	ADDHEAD(&t->tc_MemEntry, &ml->ml_Node);
+	return 0;
+}
+
+#endif /* SDL_THREAD_MORPHOS */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff -ruN SDL2-2.32.8/src/thread/n3ds/SDL_syscond.c SDL2-2.32.8.aros/src/thread/n3ds/SDL_syscond.c
--- SDL2-2.32.8/src/thread/n3ds/SDL_syscond.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/thread/n3ds/SDL_syscond.c	2025-07-27 14:24:17.452841347 +0000
@@ -0,0 +1,127 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2025 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifdef SDL_THREAD_N3DS
+
+/* An implementation of condition variables using libctru's CondVar */
+
+#include "SDL_sysmutex_c.h"
+
+struct SDL_cond
+{
+    CondVar cond_variable;
+};
+
+/* Create a condition variable */
+SDL_cond *SDL_CreateCond(void)
+{
+    SDL_cond *cond = (SDL_cond *)SDL_malloc(sizeof(SDL_cond));
+    if (cond) {
+        CondVar_Init(&cond->cond_variable);
+    } else {
+        SDL_OutOfMemory();
+    }
+    return cond;
+}
+
+/* Destroy a condition variable */
+void SDL_DestroyCond(SDL_cond *cond)
+{
+    if (cond) {
+        SDL_free(cond);
+    }
+}
+
+/* Restart one of the threads that are waiting on the condition variable */
+int SDL_CondSignal(SDL_cond *cond)
+{
+    if (!cond) {
+        return SDL_InvalidParamError("cond");
+    }
+
+    CondVar_Signal(&cond->cond_variable);
+    return 0;
+}
+
+/* Restart all threads that are waiting on the condition variable */
+int SDL_CondBroadcast(SDL_cond *cond)
+{
+    if (!cond) {
+        return SDL_InvalidParamError("cond");
+    }
+
+    CondVar_Broadcast(&cond->cond_variable);
+    return 0;
+}
+
+/* Wait on the condition variable for at most 'ms' milliseconds.
+   The mutex must be locked before entering this function!
+   The mutex is unlocked during the wait, and locked again after the wait.
+
+Typical use:
+
+Thread A:
+    SDL_LockMutex(lock);
+    while ( ! condition ) {
+        SDL_CondWait(cond, lock);
+    }
+    SDL_UnlockMutex(lock);
+
+Thread B:
+    SDL_LockMutex(lock);
+    ...
+    condition = true;
+    ...
+    SDL_CondSignal(cond);
+    SDL_UnlockMutex(lock);
+ */
+int SDL_CondWaitTimeout(SDL_cond *cond, SDL_mutex *mutex, Uint32 ms)
+{
+    Result res;
+
+    if (!cond) {
+        return SDL_InvalidParamError("cond");
+    }
+    if (!mutex) {
+        return SDL_InvalidParamError("mutex");
+    }
+
+    res = 0;
+    if (ms == SDL_MUTEX_MAXWAIT) {
+        CondVar_Wait(&cond->cond_variable, &mutex->lock.lock);
+    } else {
+        res = CondVar_WaitTimeout(&cond->cond_variable, &mutex->lock.lock,
+                                  (s64)ms * 1000000LL);
+    }
+
+    return R_SUCCEEDED(res) ? 0 : SDL_MUTEX_TIMEDOUT;
+}
+
+/* Wait on the condition variable forever */
+int SDL_CondWait(SDL_cond *cond, SDL_mutex *mutex)
+{
+    return SDL_CondWaitTimeout(cond, mutex, SDL_MUTEX_MAXWAIT);
+}
+
+#endif /* SDL_THREAD_N3DS */
+
+/* vi: set sts=4 ts=4 sw=4 expandtab: */
diff -ruN SDL2-2.32.8/src/thread/SDL_systhread.h SDL2-2.32.8.aros/src/thread/SDL_systhread.h
--- SDL2-2.32.8/src/thread/SDL_systhread.h	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/src/thread/SDL_systhread.h	2025-07-27 14:24:17.824841353 +0000
@@ -59,18 +59,12 @@
 /* Mark thread as cleaned up as soon as it exits, without joining. */
 extern void SDL_SYS_DetachThread(SDL_Thread *thread);
 
-/* Initialize the global TLS data */
-extern void SDL_SYS_InitTLSData(void);
-
 /* Get the thread local storage for this thread */
 extern SDL_TLSData *SDL_SYS_GetTLSData(void);
 
 /* Set the thread local storage for this thread */
 extern int SDL_SYS_SetTLSData(SDL_TLSData *data);
 
-/* Quit the global TLS data */
-extern void SDL_SYS_QuitTLSData(void);
-
 /* This is for internal SDL use, so we don't need #ifdefs everywhere. */
 extern SDL_Thread *
 SDL_CreateThreadInternal(int(SDLCALL *fn)(void *), const char *name,
diff -ruN SDL2-2.32.8/src/thread/SDL_thread.c SDL2-2.32.8.aros/src/thread/SDL_thread.c
--- SDL2-2.32.8/src/thread/SDL_thread.c	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/src/thread/SDL_thread.c	2025-07-28 15:10:01.651006095 +0000
@@ -28,15 +28,7 @@
 #include "SDL_hints.h"
 #include "../SDL_error_c.h"
 
-/* The storage is local to the thread, but the IDs are global for the process */
-
-static SDL_atomic_t SDL_tls_allocated;
-
-void SDL_InitTLSData(void)
-{
-    SDL_SYS_InitTLSData();
-}
-
+#if !defined(__AROS__) || defined(SDL2_AROS_SHARED)
 SDL_TLSID SDL_TLSCreate(void)
 {
     static SDL_atomic_t SDL_tls_id;
@@ -62,13 +54,6 @@
         return SDL_InvalidParamError("id");
     }
 
-    /* Make sure TLS is initialized.
-     * There's a race condition here if you are calling this from non-SDL threads
-     * and haven't called SDL_Init() on your main thread, but such is life.
-     */
-    SDL_InitTLSData();
-
-    /* Get the storage for the current thread */
     storage = SDL_SYS_GetTLSData();
     if (!storage || (id > storage->limit)) {
         unsigned int i, oldlimit, newlimit;
@@ -85,10 +70,8 @@
             storage->array[i].destructor = NULL;
         }
         if (SDL_SYS_SetTLSData(storage) != 0) {
-            SDL_free(storage);
             return -1;
         }
-        SDL_AtomicIncRef(&SDL_tls_allocated);
     }
 
     storage->array[id - 1].data = SDL_const_cast(void *, value);
@@ -100,7 +83,6 @@
 {
     SDL_TLSData *storage;
 
-    /* Cleanup the storage for the current thread */
     storage = SDL_SYS_GetTLSData();
     if (storage) {
         unsigned int i;
@@ -111,18 +93,6 @@
         }
         SDL_SYS_SetTLSData(NULL);
         SDL_free(storage);
-        (void)SDL_AtomicDecRef(&SDL_tls_allocated);
-    }
-}
-
-void SDL_QuitTLSData(void)
-{
-    SDL_TLSCleanup();
-
-    if (SDL_AtomicGet(&SDL_tls_allocated) == 0) {
-        SDL_SYS_QuitTLSData();
-    } else {
-        /* Some thread hasn't called SDL_CleanupTLS() */
     }
 }
 
@@ -144,27 +114,40 @@
 static SDL_mutex *SDL_generic_TLS_mutex;
 static SDL_TLSEntry *SDL_generic_TLS;
 
-void SDL_Generic_InitTLSData(void)
-{
-    if (!SDL_generic_TLS_mutex) {
-        SDL_generic_TLS_mutex = SDL_CreateMutex();
-    }
-}
-
 SDL_TLSData *SDL_Generic_GetTLSData(void)
 {
     SDL_threadID thread = SDL_ThreadID();
     SDL_TLSEntry *entry;
     SDL_TLSData *storage = NULL;
 
+#ifndef SDL_THREADS_DISABLED
+    if (!SDL_generic_TLS_mutex) {
+        static SDL_SpinLock tls_lock;
+        SDL_AtomicLock(&tls_lock);
+        if (!SDL_generic_TLS_mutex) {
+            SDL_mutex *mutex = SDL_CreateMutex();
+            SDL_MemoryBarrierRelease();
+            SDL_generic_TLS_mutex = mutex;
+            if (!SDL_generic_TLS_mutex) {
+                SDL_AtomicUnlock(&tls_lock);
+                return NULL;
+            }
+        }
+        SDL_AtomicUnlock(&tls_lock);
+    }
+    SDL_MemoryBarrierAcquire();
     SDL_LockMutex(SDL_generic_TLS_mutex);
+#endif /* SDL_THREADS_DISABLED */
+
     for (entry = SDL_generic_TLS; entry; entry = entry->next) {
         if (entry->thread == thread) {
             storage = entry->storage;
             break;
         }
     }
+#ifndef SDL_THREADS_DISABLED
     SDL_UnlockMutex(SDL_generic_TLS_mutex);
+#endif
 
     return storage;
 }
@@ -173,8 +156,8 @@
 {
     SDL_threadID thread = SDL_ThreadID();
     SDL_TLSEntry *prev, *entry;
-    int retval = 0;
 
+    /* SDL_Generic_GetTLSData() is always called first, so we can assume SDL_generic_TLS_mutex */
     SDL_LockMutex(SDL_generic_TLS_mutex);
     prev = NULL;
     for (entry = SDL_generic_TLS; entry; entry = entry->next) {
@@ -193,46 +176,25 @@
         }
         prev = entry;
     }
-    if (!entry && data) {
+    if (!entry) {
         entry = (SDL_TLSEntry *)SDL_malloc(sizeof(*entry));
         if (entry) {
             entry->thread = thread;
             entry->storage = data;
             entry->next = SDL_generic_TLS;
             SDL_generic_TLS = entry;
-        } else {
-            retval = SDL_OutOfMemory();
         }
     }
     SDL_UnlockMutex(SDL_generic_TLS_mutex);
 
-    return retval;
-}
-
-void SDL_Generic_QuitTLSData(void)
-{
-    SDL_TLSEntry *entry;
-
-    /* This should have been cleaned up by the time we get here */
-    SDL_assert(!SDL_generic_TLS);
-    if (SDL_generic_TLS) {
-        SDL_LockMutex(SDL_generic_TLS_mutex);
-        for (entry = SDL_generic_TLS; entry; ) {
-            SDL_TLSEntry *next = entry->next;
-            SDL_free(entry->storage);
-            SDL_free(entry);
-            entry = next;
-        }
-        SDL_generic_TLS = NULL;
-        SDL_UnlockMutex(SDL_generic_TLS_mutex);
-    }
-
-    if (SDL_generic_TLS_mutex) {
-        SDL_DestroyMutex(SDL_generic_TLS_mutex);
-        SDL_generic_TLS_mutex = NULL;
+    if (!entry) {
+        return SDL_OutOfMemory();
     }
+    return 0;
 }
 
+#endif /* !__AROS__*/
+
 /* Non-thread-safe global error variable */
 static SDL_error *SDL_GetStaticErrBuf(void)
 {
@@ -243,6 +205,13 @@
     return &SDL_global_error;
 }
 
+#if defined(__AROS__) && !defined(SDL2_AROS_SHARED)
+/* Routine to get the thread-specific error variable */
+SDL_error *SDL_GetErrBuf(void)
+{
+    return SDL_GetStaticErrBuf();
+}
+#else
 #ifndef SDL_THREADS_DISABLED
 static void SDLCALL SDL_FreeErrBuf(void *data)
 {
@@ -369,8 +338,6 @@
     SDL_Thread *thread;
     int ret;
 
-    SDL_InitMainThread();
-
     /* Allocate memory for the thread info structure */
     thread = (SDL_Thread *)SDL_calloc(1, sizeof(*thread));
     if (!thread) {
@@ -515,4 +482,6 @@
     }
 }
 
+#endif /* !__AROS__*/
+
 /* vi: set ts=4 sw=4 expandtab: */
diff -ruN SDL2-2.32.8/src/thread/SDL_thread_c.h SDL2-2.32.8.aros/src/thread/SDL_thread_c.h
--- SDL2-2.32.8/src/thread/SDL_thread_c.h	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/src/thread/SDL_thread_c.h	2025-07-27 14:24:17.836841353 +0000
@@ -42,6 +42,8 @@
 #include "n3ds/SDL_systhread_c.h"
 #elif defined(SDL_THREAD_STDCPP)
 #include "stdcpp/SDL_systhread_c.h"
+#elif defined(SDL_THREAD_MORPHOS)
+#include "morphos/SDL_systhread_c.h"
 #elif defined(SDL_THREAD_OS2)
 #include "os2/SDL_systhread_c.h"
 #elif defined(SDL_THREAD_NGAGE)
@@ -93,17 +95,17 @@
 /* This is how many TLS entries we allocate at once */
 #define TLS_ALLOC_CHUNKSIZE 4
 
-extern void SDL_InitTLSData(void);
-extern void SDL_QuitTLSData(void);
-
-/* Generic TLS support.
+/* Get cross-platform, slow, thread local storage for this thread.
    This is only intended as a fallback if getting real thread-local
    storage fails or isn't supported on this platform.
  */
-extern void SDL_Generic_InitTLSData(void);
 extern SDL_TLSData *SDL_Generic_GetTLSData(void);
+
+/* Set cross-platform, slow, thread local storage for this thread.
+   This is only intended as a fallback if getting real thread-local
+   storage fails or isn't supported on this platform.
+ */
 extern int SDL_Generic_SetTLSData(SDL_TLSData *data);
-extern void SDL_Generic_QuitTLSData(void);
 
 #endif /* SDL_thread_c_h_ */
 
diff -ruN SDL2-2.32.8/src/timer/morphos/SDL_systimer.c SDL2-2.32.8.aros/src/timer/morphos/SDL_systimer.c
--- SDL2-2.32.8/src/timer/morphos/SDL_systimer.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/timer/morphos/SDL_systimer.c	2025-07-27 14:24:17.884841354 +0000
@@ -0,0 +1,119 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#if defined(SDL_TIMER_MORPHOS) && !defined(SDL_TIMERS_DISABLED)
+
+#include "SDL_timer.h"
+
+#include <exec/execbase.h>
+#include <proto/exec.h>
+#include <proto/timer.h>
+
+extern struct timerequest GlobalTimeReq;
+
+static SDL_bool ticks_started = SDL_FALSE;
+static struct timeval basetime;
+
+void
+SDL_TicksInit(void)
+{
+	if (ticks_started)
+		return;
+
+	ticks_started = SDL_TRUE;
+	GetSysTime(&basetime);
+}
+
+void
+SDL_TicksQuit(void)
+{
+	ticks_started = SDL_FALSE;
+}
+
+Uint64
+SDL_GetTicks64(void)
+{
+	struct timeval tv;
+
+	if (!ticks_started)
+		SDL_TicksInit();
+
+	GetSysTime(&tv);
+
+	if (basetime.tv_micro > tv.tv_micro) {
+		tv.tv_secs--;
+		tv.tv_micro += 1000000;
+	}
+
+	return (Uint64)((tv.tv_secs - basetime.tv_secs) * 1000) + ((tv.tv_micro - basetime.tv_micro)/1000);
+}
+
+Uint64
+SDL_GetPerformanceCounter(void)
+{
+	Uint64 val = 0;
+#if !defined(__AROS__)
+	ReadCPUClock(&val);
+#endif
+	return val;
+}
+
+Uint64
+SDL_GetPerformanceFrequency(void)
+{
+	Uint64 ret = 0;
+#if !defined(__AROS__)
+	Uint64 val;
+	ret = ReadCPUClock(&val);
+#endif
+	return ret;
+}
+
+void
+InitQPort(struct MsgPort *port)
+{
+	port->mp_SigBit = SIGB_SINGLE;
+	port->mp_Flags = PA_SIGNAL;
+	port->mp_SigTask = SysBase->ThisTask;
+	NEWLIST(&port->mp_MsgList);
+}
+
+void
+SDL_Delay(Uint32 ms)
+{
+	struct timerequest req;
+	struct MsgPort port;
+
+	InitQPort(&port);
+
+	req.tr_node.io_Message.mn_Node.ln_Type = 0;
+	req.tr_node.io_Message.mn_ReplyPort = &port;
+	req.tr_node.io_Device = GlobalTimeReq.tr_node.io_Device;
+	req.tr_node.io_Unit = GlobalTimeReq.tr_node.io_Unit;
+	req.tr_node.io_Command = TR_ADDREQUEST;
+	req.tr_time.tv_secs = ms / 1000;
+	req.tr_time.tv_micro = (ms % 1000) * 1000;
+
+	DoIO((struct IORequest *)&req);
+}
+
+#endif /* SDL_TIMER_MORPHOS || SDL_TIMERS_DISABLED */
diff -ruN SDL2-2.32.8/src/video/aros/SDL_arosclipboard.c SDL2-2.32.8.aros/src/video/aros/SDL_arosclipboard.c
--- SDL2-2.32.8/src/video/aros/SDL_arosclipboard.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/video/aros/SDL_arosclipboard.c	2025-07-28 19:08:18.853965975 +0000
@@ -0,0 +1,284 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+//#define DEBUG 1
+#include <aros/debug.h>
+
+#include "../../SDL_internal.h"
+
+#include "../SDL_sysvideo.h"
+#include "../../core/morphos/SDL_misc.h"
+
+#include <devices/clipboard.h>
+#if !defined(__AROS__)
+#include <libraries/charsets.h>
+#endif
+#include <proto/exec.h>
+#include <proto/iffparse.h>
+
+#if defined(__AROS__)
+#include <string.h>
+#endif
+
+#define ID_FTXT	MAKE_ID('F','T','X','T')
+#define ID_CHRS	MAKE_ID('C','H','R','S')
+#define ID_UTF8	MAKE_ID('U','T','F','8')
+
+STATIC APTR clipboard_open(void)
+{
+	struct IOClipReq *io;
+	struct MsgPort *mp;
+
+	mp = CreateMsgPort();
+
+	if ((io = (struct IOClipReq *)CreateIORequest(mp,sizeof(struct IOClipReq)))) {
+		if (!(OpenDevice("clipboard.device", 0, (struct IORequest *)io, 0))) {
+			return io;
+		}
+
+		DeleteIORequest((struct IORequest *)io);
+	}
+
+	DeleteMsgPort(mp);
+	return NULL;
+}
+
+STATIC ULONG clipboard_write_data(struct IOClipReq *io, CONST_APTR data, ULONG len)
+{
+	LONG rc;
+
+	io->io_Command = CMD_WRITE;
+	io->io_Data    = (APTR)data;
+	io->io_Length  = len;
+	DoIO( (struct IORequest *)io);
+
+	if (io->io_Actual != len) {
+		io->io_Error = 1;
+	}
+
+	rc = io->io_Error ? FALSE : TRUE;
+	return rc;
+}
+
+
+STATIC VOID clipboard_pad_text(struct IOClipReq *io, ULONG textlen)
+{
+	if (textlen & 1)
+		clipboard_write_data(io, "", 1);
+}
+
+
+STATIC ULONG clipboard_write_header_and_text(struct IOClipReq *io, CONST_STRPTR string, ULONG slen, ULONG ulen)
+{
+	ULONG rc;
+
+	struct
+	{
+		ULONG form;
+		ULONG totalsize;
+		ULONG ftxt;
+		ULONG type;
+		ULONG strlen;
+	} iffheader;
+
+	io->io_Offset = 0;
+	io->io_Error  = 0;
+//	io->io_ClipID = 0;
+
+	iffheader.form      = ID_FORM;
+	iffheader.totalsize = (slen & 1 ? slen + 1 : slen) + (ulen & 1 ? ulen + 1 : ulen) + 12 + 8;
+	iffheader.ftxt      = ID_FTXT;
+	iffheader.type      = ID_CHRS;
+	iffheader.strlen    = slen;
+
+	rc = FALSE;
+
+	if (clipboard_write_data(io, &iffheader, sizeof(iffheader))) {
+		if (clipboard_write_data(io, string, slen)) {
+			clipboard_pad_text(io, slen);
+			rc = TRUE;
+		}
+	}
+
+	return rc;
+}
+
+
+STATIC ULONG clipboard_write_utf8(struct IOClipReq *io, CONST_STRPTR utext, ULONG ulen)
+{
+	ULONG rc;
+
+	struct
+	{
+		ULONG type;
+		ULONG strlen;
+	} utf8_header;
+
+	/* FIXME: For correct operation we should also store font name. Used font
+	 * is relevant with guides written in Japanese for example.
+	 */
+
+	utf8_header.type   = ID_UTF8;
+	utf8_header.strlen = ulen;
+
+	rc = FALSE;
+
+	if (clipboard_write_data(io, &utf8_header, sizeof(utf8_header))) {
+		if (clipboard_write_data(io, utext, ulen)) {
+			clipboard_pad_text(io, ulen);
+			rc = TRUE;
+		}
+	}
+
+	return rc;
+}
+
+STATIC VOID clipboard_finalize(struct IOClipReq *io)
+{
+	io->io_Command = CMD_UPDATE;
+	DoIO((struct IORequest *)io);
+}
+
+STATIC void clipboard_close(struct IOClipReq *io)
+{
+	if (io) {
+		struct MsgPort *mp = io->io_Message.mn_ReplyPort;
+
+		CloseDevice((struct IORequest *)io);
+		DeleteIORequest((struct IORequest *)io);
+		DeleteMsgPort(mp);
+	}
+}
+
+int
+AROS_SetClipboardText(_THIS, const char *text)
+{
+	APTR ctx;
+	int rc = -1;
+
+	if ((ctx = clipboard_open())) {
+		char *stext = NULL;
+		
+#if !defined(__AROS__)
+		stext = AROS_ConvertText(text, MIBENUM_UTF_8, MIBENUM_SYSTEM);
+#endif
+
+		if (stext) {
+			int ulen = strlen(text);
+
+			if (clipboard_write_header_and_text(ctx, stext, strlen(stext), ulen)) {
+				if (clipboard_write_utf8(ctx, text, ulen))
+					rc = 0;
+			}
+
+			SDL_free(stext);
+			clipboard_finalize(ctx);
+		}
+		
+		clipboard_close(ctx);
+	}
+
+	return rc;
+}
+
+char *
+AROS_GetClipboardText(_THIS)
+{
+	struct IFFHandle *clip = AllocIFF();
+	char *text = NULL;
+
+	if (clip) {
+		clip->iff_Stream = (IPTR)OpenClipboard(0);
+
+		if (clip->iff_Stream) {
+			InitIFFasClip(clip);
+
+			if (!OpenIFF(clip, IFFF_READ)) {
+				if (!StopChunk(clip, ID_FTXT, ID_CHRS) && !StopChunk(clip, ID_FTXT, ID_UTF8)) {
+					BOOL done = FALSE;
+
+					while (done == FALSE && !ParseIFF(clip, IFFPARSE_SCAN)) {
+						struct ContextNode *cn = CurrentChunk(clip);
+
+						if (cn) {
+							LONG size = cn->cn_Size;
+
+							if (cn->cn_Type == ID_FTXT && size > 0) {
+								if (cn->cn_ID == ID_CHRS && !text) {
+									char *tmp = SDL_malloc(size + 1);
+
+									if (tmp) {
+										ReadChunkBytes(clip, tmp, size);
+										tmp[size] = '\0';
+#if !defined(__AROS__)
+										text = AROS_ConvertText(tmp, MIBENUM_SYSTEM, MIBENUM_UTF_8);
+#else
+										strcpy(text,tmp);
+#endif
+										SDL_free(tmp);
+									}
+								}
+								else if (cn->cn_ID == ID_UTF8) {
+									if (text)
+										SDL_free(text);
+
+									if ((text = SDL_malloc(size + 1))) {
+										ReadChunkBytes(clip, text, size);
+										text[size] = '\0';
+										done = TRUE;
+										break;
+									}
+								}
+							}
+						}
+					}
+				}
+
+				CloseIFF(clip);
+			}
+
+			CloseClipboard((struct ClipboardHandle *)clip->iff_Stream);
+		}
+
+		FreeIFF(clip);
+	}
+
+	if (text == NULL) {
+		if ((text = SDL_malloc(1)))
+			text[0] = '\0';
+	}
+
+	return text;
+}
+
+SDL_bool
+AROS_HasClipboardText(_THIS)
+{
+	SDL_bool result = SDL_FALSE;
+	char *text = AROS_GetClipboardText(_this);
+
+	if (text) {
+		result = text[0] != '\0' ? SDL_TRUE : SDL_FALSE;
+		SDL_free(text);
+	}
+
+	return result;
+}
diff -ruN SDL2-2.32.8/src/video/aros/SDL_arosclipboard.h SDL2-2.32.8.aros/src/video/aros/SDL_arosclipboard.h
--- SDL2-2.32.8/src/video/aros/SDL_arosclipboard.h	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/video/aros/SDL_arosclipboard.h	2025-07-28 18:29:11.840824792 +0000
@@ -0,0 +1,30 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifndef _SDL_arosclipboard_h
+#define _SDL_arosclipboard_h
+
+extern int AROS_SetClipboardText(_THIS, const char *text);
+extern char *AROS_GetClipboardText(_THIS);
+extern SDL_bool AROS_HasClipboardText(_THIS);
+
+#endif /* _SDL_arosclipboard_h */
diff -ruN SDL2-2.32.8/src/video/aros/SDL_arosevents.c SDL2-2.32.8.aros/src/video/aros/SDL_arosevents.c
--- SDL2-2.32.8/src/video/aros/SDL_arosevents.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/video/aros/SDL_arosevents.c	2025-07-28 21:11:41.798896722 +0000
@@ -0,0 +1,787 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+//#define DEBUG 1
+#include <aros/debug.h>
+
+#include "../../SDL_internal.h"
+
+#include "SDL_scancode.h"
+#include "../SDL_sysvideo.h"
+#include "../../events/SDL_events_c.h"
+#include "../../events/SDL_mouse_c.h"
+#include "../../events/scancodes_morphos.h"
+
+#include "SDL_arosvideo.h"
+#include "SDL_aroswindow.h"
+#include "SDL_arosopengl.h"
+#include "SDL_arosmouse.h"
+
+#include "SDL_timer.h"
+#include "SDL_syswm.h"
+#include "SDL.h"
+
+#include <devices/rawkeycodes.h>
+#include <intuition/extensions.h>
+#if !defined(__AROS__)
+#include <intuition/intuimessageclass.h>
+#include <libraries/screennotify.h>
+#endif
+#include <rexx/errors.h>
+#include <rexx/storage.h>
+#include <workbench/workbench.h>
+#include <workbench/startup.h>
+#if !defined(__AROS__)
+#include <exec/system.h>
+#endif
+
+#include <libraries/gadtools.h>
+
+#include <proto/dos.h>
+#include <proto/alib.h>
+#include <proto/commodities.h>
+#include <proto/exec.h>
+#include <proto/intuition.h>
+#include <proto/keymap.h>
+#include <proto/locale.h>
+
+#include <string.h>
+#include <stdio.h>
+
+#define GLCTX_PTR    __AGLCtx
+extern 	GLAContext *__AGLCtx;
+
+void AHI_Mute(ULONG mute);
+extern AROS_GlobalMouseState globalMouseState;
+
+static int
+AROS_GetButton(int code)
+{
+    switch (code & ~IECODE_UP_PREFIX) {
+        case IECODE_LBUTTON:
+            return SDL_BUTTON_LEFT;
+        case IECODE_RBUTTON:
+            return SDL_BUTTON_RIGHT;
+        case IECODE_MBUTTON:
+            return SDL_BUTTON_MIDDLE;
+        default:
+            return 0;
+    }
+}
+
+static void
+AROS_DispatchMouseButtons(_THIS, struct IntuiMessage *m, const SDL_WindowData *data)
+{
+    SDL_WindowData *sdlwin = (SDL_WindowData *)m->IDCMPWindow->UserData;
+
+    if (sdlwin) {
+        int state = (m->Code & IECODE_UP_PREFIX) ? SDL_RELEASED : SDL_PRESSED;
+        int button = AROS_GetButton(m->Code & ~(IECODE_UP_PREFIX));
+
+        globalMouseState.buttonPressed[button] = state;
+
+        SDL_SendMouseButton(data->window, 0, state, button);
+    }
+
+}
+
+static int
+AROS_TranslateUnicode(struct IntuiMessage *m, char *buffer)
+{
+	int length = 0;
+#if !defined(__AROS__)
+    WCHAR keycode = getv(m, IMSGA_UCS4);
+	length = UTF8_Encode(keycode, buffer);
+#endif
+	return length;
+}
+
+static void
+AROS_DispatchRawKey(_THIS, struct IntuiMessage *m, const SDL_WindowData *data)
+{
+	
+	UWORD code = m->Code;
+	UWORD rawkey = m->Code & 0x7F;
+
+	switch (code) {
+		case RAWKEY_NM_WHEEL_UP:
+			SDL_SendMouseWheel(data->window, 0, 0, 1, SDL_MOUSEWHEEL_NORMAL);
+			break;
+
+		case RAWKEY_NM_WHEEL_DOWN:
+			SDL_SendMouseWheel(data->window, 0, 0, -1, SDL_MOUSEWHEEL_NORMAL);
+			break;
+
+		case RAWKEY_NM_WHEEL_LEFT:
+			SDL_SendMouseWheel(data->window, 0, -1, 0, SDL_MOUSEWHEEL_NORMAL);
+			break;
+
+		case RAWKEY_NM_WHEEL_RIGHT:
+			SDL_SendMouseWheel(data->window, 0, 1, 0,  SDL_MOUSEWHEEL_NORMAL);
+			break;
+
+		case RAWKEY_NM_BUTTON_FOURTH:
+		    globalMouseState.buttonPressed[SDL_BUTTON_X1] = SDL_PRESSED;;
+			SDL_SendMouseButton(data->window, 0, SDL_PRESSED, SDL_BUTTON_X1);
+			break;
+
+		case RAWKEY_NM_BUTTON_FOURTH | IECODE_UP_PREFIX:
+			globalMouseState.buttonPressed[SDL_BUTTON_X1] = SDL_RELEASED;
+			SDL_SendMouseButton(data->window, 0, SDL_RELEASED, SDL_BUTTON_X1);
+			break;
+
+		default:
+			if (rawkey < sizeof(morphos_scancode_table) / sizeof(morphos_scancode_table[0])) {
+                SDL_Scancode s = morphos_scancode_table[rawkey];
+                if (m->Code < 128) {
+                    char text[5] = { 0 };
+					int length = AROS_TranslateUnicode(m, text);
+					SDL_SendKeyboardKey(SDL_PRESSED, s);
+					if (length > 0) {
+						text[length] = '\0';
+						SDL_SendKeyboardText(text);
+					}
+				} else {
+					SDL_SendKeyboardKey(SDL_RELEASED, s);
+				}
+			}
+			break;
+	}
+}
+
+static void
+AROS_MouseMove(_THIS, struct IntuiMessage *m, SDL_WindowData *data)
+{
+    struct Screen *s = data->win->WScreen;
+
+    //D(bug("[SDL2:arosevt] %s: X:%d Y:%d, ScreenX: %d ScreenY: %d\n", __func__, m->MouseX, m->MouseY, s->MouseX, s->MouseY);
+    globalMouseState.x = s->MouseX;
+    globalMouseState.y = s->MouseY;
+
+    if (SDL_GetRelativeMouseMode()) {
+        if (data->first_deltamove) {
+            data->first_deltamove = 0;
+            return;
+        }
+        SDL_SendMouseMotion(data->window, 0, 1, m->MouseX, m->MouseY);
+    } else {
+    	//struct Screen *s = data->win->WScreen;
+        int x = (s->MouseX - data->win->LeftEdge - data->win->BorderLeft);
+        int y = (s->MouseY - data->win->TopEdge - data->win->BorderTop);
+        SDL_SendMouseMotion(data->window, 0, 0, x, y);
+    }
+}
+
+static void
+AROS_HandleActivation(_THIS, struct IntuiMessage *m, SDL_bool activated)
+{
+	D(bug("[SDL2:arosevt] %s()\n", __func__));
+
+	SDL_WindowData *data = (SDL_WindowData *)m->IDCMPWindow->UserData;
+    if (data) {
+        if (data->window) {
+            if (activated) {
+
+                SDL_SendWindowEvent(data->window, SDL_WINDOWEVENT_SHOWN, 0, 0);
+                if (SDL_GetKeyboardFocus() != data->window)
+                    SDL_SetKeyboardFocus(data->window);
+
+                SDL_SetMouseFocus(data->window);
+                AROS_MouseMove(_this, m, data);
+
+            } else {
+                if (SDL_GetKeyboardFocus() == data->window)
+                    SDL_SetKeyboardFocus(NULL);
+                if (SDL_GetMouseFocus() == data->window)
+                    SDL_SetMouseFocus(NULL);
+            }
+        }
+    }
+}
+
+static void
+AROS_ChangeWindow(_THIS, const struct IntuiMessage *m, SDL_WindowData *data)
+{
+	struct Window *w = data->win;
+
+	D(bug("[SDL2:arosevt] %s()\n", __func__));
+
+	if (data->curr_x != w->LeftEdge || data->curr_h != w->TopEdge) {
+		data->curr_x = w->LeftEdge;
+		data->curr_y = w->TopEdge;
+		SDL_SendWindowEvent(data->window, SDL_WINDOWEVENT_MOVED, data->curr_x, data->curr_y);
+	}
+
+	if (data->curr_w != w->Width || data->curr_h != w->Height) {
+		data->curr_w = w->Width;
+		data->curr_h = w->Height;
+		SDL_SendWindowEvent(data->window, SDL_WINDOWEVENT_RESIZED, (data->curr_w - w->BorderLeft - w->BorderRight), (data->curr_h - w->BorderTop - w->BorderBottom));
+		if (GLCTX_PTR)
+        {
+            AROS_GL_ResizeContext(_this, data->window);
+        }
+	}
+}
+
+static void AROS_GadgetEvent(_THIS, const struct IntuiMessage *m)
+{
+	D(bug("[SDL2:arosevt] %s()\n", __func__));
+
+	switch (((struct Gadget *)m->IAddress)->GadgetID) {
+		case ETI_Iconify:
+			AROS_HideApp(_this, TRUE);
+			break;
+		case ETI_Jump:
+			D(bug("[SDL2:arosevt] %s: ETI_JUMP\n", __func__));
+			//SDL_WindowData *data = (SDL_WindowData *)m->IDCMPWindow->UserData;
+			//SDL_SetWindowFullscreen(data->window, data->winflags);
+			break;
+	}
+}
+
+static const char porters[] = "Kalamatee (kalamatee@gmail.com), based on the morphos port\n";
+static const char bases[] = "SDL 2.32.8 sources by Ilkka Lehtoranta";
+
+static void
+AROS_AboutSDL(struct Window *window)
+{
+	struct EasyStruct es;
+	es.es_StructSize   = sizeof(struct EasyStruct);
+	es.es_Flags        = 0;
+	es.es_Title        = "SDL2";
+
+	es.es_TextFormat   = "SDL %ld.%ld.%ld -AROS-\nCompiled on " ADATE "\n\nSimple DirectMedia Layer is cross-platform development library designed to\nprovide low level access audio, keyboard, mouse, joysticks, and graphics hardware.\n\nSDL 2.0 is distributed under zlib license.\nThis license allows you to use SDL freely in any software.\n\nPorters:\n%s\nBased on %s\n\nwww.libsdl.org";
+	es.es_GadgetFormat = "Ok";
+
+	EasyRequest(window, &es, NULL, SDL_MAJOR_VERSION, SDL_MINOR_VERSION, SDL_PATCHLEVEL, (IPTR)porters, (IPTR)bases);
+}
+
+static void
+AROS_AboutSystem(struct Window *window)
+{
+	struct EasyStruct es;
+	es.es_StructSize   = sizeof(struct EasyStruct);
+	es.es_Flags        = 0;
+	es.es_Title        = "About System";
+	es.es_TextFormat   = "System: %s - Vendor: %s\n";
+	es.es_GadgetFormat = "Ok";
+
+	char System[256];
+	char Vendor[256];
+
+#if !defined(__AROS__)
+	NewGetSystemAttrs(&System,sizeof(System),SYSTEMINFOTYPE_SYSTEM,TAG_DONE);
+	NewGetSystemAttrs(&Vendor,sizeof(Vendor),SYSTEMINFOTYPE_VENDOR,TAG_DONE);
+	EasyRequest(window, &es, NULL, System, Vendor, ((HasAltiVec)?"Yes":"No"));
+#else
+    EasyRequest(window, &es, NULL, System, Vendor);
+#endif
+}
+
+static void
+AROS_Joystick(struct Window *window)
+{
+	char text1[2000] = "";
+	char text2[254] = "";
+	int i;
+    int controller_count = 0;
+    char guid[64];
+	
+	SDL_InitSubSystem(SDL_INIT_JOYSTICK | SDL_INIT_GAMECONTROLLER);
+	
+	for (i = 0; i < SDL_NumJoysticks(); ++i) {
+    	const char *name;
+		char text[254] = "";
+		SDL_JoystickGetGUIDString(SDL_JoystickGetDeviceGUID(i), guid, sizeof (guid));
+		SDL_Joystick *joystick = SDL_JoystickOpen(i);
+        if (joystick != NULL) {		
+			if (SDL_IsGameController(i)) {
+				controller_count++;
+				name = SDL_GameControllerNameForIndex(i);
+			} else {
+				name = SDL_JoystickNameForIndex(i);	
+			}			
+		
+			snprintf(text, sizeof(text), "%d: %s (guid %s, VID 0x%.4x, PID 0x%.4x, player index = %d)\n",
+				i, name ? name : "Unknown", guid,
+			SDL_JoystickGetDeviceVendor(i), SDL_JoystickGetDeviceProduct(i), SDL_JoystickGetDevicePlayerIndex(i));
+			strcat(text1, text);
+			snprintf(text, sizeof(text),"    Joystick has %d axes, %d hats, %d balls, and %d buttons\n",
+			SDL_JoystickNumAxes(joystick), SDL_JoystickNumHats(joystick),
+			SDL_JoystickNumBalls(joystick), SDL_JoystickNumButtons(joystick));
+			strcat(text1, text);
+			SDL_JoystickClose(joystick);
+		}
+	}
+	
+	snprintf(text2, sizeof(text2),"There are %d game controller(s) attached (%d joystick(s))\n", controller_count, SDL_NumJoysticks());
+	struct EasyStruct es;
+	es.es_StructSize   = sizeof(struct EasyStruct);
+	es.es_Flags        = 0;
+	es.es_Title        = "SDL2 Joystick/GameController";
+	es.es_TextFormat   = "SDL %ld.%ld.%ld -AROS-\n\n%s\n%s";
+	es.es_GadgetFormat = "Ok";
+
+	EasyRequest(window, &es, NULL, SDL_MAJOR_VERSION, SDL_MINOR_VERSION, SDL_PATCHLEVEL, (IPTR)text2, (IPTR)text1);
+}
+
+static int 
+AROS_setenv(const char *name, const char *value, int overwrite)
+{
+	char dummy[2];
+	if (!name || SDL_strlen(name) == 0 || SDL_strchr(name, '=') != NULL || !value) {
+		return (-1);
+	}
+
+	if (!overwrite && GetVar(name, dummy, sizeof(dummy), GVF_GLOBAL_ONLY) != -1) {
+		return 0;
+	}
+	
+	if (SDL_strlen(value) > 0)
+	{		
+		if (!SetVar(name, value, -1, LV_VAR | GVF_GLOBAL_ONLY | GVF_SAVE_VAR)) 
+			return -1;
+	
+	} else {
+		DeleteVar(name, LV_VAR | GVF_GLOBAL_ONLY | GVF_SAVE_VAR);
+	}
+
+	return 0;
+}
+
+static void
+AROS_Priority(ULONG prio)
+{
+	SDL_ThreadPriority Priority = prio ? SDL_THREAD_PRIORITY_LOW : SDL_THREAD_PRIORITY_NORMAL;
+	SDL_SetThreadPriority(Priority);
+	AROS_setenv("SDL_THREAD_PRIORITY_POLICY", (prio ? "-1" : "0"), SDL_TRUE);
+}
+
+void 
+AROS_GlobalMenu(struct Menu * mymenu, UWORD menu, UWORD item, UWORD sub, UWORD check)
+{
+	struct MenuItem *subitem;
+	subitem = ItemAddress(mymenu, FULLMENUNUM(menu, item, sub));
+	if (subitem) {
+		if (check)
+			subitem->Flags |= CHECKED;
+		else
+			subitem->Flags &= ~CHECKED;
+	}
+}
+
+static void
+AROS_HandleMenu(_THIS, struct IntuiMessage *m)
+{
+    SDL_WindowData *data = (SDL_WindowData *)m->IDCMPWindow->UserData;
+    if (data->win) {
+        if (data->menu) {
+            struct MenuItem *item = ItemAddress(data->menu, m->Code);
+            if (item) {
+                switch ((IPTR)GTMENUITEM_USERDATA(item)) {
+                case MID_ABOUT:
+                    AROS_AboutSDL(data->win);
+                    break;
+                case MID_QUIT:
+                    SDL_SendWindowEvent(data->window, SDL_WINDOWEVENT_CLOSE, 0, 0);
+                    break;
+                case MID_HIDE:
+                    AROS_HideApp(_this, TRUE);
+                    break;
+                case MID_MUTE:
+                    AHI_Mute(item->Flags & CHECKED);
+                    break;
+                case MID_PRIORITY:
+                    AROS_Priority(item->Flags & CHECKED);
+                    break;
+                case MID_RRAUTO:
+                    AROS_GlobalMenu(data->menu, 1, 3, 1, 0);
+                    AROS_GlobalMenu(data->menu, 1, 3, 2, 0);
+                    SDL_SetHint(SDL_HINT_RENDER_DRIVER, "");
+                    AROS_setenv("SDL_RENDER_DRIVER", "", SDL_TRUE);
+                    break;
+                case MID_RRGL:
+                    AROS_GlobalMenu(data->menu, 1, 3, 0, 0);
+                    AROS_GlobalMenu(data->menu, 1, 3, 2, 0);
+                    SDL_SetHint(SDL_HINT_RENDER_DRIVER, "opengl");
+                    AROS_setenv("SDL_RENDER_DRIVER", "opengl", SDL_TRUE);
+                    break;
+                case MID_RRSOFT:
+                    AROS_GlobalMenu(data->menu, 1, 3, 0, 0);
+                    AROS_GlobalMenu(data->menu, 1, 3, 1, 0);
+                    SDL_SetHint(SDL_HINT_RENDER_DRIVER, "software");
+                    AROS_setenv("SDL_RENDER_DRIVER", "software", SDL_TRUE);
+                    break;
+                case MID_RVAUTO:
+                    AROS_GlobalMenu(data->menu, 1, 4, 1, 0);
+                    AROS_GlobalMenu(data->menu, 1, 4, 2, 0);
+                    SDL_SetHint(SDL_HINT_RENDER_VSYNC, "");
+                    AROS_setenv("SDL_RENDER_VSYNC", "", SDL_TRUE);
+                    break;
+                case MID_RVENABLE:
+                    AROS_GlobalMenu(data->menu, 1, 4, 0, 0);
+                    AROS_GlobalMenu(data->menu, 1, 4, 2, 0);
+                    SDL_SetHint(SDL_HINT_RENDER_VSYNC, "1");
+                    AROS_setenv("SDL_RENDER_VSYNC", "1", SDL_TRUE);
+                    break;
+                case MID_RVDISABLE:
+                    AROS_GlobalMenu(data->menu, 1, 4, 0, 0);
+                    AROS_GlobalMenu(data->menu, 1, 4, 1, 0);
+                    SDL_SetHint(SDL_HINT_RENDER_VSYNC, "0");
+                    AROS_setenv("SDL_RENDER_VSYNC", "0", SDL_TRUE);
+                    break;
+                case MID_AUTO:
+                    AROS_GlobalMenu(data->menu, 1, 5, 1, 0);
+                    AROS_GlobalMenu(data->menu, 1, 5, 2, 0);
+                    SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "");
+                    AROS_setenv("SDL_RENDER_SCALE_QUALITY", "", SDL_TRUE);
+                    break;
+                case MID_NEAREST:
+                    AROS_GlobalMenu(data->menu, 1, 5, 0, 0);
+                    AROS_GlobalMenu(data->menu, 1, 5, 2, 0);
+                    SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "nearest");
+                    AROS_setenv("SDL_RENDER_SCALE_QUALITY", "nearest", SDL_TRUE);
+                    break;
+                case MID_LINEAR:
+                    AROS_GlobalMenu(data->menu, 1, 5, 0, 0);
+                    AROS_GlobalMenu(data->menu, 1, 5, 1, 0);
+                    SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "linear");
+                    AROS_setenv("SDL_RENDER_SCALE_QUALITY", "linear", SDL_TRUE);
+                    break;
+                case MID_LAUTO:
+                    AROS_GlobalMenu(data->menu, 1, 6, 1, 0);
+                    AROS_GlobalMenu(data->menu, 1, 6, 2, 0);
+                    SDL_SetHint(SDL_HINT_RENDER_LOGICAL_SIZE_MODE, "");
+                    AROS_setenv("SDL_RENDER_LOGICAL_SIZE_MODE", "", SDL_TRUE);
+                    break;
+                case MID_LLETTER:
+                    AROS_GlobalMenu(data->menu, 1, 6, 0, 0);
+                    AROS_GlobalMenu(data->menu, 1, 6, 2, 0);
+                    SDL_SetHint(SDL_HINT_RENDER_LOGICAL_SIZE_MODE, "0");
+                    AROS_setenv("SDL_RENDER_LOGICAL_SIZE_MODE", "0", SDL_TRUE);
+                    break;
+                case MID_LOVERS:
+                    AROS_GlobalMenu(data->menu, 1, 6, 0, 0);
+                    AROS_GlobalMenu(data->menu, 1, 6, 1, 0);
+                    SDL_SetHint(SDL_HINT_RENDER_LOGICAL_SIZE_MODE, "1");
+                    AROS_setenv("SDL_RENDER_LOGICAL_SIZE_MODE", "1", SDL_TRUE);
+                    break;
+                case MID_BAUTO:
+                    AROS_GlobalMenu(data->menu, 1, 7, 1, 0);
+                    AROS_GlobalMenu(data->menu, 1, 7, 2, 0);
+                    SDL_SetHint(SDL_HINT_RENDER_BATCHING, "");
+                    AROS_setenv("SDL_RENDER_BATCHING", "", SDL_TRUE);
+                    break;
+                case MID_BENABLE:
+                    AROS_GlobalMenu(data->menu, 1, 7, 0, 0);
+                    AROS_GlobalMenu(data->menu, 1, 7, 2, 0);
+                    SDL_SetHint(SDL_HINT_RENDER_BATCHING, "0");
+                    AROS_setenv("SDL_RENDER_BATCHING", "0", SDL_TRUE);
+                    break;
+                case MID_BDISABLE:
+                    AROS_GlobalMenu(data->menu, 1, 7, 0, 0);
+                    AROS_GlobalMenu(data->menu, 1, 7, 1, 0);
+                    SDL_SetHint(SDL_HINT_RENDER_BATCHING, "1");
+                    AROS_setenv("SDL_RENDER_BATCHING", "1", SDL_TRUE);
+                    break;
+                case MID_MDEF:
+                    AROS_GlobalMenu(data->menu, 1, 8, 1, 0);
+                    AROS_GlobalMenu(data->menu, 1, 8, 2, 0);
+                    AROS_GlobalMenu(data->menu, 1, 8, 3, 0);
+                    SDL_SetHint(SDL_HINT_RENDER_LINE_METHOD, "");
+                    AROS_setenv("SDL_RENDER_LINE_METHOD", "", SDL_TRUE);
+                    break;
+                case MID_MPOINT:
+                    AROS_GlobalMenu(data->menu, 1, 8, 0, 0);
+                    AROS_GlobalMenu(data->menu, 1, 8, 2, 0);
+                    AROS_GlobalMenu(data->menu, 1, 8, 3, 0);
+                    SDL_SetHint(SDL_HINT_RENDER_LINE_METHOD, "1");
+                    AROS_setenv("SDL_RENDER_LINE_METHOD", "1", SDL_TRUE);
+                    break;
+                case MID_MLINE:
+                    AROS_GlobalMenu(data->menu, 1, 8, 0, 0);
+                    AROS_GlobalMenu(data->menu, 1, 8, 1, 0);
+                    AROS_GlobalMenu(data->menu, 1, 8, 3, 0);
+                    SDL_SetHint(SDL_HINT_RENDER_LINE_METHOD, "2");
+                    AROS_setenv("SDL_RENDER_LINE_METHOD", "2", SDL_TRUE);
+                    break;
+                case MID_MGEO:
+                    AROS_GlobalMenu(data->menu, 1, 8, 0, 0);
+                    AROS_GlobalMenu(data->menu, 1, 8, 1, 0);
+                    AROS_GlobalMenu(data->menu, 1, 8, 2, 0);
+                    SDL_SetHint(SDL_HINT_RENDER_LINE_METHOD, "3");
+                    AROS_setenv("SDL_RENDER_LINE_METHOD", "3", SDL_TRUE);
+                    break;
+                case MID_SHADERS_AUTO:
+                    AROS_GlobalMenu(data->menu, 1, 9, 1, 0);
+                    AROS_GlobalMenu(data->menu, 1, 9, 2, 0);
+                    SDL_SetHint(SDL_HINT_RENDER_BATCHING, "");
+                    AROS_setenv("SDL_RENDER_OPENGL_SHADERS", "", SDL_TRUE);
+                    break;
+                case MID_SHADERS_ENABLE:
+                    AROS_GlobalMenu(data->menu, 1, 9, 0, 0);
+                    AROS_GlobalMenu(data->menu, 1, 9, 2, 0);
+                    SDL_SetHint(SDL_HINT_RENDER_OPENGL_SHADERS, "1");
+                    AROS_setenv("SDL_RENDER_OPENGL_SHADERS", "1", SDL_TRUE);
+                    break;
+                case MID_SHADERS_DISABLE:
+                    AROS_GlobalMenu(data->menu, 1, 9, 0, 0);
+                    AROS_GlobalMenu(data->menu, 1, 9, 1, 0);
+                    SDL_SetHint(SDL_HINT_RENDER_OPENGL_SHADERS, "0");
+                    AROS_setenv("SDL_RENDER_OPENGL_SHADERS", "0", SDL_TRUE);
+                    break;
+                case MID_JOYSTICK:
+                    AROS_Joystick(data->win);
+                    break;
+                case MID_ABOUTSYS:
+                    AROS_AboutSystem(data->win);
+                default:
+                    break;
+                }
+            }
+        }
+    }
+
+}
+
+static void
+AROS_DispatchEvent(_THIS, struct IntuiMessage *m)
+{
+    //D(bug("[SDL2:arosevt] %s: \n", __func__));
+    SDL_WindowData *data = (SDL_WindowData *)m->IDCMPWindow->UserData;
+
+    switch (m->Class) {
+    case IDCMP_MENUPICK:
+        AROS_HandleMenu(_this, m);
+        break;
+
+    case IDCMP_REFRESHWINDOW:
+        BeginRefresh(m->IDCMPWindow);
+        SDL_SendWindowEvent(data->window, SDL_WINDOWEVENT_EXPOSED, 0, 0);
+        EndRefresh(m->IDCMPWindow, TRUE);
+        break;
+
+    case IDCMP_CLOSEWINDOW:
+        SDL_SendWindowEvent(data->window, SDL_WINDOWEVENT_CLOSE, 0, 0);
+        break;
+
+    case IDCMP_MOUSEMOVE:
+        AROS_MouseMove(_this, m, data);
+        break;
+
+    case IDCMP_MOUSEBUTTONS:
+        AROS_DispatchMouseButtons(_this, m, data);
+        break;
+
+    case IDCMP_RAWKEY:
+        AROS_DispatchRawKey(_this, m, data);
+        break;
+
+    case IDCMP_ACTIVEWINDOW:
+        AROS_HandleActivation(_this, m, SDL_TRUE);
+        break;
+
+    case IDCMP_INACTIVEWINDOW:
+        AROS_HandleActivation(_this, m, SDL_FALSE);
+        break;
+
+    case IDCMP_CHANGEWINDOW:
+        AROS_ChangeWindow(_this, m, data);
+        break;
+
+    case IDCMP_GADGETUP:
+        AROS_GadgetEvent(_this, m);
+        break;
+
+    default:
+        break;
+    }
+}
+
+static void
+AROS_CheckBrokerMsg(_THIS)
+{
+	SDL_VideoData *data = (SDL_VideoData *) _this->driverdata;
+	CxMsg *msg;
+
+	while ((msg = (CxMsg *)GetMsg(&data->BrokerPort))) {
+		size_t id = CxMsgID(msg);
+		size_t tp = CxMsgType(msg);
+
+		D(bug("[SDL2:arosevt] %s: check CxMsg\n", __func__));
+
+		ReplyMsg((APTR)msg);
+
+		if (tp == CXM_COMMAND) {
+			switch (id) {
+				case CXCMD_KILL:
+					SDL_SendAppEvent(SDL_QUIT);
+					break;
+
+				case CXCMD_APPEAR:
+					AROS_ShowApp(_this);
+					break;
+
+				case CXCMD_DISAPPEAR:
+					AROS_HideApp(_this, TRUE);
+					break;
+			}
+		}
+	}
+}
+
+static void
+AROS_CheckScreenEvent(_THIS)
+{
+	SDL_VideoData *data = (SDL_VideoData *) _this->driverdata;
+
+#if !defined(__AROS__)
+	for (;;) {
+		struct ScreenNotifyMessage *snm;
+
+		while ((snm = (struct ScreenNotifyMessage *)GetMsg(&data->ScreenNotifyPort)) != NULL) {
+			D(bug("[SDL2:arosevt] %s: check ScreenNotifyMessage\n", __func__));
+
+			switch ((size_t)snm->snm_Value) {
+				case FALSE:
+					AROS_HideApp(_this, FALSE);
+					break;
+
+				case TRUE:
+					AROS_ShowApp(_this);
+					break;
+			}
+		}
+
+		if (data->WScreen)
+			break;
+
+		WaitPort(&data->ScreenNotifyPort);
+	}
+#endif
+}
+
+static void
+AROS_CheckWBEvents(_THIS)
+{
+	SDL_VideoData *data = (SDL_VideoData *) _this->driverdata;
+	struct AppMessage *msg;
+	
+	while ((msg = (struct AppMessage *)GetMsg(&data->WBPort)) != NULL) {
+		D(bug("[SDL2:arosevt] %s: check AppMessage\n", __func__));
+
+		switch (msg->am_Type) {
+			case AMTYPE_APPWINDOW: 
+				{
+				    SDL_Window *window = (SDL_Window *)msg->am_UserData;
+					char filename[1024];
+					struct WBArg *argptr = msg->am_ArgList;
+				    for (int i = 0; i < msg->am_NumArgs; i++) {
+						if (argptr->wa_Lock) {
+							NameFromLock(argptr->wa_Lock, filename, 1024);
+							AddPart(filename, argptr->wa_Name, 1024);
+
+							D(bug("[SDL2:arosevt] %s: SDL_SendDropfile : '%s'\n", __func__, filename));
+							SDL_SendDropFile(window, filename);
+							argptr++;
+						}
+					}
+					SDL_SendDropComplete(window);
+                    SDL_RaiseWindow(window);
+				}
+				break;
+			case AMTYPE_APPICON:
+				AROS_ShowApp(_this);
+				break;
+			default:
+				//D(bug("[SDL2:arosevt] %s: Unknown AppMsg %d %p\n", __func__, msg->am_Type, (APTR)msg->am_UserData));
+				break;
+		}
+
+	}
+}
+
+void
+AROS_PumpEvents(_THIS)
+{
+    SDL_VideoData *data = (SDL_VideoData *)_this->driverdata;
+    struct IntuiMessage *m;
+
+    BOOL check_mousecoord = FALSE;
+    size_t sigs = SetSignal(0, data->ScrNotifySig | data->BrokerSig | data->WBSig | data->WinSig | SIGBREAKF_CTRL_C);
+
+    if (sigs & data->WinSig) {
+        SDL_WindowData *wdata = NULL;
+        while ((m = (struct IntuiMessage *)GetMsg(&data->WinPort))) {
+            wdata = (SDL_WindowData *)m->IDCMPWindow->UserData;
+            if (m->Class == IDCMP_MOUSEMOVE && !SDL_GetRelativeMouseMode())
+                check_mousecoord = TRUE;
+
+            AROS_DispatchEvent(_this, m);
+            ReplyMsg((struct Message *)m);
+        }
+
+        if (wdata && check_mousecoord && wdata->win) {
+            struct Window *w = wdata->win;
+            struct Screen *s = w->WScreen;
+            if (s) {
+                LONG mx = s->MouseX;
+                LONG my = s->MouseY;
+                LONG ws = w->LeftEdge + w->BorderLeft;
+                LONG wy = w->TopEdge + w->BorderTop;
+                LONG wx2 = w->LeftEdge + w->Width - w->BorderRight;
+                LONG wy2 = w->TopEdge + w->Height - w->BorderBottom;
+                if (mx >= ws && my >= wy && mx <= wx2 && my <= wy2) {
+                    w->Flags |= WFLG_RMBTRAP;
+
+                    if (data->CurrentPointer) {
+                        if (!IS_SYSTEM_CURSOR(data->CurrentPointer)) {
+                            SDL_AROSCursor *ac = (SDL_AROSCursor *)data->CurrentPointer;
+                            if (ac->Pointer.mouseptr)
+                                SetWindowPointer(w, WA_Pointer, (size_t)ac->Pointer.mouseptr, TAG_DONE);
+                        }
+                    } else {
+#if !defined(__AROS__)
+                        size_t pointertags[] = { WA_PointerType, POINTERTYPE_INVISIBLE, TAG_DONE };
+                        SetAttrsA(w, (struct TagItem *)&pointertags);
+#endif
+                    }
+
+                } else {
+                    w->Flags &= ~WFLG_RMBTRAP;
+                    ClearPointer(w);
+                }
+            }
+        }
+    }
+
+    if (sigs & data->ScrNotifySig && data->ScreenNotifyHandle)
+        AROS_CheckScreenEvent(_this);
+
+    if (sigs & data->BrokerSig)
+        AROS_CheckBrokerMsg(_this);
+
+    if (sigs & data->WBSig)
+        AROS_CheckWBEvents(_this);
+
+    if (sigs & SIGBREAKF_CTRL_C)
+        SDL_SendAppEvent(SDL_QUIT);
+}
diff -ruN SDL2-2.32.8/src/video/aros/SDL_arosevents.h SDL2-2.32.8.aros/src/video/aros/SDL_arosevents.h
--- SDL2-2.32.8/src/video/aros/SDL_arosevents.h	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/video/aros/SDL_arosevents.h	2025-07-28 18:19:36.534462256 +0000
@@ -0,0 +1,29 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifndef _SDL_arosevents_h
+#define _SDL_arosevents_h
+
+extern void AROS_PumpEvents(_THIS);
+extern void AROS_GlobalMenu(struct Menu *mymenu, UWORD menu, UWORD item, UWORD sub, UWORD check);
+
+#endif /* _SDL_arosevents_h */
diff -ruN SDL2-2.32.8/src/video/aros/SDL_arosframebuffer.c SDL2-2.32.8.aros/src/video/aros/SDL_arosframebuffer.c
--- SDL2-2.32.8/src/video/aros/SDL_arosframebuffer.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/video/aros/SDL_arosframebuffer.c	2025-07-28 19:36:13.379395048 +0000
@@ -0,0 +1,127 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2025 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+//#define DEBUG 1
+#include <aros/debug.h>
+
+#include "../../SDL_internal.h"
+
+#include "SDL_arosvideo.h"
+
+#include <cybergraphx/cybergraphics.h>
+#include <intuition/intuition.h>
+#include <proto/cybergraphics.h>
+#include <graphics/rpattr.h>
+#include <proto/graphics.h>
+
+#ifndef MIN
+#   define MIN(x,y) ((x)<(y)?(x):(y))
+#endif
+
+
+void
+AROS_DestroyWindowFramebuffer(_THIS, SDL_Window * window)
+{
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+	if (data->bitmap) {
+        FreeBitMap(data->bitmap);
+        data->bitmap = NULL;
+    }
+}
+
+int
+AROS_CreateWindowFramebuffer(_THIS, SDL_Window * window, Uint32 * format,
+                            void ** pixels, int *pitch)
+{
+	D(bug("[SDL2:arosfb] %s()\n", __func__));
+
+	APTR lock;
+    APTR base_address;
+    Uint32 bytes_per_row;
+
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+    if (data->bitmap) {
+		D(bug("[SDL2:arosfb] %s: freeing existing bitmap @ 0x%p\n", __func__, data->bitmap));
+        FreeBitMap(data->bitmap);
+    }
+
+	if (!data->win) {
+		D(bug("[SDL2:arosfb] %s: ERROR: no window ptr\n", __func__));
+        return SDL_SetError("No system window");
+    }
+	
+    *format = SDL_PIXELFORMAT_BGRA8888;
+	struct BitMap * friend_bitmap = data->win->RPort->BitMap;
+	Uint32 depth =  GetBitMapAttr(friend_bitmap, BMA_DEPTH);
+	data->bitmap = AllocBitMap(window->w, window->h, depth, BMF_MINPLANES|BMF_CLEAR, friend_bitmap);
+	if (!data->bitmap) {
+		D(bug("[SDL2:arosfb] %s: ERROR: failed to allocate a bitmap\n", __func__));
+		return SDL_SetError("Failed to allocate bitmap for framebuffer");
+	} 
+		
+	D("[SDL2:arosfb] %s: Allocate bitmap %d x %d x %d for framebuffer\n", __FUNCTION__, window->w, window->h, depth);
+	lock = LockBitMapTags(
+        data->bitmap,
+        LBMI_BASEADDRESS, &base_address,
+        LBMI_BYTESPERROW, &bytes_per_row,
+        TAG_DONE);
+
+    if (lock) {
+        *pixels = base_address;
+        *pitch = bytes_per_row;
+
+        UnLockBitMap(lock);
+    } else {
+		D(bug("[SDL2:arosfb] %s: ERROR: failed to lock the bitmap\n", __func__));
+
+        FreeBitMap(data->bitmap);
+        data->bitmap = NULL;
+        return SDL_SetError("Failed to lock framebuffer bitmap");
+    }
+
+	D(bug("[SDL2:arosfb] %s: done\n", __func__));
+
+	return 0;
+}
+
+int
+AROS_UpdateWindowFramebuffer(_THIS, SDL_Window * window, const SDL_Rect * rects, int numrects)
+{
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+	if (data->bitmap && data->win) {
+		
+		const struct IBox windowBox = {
+                data->win->BorderLeft,
+                data->win->BorderTop,
+                data->win->Width - data->win->BorderLeft - data->win->BorderRight,
+                data->win->Height - data->win->BorderTop - data->win->BorderBottom };
+		
+		for (int i = 0; i < numrects; ++i) {
+            const SDL_Rect * r = &rects[i];
+			int dx = r->x + windowBox.Left;
+			int dy = r->y + windowBox.Top;
+		    int w =  MIN(r->w, windowBox.Width);
+			int h = MIN(r->h, windowBox.Height);
+			BltBitMapRastPort(data->bitmap,  r->x, r->y, data->win->RPort, dx, dy, w, h, 0xc0);
+		}
+	}
+	return 0;
+}
diff -ruN SDL2-2.32.8/src/video/aros/SDL_arosframebuffer.h SDL2-2.32.8.aros/src/video/aros/SDL_arosframebuffer.h
--- SDL2-2.32.8/src/video/aros/SDL_arosframebuffer.h	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/video/aros/SDL_arosframebuffer.h	2025-07-28 18:12:17.694941784 +0000
@@ -0,0 +1,30 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifndef _SDL_arosframebuffer_h
+#define _SDL_arosframebuffer_h
+
+extern int AROS_CreateWindowFramebuffer(_THIS, SDL_Window * window, Uint32 * format, void ** pixels, int *pitch);
+extern int AROS_UpdateWindowFramebuffer(_THIS, SDL_Window * window, const SDL_Rect * rects, int numrects);
+extern void AROS_DestroyWindowFramebuffer(_THIS, SDL_Window * window);
+
+#endif /* _SDL_arosframebuffer_h */
diff -ruN SDL2-2.32.8/src/video/aros/SDL_aroskeyboard.c SDL2-2.32.8.aros/src/video/aros/SDL_aroskeyboard.c
--- SDL2-2.32.8/src/video/aros/SDL_aroskeyboard.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/video/aros/SDL_aroskeyboard.c	2025-07-28 19:07:53.934076430 +0000
@@ -0,0 +1,88 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+//#define DEBUG 1
+#include <aros/debug.h>
+
+#include "../../SDL_internal.h"
+
+#include "../SDL_sysvideo.h"
+#include "../../events/SDL_keyboard_c.h"
+#include "../../events/scancodes_morphos.h"
+
+#include <proto/keymap.h>
+
+static SDL_Keycode AROS_MapRawKey(UWORD code)
+{
+    struct InputEvent ie;
+    char buffer[2] = {0, 0};
+
+    ie.ie_Class = IECLASS_RAWKEY;
+    ie.ie_SubClass = 0;
+    ie.ie_Code = code;
+    ie.ie_Qualifier = 0;
+    ie.ie_EventAddress = NULL;
+
+    const WORD res = MapRawKey(&ie, buffer, sizeof(buffer), NULL);
+    if (res == 1)
+    {
+        return buffer[0];
+    }
+
+	D(bug("[SDL2:aroskb] %s: %u->%d\n", __func__, code, res));
+
+    return 0;
+}
+
+static void AROS_UpdateKeymap(_THIS)
+{
+    SDL_Keycode keymap[SDL_NUM_SCANCODES];
+
+    SDL_GetDefaultKeymap(keymap);
+
+    for (int i = 0; i < SDL_arraysize(morphos_scancode_table); i++) {
+        /* Make sure this scancode is a valid character scancode */
+        const SDL_Scancode scancode  = morphos_scancode_table[i];
+        if (scancode == SDL_SCANCODE_UNKNOWN)
+            continue;
+
+        /* If this key is one of the non-mappable keys, ignore it */
+        /* Don't allow the number keys right above the qwerty row to translate or the top left key (grave/backquote) */
+        /* Not mapping numbers fixes the French layout, giving numeric keycodes for the number keys, which is the expected behavior */
+        if ((keymap[scancode] & SDLK_SCANCODE_MASK) || scancode == SDL_SCANCODE_GRAVE) 
+            continue;
+
+        keymap[scancode] = AROS_MapRawKey(i);
+    }
+
+    SDL_SetKeymap(0, keymap, SDL_NUM_SCANCODES, SDL_FALSE);
+}
+
+void AROS_InitKeyboard(_THIS)
+{
+    AROS_UpdateKeymap(_this);
+  
+    SDL_SetScancodeName(SDL_SCANCODE_APPLICATION, "Menu");
+    SDL_SetScancodeName(SDL_SCANCODE_LGUI, "Left Command");
+    SDL_SetScancodeName(SDL_SCANCODE_RGUI, "Right Command");
+	//SDL_SetScancodeName(SDL_SCANCODE_LCTRL, "Control");
+
+}
diff -ruN SDL2-2.32.8/src/video/aros/SDL_aroskeyboard.h SDL2-2.32.8.aros/src/video/aros/SDL_aroskeyboard.h
--- SDL2-2.32.8/src/video/aros/SDL_aroskeyboard.h	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/video/aros/SDL_aroskeyboard.h	2025-07-28 18:28:38.729149009 +0000
@@ -0,0 +1,28 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifndef _SDL_aroskeyboard_h
+#define _SDL_aroskeyboard_h
+
+extern void AROS_InitKeyboard(_THIS);
+
+#endif /* _SDL_aroskeyboard_h */
diff -ruN SDL2-2.32.8/src/video/aros/SDL_arosmessagebox.c SDL2-2.32.8.aros/src/video/aros/SDL_arosmessagebox.c
--- SDL2-2.32.8/src/video/aros/SDL_arosmessagebox.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/video/aros/SDL_arosmessagebox.c	2025-07-28 19:13:51.160502756 +0000
@@ -0,0 +1,110 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+//#define DEBUG 1
+#include <aros/debug.h>
+
+#include "../../SDL_internal.h"
+
+#include "SDL_messagebox.h"
+#include "../SDL_sysvideo.h"
+#include "../../core/morphos/SDL_misc.h"
+
+#if !defined(__AROS__)
+#include <proto/charsets.h>
+#endif
+#include <proto/exec.h>
+#include <proto/muimaster.h>
+
+int
+AROS_ShowMessageBox(const SDL_MessageBoxData *mbd, int *buttonid)
+{
+	struct Library *MUIMasterBase = OpenLibrary("muimaster.library", 0);
+	int rc = -1;
+
+	D(bug("[SDL2:arosmb] %s()\n", __func__));
+
+	if (MUIMasterBase) {
+		const char *title = NULL;
+#if !defined(__AROS__)
+        title = AROS_ConvertText(mbd->title, MIBENUM_UTF_8, MIBENUM_SYSTEM);
+#else
+        title = mbd->title;
+#endif
+        if (title) {
+            const char *message = NULL;
+#if !defined(__AROS__)
+            message = AROS_ConvertText(mbd->message, MIBENUM_UTF_8, MIBENUM_SYSTEM);
+#else
+            message = mbd->message;
+#endif
+            if (message) {
+                size_t i, tlen = 1024;
+                char *btxt;
+
+                btxt = SDL_malloc(tlen);
+
+                if (btxt) {
+                    char *buf = btxt;
+
+                    for (i = 0; i < mbd->numbuttons; i++) {
+                        if (i > 0)
+                            *buf++ = '|';
+
+                        if (mbd->buttons[i].flags & SDL_MESSAGEBOX_BUTTON_RETURNKEY_DEFAULT)
+                            *buf++ = '*';
+
+#if !defined(__AROS__)
+                        buf += ConvertTagList((APTR)mbd->buttons[i].text, -1, buf, -1, MIBENUM_UTF_8, MIBENUM_SYSTEM, NULL);
+#else
+                        strcpy(buf, mbd->buttons[i].text);
+                        buf += strlen(mbd->buttons[i].text);
+#endif
+                    }
+
+                    *buf = '\0';
+
+                    rc = MUI_RequestA(NULL, NULL, 0, title == NULL ? "SDL2" : title, btxt, message, NULL);
+
+                    if (rc == 0)
+                        rc = mbd->numbuttons - 1;
+                    else
+                        rc -= 1;
+
+                    *buttonid = mbd->buttons[rc].buttonid;
+
+                    SDL_free(btxt);
+                    rc = 0;
+                }
+#if !defined(__AROS__)
+                SDL_free(message);
+#endif
+            }
+#if !defined(__AROS__)
+            SDL_free(title);
+#endif
+        }
+
+		CloseLibrary(MUIMasterBase);
+	}
+
+	return rc;
+}
diff -ruN SDL2-2.32.8/src/video/aros/SDL_arosmessagebox.h SDL2-2.32.8.aros/src/video/aros/SDL_arosmessagebox.h
--- SDL2-2.32.8/src/video/aros/SDL_arosmessagebox.h	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/video/aros/SDL_arosmessagebox.h	2025-07-28 18:25:11.655177990 +0000
@@ -0,0 +1,28 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifndef _SDL_arosmessagebox_h
+#define _SDL_arosmessagebox_h
+
+extern int AROS_ShowMessageBox(const SDL_MessageBoxData *mbd, int *buttonid);
+
+#endif /* _SDL_arosmessagebox_h */
diff -ruN SDL2-2.32.8/src/video/aros/SDL_arosmodes.c SDL2-2.32.8.aros/src/video/aros/SDL_arosmodes.c
--- SDL2-2.32.8/src/video/aros/SDL_arosmodes.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/video/aros/SDL_arosmodes.c	2025-07-28 19:30:43.532548592 +0000
@@ -0,0 +1,448 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+//#define DEBUG 1
+#include <aros/debug.h>
+
+#include "../../SDL_internal.h"
+
+#include "SDL_arosmodes.h"
+#include "SDL_arosvideo.h"
+
+#if !defined(__AROS__)
+#include <machine/endian.h>
+#endif
+
+#include <cybergraphx/cybergraphics.h>
+#include <intuition/extensions.h>
+#include <intuition/monitorclass.h>
+#include <proto/alib.h>
+#include <proto/cybergraphics.h>
+#include <proto/graphics.h>
+#include <proto/intuition.h>
+#if !defined(__AROS__)
+#include <proto/screennotify.h>
+#endif
+#include <proto/exec.h>
+
+static int
+AROS_GetRefreshRate(struct Screen *s)
+{
+	D(bug("[SDL2:arosmodes] %s()\n", __func__));
+
+    ULONG freq = 60;
+
+    if (s) {
+
+        ULONG modeid = getv(s, SA_DisplayID);
+        APTR handle = FindDisplayInfo(modeid);
+        if (handle) {
+            struct MonitorInfo mi;
+
+            if (GetDisplayInfoData(handle, (UBYTE *)&mi, sizeof(mi), DTAG_MNTR, 0) >= sizeof(mi))
+                if (mi.TotalRows)
+                    freq = (ULONG)(1000000000L / ((FLOAT)mi.TotalColorClocks * 280.0 * (FLOAT)mi.TotalRows / 1000.0) + 5.0);
+        }
+    }
+	D(bug("[SDL2:arosmodes] %s: returning %u\n", __func__, freq));
+	return freq;
+}
+
+static Uint32
+AROS_SDLPixelFormatToDepth(Uint32 pixfmt)
+{
+	switch (pixfmt) {
+		case SDL_PIXELFORMAT_INDEX8:
+			return 8;
+
+		case SDL_PIXELFORMAT_RGB555:
+			return 15;
+
+		case SDL_PIXELFORMAT_RGB565:
+		case SDL_PIXELFORMAT_BGR565:
+			return 16;
+
+		case SDL_PIXELFORMAT_RGB888:
+		case SDL_PIXELFORMAT_BGR888:
+			return 24;
+
+		default:
+		case SDL_PIXELFORMAT_ARGB8888:
+		case SDL_PIXELFORMAT_BGRA8888:
+		case SDL_PIXELFORMAT_RGBA8888:
+			return 32;
+	}
+}
+
+static Uint32
+AROS_GetSDLPixelFormat(Uint32 pixfmt, Uint32 default_pixfmt)
+{
+	switch (pixfmt) {
+		case PIXFMT_LUT8   : 
+			return SDL_PIXELFORMAT_INDEX8;
+		case PIXFMT_BGR15:	 // 		case PIXFMT_RGB15X : 
+		case PIXFMT_BGR15PC:	
+			return default_pixfmt; //
+		case PIXFMT_RGB15PC: 
+		case PIXFMT_RGB15  : 
+			return SDL_PIXELFORMAT_RGB555;
+		case PIXFMT_RGB16  : 
+		case PIXFMT_RGB16PC: 
+			return SDL_PIXELFORMAT_RGB565;
+		case PIXFMT_BGR16  : 
+		case PIXFMT_BGR16PC: 
+			return SDL_PIXELFORMAT_BGR565;
+		case PIXFMT_RGB24  : 
+			return SDL_PIXELFORMAT_RGB888;
+		case PIXFMT_BGR24  : 
+			return SDL_PIXELFORMAT_BGR888;
+		case PIXFMT_ARGB32 : 
+			return SDL_PIXELFORMAT_ARGB8888;
+		case PIXFMT_BGRA32 : 
+			return SDL_PIXELFORMAT_BGRA8888;
+		case PIXFMT_RGBA32 : 
+			return SDL_PIXELFORMAT_RGBA8888;
+		default            : 
+			return SDL_PIXELFORMAT_BGRA8888;
+	}
+}
+
+#if defined(PIXFMT_RGB15X)
+#define MAX_SDL_PIXEL_FORMATS 15
+#else
+#define MAX_SDL_PIXEL_FORMATS 14
+#endif
+
+static const struct
+{
+	Uint32 PixFmt, NewPixFmt;
+} pixelformats[MAX_SDL_PIXEL_FORMATS] =
+{
+	{ PIXFMT_LUT8, SDL_PIXELFORMAT_INDEX8 },
+	{ PIXFMT_RGB15, SDL_PIXELFORMAT_RGB555 },
+#if defined(PIXFMT_RGB15X)
+	{ PIXFMT_RGB15X, SDL_PIXELFORMAT_RGB555 },
+#endif
+	{ PIXFMT_BGR15, SDL_PIXELFORMAT_BGR555 },
+	{ PIXFMT_RGB15PC, SDL_PIXELFORMAT_RGB555 },
+	{ PIXFMT_BGR15PC, SDL_PIXELFORMAT_BGR555 },
+	{ PIXFMT_RGB16, SDL_PIXELFORMAT_RGB565 },
+	{ PIXFMT_BGR16, SDL_PIXELFORMAT_BGR565 },
+	{ PIXFMT_RGB16PC, SDL_PIXELFORMAT_RGB565 },
+	{ PIXFMT_BGR16PC, SDL_PIXELFORMAT_BGR565 },
+	{ PIXFMT_RGB24, SDL_PIXELFORMAT_RGB888 },
+	{ PIXFMT_BGR24, SDL_PIXELFORMAT_BGR888 },
+	{ PIXFMT_ARGB32, SDL_PIXELFORMAT_ARGB8888 },
+	{ PIXFMT_BGRA32, SDL_PIXELFORMAT_BGRA8888 },
+	{ PIXFMT_RGBA32, SDL_PIXELFORMAT_RGBA8888 },
+};
+
+int
+AROS_InitModes(_THIS)
+{
+	D(bug("[SDL2:arosmodes] %s()\n", __func__));
+
+	Uint32 pixfmt = SDL_PIXELFORMAT_BGRA8888;
+	int width = 1920, height = 1080, dispcount = 0;
+	SDL_VideoDisplay display;
+	SDL_DisplayMode mode;
+	Object **monitors;
+	STRPTR monitorname = NULL;
+	struct Screen *s;
+	APTR mon = NULL;
+
+	SDL_zero(display);
+
+	mode.w = 1920;
+	mode.h = 1080;
+	mode.refresh_rate = 60;
+	mode.format = SDL_PIXELFORMAT_BGRA8888;
+	mode.driverdata = NULL;
+
+	s = LockPubScreen(NULL);
+
+	if (s) {
+		SDL_DisplayModeData *modedata;
+
+		// This is not actual view size but virtual screens are so 90s
+		width = s->Width;
+		height = s->Height;
+
+		pixfmt = AROS_GetSDLPixelFormat(getv(s, SA_PixelFormat), SDL_PIXELFORMAT_BGRA8888);
+		mon = (APTR)getv(s, SA_MonitorObject);
+
+		modedata = SDL_malloc(sizeof(*modedata));
+
+		if (modedata) {
+			modedata->monitor = mon;
+
+			mode.format = pixfmt;
+			mode.w = width;
+			mode.h = height;
+			mode.refresh_rate = (int)AROS_GetRefreshRate(s) / 1000;
+			mode.driverdata = SDL_malloc(4);
+
+			display.desktop_mode = mode;
+			display.current_mode = mode;
+			display.driverdata = modedata;
+			GetAttr(MA_MonitorName, mon, (IPTR *)&monitorname);
+			display.name = monitorname;
+
+			SDL_AddVideoDisplay(&display, SDL_FALSE);
+			dispcount++;
+
+			mode.driverdata = NULL;
+
+			
+			D(bug("[SDL2:arosmodes] %s:  Added Workbench screen - monitor @ 0x%p - name='%s'\n", __func__, mon, display.name));
+		}
+		UnlockPubScreen(NULL, s);
+	}
+
+	// Add other monitors (not desktop)
+	if ((monitors = GetMonitorList(NULL))) {
+		APTR m;
+		int i, j;
+
+		for (i = 0; (m = monitors[i]); i++) {
+			
+			if (m != mon) {
+				D(bug("[SDL2:arosmodes] %s: Adding additional monitor @ 0x%p\n", __func__, monitors[i]));
+
+				SDL_DisplayModeData *modedata = SDL_malloc(sizeof(*modedata));
+
+				if (modedata) {
+					ULONG *fmt = (ULONG *)getv(m, MA_PixelFormats);
+
+					for (j = MAX_SDL_PIXEL_FORMATS - 1; j >= 0; j--) {
+						pixfmt = pixelformats[j].PixFmt;
+
+						if (fmt[pixfmt]) {
+							mode.format = pixelformats[j].NewPixFmt;
+							
+							D(bug("[SDL2:arosmodes] %s: Add %ld/%ld pixfmt %ld\n", __func__, mode.w, mode.h, mode.format));
+							break;
+						}
+					}
+
+					modedata->monitor = m;
+
+					display.desktop_mode = mode;
+					display.current_mode = mode;
+					display.driverdata = modedata;
+					GetAttr(MA_MonitorName, m, (IPTR *)&monitorname);
+					display.name = monitorname;
+					
+					D(bug("[SDL2:arosmodes] %s: Add video display '%s'\n", __func__, display.name));
+
+					SDL_AddVideoDisplay(&display, SDL_FALSE);
+					dispcount++;
+				}
+			}
+		}
+
+		FreeMonitorList(monitors);
+	}
+
+	return dispcount > 0 ? 0 : -1;
+}
+
+void
+AROS_GetDisplayModes(_THIS, SDL_VideoDisplay * sdl_display)
+{
+	SDL_DisplayModeData *md = sdl_display->driverdata;
+
+	D(bug("[SDL2:arosmodes] %s()\n", __func__));
+
+	if (md) {
+		Object **modes = NULL;
+#if !defined(__AROS__)
+		modes = GetMonitorModesList(md->monitor, NULL);
+#endif
+		if (modes) {
+			int modei = 0;
+			while (modes[modei]) {
+				SDL_DisplayMode mode = sdl_display->desktop_mode;
+#if !defined(__AROS__)
+				Boopsiobject *amode = modes[modei++];
+#else
+				APTR amode;
+#endif
+				ULONG modeid = INVALID_ID;
+				STRPTR name = NULL;
+				ULONG width = 0;
+				ULONG height = 0;
+				ULONG pixelfmt = PIXFMT_ARGB32;
+#if !defined(__AROS__)
+				GetAttr(MA_Mode_Name, amode, (IPTR *)&name);
+				GetAttr(MA_Mode_ModeID, amode, (IPTR *)&modeid);
+				GetAttr(MA_Mode_Width, amode, (IPTR *)&width);
+				GetAttr(MA_Mode_Height, amode, (IPTR *)&height);
+				GetAttr(MA_Mode_PixelFormat, amode, (IPTR *)&pixelfmt);
+#endif
+				mode.w = width;
+				mode.h = height;
+				float vert = 0, hori = 0;
+#if !defined(__AROS__)
+				DoMethod(amode, MM_Mode_GetRefreshFrequencies, &hori, &vert);
+#endif
+				mode.refresh_rate = (int)hori;
+				mode.format = AROS_GetSDLPixelFormat(pixelfmt, SDL_PIXELFORMAT_BGRA8888);
+
+				//D("[%s] Mode %s - pixelfmt %ld\n", __func__, name, pixelfmt);
+				mode.driverdata = sdl_display->desktop_mode.driverdata ? SDL_malloc(4) : NULL;
+				SDL_AddDisplayMode(sdl_display, &mode);
+			}
+#if !defined(__AROS__)
+			FreeMonitorModesList(modes);
+#endif
+		}
+	}
+				
+}
+
+int
+AROS_GetScreen(_THIS, BYTE fullscreen, SDL_bool support3d)
+{
+	SDL_VideoData *data = (SDL_VideoData *) _this->driverdata;
+	struct Screen *screen;
+	int use_wb_screen = 0;
+	ULONG openError = 0;
+
+	D(bug("[SDL2:arosmodes] %s()\n", __func__));
+
+	if (!fullscreen && data->ScrMonName == NULL) {
+		data->CustomScreen = NULL;
+		screen = LockPubScreen(NULL);
+		use_wb_screen = 1;
+
+		D(bug("[SDL2:arosmodes] %s: Use WB Screen\n", __func__));
+
+	} else {
+
+		screen = OpenScreenTags(NULL,
+				SA_GammaControl, TRUE,
+				SA_Width, data->ScrWidth,
+				SA_Height, data->ScrHeight,
+				SA_Depth, data->ScrDepth,
+				data->ScrMonName ? SA_MonitorName : TAG_IGNORE , data->ScrMonName,
+				SA_Quiet, TRUE,
+				SA_ShowTitle, FALSE,
+				SA_Title, (IPTR)"SDL2",
+				SA_AdaptSize, TRUE,
+				SA_ErrorCode, (IPTR)&openError,
+				TAG_DONE);
+
+		if (screen)
+			data->CustomScreen = screen;
+	}
+
+	if (screen == NULL) {
+		if (data->ScrMonName != NULL)
+			screen = LockPubScreen("Workbench");
+
+		if (screen == NULL) {
+			switch (openError) {
+            case OSERR_NOMONITOR:
+                SDL_SetError("Monitor for display mode not available");
+                break;
+            case OSERR_NOCHIPS:
+                SDL_SetError("Newer custom chips required");
+                break;
+            case OSERR_NOMEM:
+            case OSERR_NOCHIPMEM:
+                SDL_OutOfMemory();
+                break;
+            case OSERR_PUBNOTUNIQUE:
+                SDL_SetError("Public screen name not unique");
+                break;
+            case OSERR_UNKNOWNMODE:
+            case OSERR_TOODEEP:
+                SDL_SetError("Unknown display mode");
+                break;
+            case OSERR_ATTACHFAIL:
+                SDL_SetError("Attachment failed");
+                break;
+            default:
+				SDL_SetError("Failed to get screen.");
+				break;
+			}
+			return -1;
+		}
+		use_wb_screen = 1;
+	}
+
+	data->WScreen = screen;
+
+#if !defined(__AROS__)
+	if (use_wb_screen) {
+		data->ScreenNotifyHandle = AddWorkbenchClient(&data->ScreenNotifyPort, -20);
+	}
+#endif
+
+	if (data->ScreenSaverSuspendCount) {
+		size_t i;
+
+		for (i = data->ScreenSaverSuspendCount; i > 0; i--)
+			SetAttrs(screen, SA_StopBlanker, TRUE, TAG_DONE);
+	}
+
+	return 0;
+}
+
+int
+AROS_SetDisplayMode(_THIS, SDL_VideoDisplay *display, SDL_DisplayMode *mode)
+{
+	SDL_VideoData *data = (SDL_VideoData *) _this->driverdata;
+
+	D(bug("[SDL2:arosmodes] %s()\n", __func__));
+
+	AROS_CloseWindows(_this);
+	AROS_CloseDisplay(_this);
+
+	data->sdlpixfmt = mode->format;
+	data->ScrMonName = NULL;
+
+	// NULL means non-WB mode
+	data->ScrWidth = mode->w;
+	data->ScrHeight = mode->h;
+	data->ScrDepth = AROS_SDLPixelFormatToDepth(mode->format);
+
+	if (mode->driverdata == NULL) {
+		data->ScrMonName = display->name;
+
+		D(bug("[SDL2:arosmodes] %s: Use monitor %s\n", __func__, data->ScrMonName));
+	}
+
+    return 0;
+}
+
+int
+AROS_GetDisplayBounds(_THIS, SDL_VideoDisplay * display, SDL_Rect * rect)
+{
+	
+	rect->x = 0;
+    rect->y = 0;
+    rect->w = display->current_mode.w;
+    rect->h = display->current_mode.h;
+
+    return 0;
+}
diff -ruN SDL2-2.32.8/src/video/aros/SDL_arosmodes.h SDL2-2.32.8.aros/src/video/aros/SDL_arosmodes.h
--- SDL2-2.32.8/src/video/aros/SDL_arosmodes.h	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/video/aros/SDL_arosmodes.h	2025-07-28 17:58:38.549756245 +0000
@@ -0,0 +1,43 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifndef _SDL_arosmodes_h
+#define _SDL_arosmodes_h
+
+#include "../SDL_sysvideo.h"
+
+#ifndef EXEC_TYPES_H
+#include <exec/types.h>
+#endif
+
+typedef struct
+{
+	APTR monitor;
+} SDL_DisplayModeData;
+
+extern int AROS_InitModes(_THIS);
+extern void AROS_GetDisplayModes(_THIS, SDL_VideoDisplay * sdl_display);
+extern int AROS_SetDisplayMode(_THIS, SDL_VideoDisplay *display, SDL_DisplayMode *mode);
+extern int AROS_GetScreen(_THIS, BYTE FullScreen, SDL_bool support3d);
+extern int AROS_GetDisplayBounds(_THIS, SDL_VideoDisplay * display, SDL_Rect * rect);
+
+#endif /* _SDL_arosmodes_h */
diff -ruN SDL2-2.32.8/src/video/aros/SDL_arosmouse.c SDL2-2.32.8.aros/src/video/aros/SDL_arosmouse.c
--- SDL2-2.32.8/src/video/aros/SDL_arosmouse.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/video/aros/SDL_arosmouse.c	2025-07-28 19:07:41.226132167 +0000
@@ -0,0 +1,342 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+//#define DEBUG 1
+#include <aros/debug.h>
+
+#include "../../SDL_internal.h"
+
+#include "SDL_arosmouse.h"
+#include "SDL_arosvideo.h"
+
+#include "../../events/SDL_mouse_c.h"
+#include "SDL_hints.h"
+
+#include <cybergraphx/cybergraphics.h>
+#include <devices/input.h>
+#include <intuition/pointerclass.h>
+#include <proto/cybergraphics.h>
+#include <proto/exec.h>
+#include <proto/graphics.h>
+#include <proto/dos.h>
+#include <dos/rdargs.h>
+
+AROS_GlobalMouseState globalMouseState;
+
+static SDL_Cursor *
+AROS_CreateCursor(SDL_Surface * surface, int hot_x, int hot_y)
+{
+	D(bug("[SDL2:arosmouse] %s(0x%p, %d, %d)\n", __func__, surface, hot_x, hot_y));
+
+	SDL_AROSCursor *cursor = SDL_malloc(sizeof(*cursor));
+
+	if (cursor) {
+		SDL_AROSCursor *ac = SDL_malloc(sizeof(*ac));
+		struct BitMap *bmp;
+
+		cursor->Cursor.next = NULL;
+		cursor->Cursor.driverdata = &cursor->Pointer;
+		cursor->Pointer.offx = hot_x;
+		cursor->Pointer.offy = hot_y;
+
+		bmp = AllocBitMap(surface->w, surface->h, 32, BMF_MINPLANES | BMF_CLEAR | BMF_SPECIALFMT | SHIFT_PIXFMT(PIXFMT_ARGB32), NULL);
+
+		if (bmp != NULL) {
+			struct RastPort rp;
+
+			InitRastPort(&rp);
+			rp.BitMap = bmp;
+
+			if (SDL_LockSurface(surface) == 0) {
+				WritePixelArray(surface->pixels, 0, 0, surface->pitch, &rp, 0, 0, surface->w, surface->h, RECTFMT_ARGB);
+				Object *mouseptr = NewObject(NULL, POINTERCLASS,
+								POINTERA_BitMap, bmp,
+								POINTERA_XOffset, -hot_x,
+								POINTERA_YOffset, -hot_y,
+								TAG_DONE);
+
+				cursor->Pointer.mouseptr = mouseptr;
+				D(bug("[SDL2:arosmouse] %s: allocated pointerobject @ 0x%p\n", __func__, cursor->Pointer.mouseptr));
+				SDL_UnlockSurface(surface);
+			}
+
+			FreeBitMap(bmp);
+		} else {
+			SDL_free(cursor);
+			cursor = NULL;
+			return NULL;
+		}
+	}
+
+	return &cursor->Cursor;
+}
+
+static SDL_Cursor *
+AROS_CreateSystemCursor(SDL_SystemCursor id)
+{
+	SDL_Cursor *cursor = SDL_malloc(sizeof(*cursor));
+
+	D(bug("[SDL2:arosmouse] %s()\n", __func__));
+
+	if (cursor) {
+#if !defined(__AROS__)
+		size_t type = POINTERTYPE_NORMAL;
+		cursor->next = NULL;
+		switch (id) {
+			default:
+			case SDL_SYSTEM_CURSOR_ARROW:     type = POINTERTYPE_NORMAL; break;
+			case SDL_SYSTEM_CURSOR_IBEAM:     type = POINTERTYPE_SELECTTEXT; break;
+			case SDL_SYSTEM_CURSOR_WAIT:      type = POINTERTYPE_BUSY; break;
+			case SDL_SYSTEM_CURSOR_CROSSHAIR: type = POINTERTYPE_AIMING; break;
+			case SDL_SYSTEM_CURSOR_WAITARROW: type = POINTERTYPE_WORKING; break;
+			case SDL_SYSTEM_CURSOR_SIZENWSE:  type = POINTERTYPE_DIAGONALRESIZE2; break;
+			case SDL_SYSTEM_CURSOR_SIZENESW:  type = POINTERTYPE_DIAGONALRESIZE1; break;
+			case SDL_SYSTEM_CURSOR_SIZEWE:    type = POINTERTYPE_HORIZONTALRESIZE; break;
+			case SDL_SYSTEM_CURSOR_SIZENS:    type = POINTERTYPE_VERTICALRESIZE; break;
+			case SDL_SYSTEM_CURSOR_SIZEALL:   type = POINTERTYPE_MOVE; break;
+			case SDL_SYSTEM_CURSOR_NO:        type = POINTERTYPE_NOTAVAILABLE; break;
+			case SDL_SYSTEM_CURSOR_HAND:      type = POINTERTYPE_SELECTLINK; break;
+		}
+		cursor->driverdata = (APTR)type;
+#else
+		cursor->next = NULL;
+		cursor->driverdata = NULL;
+#endif
+	} else {
+		SDL_OutOfMemory();
+	}
+
+	return cursor;
+}
+
+static void
+AROS_FreeCursor(SDL_Cursor *cursor)
+{
+	D(bug("[SDL2:arosmouse] %s(0x%p)\n", __func__, cursor));
+
+	if (!IS_SYSTEM_CURSOR(cursor))
+		if (((SDL_AROSCursor *)cursor)->Pointer.mouseptr)
+			DisposeObject(((SDL_AROSCursor *)cursor)->Pointer.mouseptr);
+
+	SDL_free(cursor);
+}
+
+static int
+AROS_ShowCursor(SDL_Cursor * cursor)
+{
+	SDL_VideoDevice *video = SDL_GetVideoDevice();
+	SDL_VideoData *data = (SDL_VideoData *)video->driverdata;
+
+	D(bug("[SDL2:arosmouse] %s(0x%p)\n", __func__, cursor));
+
+	if (IS_SYSTEM_CURSOR(cursor)) {
+#if !defined(__AROS__)
+		size_t type = cursor ? (size_t)cursor->driverdata : POINTERTYPE_INVISIBLE;
+
+		if (data->CurrentPointer != cursor) {
+			SDL_WindowData *wd;
+			size_t pointertags[] = { WA_PointerType, type, TAG_DONE };
+			ForeachNode(&data->windowlist, wd) {
+				if (wd->win) {
+                    SetAttrsA(wd->win, (struct TagItem *)&pointertags);
+                }
+            }
+		}
+#endif
+	} else {
+		SDL_AROSCursor *ac = (SDL_AROSCursor *)cursor;
+		SDL_WindowData *wd;
+
+		ForeachNode(&data->windowlist, wd) {
+            if (wd->win) {
+                if (ac->Pointer.mouseptr) {
+                    SetWindowPointer(wd->win, WA_Pointer, (size_t)ac->Pointer.mouseptr, TAG_DONE);
+                }
+            }
+        }
+	}
+
+	data->CurrentPointer = cursor;
+
+	return 0;
+}
+
+static void
+AROS_WarpMouse(SDL_Window * window, int x, int y)
+{
+	SDL_WindowData *data = (SDL_WindowData *)window->driverdata;
+	struct Window *win;
+
+	BOOL warpHostPointer;
+	warpHostPointer = !SDL_GetRelativeMouseMode() && (window == SDL_GetMouseFocus());
+
+	if (warpHostPointer) {
+
+		if ((win = data->win)) {
+			struct MsgPort *port;
+			struct IOStdReq *req;
+
+			port = CreateMsgPort();
+			if (port) {
+				req = CreateIORequest(port, sizeof(*req));
+				if (req) {
+					if (OpenDevice("input.device", 0, (struct IORequest *)req, 0) == 0) {
+						struct InputEvent ie = { 0 };
+						struct IEPointerPixel newpos = { 0 };
+
+						newpos.iepp_Screen = win->WScreen;
+						newpos.iepp_Position.X = x + win->BorderLeft + win->LeftEdge;
+						newpos.iepp_Position.Y = y + win->BorderTop + win->TopEdge;
+
+						ie.ie_EventAddress = &newpos;
+						ie.ie_NextEvent = NULL;
+						ie.ie_Class = IECLASS_NEWPOINTERPOS;
+						ie.ie_SubClass = IESUBCLASS_PIXEL;
+						ie.ie_Code = IECODE_NOBUTTON;
+						ie.ie_Qualifier = 0;
+
+						req->io_Data = &ie;
+						req->io_Length = sizeof(ie);
+						req->io_Command = IND_WRITEEVENT;
+
+						DoIO((struct IORequest *)req);
+						CloseDevice((struct IORequest *)req);
+					}
+				}
+
+				DeleteMsgPort(port);
+			}
+		}
+	} else {
+		SDL_SendMouseMotion(window,0, SDL_GetRelativeMouseMode(), x, y);
+	}
+}
+
+static int
+AROS_SetRelativeMouseMode(SDL_bool enabled)
+{
+	D(bug("[SDL2:arosmouse] %s()\n", __func__));
+
+	SDL_VideoDevice *video = SDL_GetVideoDevice();
+	SDL_VideoData *data = (SDL_VideoData *)video->driverdata;
+	SDL_WindowData *wd;
+	size_t or_mask, and_mask;
+
+	if (enabled) {
+		or_mask = IDCMP_DELTAMOVE;
+		and_mask = ~0;
+	} else {
+		or_mask = 0;
+		and_mask = ~IDCMP_DELTAMOVE;
+	}
+
+	ForeachNode(&data->windowlist, wd)
+		if (wd->win)
+			ModifyIDCMP(wd->win, (wd->win->IDCMPFlags | or_mask) & and_mask);
+
+	return 0;
+}
+
+static Uint32
+AROS_GetDoubleClickTimeInMillis(_THIS)
+{
+    Uint32 interval = 500;
+
+    struct RDArgs rda;
+    SDL_memset(&rda, 0, sizeof(rda));
+    rda.RDA_Source.CS_Buffer = (STRPTR)SDL_LoadFile("ENV:sys/mouse.conf", (size_t *)&rda.RDA_Source.CS_Length);
+    if (rda.RDA_Source.CS_Buffer) {
+        IPTR *array[4] = {0};
+        if (ReadArgs("Pointer/K,RMBEmulationQualifier/K,DoubleClickS/N/K,DoubleClickM/N/K,/F", (IPTR *)array, &rda)) {
+			if (array[2] != 0L && array[3] != 0L)
+            	interval = *array[2] * 1000 + *array[3] / 1000;
+
+	    	FreeArgs(&rda);
+        }
+        SDL_free(rda.RDA_Source.CS_Buffer);
+    }
+
+    return interval;
+}
+
+static Uint32
+AROS_GetGlobalMouseState(int *x, int *y)
+{
+    Uint32 buttons = 0;
+
+    if (x) {
+        *x = globalMouseState.x;
+    }
+
+    if (y) {
+        *y = globalMouseState.y;
+    }
+
+    if (globalMouseState.buttonPressed[SDL_BUTTON_LEFT]) {
+        buttons |= SDL_BUTTON_LMASK;
+    }
+
+    if (globalMouseState.buttonPressed[SDL_BUTTON_MIDDLE]) {
+        buttons |= SDL_BUTTON_MMASK;
+    }
+
+    if (globalMouseState.buttonPressed[SDL_BUTTON_RIGHT]) {
+        buttons |= SDL_BUTTON_RMASK;
+    }
+    
+    if (globalMouseState.buttonPressed[SDL_BUTTON_X1]) {
+        buttons |= SDL_BUTTON_X1MASK;
+    }
+
+    return buttons;
+}
+
+void
+AROS_InitMouse(_THIS)
+{
+	SDL_Mouse *mouse = SDL_GetMouse();
+	char buffer[16];
+
+	mouse->CreateCursor = AROS_CreateCursor;
+	mouse->CreateSystemCursor = AROS_CreateSystemCursor;
+	mouse->ShowCursor = AROS_ShowCursor;
+	mouse->FreeCursor = AROS_FreeCursor;
+	mouse->WarpMouse = AROS_WarpMouse;
+	mouse->SetRelativeMouseMode = AROS_SetRelativeMouseMode;
+    mouse->GetGlobalMouseState = AROS_GetGlobalMouseState;
+
+	SDL_SetDefaultCursor(AROS_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW));
+	SDL_SetHint(SDL_HINT_MOUSE_DOUBLE_CLICK_TIME,  SDL_uitoa(AROS_GetDoubleClickTimeInMillis(_this), buffer, 10));
+}
+
+void
+AROS_QuitMouse(_THIS)
+{
+	SDL_Mouse *mouse = SDL_GetMouse();
+
+	D(bug("[SDL2:arosmouse] %s()\n", __func__));
+
+	if ( mouse->def_cursor ) {
+		SDL_free(mouse->def_cursor);
+		mouse->def_cursor = NULL;
+		mouse->cur_cursor = NULL;
+	}
+}
diff -ruN SDL2-2.32.8/src/video/aros/SDL_arosmouse.h SDL2-2.32.8.aros/src/video/aros/SDL_arosmouse.h
--- SDL2-2.32.8/src/video/aros/SDL_arosmouse.h	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/video/aros/SDL_arosmouse.h	2025-07-28 18:23:41.408061933 +0000
@@ -0,0 +1,54 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifndef _SDL_arosmouse_h
+#define _SDL_arosmouse_h
+
+#include "SDL_arosvideo.h"
+
+#include <proto/intuition.h>
+
+#define IS_SYSTEM_CURSOR(cursor) (cursor == NULL || ((size_t)(cursor)->driverdata) < 5)
+
+struct SDL_AROSPointerData
+{
+	Object *mouseptr;
+	int offx, offy;
+};
+
+typedef struct
+{
+	struct SDL_Cursor Cursor;
+	struct SDL_AROSPointerData Pointer;
+} SDL_AROSCursor;
+
+typedef struct AROS_GlobalMouseState
+{
+    int x;
+    int y;
+    int buttonPressed[SDL_BUTTON_X1 + 1];
+} AROS_GlobalMouseState;
+
+extern void AROS_InitMouse(_THIS);
+extern void AROS_QuitMouse(_THIS);
+
+#endif /* _SDL_arosmouse_h */
diff -ruN SDL2-2.32.8/src/video/aros/SDL_arosopengl.c SDL2-2.32.8.aros/src/video/aros/SDL_arosopengl.c
--- SDL2-2.32.8/src/video/aros/SDL_arosopengl.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/video/aros/SDL_arosopengl.c	2025-07-28 19:07:36.006154984 +0000
@@ -0,0 +1,355 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2025 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#include "../../SDL_internal.h"
+
+#if SDL_VIDEO_OPENGL_AGL
+//#define DEBUG 1
+#include <aros/debug.h>
+
+#include "SDL_error.h"
+#include "SDL_syswm.h"
+#include "../SDL_sysvideo.h"
+#include "SDL_arosvideo.h"
+#include "SDL_arosmodes.h"
+#include "SDL_aroswindow.h"
+
+#include <proto/exec.h>
+#include <proto/gl.h>
+#include <proto/intuition.h>
+#include <proto/graphics.h>
+
+GLAContext *__AGLCtx;
+
+extern struct SDL_Library *SDL2Base;
+
+int
+AROS_GL_LoadLibrary(_THIS, const char *path)
+{
+#if (0)
+	if (!TinyGLBase)
+		TinyGLBase = OpenLibrary("tinygl.library", 53); 
+
+	if (TinyGLBase) {
+			if (!LIB_MINVER(TinyGLBase, 53, 8))		
+			{
+				SDL_SetError("Failed to open tinygl.library 53.8+");
+				return -1;
+			}
+			if (SDL2Base->MyTinyGLBase)				
+				*SDL2Base->MyTinyGLBase = TinyGLBase;	
+			
+			return 0;
+	} else 
+		SDL_SetError("Failed to open tinygl.library 53+");
+#endif
+	return -1;
+}
+
+void *
+AROS_GL_GetProcAddress(_THIS, const char *proc)
+{
+	void *func = NULL;
+#if (0)
+	func = tglGetProcAddress(proc);
+	if (!func) {
+    	SDL_SetError("Couldn't find OpenGL symbol");
+		return NULL;
+    }
+#endif
+	return func;
+}
+
+void
+AROS_GL_UnloadLibrary(_THIS)
+{
+	D(bug("[SDL2:arosgl] %s:\n", __func__));
+#if (0)
+	if (SDL2Base->MyTinyGLBase && *SDL2Base->MyTinyGLBase && TinyGLBase) {
+		CloseLibrary(TinyGLBase);
+		*SDL2Base->MyTinyGLBase = TinyGLBase = NULL;
+	}
+#endif
+}
+
+static void
+AROS_GL_FreeBitMap(_THIS, SDL_Window *window)
+{
+    D(bug("[SDL2:arosgl] %s:\n", __func__));
+#if (0)
+    SDL_WindowData *data = (SDL_WindowData *)window->driverdata;
+    if (data->bitmap != NULL) {
+        FreeBitMap(data->bitmap);
+        data->bitmap = NULL;
+    }
+#endif
+}
+
+static SDL_bool
+AROS_GL_AllocBitmap(_THIS, SDL_Window * window)
+{
+    D(bug("[SDL2:arosgl] %s:\n", __func__));
+#if (0)
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+
+	if (data->bitmap != NULL)
+		AROS_GL_FreeBitMap(_this, window);
+	
+	struct BitMap * friend_bitmap = data->win->RPort->BitMap;
+	ULONG depth = GetBitMapAttr(friend_bitmap, BMA_DEPTH);
+
+	int w = getv(data->win, WA_InnerWidth);
+	int h = getv(data->win, WA_InnerHeight);
+	
+	D("[SDL2:arosgl] %s: AllocBitMap w=%d h=%d depth=%d\n", __func__, w, h, (int)depth);
+	
+	return (data->bitmap = AllocBitMap(w, h, depth, BMF_MINPLANES|BMF_DISPLAYABLE|BMF_3DTARGET, friend_bitmap)) != NULL;
+#endif
+	return SDL_FALSE;
+}
+
+static SDL_bool
+AROS_GL_InitContext(_THIS, SDL_Window * window)
+{
+    D(bug("[SDL2:arosgl] %s:\n", __func__));
+#if (0)
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+	
+	if (data->__AGLCtx != NULL) {
+		GLADestroyContext(data->__AGLCtx);
+		data->__AGLCtx = NULL;
+        AROS_GL_FreeBitMap(_this, window);
+	}
+
+	struct TagItem tgltags[] =
+	{
+		{TAG_IGNORE, 0},
+		{TGL_CONTEXT_STENCIL, TRUE},
+		{TAG_DONE}
+	};	
+
+	if (AROS_GL_AllocBitmap(_this, window)) {	
+		tgltags[0].ti_Tag = TGL_CONTEXT_BITMAP;
+		tgltags[0].ti_Data = (IPTR)data->bitmap;
+	} else {
+		D("[SDL2:arosgl] %s: Failed to AllocBitmap !", __func__);	
+		return SDL_FALSE;
+	}
+		
+	// Initialize new context
+ 	int success = GLAInitializeContext(__AGLCtx, tgltags);
+	if (success) {
+		data->__AGLCtx = __AGLCtx;
+		
+		// Clean Screen
+		if (!window->flags & SDL_WINDOW_FULLSCREEN) {
+			GLClearColor(__AGLCtx, 0.0f, 0.0f, 0.0f, 1.0f);
+			GLClear(__AGLCtx, GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
+		}
+		return SDL_TRUE;	
+	}
+#endif
+	return SDL_FALSE;		
+}
+
+SDL_GLContext
+AROS_GL_CreateContext(_THIS, SDL_Window * window)
+{
+    D(bug("[SDL2:arosgl] %s:\n", __func__));
+#if (0)
+	SDL_WindowData *data = window->driverdata;
+	
+	GLContext *glcont = GLInit();
+	if (glcont) {
+		__AGLCtx = glcont;
+#ifdef TGL_CONTEXT_VERSION_53_9
+		if (SDL2Base->MyGetMaximumContextVersion)
+		{
+			unsigned int contextversion;
+			contextversion = SDL2Base->MyGetMaximumContextVersion(TinyGLBase);
+
+			if (contextversion == TGL_CONTEXT_VERSION_53_1)
+			{
+				TGLEnableNewExtensions(__AGLCtx, 0);
+			}
+			else if (contextversion >= TGL_CONTEXT_VERSION_53_9)
+			{
+				TGLSetContextVersion(__AGLCtx, contextversion);
+			}
+		}
+#endif
+		if (AROS_GL_InitContext(_this, window)) {
+			D("[SDL2:arosgl] %s: AROS_GL_InitContext SUCCES 0x%08lx, data->__AGLCtx=0x%08lx\n", __func__, glcont, data->__AGLCtx);
+
+			*SDL2Base->MyGLContext = glcont;
+			
+			GLClearColor(glcont, 0.0f, 0.0f, 0.0f, 1.0f);
+			GLClear(glcont, GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
+			
+			return glcont;
+		} else {
+			D("[SDL2:arosgl] %s: AROS_GL_InitContext FAILED 0x%08lx, data->__AGLCtx=0x%08lx\n", __func__, glcont, data->__AGLCtx);
+
+            AROS_GL_FreeBitMap(_this, window);
+			GLClose(glcont);
+			*SDL2Base->MyGLContext = data->__AGLCtx = __AGLCtx = NULL;
+			
+			SDL_SetError("Couldn't initialize TinyGL context");
+		}
+	} else {
+		SDL_SetError("Couldn't create TinyGL context");
+	}
+#endif
+	return NULL;
+}
+
+int
+AROS_GL_MakeCurrent(_THIS, SDL_Window * window, SDL_GLContext context)
+{
+    D(bug("[SDL2:arosgl] %s: context 0x%08lx\n", __func__, context));
+#if (0)
+    if (window && context) {
+        *SDL2Base->MyGLContext = __AGLCtx = context;
+    }
+#endif
+	return 0;
+}
+
+void
+AROS_GL_GetDrawableSize(_THIS, SDL_Window *window, int *width, int *height)
+{
+#if (0)
+	SDL_WindowData *data = window->driverdata;
+    int w = 0;
+    int h = 0;
+    if (data->win) {
+			w = data->win->Width - data->win->BorderLeft - data->win->BorderRight;
+			h = data->win->Height - data->win->BorderTop - data->win->BorderBottom;
+	}
+   // D("[SDL2:arosgl] %s: System window size (%d * %d), SDL window size (%d * %d)\n", __func__, w, h, window->w, window->h);
+    if (width)
+        *width = w;
+    if (height)
+        *height = h;
+#endif
+}
+
+int
+AROS_GL_SetSwapInterval(_THIS, int interval)
+{
+#if (0)
+	SDL_VideoData *data = _this->driverdata;
+	
+	switch (interval) {
+		case 0:
+		case 1:
+			// always VSYNC in fullscreen
+			data->vsyncEnabled = /*data->CustomScreen != NULL ? TRUE : */(interval ? TRUE : FALSE);
+			return 0;
+		default:
+			return -1;
+	}	
+#endif
+	return -1;
+}
+
+int
+AROS_GL_GetSwapInterval(_THIS)
+{
+#if (0)
+	SDL_VideoData *data = _this->driverdata;
+	return data->vsyncEnabled ? 1 : 0;
+#endif
+	return 0;
+}
+
+int
+AROS_GL_SwapWindow(_THIS, SDL_Window * window)
+{
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+
+#if (0)
+	if (!data->win || !data->__AGLCtx || !__AGLCtx)
+		return 0;
+
+	SDL_VideoData *video = _this->driverdata;
+	if (video->vsyncEnabled && data->win->WScreen) {
+		BOOL displayed = getv(data->win->WScreen, SA_Displayed);
+		if (displayed) {
+			WaitBOVP(&data->win->WScreen->ViewPort);
+		}
+	}
+	
+	GLASwapBuffers(data->__AGLCtx);
+	
+	if (data->bitmap != NULL) {
+		
+		BltBitMapRastPort(data->bitmap, 0, 0, data->win->RPort, data->win->BorderLeft, data->win->BorderTop, 
+				window->w, window->h, 0xc0);
+	}
+#endif
+	
+	return 0;
+}
+
+void
+AROS_GL_DeleteContext(_THIS, SDL_GLContext context)
+{
+	D(bug("[SDL2:arosgl] %s: context 0x%08lx\n", __func__, context));
+
+#if (0)
+	if (TinyGLBase != NULL && context) {
+		SDL_Window *sdlwin;
+
+		for (sdlwin = _this->windows; sdlwin; sdlwin = sdlwin->next) {
+
+			SDL_WindowData *data = sdlwin->driverdata;
+
+			if (data->__AGLCtx == context) {
+                D("[SDL2:arosgl] %s: Found TinyGL context 0x%08lx, clearing window binding\n", __func__, context);
+                GLADestroyContext(context);
+				data->__AGLCtx = NULL;
+                AROS_GL_FreeBitMap(_this, sdlwin);
+			}
+		}
+		GLClose(context);
+		*SDL2Base->MyGLContext = __AGLCtx = NULL;
+	}
+#endif
+}
+
+int
+AROS_GL_ResizeContext(_THIS, SDL_Window *window)
+{
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+	D(bug("[SDL2:arosgl] %s: Context=0x%08lx data->__AGLCtx=0x%08lx\n", __func__, __AGLCtx, data->__AGLCtx));
+
+#if (0)
+	if (data->__AGLCtx == NULL || __AGLCtx == NULL || data->win == NULL) {
+		return -1;
+	}
+	
+	return (AROS_GL_InitContext(_this, window) ? 0 : -1);
+#endif
+	return -1;
+}
+
+#endif /* SDL_VIDEO_OPENGL_AGL */
diff -ruN SDL2-2.32.8/src/video/aros/SDL_arosopengl.h SDL2-2.32.8.aros/src/video/aros/SDL_arosopengl.h
--- SDL2-2.32.8/src/video/aros/SDL_arosopengl.h	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/video/aros/SDL_arosopengl.h	2025-07-27 14:24:21.372841404 +0000
@@ -0,0 +1,45 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+/* TinyGL implementation of SDL OpenGL support */
+
+#include "../../SDL_internal.h"
+
+#ifndef _SDL_arosopengl_h
+#define _SDL_arosopengl_h
+
+/* SDL functions */
+extern int AROS_GL_LoadLibrary(_THIS, const char *path);
+extern void *AROS_GL_GetProcAddress(_THIS, const char *proc);
+extern void AROS_GL_UnloadLibrary(_THIS);
+extern SDL_GLContext AROS_GL_CreateContext(_THIS, SDL_Window * window);
+extern int AROS_GL_MakeCurrent(_THIS, SDL_Window * window, SDL_GLContext context);
+extern void AROS_GL_GetDrawableSize(_THIS, SDL_Window * window, int *w, int *h);
+extern int AROS_GL_SetSwapInterval(_THIS, int interval);
+extern int AROS_GL_GetSwapInterval(_THIS);
+extern int AROS_GL_SwapWindow(_THIS, SDL_Window * window);
+extern void AROS_GL_DeleteContext(_THIS, SDL_GLContext context);
+
+/* Non-SDL functions */
+extern int AROS_GL_ResizeContext(_THIS, SDL_Window *window);
+extern SDL_bool AROS_GL_InitContext(_THIS, SDL_Window * window, GLAContext *glcont);
+
+#endif /* _SDL_arosopengl_h */
diff -ruN SDL2-2.32.8/src/video/aros/SDL_arosshape.c SDL2-2.32.8.aros/src/video/aros/SDL_arosshape.c
--- SDL2-2.32.8/src/video/aros/SDL_arosshape.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/video/aros/SDL_arosshape.c	2025-07-28 19:07:31.310175608 +0000
@@ -0,0 +1,192 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+//#define DEBUG 1
+#include <aros/debug.h>
+
+#include "../../SDL_internal.h"
+
+#include "../SDL_sysvideo.h"
+
+#include "SDL_arosshape.h"
+#include "SDL_aroswindow.h"
+
+#include <intuition/extensions.h>
+#include <proto/graphics.h>
+#include <proto/intuition.h>
+
+SDL_WindowShaper*
+AROS_CreateShaper(SDL_Window *window)
+{
+	D(bug("[SDL2:arosshape] %s()\n", __func__));
+
+	SDL_WindowShaper *result;
+
+	if ((result = SDL_malloc(sizeof(*result)))) {
+		result->window = window;
+		result->mode.mode = ShapeModeDefault;
+		result->mode.parameters.binarizationCutoff = 1;
+		result->userx = window->x;
+		result->usery = window->y;
+		result->driverdata = NULL;
+
+		window->shaper = result;
+	} else {
+		SDL_OutOfMemory();
+	}
+
+	return result;
+}
+
+int
+AROS_ResizeWindowShape(SDL_Window* window)
+{
+	D(bug("[SDL2:arosshape] %s()\n", __func__));
+
+	SDL_WindowShaper *shaper = window->shaper;
+
+	shaper->userx = window->x;
+	shaper->usery = window->y;
+
+	return 0;
+}
+
+static void
+AROS_ShapeToRegion(struct Region *region, SDL_Surface *shape, const SDL_WindowShapeMode mode)
+{
+	D(bug("[SDL2:arosshape] %s()\n", __func__));
+
+	Uint32 y, bpr = shape->format->BytesPerPixel, pitch;
+	const Uint8 *pixels;
+	SDL_Color key;
+
+	D(bug("[SDL2:arosshape] %s: mode: %ld\n", __func__, mode.mode));
+
+	if (SDL_MUSTLOCK(shape))
+		SDL_LockSurface(shape);
+
+	pixels = shape->pixels;
+	pitch = shape->pitch;
+
+	for (y = 0; y < shape->h; y++) {
+		struct Rectangle rect;
+		int x, have_transp = 0;
+
+		for (x = 0; x < shape->w; x++) {
+			Uint32 pixel_value = 0, mask_value = 0;
+			Uint8 *pixel = (Uint8 *)(pixels) + (y * pitch) + (x * bpr);
+			Uint8 r, g, b, alpha;
+
+			switch (bpr) {
+				case 1:
+					pixel_value = *(Uint8*)pixel;
+					break;
+
+				case 2:
+					pixel_value = *(Uint16*)pixel;
+					break;
+
+				case 3:
+					pixel_value = *(Uint32*)pixel & (~shape->format->Amask);
+					break;
+
+				case 4:
+					pixel_value = *(Uint32*)pixel;
+					break;
+			}
+
+			SDL_GetRGBA(pixel_value, shape->format, &r, &g, &b, &alpha);
+
+			switch (mode.mode) {
+				case ShapeModeDefault:
+					mask_value = (alpha >= 1 ? 1 : 0);
+					break;
+
+				case ShapeModeBinarizeAlpha:
+					mask_value = (alpha >= mode.parameters.binarizationCutoff ? 1 : 0);
+					break;
+
+				case ShapeModeReverseBinarizeAlpha:
+					mask_value = (alpha <= mode.parameters.binarizationCutoff ? 1 : 0);
+					break;
+
+				case ShapeModeColorKey:
+					key = mode.parameters.colorKey;
+					mask_value = ((key.r != r || key.g != g || key.b != b) ? 1 : 0);
+					break;
+			}
+
+			if (have_transp == 0) {
+				if (mask_value == 0) {
+					rect.MinX = x;
+					rect.MinY = y;
+					rect.MaxY = y;
+					have_transp = 1;
+				}
+			} else {
+				if (mask_value == 1) {
+					rect.MaxX = x - 1;
+					have_transp = 0;
+					OrRectRegion(region, &rect);
+				}
+			}
+		}
+
+		if (have_transp) {
+			rect.MaxX = shape->w - 1;
+			OrRectRegion(region, &rect);
+		}
+	}
+
+	if (SDL_MUSTLOCK(shape))
+		SDL_UnlockSurface(shape);
+}
+
+int
+AROS_SetWindowShape(SDL_WindowShaper *shaper, SDL_Surface *shape, SDL_WindowShapeMode *mode)
+{
+	SDL_WindowData *data = shaper->window->driverdata;
+	struct Region *old = data->region;
+	struct Region *region = NewRegion();
+
+	D(bug("[SDL2:arosshape] %s: shaper: 0x%08lx, window: 0x%08lx, driverdata: 0x%08lx, old: 0x%08lx\n", __func__, shaper, shaper->window, data, old));
+
+	if (region) {
+		data->region = region;
+
+		AROS_ShapeToRegion(region, shape, shaper->mode);
+
+		if (data->win) {
+#if !defined(__AROS__)
+			size_t tags[] = { TRANSPCONTROL_REGION, (size_t)region, TAG_DONE };
+			D(bug("[SDL2:arosshape] %s:  Set transparency region (0x%08lx)\n", __func__, region));
+			TransparencyControl(data->win, TRANSPCONTROLMETHOD_INSTALLREGION, (struct TagItem *)&tags);
+#endif
+		}
+
+		D(bug("[SDL2:arosshape] %s:  DisposeRegion(0x%08lx)\n", __func__, old));
+
+		if (old)
+			DisposeRegion(old);
+	}
+
+	return 0;
+}
diff -ruN SDL2-2.32.8/src/video/aros/SDL_arosshape.h SDL2-2.32.8.aros/src/video/aros/SDL_arosshape.h
--- SDL2-2.32.8/src/video/aros/SDL_arosshape.h	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/video/aros/SDL_arosshape.h	2025-07-28 18:18:43.334984401 +0000
@@ -0,0 +1,34 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifndef _SDL_arosshape_h
+#define _SDL_arosshape_h
+
+typedef struct
+{
+} SDL_ShapeData;
+
+extern SDL_WindowShaper *AROS_CreateShaper(SDL_Window *window);
+extern int AROS_ResizeWindowShape(SDL_Window* window);
+extern int AROS_SetWindowShape(SDL_WindowShaper *shaper, SDL_Surface *shape, SDL_WindowShapeMode *shape_mode);
+
+#endif /* _SDL_arosshape_h */
diff -ruN SDL2-2.32.8/src/video/aros/SDL_arosvideo.c SDL2-2.32.8.aros/src/video/aros/SDL_arosvideo.c
--- SDL2-2.32.8/src/video/aros/SDL_arosvideo.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/video/aros/SDL_arosvideo.c	2025-07-28 19:22:18.878313135 +0000
@@ -0,0 +1,411 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+//#define DEBUG 1
+#include <aros/debug.h>
+
+#include <dos/bptr.h>
+
+#include "../../SDL_internal.h"
+
+#include "SDL_video.h"
+#include "SDL_mouse.h"
+#include "../SDL_sysvideo.h"
+#include "../SDL_pixels_c.h"
+#include "SDL_hints.h"
+
+#include "SDL_arosclipboard.h"
+
+#include "SDL_arosframebuffer.h"
+#include "SDL_aroskeyboard.h"
+#include "SDL_arosmodes.h"
+#include "SDL_arosmouse.h"
+#include "SDL_arosshape.h"
+#include "SDL_arosvideo.h"
+#include "SDL_aroswindow.h"
+#include "SDL_arosmessagebox.h"
+#include "SDL_arosopengl.h"
+
+#include <exec/execbase.h>
+#include <intuition/pointerclass.h>
+#include <proto/commodities.h>
+#include <proto/dos.h>
+#include <proto/exec.h>
+#include <proto/icon.h>
+#include <proto/intuition.h>
+#if !defined(__AROS__)
+#include <proto/screennotify.h>
+#else
+#include <string.h>
+#endif
+#include <proto/wb.h>
+
+#include "SDL_arosevents.h"
+
+void
+AROS_CloseDisplay(_THIS)
+{
+	SDL_VideoData *data = (SDL_VideoData *) _this->driverdata;
+	D(bug("[SDL2:arosvideo] %s: CustomScreen=0x%08lx  WScreen=0x%08lx \n", __func__, data->CustomScreen, data->WScreen));
+
+	if (data->CustomScreen) {
+		CloseScreen(data->CustomScreen);
+	}
+	else if (data->WScreen) {
+		if (data->ScreenSaverSuspendCount) {
+			size_t i;
+
+			for (i = data->ScreenSaverSuspendCount; i > 0; i--)
+				SetAttrs(data->WScreen, SA_StopBlanker, FALSE, TAG_DONE);
+		}
+
+		UnlockPubScreen(NULL, data->WScreen);
+
+#if !defined(__AROS__)
+		if (data->ScreenNotifyHandle) {
+			while (!RemWorkbenchClient(data->ScreenNotifyHandle))
+				Delay(10);
+
+			data->ScreenNotifyHandle = NULL;
+		}
+#endif
+	}
+
+	data->CustomScreen = NULL;
+	data->WScreen = NULL;
+}
+
+size_t getv(APTR obj, size_t attr)
+{
+	IPTR val = 0;
+	GetAttr(attr, obj, (IPTR *)&val);
+	return (size_t)val;
+}
+
+void
+AROS_HideApp(_THIS, size_t with_app_icon)
+{
+	SDL_VideoData *data = (SDL_VideoData *) _this->driverdata;
+	D(bug("[SDL2:arosvideo] %s: %siconify\n", __func__, with_app_icon ? "" : "no "));
+
+    SDL_WindowData *wd;
+    ForeachNode(&data->windowlist, wd)
+    {
+        struct Window *win = wd->win;
+        if (win)
+            AROS_SetWindowOpacity(_this, wd->window, 0.0);
+    }
+
+	if (with_app_icon && data->AppIcon)
+		data->AppIconRef = AddAppIconA(0, 0, FilePart(data->FullAppName), &data->WBPort, 0, data->AppIcon, NULL);
+}
+
+void
+AROS_ShowApp(_THIS)
+{
+    D(bug("[SDL2:arosvideo] %s()\n", __func__));
+
+	SDL_VideoData *data = (SDL_VideoData *) _this->driverdata;
+
+	if (data->AppIconRef) {
+		struct Message *msg;
+
+		RemoveAppIcon(data->AppIconRef);
+		data->AppIconRef = NULL;
+
+		while ((msg = GetMsg(&data->WBPort)) != NULL)
+			ReplyMsg(msg);
+	}
+
+    SDL_WindowData *wd;
+    ForeachNode(&data->windowlist, wd)
+    {
+        struct Window *win = wd->win;
+        if (win) {
+            AROS_SetWindowOpacity(_this, wd->window, 1.0);
+            AROS_WindowToFront(win);
+        }
+    }
+
+}
+
+static int
+AROS_VideoInit(_THIS)
+{
+	D(bug("[SDL2:arosvideo] %s()\n", __func__));
+
+	if (AROS_InitModes(_this) < 0)
+	{
+		D(bug("[SDL2:arosvideo] %s: failed to initialize video modes\n", __func__));
+		return SDL_SetError("Failed to initialize modes");
+	}
+
+	AROS_InitKeyboard(_this);
+	AROS_InitMouse(_this);
+
+	SDL_SetHint(SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS, SDL_FALSE);
+	SDL_SetHint(SDL_HINT_GAMECONTROLLERCONFIG_FILE, "ENV:gamecontrollerdb.txt");
+	SDL_SetHint(SDL_HINT_POLL_SENTINEL, "0");
+
+	return 0;
+}
+
+static void
+AROS_VideoQuit(_THIS)
+{
+	D(bug("[SDL2:arosvideo] %s()\n", __func__));
+
+	AROS_CloseWindows(_this);
+	AROS_CloseDisplay(_this);
+	AROS_QuitMouse(_this);
+}
+
+static void
+AROS_DeleteDevice(SDL_VideoDevice * device)
+{
+	D(bug("[SDL2:arosvideo] %s()\n", __func__));
+	SDL_VideoData *data = (SDL_VideoData *) device->driverdata;
+
+	FreeSignal(data->ScreenNotifyPort.mp_SigBit);
+	FreeSignal(data->BrokerPort.mp_SigBit);
+	FreeSignal(data->WBPort.mp_SigBit);
+	FreeSignal(data->WinPort.mp_SigBit);
+
+	if (data->BrokerRef)
+		DeleteCxObjAll(data->BrokerRef);
+
+	if (data->AppIcon)
+		FreeDiskObject(data->AppIcon);
+
+	SDL_free(data);
+	SDL_free(device);
+}
+
+void
+AROS_SuspendScreenSaver(_THIS)
+{
+	SDL_VideoData *data = (SDL_VideoData *) _this->driverdata;
+	LONG suspend = _this->suspend_screensaver;
+
+	D(bug("[SDL2:arosvideo] %s: screen 0x%08lx, suspend %ld\n", __func__, data->WScreen, suspend));
+
+	if (suspend == 0 && data->ScreenSaverSuspendCount == 0)
+		return;
+
+	data->ScreenSaverSuspendCount += suspend ? 1 : -1;
+
+	if (data->WScreen)
+		SetAttrs(data->WScreen, SA_StopBlanker, suspend, TAG_DONE);
+}
+
+static CONST_STRPTR
+AROS_GetTaskName()
+{
+	struct Process *task = (struct Process *)FindTask(NULL);
+	STRPTR name = "SDL";
+
+	if (task->pr_Task.tc_Node.ln_Type == NT_PROCESS || task->pr_Task.tc_Node.ln_Type == NT_TASK) {
+		if (task->pr_Task.tc_Node.ln_Type == NT_PROCESS && task->pr_CLI) {
+			struct CommandLineInterface *cli = (struct CommandLineInterface *)BADDR(task->pr_CLI);
+
+			if (cli->cli_Module && cli->cli_CommandName) {
+				CONST_STRPTR src = (CONST_STRPTR)AROS_BSTR_ADDR(cli->cli_CommandName);
+				size_t len = AROS_BSTR_strlen(cli->cli_CommandName) + 1;
+
+				if (len > 1) {
+					if (src[1] == '"' && src[len] == '"')
+					{
+						len -= 2;
+						src++;
+					}
+
+					STRPTR tmpname = SDL_malloc(len);
+					if (tmpname)
+					{
+						name = tmpname;
+						stccpy(name, src, len);
+					}
+				}
+			}
+		} else {
+			size_t len = strlen(task->pr_Task.tc_Node.ln_Name) + sizeof("PROGDIR:") + 1;
+			STRPTR tmpname = SDL_malloc(len);
+			if (tmpname) {
+				name = tmpname;
+				strcpy(name, "PROGDIR:");
+				strcpy((APTR)((IPTR)name + 8), task->pr_Task.tc_Node.ln_Name);
+				D(bug("[SDL2:arosvideo] %s: using task name '%s'\n", __func__, name));
+			}
+		}
+	}
+
+	D(bug("[SDL2:arosvideo] %s: '%s'\n", __func__, name));
+
+	return name;
+}
+
+static void
+AROS_InitPort(struct MsgPort *port)
+{
+	port->mp_Node.ln_Name = "SDL";
+	port->mp_Flags = PA_SIGNAL;
+	port->mp_SigTask = SysBase->ThisTask;
+	NEWLIST(&port->mp_MsgList);
+	port->mp_SigBit = AllocSignal(-1);
+}
+
+static void
+AROS_InitBroker(SDL_VideoData *data)
+{
+	D(bug("[SDL2:arosvideo] %s()\n", __func__));
+	
+	STRPTR name = FilePart(data->FullAppName);
+	data->AppBroker.nb_Version = NB_VERSION;
+	data->AppBroker.nb_Name = name;
+	data->AppBroker.nb_Title = name;
+	data->AppBroker.nb_Descr = "SDL";
+	data->AppBroker.nb_Unique = NBU_DUPLICATE;
+	data->AppBroker.nb_Flags = COF_SHOW_HIDE;
+	data->AppBroker.nb_Pri = 0;
+	data->AppBroker.nb_Port = &data->BrokerPort;
+	data->AppBroker.nb_ReservedChannel = 0;
+	data->BrokerRef = CxBroker(&data->AppBroker, NULL);
+	if (data->BrokerRef)
+		ActivateCxObj(data->BrokerRef, 1);
+}
+
+static SDL_VideoDevice *
+AROS_CreateDevice()
+{
+	/* Initialize all variables that we clean on shutdown */
+	SDL_VideoDevice *device = (SDL_VideoDevice *) SDL_calloc(1, sizeof(SDL_VideoDevice));
+	D(bug("[SDL2:arosvideo] %s()\n", __func__));
+
+	if (device) {
+		SDL_VideoData *data = (struct SDL_VideoData *) SDL_calloc(1, sizeof(SDL_VideoData));
+
+		device->driverdata = data;
+
+		if (data) {
+			AROS_InitPort(&data->ScreenNotifyPort);
+			AROS_InitPort(&data->BrokerPort);
+			AROS_InitPort(&data->WBPort);
+			AROS_InitPort(&data->WinPort);
+
+			data->ScrNotifySig = 1 << data->ScreenNotifyPort.mp_SigBit;
+			data->BrokerSig = 1 << data->BrokerPort.mp_SigBit;
+			data->WBSig = 1 << data->WBPort.mp_SigBit;
+			data->WinSig = 1 << data->WinPort.mp_SigBit;
+
+			data->sdlpixfmt = SDL_PIXELFORMAT_ARGB8888;
+
+			NEWLIST(&data->windowlist);
+
+			data->FullAppName = AROS_GetTaskName();
+			data->AppIcon = GetDiskObject((STRPTR)data->FullAppName);
+
+			if (data->AppIcon == NULL)
+				data->AppIcon = GetDiskObject((STRPTR)"ENVARC:Sys/def_SDL");
+
+			if (data->AppIcon) {
+				data->AppIcon->do_CurrentX = NO_ICON_POSITION;
+				data->AppIcon->do_CurrentY = NO_ICON_POSITION;
+				data->AppIcon->do_Type = 0;
+			}
+
+			AROS_InitBroker(data);
+
+			data->VideoDevice = device;
+
+			/* Set the function pointers */
+			device->VideoInit = AROS_VideoInit;
+			device->VideoQuit = AROS_VideoQuit;
+			device->GetDisplayModes = AROS_GetDisplayModes;
+			device->GetDisplayBounds = AROS_GetDisplayBounds;
+			device->SetDisplayMode = AROS_SetDisplayMode;
+			device->SuspendScreenSaver = AROS_SuspendScreenSaver;
+			device->PumpEvents = AROS_PumpEvents;
+			device->CreateSDLWindow = AROS_CreateWindow;
+			device->CreateSDLWindowFrom = AROS_CreateWindowFrom;
+			device->SetWindowTitle = AROS_SetWindowTitle;
+			device->SetWindowIcon = AROS_SetWindowIcon;
+			device->SetWindowPosition = AROS_SetWindowPosition;
+			device->SetWindowSize = AROS_SetWindowSize;
+			device->SetWindowMinimumSize = AROS_SetWindowMinimumSize;
+			device->SetWindowMaximumSize = AROS_SetWindowMaximumSize;
+			device->ShowWindow = AROS_ShowWindow;
+			device->HideWindow = AROS_HideWindow;
+			device->RaiseWindow = AROS_RaiseWindow;
+			device->MaximizeWindow = AROS_MaximizeWindow;
+			device->MinimizeWindow = AROS_MinimizeWindow;
+			device->RestoreWindow = AROS_RestoreWindow;
+			device->SetWindowBordered = AROS_SetWindowBordered;
+			device->SetWindowAlwaysOnTop = AROS_SetWindowAlwaysOnTop;
+			device->SetWindowFullscreen = AROS_SetWindowFullscreen;
+ 			device->SetWindowGammaRamp = AROS_SetWindowGammaRamp;
+			device->SetWindowMouseGrab = AROS_SetWindowGrab;
+			device->DestroyWindow = AROS_DestroyWindow;
+			device->CreateWindowFramebuffer = AROS_CreateWindowFramebuffer;
+			device->UpdateWindowFramebuffer = AROS_UpdateWindowFramebuffer;
+			device->DestroyWindowFramebuffer = AROS_DestroyWindowFramebuffer;
+			device->GetWindowWMInfo = AROS_GetWindowWMInfo;
+			device->shape_driver.CreateShaper = AROS_CreateShaper;
+			device->shape_driver.SetWindowShape = AROS_SetWindowShape;
+			device->shape_driver.ResizeWindowShape = AROS_ResizeWindowShape;
+			device->GL_LoadLibrary = AROS_GL_LoadLibrary;
+			device->GL_GetProcAddress = AROS_GL_GetProcAddress;
+			device->GL_UnloadLibrary = AROS_GL_UnloadLibrary;
+			device->GL_CreateContext = AROS_GL_CreateContext;
+			device->GL_MakeCurrent = AROS_GL_MakeCurrent;
+			device->GL_GetDrawableSize = AROS_GL_GetDrawableSize;
+			device->GL_SetSwapInterval = AROS_GL_SetSwapInterval;
+			device->GL_GetSwapInterval = AROS_GL_GetSwapInterval;
+			device->GL_SwapWindow = AROS_GL_SwapWindow;
+			device->GL_DeleteContext = AROS_GL_DeleteContext;
+			device->SetClipboardText = AROS_SetClipboardText;
+			device->GetClipboardText = AROS_GetClipboardText;
+			device->HasClipboardText = AROS_HasClipboardText;
+			device->SetWindowResizable = AROS_SetWindowResizable;
+			device->GetWindowBordersSize = AROS_GetWindowBordersSize;
+			device->SetWindowOpacity = AROS_SetWindowOpacity;
+			device->FlashWindow = AROS_FlashWindow;
+			//device->SetWindowHitTest = AROS_SetWindowHitTest;
+			device->free = AROS_DeleteDevice;
+
+			D(bug("[SDL2:arosvideo] %s: instance @ 0x%p\n", __func__, device));
+			return device;
+		}
+
+		SDL_free(device);
+	}
+
+	SDL_OutOfMemory();
+
+	D(bug("[SDL2:arosvideo] %s: returning NULL\n", __func__));
+
+	return NULL;
+}
+
+VideoBootStrap AROS_bootstrap = {
+	"aros", "SDL AROS Cgfx/AGL video driver",
+	AROS_CreateDevice,
+    AROS_ShowMessageBox
+};
diff -ruN SDL2-2.32.8/src/video/aros/SDL_arosvideo.h SDL2-2.32.8.aros/src/video/aros/SDL_arosvideo.h
--- SDL2-2.32.8/src/video/aros/SDL_arosvideo.h	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/video/aros/SDL_arosvideo.h	2025-07-28 18:33:52.250625135 +0000
@@ -0,0 +1,97 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifndef _SDL_arosvideo_h
+#define _SDL_arosvideo_h
+
+#include "SDL_keycode.h"
+
+#include "../SDL_sysvideo.h"
+#include "../../events/SDL_mouse_c.h"
+
+#include "SDL_arosclipboard.h"
+#include "SDL_aroswindow.h"
+
+#ifndef EXEC_PORTS_H
+#include <exec/ports.h>
+#endif
+
+#ifndef LIBRARIES_COMMODITIES_H
+#include <libraries/commodities.h>
+#endif
+
+/* Private display data */
+
+struct DiskObject;
+
+typedef struct SDL_VideoData
+{
+	struct MsgPort ScreenNotifyPort;
+	struct MsgPort BrokerPort;
+	struct MsgPort WBPort;
+	struct MsgPort WinPort;
+
+	size_t ScrNotifySig, BrokerSig, WBSig, WinSig;
+
+	struct Screen *WScreen;
+	struct Screen *CustomScreen;
+
+	struct MinList windowlist;
+
+	SDL_Cursor *CurrentPointer;
+	ULONG sdlpixfmt;
+
+	ULONG coltab[256];
+	UBYTE gammatable[3][256];
+
+	LONG ScreenSaverSuspendCount;
+
+	APTR ScreenNotifyHandle;
+
+	CONST_STRPTR FullAppName;
+	struct DiskObject *AppIcon;
+
+	APTR AppIconRef;
+	APTR BrokerRef;
+
+	struct NewBroker AppBroker;
+
+	// Screen information
+	size_t ScrWidth, ScrHeight, ScrDepth;
+	CONST_STRPTR ScrMonName;
+
+	SDL_VideoDevice *VideoDevice;
+
+	BYTE FullScreen;
+	BYTE vsyncEnabled;
+	
+} SDL_VideoData;
+
+/* SDL functions */
+extern void AROS_CloseDisplay(_THIS);
+extern void AROS_HideApp(_THIS, size_t with_app_icon);
+extern void AROS_ShowApp(_THIS);
+
+/* Non-SDL functions */
+extern size_t getv(APTR obj, size_t attr);
+
+#endif /* _SDL_arosvideo_h */
diff -ruN SDL2-2.32.8/src/video/aros/SDL_aroswindow.c SDL2-2.32.8.aros/src/video/aros/SDL_aroswindow.c
--- SDL2-2.32.8/src/video/aros/SDL_aroswindow.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/video/aros/SDL_aroswindow.c	2025-07-28 21:17:26.398345333 +0000
@@ -0,0 +1,1079 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+//#define DEBUG 1
+#include <aros/debug.h>
+
+#include "../../SDL_internal.h"
+
+#include "SDL_hints.h"
+#include "SDL_syswm.h"
+#include "SDL_timer.h"
+#include "SDL_version.h"
+#include "../SDL_sysvideo.h"
+#include "../SDL_pixels_c.h"
+#include "../../core/morphos/SDL_misc.h"
+#include "../../events/SDL_keyboard_c.h"
+#include "../../events/SDL_events_c.h"
+#include "../../events/SDL_mouse_c.h"
+
+#include "SDL_arosvideo.h"
+#include "SDL_arosmodes.h"
+#include "SDL_arosmouse.h"
+#include "SDL_arosopengl.h"
+#include "SDL_arosevents.h"
+
+#include <sys/param.h>
+
+#include <intuition/extensions.h>
+#if !defined(__AROS__)
+#include <libraries/charsets.h>
+#endif
+#include <proto/alib.h>
+#include <proto/exec.h>
+#include <proto/gadtools.h>
+#include <proto/graphics.h>
+#include <proto/intuition.h>
+#include <proto/wb.h>
+#include <proto/dos.h>
+
+#if defined(__AROS__)
+#include <string.h>
+#include <math.h>
+#define MOSWIN_TAGTYPE	IPTR
+#else
+#define MOSWIN_TAGTYPE	size_t
+#endif
+
+struct NewMenu SDL_NewMenu[] =
+{
+	{ NM_TITLE, (char *)"Project", 0, 0, 0, (APTR)MID_PROJECT },
+	{ NM_ITEM , (char *)"About...", (const STRPTR)"A", 0, 0, (APTR)MID_ABOUT },
+	{ NM_ITEM, NM_BARLABEL, NULL, 0, 0, NULL },
+	{ NM_ITEM , (char *)"About Joystick", (const STRPTR)"J", 0, 0, (APTR)MID_JOYSTICK},
+	{ NM_ITEM , (char *)"About System", (const STRPTR)"S", 0, 0, (APTR)MID_ABOUTSYS},
+	{ NM_ITEM, NM_BARLABEL, NULL, 0, 0, NULL },
+	{ NM_ITEM , (char *)"Hide", (const STRPTR)"H", 0, 0, (APTR)MID_HIDE },
+	{ NM_ITEM, NM_BARLABEL, NULL, 0, 0, NULL },
+	{ NM_ITEM , (char *)"Quit", (const STRPTR)"Q", 0, 0, (APTR)MID_QUIT},
+	{ NM_TITLE, (char *)"Options", 0, 0, 0, (APTR)MID_OPTIONS },
+	{ NM_ITEM , (char *)"Mute Sound", (const STRPTR)"M", (CHECKIT | MENUTOGGLE), 0, (APTR)MID_MUTE},
+	{ NM_ITEM , (char *)"Low CPU Priority", (const STRPTR)"P", (CHECKIT | MENUTOGGLE), 0, (APTR)MID_PRIORITY},
+	{ NM_ITEM, NM_BARLABEL, NULL, 0, 0, NULL },
+	{ NM_ITEM, (char *)"HINT RENDER DRIVER", 0, 0, 0, (APTR)MID_RRENDER },
+	{ NM_SUB, (char *)"Default", 0, (CHECKED | CHECKIT | MENUTOGGLE), 0, (APTR)MID_RRAUTO },
+	{ NM_SUB, (char *)"OpenGL", 0, (CHECKIT | MENUTOGGLE), 0, (APTR)MID_RRGL },
+	{ NM_SUB, (char *)"Software", 0, (CHECKIT | MENUTOGGLE), 0, (APTR)MID_RRSOFT },
+	{ NM_ITEM, (char *)"HINT RENDER VSYNC", 0, 0, 0, (APTR)MID_RVSYNC },
+	{ NM_SUB, (char *)"Default", 0, (CHECKED | CHECKIT | MENUTOGGLE), 0, (APTR)MID_RVAUTO },
+	{ NM_SUB, (char *)"Enabled", 0, (CHECKIT | MENUTOGGLE), 0, (APTR)MID_RVENABLE },
+	{ NM_SUB, (char *)"Disabled", 0, (CHECKIT | MENUTOGGLE), 0, (APTR)MID_RVDISABLE },
+	{ NM_ITEM, (char *)"HINT RENDER SCALER", 0, 0, 0, (APTR)MID_RSCALER},
+	{ NM_SUB, (char *)"Default", 0, (CHECKED | CHECKIT | MENUTOGGLE), 0, (APTR)MID_AUTO },
+	{ NM_SUB, (char *)"Nearest", 0, (CHECKIT | MENUTOGGLE), 0, (APTR)MID_NEAREST },
+	{ NM_SUB, (char *)"Linear", 0, (CHECKIT | MENUTOGGLE), 0, (APTR)MID_LINEAR },
+	{ NM_ITEM, (char *)"HINT RENDER LOGICAL SIZE", 0, 0, 0, (APTR)MID_LLOGICAL},
+	{ NM_SUB, (char *)"Default", 0, (CHECKED | CHECKIT | MENUTOGGLE), 0, (APTR)MID_LAUTO },
+	{ NM_SUB, (char *)"Letterbox / sidebars", 0, (CHECKIT | MENUTOGGLE), 0, (APTR)MID_LLETTER },
+	{ NM_SUB, (char *)"Overscan", 0, (CHECKIT | MENUTOGGLE), 0, (APTR)MID_LOVERS },
+	{ NM_ITEM, (char *)"HINT RENDER BATCHING", 0, 0, 0, (APTR)MID_RBATCHING },
+	{ NM_SUB, (char *)"Default", 0, (CHECKED | CHECKIT | MENUTOGGLE), 0, (APTR)MID_BAUTO },
+	{ NM_SUB, (char *)"Enabled", 0, (CHECKIT | MENUTOGGLE), 0, (APTR)MID_BENABLE },
+	{ NM_SUB, (char *)"Disabled", 0, (CHECKIT | MENUTOGGLE), 0, (APTR)MID_BDISABLE },
+	{ NM_ITEM, (char *)"HINT RENDER LINE METHOD", 0, 0, 0, (APTR)MID_RMETHOD },
+	{ NM_SUB, (char *)"Default", 0, (CHECKED | CHECKIT | MENUTOGGLE), 0, (APTR)MID_MDEF },
+	{ NM_SUB, (char *)"Point API", 0, (CHECKIT | MENUTOGGLE), 0, (APTR)MID_MPOINT },
+	{ NM_SUB, (char *)"Line API", 0, (CHECKIT | MENUTOGGLE), 0, (APTR)MID_MLINE },
+	{ NM_SUB, (char *)"Geometry API", 0, (CHECKIT | MENUTOGGLE), 0, (APTR)MID_MGEO },
+	{ NM_ITEM, (char *)"HINT RENDER SHADERS", 0, 0, 0, (APTR)MID_SHADERS },
+	{ NM_SUB, (char *)"Default", 0, (CHECKED | CHECKIT | MENUTOGGLE), 0, (APTR)MID_SHADERS_AUTO },
+	{ NM_SUB, (char *)"Enabled", 0, (CHECKIT | MENUTOGGLE), 0, (APTR)MID_SHADERS_ENABLE },
+	{ NM_SUB, (char *)"Disabled", 0, (CHECKIT | MENUTOGGLE), 0, (APTR)MID_SHADERS_DISABLE },
+	{ NM_END , NULL, NULL, 0, 0, NULL }
+};
+
+static void 
+AROS_CloseWindowSafely(SDL_Window *sdlwin, struct Window *win)
+{
+	D(bug("[SDL2:aroswindow] %s()\n", __func__));
+
+	if (SDL_GetKeyboardFocus() == sdlwin)
+		SDL_SetKeyboardFocus(NULL);
+
+	if (SDL_GetMouseFocus() == sdlwin)
+		SDL_SetMouseFocus(NULL);
+		
+    if ((sdlwin->flags & SDL_WINDOW_FOREIGN) == 0) {
+        struct IntuiMessage *msg, *tmp;
+
+        Forbid();
+
+        ForeachNodeSafe(&win->UserPort->mp_MsgList, msg, tmp)
+        {
+            if (msg->IDCMPWindow == win) {
+                REMOVE(&msg->ExecMessage.mn_Node);
+                ReplyMsg(&msg->ExecMessage);
+            }
+        }
+		SDL_WindowData *data = (SDL_WindowData *) sdlwin->driverdata;
+		if (data->menuactive == TRUE) {
+            ClearMenuStrip(win);
+            FreeMenus(data->menu);
+            data->menu = NULL;
+            FreeVisualInfo(data->menuvisualinfo);
+            data->menuvisualinfo = NULL;
+            data->menuactive = FALSE;
+        }
+
+        CloseWindow(win);
+
+        Permit();
+    }
+}
+
+void 
+AROS_CloseWindows(_THIS)
+{
+	D(bug("[SDL2:aroswindow] %s()\n", __func__));
+
+    SDL_VideoData *data = (SDL_VideoData *)_this->driverdata;
+    SDL_WindowData *wd;
+
+    ForeachNode(&data->windowlist, wd)
+    {
+        struct Window *win = wd->win;
+
+        if (win) {
+            wd->win = NULL;
+            AROS_CloseWindowSafely(wd->window, win);
+        }
+    }
+}
+
+void 
+AROS_OpenWindows(_THIS)
+{
+	D(bug("[SDL2:aroswindow] %s()\n", __func__));
+
+    SDL_VideoData *data = (SDL_VideoData *)_this->driverdata;
+    SDL_WindowData *wd;
+
+    ForeachNode(&data->windowlist, wd)
+    {
+        if (!(wd->window->flags & SDL_WINDOW_FOREIGN) && (wd->winflags & SDL_AROS_WINDOW_SHOWN)) {
+            if (wd->win == NULL) {
+                AROS_ShowWindow_Internal(_this, wd->window);
+            } else {
+                if ((wd->window->flags & SDL_WINDOW_FULLSCREEN_DESKTOP) == SDL_WINDOW_FULLSCREEN_DESKTOP) {
+                    AROS_RecreateWindow(_this, wd->window);
+                } else if (wd->winflags & SDL_AROS_WINDOW_FULLSCREEN_DESKTOP) {
+                    wd->winflags &= ~SDL_AROS_WINDOW_FULLSCREEN_DESKTOP;
+                    wd->window->flags &= ~SDL_WINDOW_FULLSCREEN_DESKTOP;
+                    AROS_RecreateWindow(_this, wd->window);
+                }
+            }
+        }
+    }
+}
+
+static int
+AROS_SetupWindowData(_THIS, SDL_Window *window, struct Window *win)
+{
+	D(bug("[SDL2:aroswindow] %s()\n", __func__));
+	
+	SDL_VideoData *data = (SDL_VideoData *) _this->driverdata;
+	SDL_WindowData *wd = SDL_calloc(1, sizeof(*wd));
+	
+	if (wd) {
+		window->driverdata = wd;
+		ADDHEAD(&data->windowlist, wd);
+		wd->bitmap = NULL;
+		wd->region = NULL;
+		wd->fb = NULL;
+		wd->window = window;
+		wd->win = win;
+		wd->__AGLCtx = NULL;
+		wd->grabbed = -1;
+		wd->sdlflags = 0;
+		wd->window_title = NULL;
+		wd->videodata = data;
+		wd->first_deltamove = 0;
+		wd->winflags = 0;
+		wd->appmsg = NULL;
+		wd->menu = NULL;     
+	    wd->menuvisualinfo = NULL;
+        wd->menuactive = FALSE;
+		if (win)
+			win->UserData = (APTR)wd;
+		else {
+			wd->old_w = 0;
+			wd->old_h = 0;
+			wd->old_x = 0;
+			wd->old_y = 0;
+		}
+	} else {
+		return SDL_OutOfMemory();
+	}
+
+	return 0;
+}
+
+int
+AROS_CreateWindow(_THIS, SDL_Window * window)
+{
+	return AROS_SetupWindowData(_this, window, NULL);
+}
+
+int
+AROS_CreateWindowFrom(_THIS, SDL_Window * window, const void *data)
+{
+	struct Window *win = (struct Window *)data;
+	size_t flags;
+
+	if (win->Title && win->Title != (APTR)-1)
+	{
+#if !defined(__AROS__)
+		window->title = AROS_ConvertText(win->Title, MIBENUM_SYSTEM, MIBENUM_UTF_8);
+#else
+		window->title = win->Title;
+#endif
+	}
+
+	flags = (window->flags | SDL_WINDOW_SHOWN | SDL_WINDOW_FOREIGN) & ~SDL_WINDOW_MINIMIZED;
+
+	if (win->Flags & WFLG_SIZEGADGET)
+		flags |= SDL_WINDOW_RESIZABLE;
+	else
+		flags &= ~SDL_WINDOW_RESIZABLE;
+
+	if (win->Flags & WFLG_BORDERLESS)
+		flags |= SDL_WINDOW_BORDERLESS;
+	else
+		flags &= ~SDL_WINDOW_BORDERLESS;
+
+	if (win->Flags & WFLG_WINDOWACTIVE) {
+		flags |= SDL_WINDOW_INPUT_FOCUS;
+		SDL_SetKeyboardFocus(window);
+	}
+
+	window->flags = flags;
+
+	return AROS_SetupWindowData(_this, window, win);
+}
+
+void
+AROS_SetWindowTitle(_THIS, SDL_Window * window)
+{
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+
+	if (data->win) {
+		APTR title = NULL;
+#if !defined(__AROS__)
+		APTR old = data->window_title;
+		title = AROS_ConvertText(window->title, MIBENUM_UTF_8, MIBENUM_SYSTEM);
+#else
+		title = window->title;
+#endif
+		D(bug("[SDL2:aroswindow] %s to %s (0x%08lx)\n", __FUNCTION__, window->title, title, data->win));
+		SetWindowTitles(data->win, title, title);
+#if !defined(__AROS__)
+		data->window_title = title;
+		SDL_free(old);
+#endif
+	}
+}
+
+void
+AROS_SetWindowIcon(_THIS, SDL_Window * window, SDL_Surface * icon)
+{
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+	D(bug("[SDL2:aroswindow] %s: wnd 0x%08lx - TODO convert this icon to appicon \n", __FUNCTION__, data->win));
+}
+
+void
+AROS_SetWindowPosition(_THIS, SDL_Window * window)
+{
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+
+	D(bug("[SDL2:aroswindow] %s: 0x%08lx\n", __FUNCTION__, data->win));
+
+	if (data->win) {
+		SDL_VideoData *vd = data->videodata;
+		size_t top = window->y;
+
+		top = MAX((vd->CustomScreen == NULL ? vd->WScreen->BarHeight + 1 : 0), top);
+
+		ChangeWindowBox(data->win, window->x, top, data->win->Width, data->win->Height);
+	}
+}
+
+void
+AROS_SetWindowMinimumSize(_THIS, SDL_Window * window)
+{
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+
+	D(bug("[SDL2:aroswindow] %s:  0x%08lx\n", __FUNCTION__, data->win));
+
+	if (data->win) {
+		SDL_VideoData *vd = data->videodata;
+		size_t min_h = window->min_h, min_w = window->min_w;
+
+		if ((window->flags & SDL_WINDOW_BORDERLESS) == 0) {
+			min_w += data->win->BorderLeft + data->win->BorderRight;
+			min_h += data->win->BorderTop + data->win->BorderBottom;
+		}
+
+		min_h = MIN(vd->WScreen->Height - (vd->CustomScreen == NULL ? vd->WScreen->BarHeight + 1 : 0), min_h);
+
+		WindowLimits(data->win, min_w, min_h, data->win->MaxWidth, MAX(data->win->MaxHeight, min_h));
+	}
+}
+
+void
+AROS_SetWindowMaximumSize(_THIS, SDL_Window * window)
+{
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+
+	D(bug("[SDL2:aroswindow] %s: 0x%08lx\n", __FUNCTION__, data->win));
+
+	if (data->win) {
+		SDL_VideoData *vd = data->videodata;
+		size_t max_h = window->max_h, max_w = window->max_w;
+
+		if ((window->flags & SDL_WINDOW_BORDERLESS) == 0) {
+			max_w += data->win->BorderLeft + data->win->BorderRight;
+			max_h += data->win->BorderTop + data->win->BorderBottom;
+		}
+
+		max_h = MIN(vd->WScreen->Height - (vd->CustomScreen == NULL ? vd->WScreen->BarHeight + 1 : 0), max_h);
+
+		WindowLimits(data->win, data->win->MinWidth, MIN(data->win->MinHeight, max_h), max_w, max_h);
+	}
+}
+
+void
+AROS_SetWindowSize(_THIS, SDL_Window * window)
+{
+	D(bug("[SDL2:aroswindow] %s()\n", __func__));
+
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+
+	if (data->win) {
+		SDL_VideoData *vd = data->videodata;
+		size_t h = window->h, w = window->w; 
+
+		if ((window->flags & SDL_WINDOW_BORDERLESS) == 0) {
+			w += data->win->BorderLeft + data->win->BorderRight;
+			h += data->win->BorderTop + data->win->BorderBottom;
+		}
+
+		h = MIN(vd->WScreen->Height - (vd->CustomScreen == NULL ? vd->WScreen->BarHeight + 1 : 0), h);
+
+		ChangeWindowBox(data->win, data->win->LeftEdge, data->win->TopEdge, w, h);
+	}
+}
+
+void
+AROS_WindowToFront(struct Window *win)
+{
+	D(bug("[SDL2:aroswindow] %s: wnd 0x%08lx\n", __FUNCTION__, win));
+
+	ActivateWindow(win);
+	WindowToFront(win);
+}
+
+char *AROS_getenv(const char *name)
+{
+	char *value = NULL;
+	char dummy[32];
+	size_t len;
+
+	if (GetVar((char *)name, dummy, sizeof(dummy), GVF_BINARY_VAR) == -1)
+	{
+		return NULL;
+	}
+	
+	len = IoErr() + 1;
+	
+	if ((value = SDL_malloc(len)))
+	{
+		if (GetVar((char *)name, value, len, GVF_GLOBAL_ONLY) == -1)
+		{
+			SDL_free(value);
+			value = NULL;
+		}
+	}
+	return value;
+}
+
+void
+AROS_ShowWindow_Internal(_THIS, SDL_Window * window) 
+{
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+	SDL_VideoData *vd = data->videodata;
+
+	D(bug("[SDL2:aroswindow] %s: wnd 0x%08lx, scr 0x%08lx\n", __FUNCTION__, data->win, vd->WScreen));
+
+	if (data->win == NULL && (data->sdlflags & SDL_WINDOW_MINIMIZED) == 0) {
+		struct Screen *scr;
+		size_t flags = WFLG_SIMPLE_REFRESH | WFLG_REPORTMOUSE | WFLG_ACTIVATE;
+		size_t w = window->w, h = window->h;
+		size_t min_w = window->min_w, min_h = window->min_h;
+		size_t left = window->x, top = window->y;
+
+		int maxheight, barheight = 0;
+		BYTE fullscreen = data->winflags & SDL_AROS_WINDOW_FULLSCREEN;
+		BYTE fs_desktop = data->winflags & SDL_AROS_WINDOW_FULLSCREEN_DESKTOP;
+		
+		SDL_bool win_resizable = (window->flags & SDL_WINDOW_RESIZABLE && !fullscreen);
+
+		data->winflags |= SDL_AROS_WINDOW_SHOWN;
+		
+		if (vd->WScreen == NULL)
+			AROS_GetScreen(vd->VideoDevice, vd->FullScreen, (window->flags & SDL_WINDOW_OPENGL) != 0);
+		
+		scr = vd->WScreen;
+		
+		size_t max_w = window->max_w ? window->max_w : (win_resizable ? scr->Width : w);
+		size_t max_h = window->max_h ? window->max_h : (win_resizable ? scr->Height : h);
+	
+		D(bug("[SDL2:aroswindow] %s: initial sizes %ld/%ld and max: %ld/%ld\n", __FUNCTION__, w, h, max_w, max_h));
+		D(bug("[SDL2:aroswindow] %s: screen 0x%08lx is %ld/%ld\n", __FUNCTION__, scr, scr->Width, scr->Height));
+
+		// Add border sizes
+		APTR di = GetScreenDrawInfo(scr);
+
+#if !defined(__AROS__)
+		if (vd->CustomScreen == NULL)
+			barheight = GetSkinInfoAttrA(di, SI_ScreenTitlebarHeight, NULL);
+#endif
+		FreeScreenDrawInfo(scr, di);
+
+		if (!fs_desktop)
+			maxheight = scr->Height - barheight;
+		else
+			maxheight = scr->Height;
+
+		if (fullscreen) {
+			w = scr->Width;
+			h = maxheight;
+			top = left = 0;
+		} else if (data->sdlflags & SDL_WINDOW_MAXIMIZED) { // Maximize window
+			int border_w = 0, border_h = 0;
+#if !defined(__AROS__)
+			border_w = GetSkinInfoAttrA(di, SI_BorderLeft    , NULL) + GetSkinInfoAttrA(di, SI_BorderRight, NULL);
+			border_h = GetSkinInfoAttrA(di, SI_BorderTopTitle, NULL) + GetSkinInfoAttrA(di, win_resizable ? SI_BorderBottomSize : SI_BorderBottom, NULL);
+#endif
+			D(bug("[SDL2:aroswindow] %s: Border width %ld, border height %ld, bar height %ld\n", __FUNCTION__, border_w, border_h, barheight));
+
+			max_w = MAX(w, max_w) - border_w;
+			max_h = MAX(h, max_h) - border_h;
+			max_h = MIN(maxheight - border_h, max_h);
+
+			left = 0;
+			top = barheight;
+
+			w = max_w;
+			h = max_h;
+
+			D(bug("[SDL2:aroswindow] %s: maximize to %ld/%ld\n", __FUNCTION__, w, h));
+		}
+
+		min_w = MIN(min_w, scr->Width);
+		min_h = MIN(min_h, maxheight);
+		max_w = MIN(max_w, scr->Width);
+		max_h = MIN(max_h, maxheight);
+		w = MAX(min_w, w);
+		h = MAX(min_h, h);
+
+		if (window->flags & SDL_WINDOW_BORDERLESS || fullscreen)
+			flags |= WFLG_BORDERLESS;
+		else
+			flags |= WFLG_DRAGBAR | WFLG_DEPTHGADGET | WFLG_CLOSEGADGET;
+
+		SDL_bool win_top = (window->flags & SDL_WINDOW_ALWAYS_ON_TOP && !fullscreen);
+		if (win_resizable)
+			flags |= WFLG_SIZEGADGET | WFLG_SIZEBBOTTOM;
+
+		if (fullscreen)
+			win_top = SDL_TRUE;
+		
+		if (data->window_title == NULL)
+		{
+#if !defined(__AROS__)
+			data->window_title = AROS_ConvertText(window->title, MIBENUM_UTF_8, MIBENUM_SYSTEM);
+#else
+			data->window_title = window->title;
+#endif
+		}
+		D(bug("[SDL2:aroswindow] %s: min %ld/%ld, normal %ld/%ld, max %ld/%ld\n", __FUNCTION__, min_w, min_h, w, h, max_w, max_h));
+
+		ULONG opacity_value = ((window->opacity) * (ULONG_MAX));
+		
+		data->win = OpenWindowTags(NULL,
+			WA_Left, left, WA_Top, top,
+			WA_InnerWidth, w,
+			WA_InnerHeight, h,
+			WA_MinWidth, win_resizable ? 32 : min_w,
+			WA_MinHeight, win_resizable ? 32 : min_h,
+			WA_MaxWidth, win_resizable ? -1 : max_w,
+			WA_MaxHeight, win_resizable ? -1 : max_h,
+			WA_Flags, flags,
+			vd->CustomScreen ? WA_CustomScreen : TAG_IGNORE, vd->CustomScreen,
+			vd->CustomScreen ? TAG_IGNORE : WA_PubScreen, vd->WScreen,
+			(window->flags & SDL_WINDOW_BORDERLESS || fullscreen) ? TAG_IGNORE : WA_ScreenTitle, data->window_title,
+			(window->flags & SDL_WINDOW_BORDERLESS || fullscreen) ? TAG_IGNORE : WA_Title, data->window_title,
+#if !defined(__AROS__)
+			data->region ? WA_TransparentRegion : TAG_IGNORE, data->region,
+			WA_UserPort, &vd->WinPort,
+			WA_Opacity, opacity_value,
+			WA_FrontWindow, win_top ? TRUE : FALSE,
+#endif
+			WA_AutoAdjust, TRUE,
+			WA_IDCMP, IDCMP_CLOSEWINDOW | IDCMP_RAWKEY | IDCMP_MOUSEMOVE | IDCMP_DELTAMOVE | IDCMP_MOUSEBUTTONS | IDCMP_REFRESHWINDOW | IDCMP_ACTIVEWINDOW | IDCMP_INACTIVEWINDOW | IDCMP_CHANGEWINDOW | IDCMP_GADGETUP | IDCMP_MENUPICK,
+			vd->CustomScreen ? TAG_IGNORE : WA_ExtraTitlebarGadgets, ETG_ICONIFY,
+			TAG_DONE);
+
+		if (data->win) {
+			if (IS_SYSTEM_CURSOR(vd->CurrentPointer)) {
+#if !defined(__AROS__)
+				MOSWIN_TAGTYPE pointertags[] = { WA_PointerType, vd->CurrentPointer == NULL ? POINTERTYPE_INVISIBLE : (MOSWIN_TAGTYPE)vd->CurrentPointer->driverdata, TAG_DONE };
+				SetAttrsA(data->win, (struct TagItem *)&pointertags);
+#endif
+			} else{
+				SDL_AROSCursor *ac = (SDL_AROSCursor *)vd->CurrentPointer;
+				if (ac->Pointer.mouseptr) {
+#if !defined(__AROS__)
+					SetWindowPointer(data->win, WA_Pointer, (MOSWIN_TAGTYPE)ac->Pointer.mouseptr,TAG_DONE);
+#endif
+				}
+			}
+
+			data->curr_x = data->win->LeftEdge;
+			data->curr_y = data->win->TopEdge;
+			data->curr_w = data->win->Width;
+			data->curr_h = data->win->Height;
+			data->first_deltamove = TRUE;
+            data->menuactive = FALSE;
+            data->win->UserData = (APTR)data;
+
+			/* Menu */
+            if (!fullscreen) {
+                data->menuvisualinfo = GetVisualInfoA(vd->WScreen, NULL);
+                if (data->menuvisualinfo) {
+                    data->menu = CreateMenusA(SDL_NewMenu, NULL);
+                    if (data->menu) {
+                        if (!LayoutMenusA(data->menu, data->menuvisualinfo, NULL)) {
+                            ClearMenuStrip(data->win);
+                            FreeMenus(data->menu);
+                            FreeVisualInfo(data->menuvisualinfo);
+                            data->menuactive = FALSE;
+                        } else {
+                            data->menuactive = TRUE;
+                        }
+                    } else {
+                        FreeVisualInfo(data->menuvisualinfo);
+                        data->menuactive = FALSE;
+                    }
+                }
+            } else {
+			//	D("[SDL2:aroswindow] Screen to Front\n", __FUNCTION__);
+				ScreenToFront(vd->CustomScreen);
+			}
+
+            if (data->menuactive == TRUE) {
+				if (SetMenuStrip(data->win, data->menu)) {
+					char *val = AROS_getenv("SDL_THREAD_PRIORITY_POLICY");
+					if (val && strlen(val)>0 && strcmp(val, "-1")==0) {
+						SDL_SetThreadPriority(SDL_THREAD_PRIORITY_LOW);
+						AROS_GlobalMenu(data->menu, 1, 1, 0, 1);
+					}
+					val = AROS_getenv("SDL_RENDER_DRIVER");
+					if (val && strlen(val)>0) {					
+						AROS_GlobalMenu(data->menu, 1, 3, 0, 0);
+						AROS_GlobalMenu(data->menu, 1, 3, 1, (strcmp(val, "opengl")==0 ? 1 : 0));
+						AROS_GlobalMenu(data->menu, 1, 3, 2, (strcmp(val, "opengl")==0 ? 0 : 1));
+						SDL_SetHint(SDL_HINT_RENDER_DRIVER, (strcmp(val, "opengl")==0 ? "opengl" : "software"));
+					}
+					val = AROS_getenv("SDL_RENDER_VSYNC");
+					if (val && strlen(val)>0) {
+						AROS_GlobalMenu(data->menu, 1, 4, 0, 0);
+						AROS_GlobalMenu(data->menu, 1, 4, 1, (strcmp(val, "1")==0 ? 1 : 0));
+						AROS_GlobalMenu(data->menu, 1, 4, 2, (strcmp(val, "1")==0 ? 0 : 1));
+						SDL_SetHint(SDL_HINT_RENDER_VSYNC, (strcmp(val, "1")==0 ? "1" :"0"));
+					}
+					val = AROS_getenv("SDL_RENDER_SCALE_QUALITY");
+					if (val && strlen(val)>0) {
+						AROS_GlobalMenu(data->menu, 1, 5, 0, 0);
+						AROS_GlobalMenu(data->menu, 1, 5, 1, (strcmp(val, "nearest")==0 ? 1 : 0));
+						AROS_GlobalMenu(data->menu, 1, 5, 2, (strcmp(val, "nearest")==0 ? 0 : 1));
+						SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, (strcmp(val, "nearest")==0 ? "nearest" : "linear"));
+					}
+					val = AROS_getenv("SDL_RENDER_LOGICAL_SIZE_MODE");
+					if (val && strlen(val)>0) {
+						AROS_GlobalMenu(data->menu, 1, 6, 0, 0);
+						AROS_GlobalMenu(data->menu, 1, 6, 1, (strcmp(val, "0")==0 ? 1 : 0));
+						AROS_GlobalMenu(data->menu, 1, 6, 2, (strcmp(val, "0")==0 ? 0 : 1));
+						SDL_SetHint(SDL_HINT_RENDER_LOGICAL_SIZE_MODE, (strcmp(val, "0")==0 ? "0" : "1"));
+					}
+					val = AROS_getenv("SDL_RENDER_BATCHING");
+					if (val && strlen(val)>0) {
+						AROS_GlobalMenu(data->menu, 1, 7, 0, 0);
+						AROS_GlobalMenu(data->menu, 1, 7, 1, (strcmp(val, "0")==0 ? 1 : 0));
+						AROS_GlobalMenu(data->menu, 1, 7, 2, (strcmp(val, "0")==0 ? 0 : 1));
+						SDL_SetHint(SDL_HINT_RENDER_BATCHING, (strcmp(val, "0")==0 ? "0" : "1"));
+					}
+					val = AROS_getenv("SDL_RENDER_LINE_METHOD");
+					if (val && strlen(val)>0) {
+						AROS_GlobalMenu(data->menu, 1, 8, 0, 0);
+						AROS_GlobalMenu(data->menu, 1, 8, 1, (strcmp(val, "1")==0 ? 1 : 0));
+						AROS_GlobalMenu(data->menu, 1, 8, 2, (strcmp(val, "2")==0 ? 1 : 0));
+						AROS_GlobalMenu(data->menu, 1, 8, 3, (strcmp(val, "3")==0 ? 1 : 0));
+						SDL_SetHint(SDL_HINT_RENDER_LINE_METHOD, (strcmp(val, "1")==0 ? "1" : (strcmp(val, "2")==0 ? "2" : "3")));
+					}
+					val = AROS_getenv("SDL_RENDER_OPENGL_SHADERS");
+					if (val && strlen(val)>0) {
+						AROS_GlobalMenu(data->menu, 1, 9, 0, 0);
+						AROS_GlobalMenu(data->menu, 1, 9, 1, (strcmp(val, "1")==0 ? 1 : 0));
+						AROS_GlobalMenu(data->menu, 1, 9, 2, (strcmp(val, "0")==0 ? 1 : 0));
+						SDL_SetHint(SDL_HINT_RENDER_OPENGL_SHADERS, (strcmp(val, "0")==0 ? "0" : "1"));
+					}
+				}
+			}
+			
+			if (!data->appmsg) {
+				data->appmsg = AddAppWindow(0, (IPTR)window, data->win, &vd->WBPort, TAG_DONE);
+				if (!data->appmsg)
+				{
+					D(bug("[SDL2:aroswindow] %s: ERROR AddAppWindow \n", __FUNCTION__));
+				}
+			}
+			
+#if !defined(__AROS__)
+			if (data->grabbed > 0)
+				DoMethod((Object *)data->win, WM_ObtainEvents);
+#endif
+		}
+		
+	} else if (data->win) {
+		AROS_WindowToFront(data->win);
+	}
+}
+
+void
+AROS_ShowWindow(_THIS, SDL_Window *window)
+{
+	D(bug("[SDL2:aroswindow] %s()\n", __func__));
+
+	AROS_ShowWindow_Internal(_this, window);
+}
+
+void
+AROS_HideWindow(_THIS, SDL_Window *window)
+{
+	D(bug("[SDL2:aroswindow] %s()\n", __func__));
+
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+	
+	if (data->win) {
+		data->winflags &= ~SDL_AROS_WINDOW_SHOWN;
+		AROS_CloseWindowSafely(window, data->win);
+		data->win = NULL;
+	}
+	
+}
+
+void
+AROS_RaiseWindow(_THIS, SDL_Window * window)
+{
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+
+	D(bug("[SDL2:aroswindow] %s: wnd 0x%08lx\n", __FUNCTION__, data->win));
+
+	if (data->win)
+		AROS_WindowToFront(data->win);
+}
+
+void
+AROS_MaximizeWindow(_THIS, SDL_Window * window)
+{
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+	SDL_VideoData *vd = (SDL_VideoData *) data->videodata;
+
+	D(bug("[SDL2:aroswindow] %s: wnd 0x%08lx - w=%d, h=%d\n", __FUNCTION__, data->win, data->win->MaxWidth, data->win->MaxHeight));
+	
+	if (data->win && window->flags & SDL_WINDOW_RESIZABLE) {
+		
+		data->sdlflags |=  SDL_WINDOW_MAXIMIZED;
+		data->sdlflags &= ~SDL_WINDOW_MINIMIZED;
+		
+		ChangeWindowBox(data->win, 0, (vd->CustomScreen == NULL ? data->win->WScreen->BarHeight + 1 : 0), data->win->MaxWidth, data->win->MaxHeight);
+	}
+}
+
+void
+AROS_MinimizeWindow(_THIS, SDL_Window * window)
+{
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+
+	D(bug("[SDL2:aroswindow] %s: wnd 0x%08lx\n", __FUNCTION__, data->win));
+
+	data->sdlflags |=  SDL_WINDOW_MINIMIZED;
+	data->sdlflags &= ~SDL_WINDOW_MAXIMIZED;
+
+	AROS_HideWindow(_this, window);
+}
+
+void
+AROS_RestoreWindow(_THIS, SDL_Window * window)
+{
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+
+	D(bug("[SDL2:aroswindow] %s: wnd 0x%08lx\n", __FUNCTION__, data->win));
+
+	if (data->win) {
+		data->sdlflags &= ~(SDL_WINDOW_MINIMIZED | SDL_WINDOW_MAXIMIZED);
+
+		ChangeWindowBox(data->win, window->x, window->y, window->w, window->h);
+		AROS_WindowToFront(data->win);
+	}
+}
+
+void
+AROS_SetWindowFullscreen(_THIS, SDL_Window * window, SDL_VideoDisplay * _display, SDL_bool fullscreen)
+{
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+	SDL_VideoData *vd = data->videodata;
+
+	if (fullscreen) {
+		data->winflags |= SDL_AROS_WINDOW_FULLSCREEN;
+		if ((window->flags & SDL_WINDOW_FULLSCREEN_DESKTOP) == SDL_WINDOW_FULLSCREEN_DESKTOP) {
+			data->winflags |= SDL_AROS_WINDOW_FULLSCREEN_DESKTOP;
+		}	
+		int ww, hh;
+		SDL_GetWindowSize(window, &ww, &hh);
+		
+		data->old_x = data->curr_x;
+		data->old_y = data->curr_y;
+		data->old_w = ww;
+		data->old_h = hh;
+
+		D(bug("[SDL2:aroswindow] %s: Save actual position %d,%d and size %d,%d\n", __FUNCTION__, data->old_x, data->old_y, data->old_w, data->old_h));
+		
+	} else {
+		
+		data->winflags &= ~SDL_AROS_WINDOW_FULLSCREEN;
+
+		if ((data->old_w && data->old_h) && (data->old_w != data->curr_w && data->old_h != data->curr_h)) {
+			D(bug("[SDL2:aroswindow] %s: Change position %d,%d and size %d,%d\n", __FUNCTION__, data->old_x, data->old_y, data->old_w, data->old_h));
+			window->x = data->old_x;
+			window->y = data->old_y;
+			window->w = data->old_w;
+			window->h = data->old_h;
+			data->old_w = 0;
+			data->old_h = 0;
+			data->old_x = 0;
+			data->old_y = 0;		
+		}
+
+	}
+	vd->FullScreen = fullscreen;
+
+	AROS_OpenWindows(_this);
+	
+	if (data->__AGLCtx) AROS_GL_ResizeContext(_this, window);
+}
+
+int
+AROS_SetWindowGammaRamp(_THIS, SDL_Window * window, const Uint16 * ramp)
+{
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+	SDL_VideoData *vd = data->videodata;
+	int i;
+
+	for (i = 0; i < 256; i++) {
+		vd->gammatable[0][i] = ramp[0*256 + i] >> 8;
+		vd->gammatable[1][i] = ramp[1*256 + i] >> 8;
+		vd->gammatable[2][i] = ramp[2*256 + i] >> 8;
+	}
+
+	if (vd->CustomScreen) {
+		SetAttrs(vd->CustomScreen,
+			SA_GammaRed,   (IPTR)vd->gammatable[0],
+			SA_GammaGreen, (IPTR)vd->gammatable[1],
+			SA_GammaBlue,  (IPTR)vd->gammatable[2],
+			TAG_DONE);
+	}
+
+	return 0;
+}
+
+void
+AROS_SetWindowGrab(_THIS, SDL_Window * window, SDL_bool grabbed)
+{
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+
+	if (data->win && data->grabbed != (grabbed ? 1 : 0)) {
+		D(bug("[SDL2:aroswindow] %s: %s\n", __FUNCTION__, grabbed ? "grabbed" : "not grabbed"));
+
+		data->grabbed = grabbed ? 1 : 0;
+
+		if (grabbed && (data->win->Flags & WFLG_WINDOWACTIVE) == 0)
+			AROS_WindowToFront(data->win);
+#if !defined(__AROS__)
+		DoMethod((Object *)data->win, grabbed ? WM_ObtainEvents : WM_ReleaseEvents);
+#endif
+	}
+}
+
+void
+AROS_DestroyWindow(_THIS, SDL_Window * window)
+{
+	D(bug("[SDL2:aroswindow] %s()\n", __func__));
+
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+	
+	window->driverdata = NULL;
+
+	if (data) {
+		SDL_VideoData *videodata = (SDL_VideoData *) data->videodata;
+
+		if (data->__AGLCtx)
+			AROS_GL_DeleteContext(_this, data->__AGLCtx);
+		REMOVE(&data->node);
+
+		if (data->win) {
+			AROS_CloseWindowSafely(window, data->win);
+			data->win = NULL;
+		}
+		if (data->region)
+			DisposeRegion(data->region);
+
+		if (IsListEmpty((struct List *)&videodata->windowlist)) {
+			D(bug("[SDL2:aroswindow] %s: Was last window... get rid of screen.\n", __FUNCTION__));
+			AROS_CloseDisplay(_this);
+		}
+
+#if (0)
+		SDL_free(data->window_title);
+#endif
+		SDL_free(data);
+	}
+}
+
+SDL_bool
+AROS_GetWindowWMInfo(_THIS, SDL_Window * window, struct SDL_SysWMinfo * info)
+{
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+
+	if (info->version.major >= SDL_MAJOR_VERSION) {
+		info->subsystem = SDL_SYSWM_AROS;
+		info->info.intui.window = data->win;
+		return SDL_TRUE;
+	} else {
+		SDL_SetError("Application not compiled with SDL %d\n", SDL_MAJOR_VERSION);
+		return SDL_FALSE;
+	}
+}
+
+static void 
+AROS_CloseWindow(SDL_Window *window)
+{
+    SDL_WindowData *data = (SDL_WindowData *)window->driverdata;
+	D(bug("[SDL2:aroswindow] %s: 0x%08lx\n", __FUNCTION__, data->win));
+
+    if (data->win) {
+        if (data->appmsg) {
+            if (RemoveAppWindow(data->appmsg)) {
+                data->appmsg = NULL;
+            }
+        }
+
+		struct Window *win = data->win;
+        if (data->menuactive == TRUE) {
+            ClearMenuStrip(win);
+            FreeMenus(data->menu);
+            data->menu = NULL;
+            FreeVisualInfo(data->menuvisualinfo);
+            data->menuvisualinfo = NULL;
+            data->menuactive = FALSE;
+        }
+        CloseWindow(win);
+        data->win = NULL;
+    }
+}
+
+void 
+AROS_RecreateWindow(_THIS, SDL_Window * window)
+{
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+	D(bug("[SDL2:aroswindow] %s: 0x%08lx\n", __FUNCTION__, data->win));
+	
+    if (window->flags & SDL_WINDOW_FOREIGN) {
+		D(bug("[SDL2:aroswindow] %s: Cannot modify native window '%s'\n", __FUNCTION__, window->title));
+        return;
+    }
+
+    if (data->win) {
+		D(bug("[SDL2:aroswindow] %s: Closing system window '%s' before re-creation\n", __FUNCTION__, window->title));
+        AROS_CloseWindow(window);
+    }
+
+    AROS_ShowWindow_Internal(_this, window);
+
+    if (data->win) { // Make sure the new window is active
+        AROS_ShowWindow(_this, window);
+    }
+}
+
+void
+AROS_SetWindowAlwaysOnTop(_THIS, SDL_Window * window, SDL_bool on_top)
+{
+	D(bug("[SDL2:aroswindow] %s()\n", __func__));
+
+	AROS_RecreateWindow(_this, window);
+}
+
+/* int
+AROS_SetWindowHitTest(SDL_Window *window, SDL_bool enabled)
+{
+    return 0;
+}*/
+
+void
+AROS_SetWindowResizable(_THIS, SDL_Window * window, SDL_bool resizable)
+{
+	D(bug("[SDL2:aroswindow] %s()\n", __func__));
+
+	AROS_RecreateWindow(_this, window);
+}
+
+void
+AROS_SetWindowBordered(_THIS, SDL_Window * window, SDL_bool bordered)
+{
+	D(bug("[SDL2:aroswindow] %s()\n", __func__));
+
+	AROS_RecreateWindow(_this, window);
+}
+
+static SDL_bool
+AROS_SetWindowOpacityPrivate(_THIS, SDL_Window * window, ULONG value)
+{
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+	
+	LONG ret = 0;
+#if !defined(__AROS__)
+	ret = SetAttrs(data->win, WA_Opacity, value, TAG_DONE);
+#endif
+	if (ret) {
+		D(bug("[SDL2:aroswindow] %s: Failed to set window opaqueness to %lu\n", __FUNCTION__, value));
+		return SDL_FALSE;
+	}
+
+	return SDL_TRUE;
+}
+
+int
+AROS_SetWindowOpacity(_THIS, SDL_Window * window, float opacity)
+{
+    SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+	if (!data->win) 
+		return 0;
+	
+    ULONG value = ((opacity) * (ULONG_MAX));
+
+	D(bug("[SDL2:aroswindow] %s: set window opaqueness to %lu\n", __FUNCTION__, value));
+	int ret = 0;
+#if !defined(__AROS__)
+	ret = AROS_SetWindowOpacityPrivate(_this, window, value) ? 0 : -1;
+#endif
+    return ret;
+}
+
+static void
+AROS_FlashOperationPrivate(_THIS, SDL_Window * window)
+{
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+    if (data->win) {
+
+		ULONG value_old = 0;
+#if !defined(__AROS__)
+		value_old = getv(data->win, WA_Opacity);
+#endif
+		WindowToFront(data->win);
+		const Uint32 start = SDL_GetTicks();
+		ULONG elapsed = 0;
+		ULONG value = 0;
+		
+		while (TRUE) {
+			elapsed = SDL_GetTicks() - start;
+			if (elapsed > 200) break;
+			value = 128 + 127 * sinf(elapsed * 3.14159f / 50.0f) * (ULONG_MAX);
+			AROS_SetWindowOpacityPrivate(_this, window, value);	
+			SDL_Delay(1);
+		}
+		
+		ActivateWindow(data->win);
+		AROS_SetWindowOpacityPrivate(_this, window, value_old);
+	}
+}
+
+int
+AROS_FlashWindow(_THIS, SDL_Window * window, SDL_FlashOperation operation)
+{
+	D(bug("[SDL2:aroswindow] %s()\n", __func__));
+
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+	if (!data->win) 
+		return 0;
+	
+	switch(operation)
+	{
+		case SDL_FLASH_BRIEFLY:
+		case SDL_FLASH_UNTIL_FOCUSED:
+			AROS_FlashOperationPrivate(_this, window);
+			break;
+		case SDL_FLASH_CANCEL:
+			break;
+	}
+	
+	return 0;
+}
+
+int
+AROS_GetWindowBordersSize(_THIS, SDL_Window * window, int *top, int *left, int *bottom, int *right)
+{
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+	
+	if (top)
+		*top = data->win->BorderTop;
+	
+	if (left)
+		*left = data->win->BorderLeft;
+	
+	if (bottom)
+		*bottom = data->win->BorderBottom;
+	
+	if (right)
+		*right = data->win->BorderRight;	
+	
+	return 0;
+}
diff -ruN SDL2-2.32.8/src/video/aros/SDL_aroswindow.h SDL2-2.32.8.aros/src/video/aros/SDL_aroswindow.h
--- SDL2-2.32.8/src/video/aros/SDL_aroswindow.h	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/video/aros/SDL_aroswindow.h	2025-07-28 18:04:23.689199026 +0000
@@ -0,0 +1,136 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifndef _SDL_aroswindow_h
+#define _SDL_aroswindow_h
+
+#ifndef EXEC_NODES_H
+#include <exec/nodes.h>
+#endif
+
+#include <GL/gla.h>
+#include <proto/gadtools.h>
+
+enum
+{
+	MID_PROJECT = 0x0010,
+	MID_ABOUT,
+	MID_JOYSTICK,
+	MID_ABOUTSYS,
+	MID_HIDE,
+	MID_QUIT,
+	MID_OPTIONS,
+	MID_MUTE,
+	MID_PRIORITY,
+	MID_RRENDER, MID_RRAUTO, MID_RRGL, MID_RRSOFT,
+	MID_RVSYNC, MID_RVAUTO, MID_RVENABLE, MID_RVDISABLE,
+	MID_RSCALER, MID_AUTO, MID_NEAREST, MID_LINEAR,
+	MID_LLOGICAL, MID_LAUTO, MID_LLETTER,MID_LOVERS,
+	MID_RBATCHING, MID_BAUTO, MID_BENABLE, MID_BDISABLE,
+	MID_SHADERS, MID_SHADERS_AUTO, MID_SHADERS_ENABLE, MID_SHADERS_DISABLE, 
+	MID_RMETHOD, MID_MDEF, MID_MPOINT, MID_MLINE, MID_MGEO
+};
+
+typedef struct
+{
+	Uint32 kludge1, kludge2, bpr, pixfmt;
+	Uint8 buffer[0];
+} SDL_Framebuffer;
+
+typedef struct
+{
+	struct MinNode node;
+
+	struct Region *region;
+	SDL_Framebuffer *fb;
+
+	SDL_Window *window;
+	struct Window *win;
+	struct AppWindow *appmsg;
+
+	// Localized window title, use SDL_free() to deallocate
+	char *window_title;
+
+	struct SDL_VideoData *videodata;
+
+	GLAContext *__AGLCtx;
+	
+	// Currently known window position and dimensions
+	LONG curr_x, curr_y, curr_w, curr_h;
+	int old_w, old_h, old_x, old_y;
+
+	// Flags that must be taken into account at AROS_ShowWindow()
+	Uint32 sdlflags;
+
+	BYTE grabbed;
+	BYTE first_deltamove;
+	BYTE winflags;
+	
+	APTR menuvisualinfo;
+	struct Menu *menu;
+	BOOL menuactive;
+	
+	struct BitMap *bitmap;
+	
+} SDL_WindowData;
+
+/* Is this window shown (not iconified) */
+#define SDL_AROS_WINDOW_SHOWN      (1 << 0)
+#define SDL_AROS_WINDOW_FULLSCREEN (1 << 1)
+#define SDL_AROS_WINDOW_FULLSCREEN_DESKTOP (1 << 2)
+
+/* SDL functions */
+extern int AROS_CreateWindow(_THIS, SDL_Window * window);
+extern int AROS_CreateWindowFrom(_THIS, SDL_Window * window, const void *data);
+extern void AROS_SetWindowTitle(_THIS, SDL_Window * window);
+extern void AROS_SetWindowIcon(_THIS, SDL_Window * window, SDL_Surface * icon);
+extern void AROS_SetWindowPosition(_THIS, SDL_Window * window);
+extern void AROS_SetWindowMinimumSize(_THIS, SDL_Window * window);
+extern void AROS_SetWindowMaximumSize(_THIS, SDL_Window * window);
+extern void AROS_SetWindowSize(_THIS, SDL_Window * window);
+extern void AROS_ShowWindow(_THIS, SDL_Window * window);
+extern void AROS_HideWindow(_THIS, SDL_Window * window);
+extern void AROS_RaiseWindow(_THIS, SDL_Window * window);
+extern void AROS_MaximizeWindow(_THIS, SDL_Window * window);
+extern void AROS_MinimizeWindow(_THIS, SDL_Window * window);
+extern void AROS_RestoreWindow(_THIS, SDL_Window * window);
+extern void AROS_SetWindowBordered(_THIS, SDL_Window * window, SDL_bool bordered);
+extern void AROS_SetWindowFullscreen(_THIS, SDL_Window * window, SDL_VideoDisplay * display, SDL_bool fullscreen);
+extern int AROS_SetWindowGammaRamp(_THIS, SDL_Window * window, const Uint16 * ramp);
+extern void AROS_SetWindowGrab(_THIS, SDL_Window * window, SDL_bool grabbed);
+extern void AROS_DestroyWindow(_THIS, SDL_Window * window);
+extern SDL_bool AROS_GetWindowWMInfo(_THIS, SDL_Window * window, struct SDL_SysWMinfo *info);
+extern void AROS_ShowWindow_Internal(_THIS, SDL_Window * window);
+extern void AROS_SetWindowAlwaysOnTop(_THIS, SDL_Window * window, SDL_bool on_top);
+extern void AROS_SetWindowResizable (_THIS, SDL_Window * window, SDL_bool resizable);
+extern int AROS_SetWindowOpacity(_THIS, SDL_Window * window, float opacity);
+extern int AROS_GetWindowBordersSize(_THIS, SDL_Window * window, int * top, int * left, int * bottom, int * right);
+extern int AROS_FlashWindow(_THIS, SDL_Window * window, SDL_FlashOperation);
+//extern int AROS_SetWindowHitTest(SDL_Window *window, SDL_bool enabled);
+
+/* Non-SDL functions */
+extern void AROS_CloseWindows(_THIS);
+extern void AROS_OpenWindows(_THIS);
+extern void AROS_RecreateWindow(_THIS, SDL_Window * window);
+extern void AROS_WindowToFront(struct Window *win);
+
+#endif /* _SDL_aroswindow_h */
diff -ruN SDL2-2.32.8/src/video/SDL_blit_N.c SDL2-2.32.8.aros/src/video/SDL_blit_N.c
--- SDL2-2.32.8/src/video/SDL_blit_N.c	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/src/video/SDL_blit_N.c	2025-07-27 14:24:21.448841405 +0000
@@ -67,6 +67,24 @@
 
     return result;
 }
+#elif defined(__MORPHOS__)
+#include <exec/system.h>
+#include <proto/exec.h>
+
+static size_t
+SDL_IsG5(void)
+{
+    size_t is_g5 = 0;
+    char *cpu_family;
+
+    if (NewGetSystemAttrsA(&cpu_family, sizeof(cpu_family), SYSTEMINFOTYPE_CPUFAMILYNAME, NULL))
+    {
+        if (cpu_family && stricmp(cpu_family, "G5") == 0)
+            is_g5 = 1;
+    }
+
+    return is_g5;
+}
 #else
 static size_t GetL3CacheSize(void)
 {
@@ -896,8 +914,12 @@
                         /* Feature 2 is has-AltiVec */
                         | ((SDL_HasAltiVec()) ? BLIT_FEATURE_HAS_ALTIVEC : 0)
                         /* Feature 4 is dont-use-prefetch */
+#if defined(__MORPHOS__)
+                        | ((SDL_IsG5()) ? BLIT_FEATURE_ALTIVEC_DONT_USE_PREFETCH : 0));
+#else
                         /* !!!! FIXME: Check for G5 or later, not the cache size! Always prefetch on a G4. */
                         | ((GetL3CacheSize() == 0) ? BLIT_FEATURE_ALTIVEC_DONT_USE_PREFETCH : 0));
+#endif
         }
     }
     return features;
diff -ruN SDL2-2.32.8/src/video/SDL_sysvideo.h SDL2-2.32.8.aros/src/video/SDL_sysvideo.h
--- SDL2-2.32.8/src/video/SDL_sysvideo.h	2025-05-19 21:24:41.000000000 +0000
+++ SDL2-2.32.8.aros/src/video/SDL_sysvideo.h	2025-07-27 14:24:21.564841406 +0000
@@ -484,6 +484,9 @@
 extern VideoBootStrap NGAGE_bootstrap;
 extern VideoBootStrap OS2DIVE_bootstrap;
 extern VideoBootStrap OS2VMAN_bootstrap;
+extern VideoBootStrap MORPHOS_bootstrap;
+extern VideoBootStrap AROS_bootstrap;
+
 
 /* Use SDL_OnVideoThread() sparingly, to avoid regressions in use cases that currently happen to work */
 extern SDL_bool SDL_OnVideoThread(void);
diff -ruN SDL2-2.32.8/src/video/SDL_video.c SDL2-2.32.8.aros/src/video/SDL_video.c
--- SDL2-2.32.8/src/video/SDL_video.c	2025-05-19 21:24:41.000000000 +0000
+++ SDL2-2.32.8.aros/src/video/SDL_video.c	2025-07-28 17:45:23.655266063 +0000
@@ -132,6 +132,12 @@
 #ifdef SDL_VIDEO_DRIVER_EMSCRIPTEN
     &Emscripten_bootstrap,
 #endif
+#ifdef SDL_VIDEO_DRIVER_AROS
+    &AROS_bootstrap,
+#endif
+#ifdef SDL_VIDEO_DRIVER_MORPHOS
+    &MORPHOS_bootstrap,
+#endif
 #ifdef SDL_VIDEO_DRIVER_QNX
     &QNX_bootstrap,
 #endif
@@ -1314,6 +1320,10 @@
                 SDL_SendWindowEvent(window, SDL_WINDOWEVENT_RESIZED, fullscreen_mode.w, fullscreen_mode.h);
 #endif
             }
+#if defined(__MORPHOS__) || defined(__AROS__)
+            // Force window on new screen
+            _this->SetWindowFullscreen(_this, window, SDL_GetDisplayForWindow(window), SDL_TRUE);
+#endif
         }
     }
     return 0;
@@ -2701,6 +2711,9 @@
 #if defined(__EMSCRIPTEN__)
         attempt_texture_framebuffer = SDL_FALSE;
 #endif
+#if defined(__MORPHOS__) || defined(__AROS__)
+		attempt_texture_framebuffer = SDL_FALSE;
+#endif
     }
     return attempt_texture_framebuffer;
 }
@@ -3240,7 +3253,9 @@
 
 static SDL_bool ShouldMinimizeOnFocusLoss(SDL_Window *window)
 {
+#if !defined(__MORPHOS__) && !defined(__AROS__)
     const char *hint;
+#endif
 
     if (!(window->flags & SDL_WINDOW_FULLSCREEN) || window->is_destroying) {
         return SDL_FALSE;
@@ -3263,6 +3278,7 @@
     }
 #endif
 
+#if !defined(__MORPHOS__) && !defined(__AROS__)
     /* Real fullscreen windows should minimize on focus loss so the desktop video mode is restored */
     hint = SDL_GetHint(SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS);
     if (!hint || !*hint || SDL_strcasecmp(hint, "auto") == 0) {
@@ -3273,6 +3289,8 @@
             return SDL_TRUE;
         }
     }
+#endif
+
     return SDL_GetHintBoolean(SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS, SDL_FALSE);
 }
 
@@ -3341,7 +3359,12 @@
     /* Make no context current if this is the current context window */
     if (window->flags & SDL_WINDOW_OPENGL) {
         if (_this->current_glwin == window) {
+#if defined(__MORPHOS__) || defined(__AROS__)
+            // Hack to kill context before destroy window (in case when user doesnt call SDL_GL_DeleteContext !)
+            SDL_GL_DeleteContext(_this->current_glctx);
+#else
             SDL_GL_MakeCurrent(window, NULL);
+#endif
         }
     }
 
diff -ruN SDL2-2.32.8/test/checkkeys.c SDL2-2.32.8.aros/test/checkkeys.c
--- SDL2-2.32.8/test/checkkeys.c	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/test/checkkeys.c	2025-07-27 14:24:22.628841422 +0000
@@ -305,7 +305,8 @@
         loop();
     }
 #endif
-
+	SDL_DestroyRenderer(renderer);
+	SDL_DestroyWindow(window);
     SDL_Quit();
     return 0;
 }
diff -ruN SDL2-2.32.8/test/controllermap.c SDL2-2.32.8.aros/test/controllermap.c
--- SDL2-2.32.8/test/controllermap.c	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/test/controllermap.c	2025-07-27 14:24:22.668841422 +0000
@@ -741,6 +741,10 @@
         return 2;
     }
 
+#ifdef __MORPHOS__	
+	SDL_RenderClear(screen);
+#endif
+
     while (!done && SDL_NumJoysticks() == 0) {
         SDL_Event event;
 
@@ -802,7 +806,7 @@
 
     SDL_DestroyWindow(window);
 
-    SDL_QuitSubSystem(SDL_INIT_VIDEO | SDL_INIT_JOYSTICK);
+    SDL_Quit();
 
     return 0;
 }
diff -ruN SDL2-2.32.8/test/Makefile.mos SDL2-2.32.8.aros/test/Makefile.mos
--- SDL2-2.32.8/test/Makefile.mos	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/test/Makefile.mos	2025-07-27 14:24:22.708841423 +0000
@@ -0,0 +1,314 @@
+# Makefile to build the MorphOS SDL tests
+
+AR = ppc-morphos-ar
+CC	= ppc-morphos-gcc-11
+CFLAGS	= -noixemul -O2 -Wall -g -I../include -DHAVE_OPENGL
+LIBS	= -L. -lSDL2test -L../src/core/morphos/devenv/lib/ -lSDL2 -lGL -noixemul -lm
+
+TARGETS = \
+	checkkeys \
+	checkkeysthreads \
+	controllermap \
+	loopwave \
+	loopwavequeue \
+	testatomic \
+	testaudiocapture \
+	testaudiohotplug \
+	testaudioinfo \
+	testautomation \
+	testbounds \
+	testcustomcursor \
+	testdisplayinfo \
+	testdraw2 \
+	testdrawchessboard \
+	testdropfile \
+	testerror \
+	testfile \
+	testfilesystem \
+	testgamecontroller \
+	testgeometry \
+	testgesture \
+	testgl2 \
+	testgles \
+	testgles2 \
+	testhaptic \
+	testhittesting \
+	testhotplug \
+	testiconv \
+	testime \
+	testintersections \
+	testjoystick \
+	testkeys \
+	testloadso \
+	testlocale \
+	testlock \
+	testmessage \
+	testmouse \
+	testmultiaudio \
+	testoffscreen \
+	testoverlay2 \
+	testplatform \
+	testpower \
+	testqsort \
+	testrelative \
+	testrendercopyex \
+	testrendertarget \
+	testresample \
+	testrumble \
+	testscale \
+	testsem \
+	testshape \
+	testsprite2 \
+	testspriteminimal \
+	teststreaming \
+	testsurround \
+	testthread \
+	testtimer \
+	testurl \
+	testver \
+	testviewport \
+	testwm2 \
+	testyuv \
+	torturethread \
+	testnative 
+# testshader \
+
+CSRCS = SDL_test_assert.c SDL_test_common.c SDL_test_compare.c \
+        SDL_test_crc32.c SDL_test_font.c SDL_test_fuzzer.c SDL_test_harness.c \
+        SDL_test_imageBlit.c SDL_test_imageBlitBlend.c SDL_test_imageFace.c \
+        SDL_test_imagePrimitives.c SDL_test_imagePrimitivesBlend.c \
+        SDL_test_log.c SDL_test_md5.c SDL_test_random.c SDL_test_memory.c
+TESTLIB = libSDL2test.a
+COBJS = $(addprefix ../src/test/, $(CSRCS:.c=.o))
+
+all: $(TESTLIB) $(TARGETS)
+
+$(TESTLIB): $(COBJS)
+	$(AR) crvs $@ $^
+
+checkkeys: checkkeys.o
+	$(CC) -o $@ $^ $(LIBS)
+	
+checkkeysthreads: checkkeysthreads.o
+	$(CC) -o $@ $^ $(LIBS)
+
+controllermap: controllermap.o testutils.o
+	$(CC) -o $@ $^ $(LIBS)
+
+loopwave: loopwave.o testutils.o
+	$(CC) -o $@ $^ $(LIBS)
+
+loopwavequeue: loopwavequeue.o testutils.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testresample: testresample.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testaudioinfo: testaudioinfo.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testautomation: testautomation.o \
+		      testautomation_audio.o \
+		      testautomation_clipboard.o \
+		      testautomation_events.o \
+			  testautomation_guid.o \
+			  testautomation_joystick.o \
+		      testautomation_keyboard.o \
+			  testautomation_log.o \
+		      testautomation_main.o \
+			  testautomation_math.o \
+		      testautomation_mouse.o \
+		      testautomation_pixels.o \
+		      testautomation_platform.o \
+		      testautomation_rect.o \
+		      testautomation_render.o \
+		      testautomation_rwops.o \
+		      testautomation_sdltest.o \
+		      testautomation_stdlib.o \
+		      testautomation_subsystems.o \
+		      testautomation_surface.o \
+		      testautomation_syswm.o \
+		      testautomation_timer.o \
+		      testautomation_video.o \
+		      testautomation_hints.o
+	$(CC) -o $@ $^ $(LIBS) 
+
+testmultiaudio: testmultiaudio.o testutils.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testmouse: testmouse.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testaudiohotplug: testaudiohotplug.o testutils.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testaudiocapture: testaudiocapture.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testatomic: testatomic.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testintersections: testintersections.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testrelative: testrelative.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testhittesting: testhittesting.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testdraw2: testdraw2.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testdrawchessboard: testdrawchessboard.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testdropfile: testdropfile.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testerror: testerror.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testfile: testfile.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testgamecontroller: testgamecontroller.o testutils.o
+	$(CC) -o $@ $^ $(LIBS)
+ 
+testgeometry: testgeometry.o testutils.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testgesture: testgesture.o
+	$(CC) -o $@ $^ $(LIBS)
+ 
+testgl2: testgl2.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testgles: testgles.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testgles2: testgles2.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testhaptic: testhaptic.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testhotplug: testhotplug.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testrumble: testrumble.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testthread: testthread.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testiconv: testiconv.o testutils.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testime: testime.o testutils.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testjoystick: testjoystick.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testkeys: testkeys.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testlocale: testlocale.o
+	$(CC) -o $@ $^ $(LIBS)
+	
+testloadso: testloadso.o
+	$(CC) -o $@ $^ $(LIBS)
+	
+testsurround: testsurround.o
+	$(CC) -o $@ $^ $(LIBS)
+	
+testlock: testlock.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testnative: testnative.o testnativemorphos.o testutils.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testoffscreen: testoffscreen.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testoverlay2: testoverlay2.o testyuv_cvt.o testutils.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testplatform: testplatform.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testpower: testpower.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testfilesystem: testfilesystem.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testrendertarget: testrendertarget.o testutils.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testscale: testscale.o testutils.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testsem: testsem.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testsensor: testsensor.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testshader: testshader.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testshape: testshape.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testsprite2: testsprite2.o testutils.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testspriteminimal: testspriteminimal.o testutils.o
+	$(CC) -o $@ $^ $(LIBS)
+
+teststreaming: teststreaming.o testutils.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testtimer: testtimer.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testver: testver.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testviewport: testviewport.o testutils.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testwm2: testwm2.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testyuv: testyuv.o testyuv_cvt.o
+	$(CC) -o $@ $^ $(LIBS)
+
+torturethread: torturethread.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testrendercopyex: testrendercopyex.o testutils.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testmessage: testmessage.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testdisplayinfo: testdisplayinfo.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testqsort: testqsort.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testbounds: testbounds.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testcustomcursor: testcustomcursor.o
+	$(CC) -o $@ $^ $(LIBS)
+
+testurl: testurl.o
+	$(CC) -o $@ $^ $(LIBS)
+
+clean:
+	rm -f $(TARGETS) *.o $(COBJS) $(TESTLIB)
diff -ruN SDL2-2.32.8/test/testfile.c SDL2-2.32.8.aros/test/testfile.c
--- SDL2-2.32.8/test/testfile.c	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/test/testfile.c	2025-07-27 14:24:22.984841427 +0000
@@ -64,6 +64,11 @@
     SDL_RWops *rwops = NULL;
     char test_buf[30];
 
+    if (SDL_Init(0) == -1) {
+        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "SDL_Init() failed: %s\n", SDL_GetError());
+        return 1;
+    }
+
     /* Enable standard application logging */
     SDL_LogSetPriority(SDL_LOG_CATEGORY_APPLICATION, SDL_LOG_PRIORITY_INFO);
 
@@ -353,5 +358,8 @@
     rwops->close(rwops);
     SDL_Log("test5 OK\n");
     cleanup();
+
+    SDL_Quit();
+
     return 0; /* all ok */
 }
diff -ruN SDL2-2.32.8/test/testgamecontroller.c SDL2-2.32.8.aros/test/testgamecontroller.c
--- SDL2-2.32.8/test/testgamecontroller.c	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/test/testgamecontroller.c	2025-07-27 14:24:23.000841427 +0000
@@ -967,7 +967,7 @@
     CloseVirtualController();
     SDL_DestroyRenderer(screen);
     SDL_DestroyWindow(window);
-    SDL_QuitSubSystem(SDL_INIT_VIDEO | SDL_INIT_JOYSTICK | SDL_INIT_GAMECONTROLLER);
+    SDL_Quit();
 
     return 0;
 }
diff -ruN SDL2-2.32.8/test/testgl2.c SDL2-2.32.8.aros/test/testgl2.c
--- SDL2-2.32.8/test/testgl2.c	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/test/testgl2.c	2025-07-27 14:24:23.016841427 +0000
@@ -22,6 +22,9 @@
 
 #ifdef HAVE_OPENGL
 
+#ifdef __MORPHOS__
+#define _NO_PPCINLINE
+#endif
 #include "SDL_opengl.h"
 
 typedef struct GL_Context
diff -ruN SDL2-2.32.8/test/testhaptic.c SDL2-2.32.8.aros/test/testhaptic.c
--- SDL2-2.32.8/test/testhaptic.c	2024-01-22 22:20:00.000000000 +0000
+++ SDL2-2.32.8.aros/test/testhaptic.c	2025-07-27 14:24:23.052841428 +0000
@@ -99,6 +99,7 @@
         HapticPrintSupported(haptic);
     } else {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "No Haptic devices found!\n");
+        SDL_Quit();
         return 1;
     }
 
diff -ruN SDL2-2.32.8/test/testnative.c SDL2-2.32.8.aros/test/testnative.c
--- SDL2-2.32.8/test/testnative.c	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/test/testnative.c	2025-07-27 14:24:23.124841429 +0000
@@ -36,6 +36,9 @@
 #ifdef TEST_NATIVE_OS2
     &OS2WindowFactory,
 #endif
+#ifdef TEST_NATIVE_MORPHOS
+    &MorphOSWindowFactory,
+#endif
     NULL
 };
 static NativeWindowFactory *factory = NULL;
@@ -46,10 +49,13 @@
 static void
 quit(int rc)
 {
-    SDL_VideoQuit();
     if (native_window && factory) {
         factory->DestroyNativeWindow(native_window);
     }
+
+    SDL_VideoQuit();
+    SDL_Quit();
+
     exit(rc);
 }
 
@@ -177,8 +183,15 @@
     }
 
     /* Main render loop */
+#ifdef __MORPHOS__
+	done = 2000;
+	while (done) {
+		done--;
+		SDL_Delay(5);
+#else
     done = 0;
     while (!done) {
+#endif
         /* Check for events */
         while (SDL_PollEvent(&event)) {
             switch (event.type) {
@@ -200,6 +213,8 @@
         MoveSprites(renderer, sprite);
     }
 
+    SDL_DestroyRenderer(renderer);
+
     quit(0);
 
     return 0; /* to prevent compiler warning */
diff -ruN SDL2-2.32.8/test/testnative.h SDL2-2.32.8.aros/test/testnative.h
--- SDL2-2.32.8/test/testnative.h	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/test/testnative.h	2025-07-27 14:24:23.132841429 +0000
@@ -49,3 +49,8 @@
 #define TEST_NATIVE_OS2
 extern NativeWindowFactory OS2WindowFactory;
 #endif
+
+#ifdef SDL_VIDEO_DRIVER_MORPHOS
+#define TEST_NATIVE_MORPHOS
+extern NativeWindowFactory MorphOSWindowFactory;
+#endif
diff -ruN SDL2-2.32.8/test/testnativemorphos.c SDL2-2.32.8.aros/test/testnativemorphos.c
--- SDL2-2.32.8/test/testnativemorphos.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/test/testnativemorphos.c	2025-07-27 14:24:23.140841429 +0000
@@ -0,0 +1,45 @@
+/*
+  Copyright (C) 1997-2017 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely.
+*/
+
+#include "testnative.h"
+
+#ifdef TEST_NATIVE_MORPHOS
+
+#include <proto/intuition.h>
+
+static void *
+CreateWindowMOS(int w, int h)
+{
+	struct Window *window = OpenWindowTags(NULL,
+		WA_InnerWidth, w,
+		WA_InnerHeight, h,
+		WA_Title, "Native window",
+		WA_IDCMP, IDCMP_CLOSEWINDOW,
+		TAG_DONE);
+
+	return (void *) window;
+}
+
+static void
+DestroyWindowMOS(void *window)
+{
+	CloseWindow(window);
+}
+
+NativeWindowFactory MorphOSWindowFactory = {
+    "mos",
+    CreateWindowMOS,
+    DestroyWindowMOS
+};
+
+#endif
+
diff -ruN SDL2-2.32.8/test/testoffscreen.c SDL2-2.32.8.aros/test/testoffscreen.c
--- SDL2-2.32.8/test/testoffscreen.c	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/test/testoffscreen.c	2025-07-27 14:24:23.160841429 +0000
@@ -107,6 +107,7 @@
     if (SDL_VideoInit("offscreen") < 0) {
         SDL_Log("Couldn't initialize the offscreen video driver: %s\n",
                 SDL_GetError());
+        SDL_Quit();
         return SDL_FALSE;
     }
 
diff -ruN SDL2-2.32.8/test/testrumble.c SDL2-2.32.8.aros/test/testrumble.c
--- SDL2-2.32.8/test/testrumble.c	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/test/testrumble.c	2025-07-27 14:24:23.208841430 +0000
@@ -98,6 +98,7 @@
         SDL_Log("Device: %s\n", SDL_HapticName(i));
     } else {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "No Haptic devices found!\n");
+        SDL_Quit();
         return 1;
     }
 
diff -ruN SDL2-2.32.8/test/testshape.c SDL2-2.32.8.aros/test/testshape.c
--- SDL2-2.32.8/test/testshape.c	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/test/testshape.c	2025-07-27 14:24:23.236841430 +0000
@@ -112,7 +112,8 @@
         }
         SDL_free(pictures);
         SDL_VideoQuit();
-        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not create shaped window for SDL_Shape.");
+        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not create shaped window for SDL_Shape. %s", SDL_GetError());
+        SDL_Quit();
         exit(-4);
     }
     renderer = SDL_CreateRenderer(window, -1, 0);
@@ -204,6 +205,7 @@
     SDL_free(pictures);
     /* Call SDL_VideoQuit() before quitting. */
     SDL_VideoQuit();
+    SDL_Quit();
 
     return 0;
 }
diff -ruN SDL2-2.32.8/test/torturethread.c SDL2-2.32.8.aros/test/torturethread.c
--- SDL2-2.32.8/test/torturethread.c	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/test/torturethread.c	2025-07-27 14:24:23.348841432 +0000
@@ -88,7 +88,9 @@
         return 1;
     }
 
+#ifndef __MORPHOS__
     (void)signal(SIGSEGV, SIG_DFL);
+#endif
     for (i = 0; i < NUMTHREADS; i++) {
         char name[64];
         (void)SDL_snprintf(name, sizeof(name), "Parent%d", i);
diff -ruN SDL2-2.32.8/VisualC-GDK/tests/testgamecontroller/testgamecontroller.vcxproj.filters SDL2-2.32.8.aros/VisualC-GDK/tests/testgamecontroller/testgamecontroller.vcxproj.filters
--- SDL2-2.32.8/VisualC-GDK/tests/testgamecontroller/testgamecontroller.vcxproj.filters	2024-08-04 15:17:43.000000000 +0000
+++ SDL2-2.32.8.aros/VisualC-GDK/tests/testgamecontroller/testgamecontroller.vcxproj.filters	2025-07-27 14:24:24.136841443 +0000
@@ -52,4 +52,4 @@
       <UniqueIdentifier>{e704dcb9-c83c-4c94-a139-b0f3e3f428f2}</UniqueIdentifier>
     </Filter>
   </ItemGroup>
-</Project>
\ No newline at end of file
+</Project>
diff -ruN SDL2-2.32.8/VisualC-GDK/tests/testgdk/testgdk.vcxproj SDL2-2.32.8.aros/VisualC-GDK/tests/testgdk/testgdk.vcxproj
--- SDL2-2.32.8/VisualC-GDK/tests/testgdk/testgdk.vcxproj	2024-08-04 15:17:43.000000000 +0000
+++ SDL2-2.32.8.aros/VisualC-GDK/tests/testgdk/testgdk.vcxproj	2025-07-27 14:24:24.208841444 +0000
@@ -398,4 +398,4 @@
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
   <ImportGroup Label="ExtensionTargets">
   </ImportGroup>
-</Project>
\ No newline at end of file
+</Project>
diff -ruN SDL2-2.32.8/VisualC-GDK/tests/testgdk/testgdk.vcxproj.filters SDL2-2.32.8.aros/VisualC-GDK/tests/testgdk/testgdk.vcxproj.filters
--- SDL2-2.32.8/VisualC-GDK/tests/testgdk/testgdk.vcxproj.filters	2024-08-04 15:17:43.000000000 +0000
+++ SDL2-2.32.8.aros/VisualC-GDK/tests/testgdk/testgdk.vcxproj.filters	2025-07-27 14:24:24.216841444 +0000
@@ -50,4 +50,4 @@
       <UniqueIdentifier>{ac7aa2d5-f0f7-46eb-a548-5b6316f3b63b}</UniqueIdentifier>
     </Filter>
   </ItemGroup>
-</Project>
\ No newline at end of file
+</Project>
diff -ruN SDL2-2.32.8/VisualC-GDK/tests/testsprite2/testsprite2.vcxproj SDL2-2.32.8.aros/VisualC-GDK/tests/testsprite2/testsprite2.vcxproj
--- SDL2-2.32.8/VisualC-GDK/tests/testsprite2/testsprite2.vcxproj	2024-08-04 15:17:43.000000000 +0000
+++ SDL2-2.32.8.aros/VisualC-GDK/tests/testsprite2/testsprite2.vcxproj	2025-07-27 14:24:24.272841445 +0000
@@ -392,4 +392,4 @@
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
   <ImportGroup Label="ExtensionTargets">
   </ImportGroup>
-</Project>
\ No newline at end of file
+</Project>
diff -ruN SDL2-2.32.8/VisualC-GDK/tests/testsprite2/testsprite2.vcxproj.filters SDL2-2.32.8.aros/VisualC-GDK/tests/testsprite2/testsprite2.vcxproj.filters
--- SDL2-2.32.8/VisualC-GDK/tests/testsprite2/testsprite2.vcxproj.filters	2024-08-04 15:17:43.000000000 +0000
+++ SDL2-2.32.8.aros/VisualC-GDK/tests/testsprite2/testsprite2.vcxproj.filters	2025-07-27 14:24:24.280841445 +0000
@@ -49,4 +49,4 @@
       <UniqueIdentifier>{9bf62acf-6661-43f9-bde3-0de9e1db4290}</UniqueIdentifier>
     </Filter>
   </ItemGroup>
-</Project>
\ No newline at end of file
+</Project>
diff -ruN SDL2-2.32.8/WhatsNew.txt SDL2-2.32.8.aros/WhatsNew.txt
--- SDL2-2.32.8/WhatsNew.txt	2024-01-28 03:46:25.000000000 +0000
+++ SDL2-2.32.8.aros/WhatsNew.txt	2025-07-27 14:24:24.824841453 +0000
@@ -77,6 +77,9 @@
 * Enabled IME soft keyboard input
 * Added version checking to make sure the SDL Java and C code are compatible
 
+MorphOS:
+* fix redraw surface after iconify window (fix bug with liteXL)
+
 
 ---------------------------------------------------------------------------
 2.24.0:
diff -ruN SDL2-2.32.8/Xcode/SDL/pkg-support/SDL.info SDL2-2.32.8.aros/Xcode/SDL/pkg-support/SDL.info
--- SDL2-2.32.8/Xcode/SDL/pkg-support/SDL.info	2025-06-02 23:00:39.000000000 +0000
+++ SDL2-2.32.8.aros/Xcode/SDL/pkg-support/SDL.info	2025-07-27 14:24:24.912841454 +0000
@@ -3,7 +3,7 @@
 Description SDL Library for Mac OS X (http://www.libsdl.org)
 DefaultLocation /Library/Frameworks
 Diskname (null)
-DeleteWarning 
+DeleteWarning
 NeedsAuthorization NO
 DisableStop NO
 UseUserMask NO
