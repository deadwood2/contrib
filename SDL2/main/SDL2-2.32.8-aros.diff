diff -ruN SDL2-2.32.8/include/begin_code.h SDL2-2.32.8.aros/include/begin_code.h
--- SDL2-2.32.8/include/begin_code.h	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/include/begin_code.h	2025-07-28 13:13:58.433582407 +0000
@@ -66,7 +66,7 @@
 #    define DECLSPEC
 #   endif
 # else
-#  if defined(__GNUC__) && __GNUC__ >= 4
+#  if !defined(__AROS__) && defined(__GNUC__) && __GNUC__ >= 4
 #   define DECLSPEC __attribute__ ((visibility("default")))
 #  else
 #   define DECLSPEC
diff -ruN SDL2-2.32.8/include/SDL_config_aros.h SDL2-2.32.8.aros/include/SDL_config_aros.h
--- SDL2-2.32.8/include/SDL_config_aros.h	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/include/SDL_config_aros.h	2025-08-05 16:13:06.160628275 +0000
@@ -0,0 +1,479 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2022 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#ifndef _SDL_config_aros_h
+#define _SDL_config_aros_h
+
+/**
+ *  \file SDL_config.h.in
+ *
+ *  This is a set of defines to configure the SDL features
+ */
+
+/* General platform specific identifiers */
+#include "SDL_platform.h"
+
+/* C datatypes */
+#define SIZEOF_VOIDP sizeof(IPTR)
+
+#define HAVE_GCC_ATOMICS 1
+/* #undef HAVE_GCC_SYNC_LOCK_TEST_AND_SET */
+
+//#define HAVE_STDDEF_H   1
+
+#define LACKS_SYS_MMAN_H 1
+
+/* Useful headers */
+#define STDC_HEADERS 1
+#define HAVE_ALLOCA_H 1
+#define HAVE_CTYPE_H 1
+#define HAVE_FLOAT_H 1
+#define HAVE_ICONV_H 1
+#define HAVE_INTTYPES_H 1
+#define HAVE_LIMITS_H 1
+#define HAVE_MALLOC_H 1
+#define HAVE_MATH_H 1
+#define HAVE_MEMORY_H 1
+#if !defined(BUILD_SDL2_LIBRARY)
+#define HAVE_SIGNAL_H 1
+#endif
+#define HAVE_STDARG_H 1
+#define HAVE_STDINT_H 1
+#define HAVE_STDIO_H 1
+#define HAVE_STDLIB_H 1
+#define HAVE_STRINGS_H 1
+#define HAVE_STRING_H 1
+#define HAVE_SYS_TYPES_H 1
+#define HAVE_WCHAR_H 1
+/* #undef HAVE_PTHREAD_NP_H */
+/* #undef HAVE_LIBUNWIND_H */
+
+/* C library functions */
+#define HAVE_MALLOC 1
+#define HAVE_CALLOC 1
+#define HAVE_REALLOC    1
+#define HAVE_FREE   1
+#define HAVE_ALLOCA 1
+//#ifndef __WIN32__ /* Don't use C runtime versions of these on Windows */
+//#define HAVE_GETENV 1
+//#define HAVE_SETENV 1
+//#define HAVE_PUTENV 1
+//#define HAVE_UNSETENV 1
+//#endif
+#define HAVE_QSORT  1
+#define HAVE_ABS    1
+#define HAVE_BCOPY  1
+#define HAVE_MEMSET 1
+#define HAVE_MEMCPY 1
+#define HAVE_MEMMOVE    1
+#define HAVE_MEMCMP 1
+#define HAVE_WCSLEN 1
+/* #undef HAVE_WCSLCPY */
+/* #undef HAVE_WCSLCAT */
+#define HAVE_WCSCMP 1
+#define HAVE_STRLEN 1
+#define HAVE_STRLCPY    1
+#define HAVE_STRLCAT    1
+/* #undef HAVE__STRREV */
+/* #undef HAVE__STRUPR */
+/* #undef HAVE__STRLWR */
+/* #undef HAVE_INDEX */
+/* #undef HAVE_RINDEX */
+#define HAVE_STRCHR 1
+#define HAVE_STRRCHR    1
+#define HAVE_STRSTR 1
+/* #undef HAVE_ITOA */
+/* #undef HAVE__LTOA */
+/* #undef HAVE__UITOA */
+/* #undef HAVE__ULTOA */
+#define HAVE_STRTOL 1
+#define HAVE_STRTOUL    1
+/* #undef HAVE__I64TOA */
+/* #undef HAVE__UI64TOA */
+#define HAVE_STRTOLL    1
+#define HAVE_STRTOULL   1
+/* #undef HAVE_STRTOD */
+#define HAVE_STRTOD 1
+#define HAVE_ATOI   1
+#define HAVE_ATOF   1
+#define HAVE_STRCMP 1
+#define HAVE_STRNCMP    1
+/* #undef HAVE__STRICMP */
+#define HAVE_STRCASECMP 1
+/* #undef HAVE__STRNICMP */
+#define HAVE_STRNCASECMP 1
+/* #undef HAVE_SSCANF */
+#define HAVE_VSSCANF 1
+/* #undef HAVE_SNPRINTF */
+#define HAVE_VSNPRINTF  1
+#define HAVE_M_PI /**/
+#define HAVE_ACOS 1
+#define HAVE_ACOSF 1
+#define HAVE_ASIN 1
+#define HAVE_ASINF 1
+#define HAVE_ATAN 1
+#define HAVE_ATANF 1
+#define HAVE_ATAN2 1
+#define HAVE_ATAN2F 1
+#define HAVE_CEIL   1
+#define HAVE_CEILF 1
+#define HAVE_COPYSIGN   1
+#define HAVE_COPYSIGNF 1
+#define HAVE_COS    1
+#define HAVE_COSF   1
+#define HAVE_EXP    1
+#define HAVE_EXPF   1
+#define HAVE_FABS   1
+#define HAVE_FABSF 1
+#define HAVE_FLOOR  1
+#define HAVE_FLOORF 1
+#define HAVE_FMOD 1
+#define HAVE_FMODF 1
+#define HAVE_LOG    1
+#define HAVE_LOGF 1
+#define HAVE_LOG10 1
+#define HAVE_LOG10F 1
+#define HAVE_POW	1
+#define HAVE_POWF 	1
+#define HAVE_SCALBN 1
+#define HAVE_SCALBNF 1
+#define HAVE_SIN    1
+#define HAVE_SINF   1
+#define HAVE_SQRT   1
+#define HAVE_SQRTF  1
+#define HAVE_TAN 1
+#define HAVE_TANF 1
+/* #undef HAVE_FOPEN64 1 */
+/* #undef HAVE_FSEEKO 1 */
+/* #undef HAVE_FSEEKO64 1 */
+/* #undef HAVE_SIGACTION */
+/* #undef HAVE_SA_SIGACTION */
+#define HAVE_SETJMP 1
+#define HAVE_NANOSLEEP  1
+#define HAVE_SYSCONF    1
+/* #undef HAVE_SYSCTLBYNAME */
+/* #undef HAVE_CLOCK_GETTIME */
+/* #undef HAVE_GETPAGESIZE */
+#define HAVE_MPROTECT 1
+#define HAVE_ICONV 1
+#define SDL_USE_LIBICONV 1
+/* #undef HAVE_PTHREAD_SETNAME_NP */
+/* #undef HAVE_PTHREAD_SET_NAME_NP */
+/* #undef HAVE_SEM_TIMEDWAIT */
+/* #undef HAVE_GETAUXVAL */
+/* #undef HAVE_ELF_AUX_INFO */
+// #undef HAVE_POLL 1
+// #undef HAVE__EXIT 1
+
+/* #undef HAVE_O_CLOEXEC */
+/* #undef HAVE_ALTIVEC_H */
+/* #undef HAVE_DBUS_DBUS_H */
+/* #undef HAVE_FCITX */
+/* #undef HAVE_SYS_INOTIFY_H */
+/* #undef HAVE_INOTIFY_INIT */
+/* #undef HAVE_INOTIFY_INIT1 */
+/* #undef HAVE_INOTIFY */
+/* #undef HAVE_IBUS_IBUS_H */
+/* #undef HAVE_IMMINTRIN_H */
+/* #undef HAVE_LIBUDEV_H */
+/* #undef HAVE_LIBUSB */
+/* #undef HAVE_LIBSAMPLERATE_H */
+/* #undef HAVE_LIBDECOR_H */
+/* #undef HAVE_LSXINTRIN_H */
+/* #undef HAVE_LASXINTRIN_H */
+
+/* #undef HAVE_DDRAW_H */
+/* #undef HAVE_DINPUT_H */
+/* #undef HAVE_DSOUND_H */
+/* #undef HAVE_DXGI_H */
+/* #undef HAVE_WINDOWS_GAMING_INPUT_H */
+/* #undef HAVE_XINPUT_H */
+/* #undef HAVE_XINPUT_GAMEPAD_EX */
+/* #undef HAVE_XINPUT_STATE_EX */
+
+/* #undef HAVE_MMDEVICEAPI_H */
+/* #undef HAVE_AUDIOCLIENT_H */
+/* #undef HAVE_TPCSHRD_H */
+/* #undef HAVE_SENSORSAPI_H */
+/* #undef HAVE_ROAPI_H */
+/* #undef HAVE_SHELLSCALINGAPI_H */
+
+/* SDL internal assertion support */
+/* #undef SDL_DEFAULT_ASSERT_LEVEL */
+
+/* Allow disabling of core subsystems */
+/* #undef SDL_ATOMIC_DISABLED */
+/* #undef SDL_AUDIO_DISABLED */
+/* #undef SDL_CPUINFO_DISABLED */
+/* #undef SDL_EVENTS_DISABLED */
+/* #undef SDL_FILE_DISABLED */
+/* #undef SDL_JOYSTICK_DISABLED */
+//#define SDL_HAPTIC_DISABLED 1
+#define SDL_HIDAPI_DISABLED 1
+#define SDL_SENSOR_DISABLED 1
+#define SDL_LOADSO_DISABLED 1
+/* #undef SDL_RENDER_DISABLED */
+/* #undef SDL_THREADS_DISABLED */
+/* #undef SDL_TIMERS_DISABLED */
+/* #undef SDL_VIDEO_DISABLED */
+/* #undef SDL_POWER_DISABLED */
+/* #undef SDL_FILESYSTEM_DISABLED */
+/* #undef SDL_LOCALE_DISABLED */
+/* #undef SDL_MISC_DISABLED */
+
+/* Enable various audio drivers */
+/* #undef SDL_AUDIO_DRIVER_AAUDIO */
+/* #undef SDL_AUDIO_DRIVER_ALSA */
+/* #undef SDL_AUDIO_DRIVER_ALSA_DYNAMIC */
+/* #undef SDL_AUDIO_DRIVER_ANDROID */
+/* #undef SDL_AUDIO_DRIVER_ARTS */
+/* #undef SDL_AUDIO_DRIVER_ARTS_DYNAMIC */
+/* #undef SDL_AUDIO_DRIVER_COREAUDIO */
+/* #undef SDL_AUDIO_DRIVER_DISK */
+/* #undef SDL_AUDIO_DRIVER_DSOUND */
+/* #undef SDL_AUDIO_DRIVER_DUMMY */
+/* #undef SDL_AUDIO_DRIVER_EMSCRIPTEN */
+/* #undef SDL_AUDIO_DRIVER_ESD */
+/* #undef SDL_AUDIO_DRIVER_ESD_DYNAMIC */
+/* #undef SDL_AUDIO_DRIVER_FUSIONSOUND */
+/* #undef SDL_AUDIO_DRIVER_FUSIONSOUND_DYNAMIC */
+/* #undef SDL_AUDIO_DRIVER_HAIKU */
+/* #undef SDL_AUDIO_DRIVER_JACK */
+/* #undef SDL_AUDIO_DRIVER_JACK_DYNAMIC */
+/* #undef SDL_AUDIO_DRIVER_NACL */
+/* #undef SDL_AUDIO_DRIVER_NAS */
+/* #undef SDL_AUDIO_DRIVER_NAS_DYNAMIC */
+/* #undef SDL_AUDIO_DRIVER_NETBSD */
+/* #undef SDL_AUDIO_DRIVER_OPENSLES */
+/* #undef SDL_AUDIO_DRIVER_OSS */
+/* #undef SDL_AUDIO_DRIVER_OSS_SOUNDCARD_H */
+/* #undef SDL_AUDIO_DRIVER_PAUDIO */
+/* #undef SDL_AUDIO_DRIVER_PIPEWIRE */
+/* #undef SDL_AUDIO_DRIVER_PIPEWIRE_DYNAMIC */
+/* #undef SDL_AUDIO_DRIVER_PULSEAUDIO */
+/* #undef SDL_AUDIO_DRIVER_PULSEAUDIO_DYNAMIC */
+/* #undef SDL_AUDIO_DRIVER_QSA */
+/* #undef SDL_AUDIO_DRIVER_SNDIO */
+/* #undef SDL_AUDIO_DRIVER_SNDIO_DYNAMIC */
+/* #undef SDL_AUDIO_DRIVER_SUNAUDIO */
+/* #undef SDL_AUDIO_DRIVER_WASAPI */
+/* #undef SDL_AUDIO_DRIVER_WINMM */
+/* #undef SDL_AUDIO_DRIVER_OS2 */
+#define SDL_AUDIO_DRIVER_AHI 1
+
+/* Enable various input drivers */
+/* #undef SDL_INPUT_LINUXEV */
+/* #undef SDL_INPUT_FBSDKBIO */
+/* #undef SDL_INPUT_LINUXKD */
+/* #undef SDL_INPUT_WSCONS */
+/* #undef SDL_JOYSTICK_HAIKU */
+/* #undef SDL_JOYSTICK_DINPUT */
+/* #undef SDL_JOYSTICK_WGI */
+/* #undef SDL_JOYSTICK_XINPUT */
+/* #undef SDL_JOYSTICK_DUMMY */
+/* #undef SDL_JOYSTICK_IOKIT */
+/* #undef SDL_JOYSTICK_MFI */
+/* #undef SDL_JOYSTICK_LINUX */
+/* #undef SDL_JOYSTICK_ANDROID */
+/* #undef SDL_JOYSTICK_OS2 */
+/* #undef SDL_JOYSTICK_USBHID */
+/* #undef SDL_HAVE_MACHINE_JOYSTICK_H */
+/* #undef SDL_JOYSTICK_HIDAPI */
+/* #undef SDL_JOYSTICK_RAWINPUT */
+/* #undef SDL_JOYSTICK_EMSCRIPTEN */
+/* #undef SDL_JOYSTICK_VIRTUAL */
+#define SDL_JOYSTICK_AROS   1
+//#define SDL_JOYSTICK_MORPHOS   1 /* Enable MORPHOS SENSORS JOYSTICK/GAMEPAD */ 
+#define SDL_HAPTIC_DUMMY 1
+/* #undef SDL_HAPTIC_ANDROID */
+/* #undef SDL_HAPTIC_LINUX */
+/* #undef SDL_HAPTIC_IOKIT */
+/* #undef SDL_HAPTIC_DINPUT */
+/* #undef SDL_HAPTIC_XINPUT */
+
+/* Enable various sensor drivers */
+/* #undef SDL_SENSOR_ANDROID */
+/* #undef SDL_SENSOR_COREMOTION */
+/* #undef SDL_SENSOR_WINDOWS */
+/* #undef SDL_SENSOR_DUMMY */
+
+/* Enable various shared object loading systems */
+/* #undef SDL_LOADSO_DLOPEN */
+/* #undef SDL_LOADSO_DUMMY */
+/* #undef SDL_LOADSO_LDG */
+/* #undef SDL_LOADSO_WINDOWS */
+/* #undef SDL_LOADSO_OS2 */
+
+/* Enable various threading systems */
+/* #undef SDL_THREAD_GENERIC_COND_SUFFIX */
+/* #undef SDL_THREAD_PTHREAD */
+/* #undef SDL_THREAD_PTHREAD_RECURSIVE_MUTEX */
+/* #undef SDL_THREAD_PTHREAD_RECURSIVE_MUTEX_NP */
+/* #undef SDL_THREAD_WINDOWS */
+/* #undef SDL_THREAD_OS2 */
+#define SDL_THREAD_AROS    1
+
+/* Enable various timer systems */
+/* #undef SDL_TIMER_HAIKU */
+/* #undef SDL_TIMER_DUMMY */
+/* #undef SDL_TIMER_UNIX */
+/* #undef SDL_TIMER_WINDOWS */
+/* #undef SDL_TIMER_OS2 */
+#define SDL_TIMER_AROS 1
+/* #undef SDL_TIMER_MORPHOS */
+
+/* Enable various video drivers */
+/* #undef SDL_VIDEO_DRIVER_HAIKU */
+/* #undef SDL_VIDEO_DRIVER_COCOA */
+/* #undef SDL_VIDEO_DRIVER_DIRECTFB */
+/* #undef SDL_VIDEO_DRIVER_DIRECTFB_DYNAMIC */
+#define SDL_VIDEO_DRIVER_DUMMY 1
+/* #undef SDL_VIDEO_DRIVER_WINDOWS */
+/* #undef SDL_VIDEO_DRIVER_WAYLAND */
+/* #undef SDL_VIDEO_DRIVER_WAYLAND_QT_TOUCH */
+/* #undef SDL_VIDEO_DRIVER_WAYLAND_DYNAMIC */
+/* #undef SDL_VIDEO_DRIVER_WAYLAND_DYNAMIC_EGL */
+/* #undef SDL_VIDEO_DRIVER_WAYLAND_DYNAMIC_CURSOR */
+/* #undef SDL_VIDEO_DRIVER_WAYLAND_DYNAMIC_XKBCOMMON */
+/* #undef SDL_VIDEO_DRIVER_WAYLAND_DYNAMIC_LIBDECOR */
+/* #undef SDL_VIDEO_DRIVER_X11 */
+/* #undef SDL_VIDEO_DRIVER_RPI */
+/* #undef SDL_VIDEO_DRIVER_KMSDRM */
+/* #undef SDL_VIDEO_DRIVER_KMSDRM_DYNAMIC */
+/* #undef SDL_VIDEO_DRIVER_KMSDRM_DYNAMIC_GBM */
+/* #undef SDL_VIDEO_DRIVER_ANDROID */
+/* #undef SDL_VIDEO_DRIVER_EMSCRIPTEN */
+/* #undef SDL_VIDEO_DRIVER_OFFSCREEN */
+/* #undef SDL_VIDEO_DRIVER_X11_DYNAMIC */
+/* #undef SDL_VIDEO_DRIVER_X11_DYNAMIC_XEXT */
+/* #undef SDL_VIDEO_DRIVER_X11_DYNAMIC_XCURSOR */
+/* #undef SDL_VIDEO_DRIVER_X11_DYNAMIC_XINPUT2 */
+/* #undef SDL_VIDEO_DRIVER_X11_DYNAMIC_XFIXES */
+/* #undef SDL_VIDEO_DRIVER_X11_DYNAMIC_XRANDR */
+/* #undef SDL_VIDEO_DRIVER_X11_DYNAMIC_XSS */
+/* #undef SDL_VIDEO_DRIVER_X11_XCURSOR */
+/* #undef SDL_VIDEO_DRIVER_X11_XDBE */
+/* #undef SDL_VIDEO_DRIVER_X11_XINPUT2 */
+/* #undef SDL_VIDEO_DRIVER_X11_XINPUT2_SUPPORTS_MULTITOUCH */
+/* #undef SDL_VIDEO_DRIVER_X11_XFIXES */
+/* #undef SDL_VIDEO_DRIVER_X11_XRANDR */
+/* #undef SDL_VIDEO_DRIVER_X11_XSCRNSAVER */
+/* #undef SDL_VIDEO_DRIVER_X11_XSHAPE */
+/* #undef SDL_VIDEO_DRIVER_X11_SUPPORTS_GENERIC_EVENTS */
+/* #undef SDL_VIDEO_DRIVER_X11_HAS_XKBKEYCODETOKEYSYM */
+/* #undef SDL_VIDEO_DRIVER_NACL */
+/* #undef SDL_VIDEO_DRIVER_VIVANTE */
+/* #undef SDL_VIDEO_DRIVER_VIVANTE_VDK */
+/* #undef SDL_VIDEO_DRIVER_OS2 */
+/* #undef SDL_VIDEO_DRIVER_QNX */
+/* #undef SDL_VIDEO_DRIVER_RISCOS */
+#define SDL_VIDEO_DRIVER_AROS 1
+/* #undef SDL_VIDEO_DRIVER_MORPHOS  */
+
+/* #undef SDL_VIDEO_RENDER_D3D */
+/* #undef SDL_VIDEO_RENDER_D3D11 */
+/* #undef SDL_VIDEO_RENDER_D3D12 */
+#define SDL_VIDEO_RENDER_OGL 1
+/* #undef SDL_VIDEO_RENDER_OGL_ES */
+/* #undef SDL_VIDEO_RENDER_OGL_ES2 */
+/* #undef SDL_VIDEO_RENDER_DIRECTFB */
+/* #undef SDL_VIDEO_RENDER_METAL */
+
+/* Enable OpenGL support */
+#define SDL_VIDEO_OPENGL 1
+#define SDL_VIDEO_OPENGL_AGL 1
+/* #undef SDL_VIDEO_OPENGL_ES */
+/* #undef SDL_VIDEO_OPENGL_ES2 */
+/* #undef SDL_VIDEO_OPENGL_BGL */
+/* #undef SDL_VIDEO_OPENGL_CGL */
+/* #undef SDL_VIDEO_OPENGL_EGL */
+/* #undef SDL_VIDEO_OPENGL_GLX */
+/* #undef SDL_VIDEO_OPENGL_WGL */
+/* #undef SDL_VIDEO_OPENGL_OSMESA */
+/* #undef SDL_VIDEO_OPENGL_OSMESA_DYNAMIC */
+
+/* Enable Vulkan support */
+/* #undef SDL_VIDEO_VULKAN */
+
+/* Enable Metal support */
+/* #undef SDL_VIDEO_METAL */
+
+/* Enable system power support */
+/* #undef SDL_POWER_LINUX */
+/* #undef SDL_POWER_WINDOWS */
+/* #undef SDL_POWER_MACOSX */
+/* #undef SDL_POWER_HAIKU */
+/* #undef SDL_POWER_ANDROID */
+/* #undef SDL_POWER_EMSCRIPTEN */
+/* #undef SDL_POWER_HARDWIRED */
+#define SDL_POWER_AROS 1
+/* #undef SDL_POWER_MORPHOS */
+
+/* Enable system filesystem support */
+/* #undef SDL_FILESYSTEM_ANDROID */
+/* #undef SDL_FILESYSTEM_HAIKU */
+/* #undef SDL_FILESYSTEM_COCOA */
+/* #undef SDL_FILESYSTEM_DUMMY */
+/* #undef SDL_FILESYSTEM_RISCOS */
+/* #undef SDL_FILESYSTEM_UNIX */
+/* #undef SDL_FILESYSTEM_WINDOWS */
+/* #undef SDL_FILESYSTEM_NACL */
+/* #undef SDL_FILESYSTEM_EMSCRIPTEN */
+/* #undef SDL_FILESYSTEM_OS2 */
+/* #undef SDL_FILESYSTEM_VITA */
+/* #undef SDL_FILESYSTEM_PSP */
+/* #undef SDL_FILESYSTEM_PS2 */
+#define SDL_FILESYSTEM_AROS  1
+#define SDL_FILESYSTEM_MORPHOS  1
+
+/* Enable misc subsystem */
+/* #undef SDL_MISC_DUMMY */
+
+/* Enable locale subsystem */
+/* #undef SDL_LOCALE_DUMMY */
+
+/* Enable assembly routines */
+
+#if defined(__PPC__) || defined(__powerpc__)
+#define SDL_ALTIVEC_BLITTERS  1
+#define SDL_ENABLE_ALTIVEC_H 1
+#endif
+#if defined(__arm__)
+#define SDL_ARM_SIMD_BLITTERS 1
+#define SDL_ARM_NEON_BLITTERS 1
+#endif
+
+/* Whether SDL_DYNAMIC_API needs dlopen() */
+/* #undef DYNAPI_NEEDS_DLOPEN */
+
+/* Enable ime support */
+/* #undef SDL_USE_IME */
+
+/* Enable dynamic udev support */
+/* #undef SDL_UDEV_DYNAMIC */
+
+/* Enable dynamic libusb support */
+/* #undef SDL_LIBUSB_DYNAMIC */
+
+/* Enable dynamic libsamplerate support */
+/* #undef SDL_LIBSAMPLERATE_DYNAMIC */
+
+#endif /* _SDL_config_aros_h */
diff -ruN SDL2-2.32.8/include/SDL_config.h SDL2-2.32.8.aros/include/SDL_config.h
--- SDL2-2.32.8/include/SDL_config.h	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/include/SDL_config.h	2025-07-27 14:24:11.508841313 +0000
@@ -43,10 +43,14 @@
 #include "SDL_config_android.h"
 #elif defined(__OS2__)
 #include "SDL_config_os2.h"
+#elif defined(__MORPHOS__)
+#include "SDL_config_morphos.h"
 #elif defined(__EMSCRIPTEN__)
 #include "SDL_config_emscripten.h"
 #elif defined(__NGAGE__)
 #include "SDL_config_ngage.h"
+#elif defined(__AROS__)
+#include "SDL_config_aros.h"
 #else
 /* This is a minimal configuration just to get SDL running on new platforms. */
 #include "SDL_config_minimal.h"
diff -ruN SDL2-2.32.8/include/SDL_endian.h SDL2-2.32.8.aros/include/SDL_endian.h
--- SDL2-2.32.8/include/SDL_endian.h	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/include/SDL_endian.h	2025-07-27 14:24:11.608841313 +0000
@@ -353,6 +353,12 @@
     return swapper.f;
 }
 
+#ifdef __MORPHOS__
+#include <exec/types.h>
+extern void SDL_CopyAndSwap16(APTR srcx, APTR destx, LONG units);
+extern void SDL_CopyAndSwap32(APTR srcx, APTR destx, LONG units);
+#endif
+
 /* remove extra macros */
 #undef HAS_BROKEN_BSWAP
 #undef HAS_BUILTIN_BSWAP16
diff -ruN SDL2-2.32.8/include/SDL_opengl_glext.h SDL2-2.32.8.aros/include/SDL_opengl_glext.h
--- SDL2-2.32.8/include/SDL_opengl_glext.h	2023-02-04 07:02:10.000000000 +0000
+++ SDL2-2.32.8.aros/include/SDL_opengl_glext.h	2025-08-02 12:12:54.456103703 +0000
@@ -762,8 +762,10 @@
 
 #ifndef GL_VERSION_1_5
 #define GL_VERSION_1_5 1
+#ifndef __MORPHOS__
 typedef khronos_ssize_t GLsizeiptr;
 typedef khronos_intptr_t GLintptr;
+#endif
 #define GL_BUFFER_SIZE                    0x8764
 #define GL_BUFFER_USAGE                   0x8765
 #define GL_QUERY_COUNTER_BITS             0x8864
@@ -1680,7 +1682,9 @@
 #ifndef GL_VERSION_3_2
 #define GL_VERSION_3_2 1
 typedef struct __GLsync *GLsync;
+#ifndef __MORPHOS__
 typedef khronos_uint64_t GLuint64;
+#endif
 typedef khronos_int64_t GLint64;
 #define GL_CONTEXT_CORE_PROFILE_BIT       0x00000001
 #define GL_CONTEXT_COMPATIBILITY_PROFILE_BIT 0x00000002
@@ -3208,7 +3212,9 @@
 
 #ifndef GL_ARB_bindless_texture
 #define GL_ARB_bindless_texture 1
+#ifndef __MORPHOS__
 typedef khronos_uint64_t GLuint64EXT;
+#endif
 #define GL_UNSIGNED_INT64_ARB             0x140F
 typedef GLuint64 (APIENTRYP PFNGLGETTEXTUREHANDLEARBPROC) (GLuint texture);
 typedef GLuint64 (APIENTRYP PFNGLGETTEXTURESAMPLERHANDLEARBPROC) (GLuint texture, GLuint sampler);
@@ -4992,8 +4998,10 @@
 
 #ifndef GL_ARB_vertex_buffer_object
 #define GL_ARB_vertex_buffer_object 1
+#ifndef __MORPHOS__
 typedef khronos_ssize_t GLsizeiptrARB;
 typedef khronos_intptr_t GLintptrARB;
+#endif
 #define GL_BUFFER_SIZE_ARB                0x8764
 #define GL_BUFFER_USAGE_ARB               0x8765
 #define GL_ARRAY_BUFFER_ARB               0x8892
diff -ruN SDL2-2.32.8/include/SDL_rwops.h SDL2-2.32.8.aros/include/SDL_rwops.h
--- SDL2-2.32.8/include/SDL_rwops.h	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/include/SDL_rwops.h	2025-07-28 14:22:41.854722088 +0000
@@ -47,6 +47,7 @@
 #define SDL_RWOPS_JNIFILE   3U  /**< Android asset */
 #define SDL_RWOPS_MEMORY    4U  /**< Memory stream */
 #define SDL_RWOPS_MEMORY_RO 5U  /**< Read-Only memory stream */
+#define SDL_RWOPS_MORPHOSFILE 6U  /**< MorphOS file */
 
 /**
  * This is the read/write operation structure -- very basic.
@@ -93,6 +94,11 @@
     int (SDLCALL * close) (struct SDL_RWops * context);
 
     Uint32 type;
+
+    #if defined(__MORPHOS__)
+    void *r13; /* must be at offset 24 and outside union (or change fileop routine accordingly) */
+    #endif
+
     union
     {
 #if defined(__ANDROID__)
@@ -112,6 +118,23 @@
                 size_t left;
             } buffer;
         } windowsio;
+#elif defined(__MORPHOS__) || defined(__AROS__)
+        struct
+        {
+            Uint8 AppendMode : 1, NoSeek : 1, IsAtEnd : 1, autoclose : 1;
+            Uint8 Writable : 1, Readable : 1;
+
+            union
+            {
+                size_t  dos;
+                void   *libc;
+            } fp;
+        } amigaosio;
+#if defined(__AROS__)
+#define AMIGAOSIO_BPTR fp.libc
+#else
+#define AMIGAOSIO_BPTR fp.dos
+#endif
 #endif
 
 #ifdef HAVE_STDIO_H
@@ -208,7 +231,7 @@
 extern DECLSPEC SDL_RWops *SDLCALL SDL_RWFromFile(const char *file,
                                                   const char *mode);
 
-#ifdef HAVE_STDIO_H
+#if defined(HAVE_STDIO_H) && !defined(__MORPHOS__) && !defined(__AROS__)
 
 extern DECLSPEC SDL_RWops *SDLCALL SDL_RWFromFP(FILE * fp, SDL_bool autoclose);
 
diff -ruN SDL2-2.32.8/include/SDL_syswm.h SDL2-2.32.8.aros/include/SDL_syswm.h
--- SDL2-2.32.8/include/SDL_syswm.h	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/include/SDL_syswm.h	2025-07-28 13:26:12.821909338 +0000
@@ -143,12 +143,14 @@
     SDL_SYSWM_WAYLAND,
     SDL_SYSWM_MIR,  /* no longer available, left for API/ABI compatibility. Remove in 2.1! */
     SDL_SYSWM_WINRT,
+    SDL_SYSWM_MORPHOS,
     SDL_SYSWM_ANDROID,
     SDL_SYSWM_VIVANTE,
     SDL_SYSWM_OS2,
     SDL_SYSWM_HAIKU,
     SDL_SYSWM_KMSDRM,
-    SDL_SYSWM_RISCOS
+    SDL_SYSWM_RISCOS,
+    SDL_SYSWM_AROS
 } SDL_SYSWM_TYPE;
 
 /**
@@ -317,6 +319,12 @@
             EGLSurface surface;
         } android;
 #endif
+#if defined(SDL_VIDEO_DRIVER_MORPHOS) || defined(SDL_VIDEO_DRIVER_AROS)
+        struct
+        {
+            struct Window *window;      /**< Intuition window */
+        } intui;
+#endif
 
 #if defined(SDL_VIDEO_DRIVER_OS2)
         struct
diff -ruN SDL2-2.32.8/include/SDL_test.h SDL2-2.32.8.aros/include/SDL_test.h
--- SDL2-2.32.8/include/SDL_test.h	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/include/SDL_test.h	2025-07-27 14:24:11.872841315 +0000
@@ -44,6 +44,14 @@
 #include "SDL_test_memory.h"
 #include "SDL_test_random.h"
 
+#if defined(__MORPHOS__)
+#ifndef LLONG_MIN
+#define LLONG_MIN  (-9223372036854775807LL - 1)
+#define LLONG_MAX  9223372036854775807LL
+#define ULLONG_MAX 18446744073709551615ULL
+#endif
+#endif
+
 #include "begin_code.h"
 /* Set up for C function definitions, even when using C++ */
 #ifdef __cplusplus
diff -ruN SDL2-2.32.8/include/SDL_thread.h SDL2-2.32.8.aros/include/SDL_thread.h
--- SDL2-2.32.8/include/SDL_thread.h	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/include/SDL_thread.h	2025-08-01 13:03:20.604152957 +0000
@@ -57,7 +57,11 @@
 typedef struct SDL_Thread SDL_Thread;
 
 /* The SDL thread ID */
+#if defined(__AROS__)
+typedef uintptr_t SDL_threadID;
+#else
 typedef unsigned long SDL_threadID;
+#endif
 
 /* Thread local storage ID, 0 is the invalid ID */
 typedef unsigned int SDL_TLSID;
diff -ruN SDL2-2.32.8/sdl2-config SDL2-2.32.8.aros/sdl2-config
--- SDL2-2.32.8/sdl2-config	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/sdl2-config	2025-07-27 14:24:12.084841316 +0000
@@ -0,0 +1,56 @@
+#!/bin/sh
+
+prefix=/gg/usr/local
+exec_prefix=${prefix}
+exec_prefix_set=no
+
+libmode=``
+
+usage="\
+Usage: sdl2-config [--prefix[=DIR]] [--exec-prefix[=DIR]] [--version] [--libs] [--cflags]"
+
+if test $# -eq 0; then
+      echo "${usage}" 1>&2
+      exit 1
+fi
+
+while test $# -gt 0; do
+  case "$1" in
+  -*=*) optarg=`echo "$1" | sed 's/[-_a-zA-Z0-9]*=//'` ;;
+  *) optarg= ;;
+  esac
+
+  case $1 in
+    --prefix=*)
+      prefix=$optarg
+      if test $exec_prefix_set = no ; then
+        exec_prefix=$optarg
+      fi
+      ;;
+    --prefix)
+      echo $prefix
+      ;;
+    --exec-prefix=*)
+      exec_prefix=$optarg
+      exec_prefix_set=yes
+      ;;
+    --exec-prefix)
+      echo $exec_prefix
+      ;;
+    --version)
+      echo 2.32.0
+      ;;
+    --cflags)
+     	echo -noixemul -I${prefix}/include/SDL2
+      ;;
+    --libs|--static-libs)
+      libdirs="-L${exec_prefix}/lib "
+      echo  $libdirs -noixemul -lSDL2 -lGL -lc -lm
+      ;;
+    *)
+      echo "${usage}" 1>&2
+      exit 1
+      ;;
+  esac
+  shift
+done
diff -ruN SDL2-2.32.8/src/audio/ahi/SDL_ahi_audio.c SDL2-2.32.8.aros/src/audio/ahi/SDL_ahi_audio.c
--- SDL2-2.32.8/src/audio/ahi/SDL_ahi_audio.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/audio/ahi/SDL_ahi_audio.c	2025-07-30 18:16:51.000000000 +0000
@@ -0,0 +1,358 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2022 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#if defined(__AROS__)
+#include <aros/debug.h>
+#endif
+
+#include "../../SDL_internal.h"
+
+#include "SDL_audio.h"
+#include "SDL_timer.h"
+#include "../SDL_audio_c.h"
+#include "../SDL_sysaudio.h"
+#include "SDL_ahi_audio.h"
+
+#if defined(__MORPHOS__)
+# include "../../core/morphos/SDL_cpu.h"
+#else
+#if defined(__AROS__)
+#  include "../../core/aros/SDL_cpu.h"
+# endif
+#endif
+
+#include <sys/param.h>
+
+#include <dos/dos.h>
+#include <exec/execbase.h>
+#include <proto/exec.h>
+
+#if defined(__AROS__)
+#include <string.h>
+#endif
+
+#define RESTART_CAPTURE_THRESHOLD 	 500
+
+static Fixed AHI_Volume = 0x10000;
+
+void AHI_Mute(ULONG mute)
+{
+	AHI_Volume = mute ? 0 : 0x10000;
+}
+
+static void AHI_DetectDevices(void)
+{
+	D(bug("[SDL2:AHI] %s()\n", __func__));
+	
+	SDL_AudioSpec output, capture;
+	output.freq = 44100;
+	output.format = AUDIO_S16MSB;
+	output.channels = 2;
+	
+	capture.freq = 44100;
+	capture.format = AUDIO_S16MSB;
+	capture.channels = 1;
+	
+	SDL_AddAudioDevice(SDL_FALSE, "AHI output device", &output, SDL_strdup("default"));;
+	SDL_AddAudioDevice(SDL_TRUE, "AHI capture device", &capture, SDL_strdup("default"));
+	
+}
+
+static void AHI_WaitDevice(_THIS)
+{
+	MOSAudioData *hidden = this->hidden;
+	struct AHIRequest *req = &hidden->req[hidden->current_buffer];
+
+	if (req->ahir_Std.io_Data) {
+		WaitIO((struct IORequest *)req);
+
+		req->ahir_Std.io_Data = NULL;
+
+		GetMsg(&hidden->ahiport);
+	}
+}
+
+static void AHI_PlayDevice(_THIS)
+{
+	MOSAudioData *hidden = this->hidden;
+	struct AHIRequest *req;
+	ULONG current, current2;
+	
+	current = hidden->current_buffer;
+	current2 = current ^ 1;
+	req = &hidden->req[current];
+
+	req->ahir_Std.io_Data    = (APTR)hidden->buffers[current];
+	req->ahir_Std.io_Length  = hidden->audioBufferSize;
+	req->ahir_Std.io_Offset  = 0;
+	req->ahir_Frequency      = this->spec.freq;
+	req->ahir_Volume         = AHI_Volume; 
+	req->ahir_Type           = hidden->sample_format;
+	req->ahir_Position       = 0x8000;
+	req->ahir_Link           = (hidden->playing ? &hidden->req[current2] : NULL);
+
+	hidden->current_buffer = current2;
+	hidden->playing = 1;
+
+	SendIO((struct IORequest *)req);
+}
+
+static Uint8 * AHI_GetDeviceBuf(_THIS)
+{
+	MOSAudioData *hidden = this->hidden;
+	return (Uint8 *) hidden->buffers[hidden->current_buffer];
+}
+
+static void AHI_CloseDevice(_THIS)
+{
+	MOSAudioData *hidden = this->hidden;
+
+    if (hidden->buffers[0]) {
+        SDL_free(hidden->buffers[0]);
+        hidden->buffers[0] = NULL;
+    }
+
+    if (hidden->buffers[1]) {
+        SDL_free(hidden->buffers[1]);
+        hidden->buffers[1] = NULL;
+    }
+	
+	this->hidden = NULL;
+
+	CloseDevice((struct IORequest *)&hidden->req[0].ahir_Std);
+	SDL_free(hidden);
+}
+
+static void AHI_ThreadInit(_THIS)
+{
+	MOSAudioData *hidden = this->hidden;
+
+	hidden->ahiport.mp_Node.ln_Pri = 60;
+	hidden->ahiport.mp_Flags = PA_SIGNAL;
+	hidden->ahiport.mp_SigBit = SIGBREAKB_CTRL_E;
+	hidden->ahiport.mp_SigTask = FindTask(NULL);
+
+	NEWLIST(&hidden->ahiport.mp_MsgList);
+
+#if defined(__AROS__)
+	memmove(&hidden->req[1], &hidden->req[0], sizeof(hidden->req[1]));
+#else
+	bcopy(&hidden->req[0], &hidden->req[1], sizeof(hidden->req[1]));
+#endif
+}
+
+static int AHI_OpenDevice(_THIS, const char *devname)
+{
+	MOSAudioData *hidden;
+	SDL_AudioFormat test_format;
+	int sample_format = -1;
+
+	switch (this->spec.format) {
+		case AUDIO_F32LSB:
+		case AUDIO_F32MSB:
+		case AUDIO_S32LSB:
+		 	this->spec.format = AUDIO_S32MSB;
+			break;
+		case AUDIO_S16LSB:
+		default:
+			this->spec.format = AUDIO_S16MSB;
+			break;
+	}
+	/*if ((this->spec.format & 0xff) != 8)
+		 this->spec.format = AUDIO_S16MSB;*/
+
+	test_format = SDL_FirstAudioFormat(this->spec.format);
+	
+	while (sample_format < 0 && test_format) {
+
+		switch (test_format) {
+			case AUDIO_U8:
+			case AUDIO_S8:
+				sample_format = this->spec.channels == 1 ? AHIST_M8S : AHIST_S8S;
+				break; 
+			break;
+			case AUDIO_S16LSB:
+			case AUDIO_S16MSB:
+				sample_format = this->spec.channels == 1 ? AHIST_M16S : AHIST_S16S;
+				break;
+			case AUDIO_S32LSB:
+			case AUDIO_S32MSB:
+				sample_format = this->spec.channels == 1 ? AHIST_M32S : AHIST_S32S;
+				break;
+			default:
+				D("[%s] unsupported SDL format 0x%ld\n", __FUNCTION__, test_format);
+				test_format = SDL_NextAudioFormat();
+				break;
+		}
+	}
+
+	if (sample_format < 0)
+		return SDL_SetError("Unsupported audio format");
+
+	D("[%s] AHI sample format is %ld\n", __FUNCTION__, sample_format);
+
+	if (this->spec.channels > 2)
+		this->spec.channels = 2;
+
+	if (this->spec.samples > 1024) {
+		this->spec.samples = MAX(this->spec.freq / 20, 256);
+		this->spec.samples = (this->spec.samples + 7) & ~7;
+	}
+
+	/* Update the fragment size as size in bytes */
+	SDL_CalculateAudioSpec(&this->spec);
+
+	hidden = SDL_malloc(sizeof(MOSAudioData));
+
+	if (hidden == NULL)
+		return SDL_OutOfMemory();
+
+	hidden->req[0].ahir_Std.io_Message.mn_ReplyPort = &hidden->ahiport;
+	hidden->req[0].ahir_Std.io_Message.mn_Length = sizeof(struct AHIRequest);
+	hidden->req[0].ahir_Std.io_Command = CMD_WRITE;
+	hidden->req[0].ahir_Std.io_Data = NULL;
+	hidden->req[0].ahir_Version = 6;
+
+	hidden->audioBufferSize = this->spec.size;
+	hidden->buffers[0] = (Uint8 *) SDL_malloc(hidden->audioBufferSize);
+	hidden->buffers[1] = (Uint8 *) SDL_malloc(hidden->audioBufferSize);
+	if (hidden->buffers[0] == NULL || hidden->buffers[1] == NULL) {
+        SDL_SetError("No memory for audio buffer");
+        return -1;
+    }
+	
+    SDL_memset(hidden->buffers[0], this->spec.silence, hidden->audioBufferSize);
+    SDL_memset(hidden->buffers[1], this->spec.silence, hidden->audioBufferSize);
+	
+	//hidden->convert = convert;
+	hidden->current_buffer = 0;
+	hidden->sample_format = sample_format;
+	hidden->playing = 0;
+	hidden->requestSent = SDL_FALSE;
+
+	this->hidden = hidden;
+	
+	if (OpenDevice(AHINAME, 0, (struct IORequest *)&hidden->req[0].ahir_Std, 0) != 0) {
+		SDL_SetError("Unable to open ahi.device unit 0! Error code %d.\n", hidden->req[0].ahir_Std.io_Error);
+		return -1;
+	}
+	return 0;
+}
+
+static void AHI_FillCaptureRequest(struct AHIRequest *request, void *buffer, int length, int frequency, int type)
+{
+    request->ahir_Std.io_Message.mn_Node.ln_Pri = 60;
+    request->ahir_Std.io_Data    = buffer,
+    request->ahir_Std.io_Length  = length;
+    request->ahir_Std.io_Command = CMD_READ;
+    request->ahir_Volume = AHI_Volume;
+    request->ahir_Position = 0x8000;
+    request->ahir_Link = NULL;
+    request->ahir_Frequency = frequency;
+    request->ahir_Type = type;
+}
+
+static int AHI_CaptureFromDevice(_THIS, void *buffer, int buflen)
+{
+	struct AHIRequest  *request;
+	MOSAudioData *hidden = this->hidden;
+	Uint32 now;
+	UBYTE current;
+	size_t copyLen;
+    void *completedBuffer;
+	
+	now = SDL_GetTicks();
+	current = hidden->current_buffer;
+	request = &hidden->req[0];
+	
+    if (hidden->lastCaptureTicks == 0 || (now - hidden->lastCaptureTicks) > RESTART_CAPTURE_THRESHOLD) {
+
+	    if (hidden->requestSent)
+            WaitIO((struct IORequest *)request);
+		
+        AHI_FillCaptureRequest(
+            request,
+            hidden->buffers[current],
+            this->spec.size,
+            this->spec.freq,
+            hidden->sample_format);
+
+        request->ahir_Std.io_Offset = 0;
+
+        D("[%s] Start recording\n", __FUNCTION__);
+
+        DoIO((struct IORequest *)request);
+        hidden->requestSent = SDL_FALSE;
+		
+		current = 1 - current;
+
+    } else {
+		if (hidden->requestSent)
+        	WaitIO((struct IORequest *)request);
+    }
+
+    AHI_FillCaptureRequest(
+        request,
+        hidden->buffers[current],
+        this->spec.size,
+        this->spec.freq,
+        hidden->sample_format);
+
+    SendIO((struct IORequest *)request);
+    hidden->requestSent = SDL_TRUE;
+
+	current = 1 - current;
+	
+    completedBuffer = hidden->buffers[current];
+
+    copyLen = MIN(buflen, this->spec.size);
+
+    SDL_memcpy(buffer, completedBuffer, copyLen);
+
+    hidden->lastCaptureTicks = now;
+    hidden->current_buffer = current;
+
+    return copyLen;
+}
+
+static SDL_bool AHI_Init(SDL_AudioDriverImpl * impl)
+{
+	/* Set the function pointers */
+	impl->DetectDevices = AHI_DetectDevices;
+	impl->OpenDevice = AHI_OpenDevice;
+	impl->ThreadInit = AHI_ThreadInit;
+	impl->PlayDevice = AHI_PlayDevice;
+	impl->WaitDevice = AHI_WaitDevice;
+	impl->CaptureFromDevice = AHI_CaptureFromDevice;	
+	impl->GetDeviceBuf = AHI_GetDeviceBuf;
+	impl->CloseDevice = AHI_CloseDevice;
+
+	impl->ProvidesOwnCallbackThread = SDL_FALSE;
+	impl->HasCaptureSupport = SDL_TRUE;
+	impl->OnlyHasDefaultOutputDevice = SDL_TRUE;
+	impl->OnlyHasDefaultCaptureDevice = SDL_TRUE;
+	
+	return SDL_TRUE;   /* this audio target is available. */
+}
+
+AudioBootStrap AHIAUD_bootstrap = {
+    "ahi", "MorphOS AHI audio driver", AHI_Init, SDL_FALSE 
+};
diff -ruN SDL2-2.32.8/src/audio/ahi/SDL_ahi_audio.h SDL2-2.32.8.aros/src/audio/ahi/SDL_ahi_audio.h
--- SDL2-2.32.8/src/audio/ahi/SDL_ahi_audio.h	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/audio/ahi/SDL_ahi_audio.h	2025-07-27 14:24:12.204841317 +0000
@@ -0,0 +1,49 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2022 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifndef _SDL_ahi_audio_h
+#define _SDL_ahi_audio_h
+
+#include "SDL_types.h"
+
+#include <devices/ahi.h>
+
+/* Hidden "this" pointer for the audio functions */
+#define _THIS   SDL_AudioDevice *this
+
+struct SDL_PrivateAudioData
+{
+	struct MsgPort    ahiport;
+	struct AHIRequest req[2];
+
+	Uint8  *buffers[2];
+	Uint32 audioBufferSize;
+	UBYTE current_buffer;
+	UBYTE sample_format;
+	UBYTE playing;
+	Uint32	lastCaptureTicks;
+	SDL_bool requestSent;
+};
+
+typedef struct SDL_PrivateAudioData MOSAudioData;
+
+#endif /* _SDL_ahi_audio_h */
diff -ruN SDL2-2.32.8/src/audio/SDL_audio.c SDL2-2.32.8.aros/src/audio/SDL_audio.c
--- SDL2-2.32.8/src/audio/SDL_audio.c	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/src/audio/SDL_audio.c	2025-07-27 14:24:12.824841320 +0000
@@ -135,6 +135,9 @@
 #ifdef SDL_AUDIO_DRIVER_DUMMY
     &DUMMYAUDIO_bootstrap,
 #endif
+#if SDL_AUDIO_DRIVER_AHI
+    &AHIAUD_bootstrap,
+#endif
     NULL
 };
 
diff -ruN SDL2-2.32.8/src/audio/SDL_sysaudio.h SDL2-2.32.8.aros/src/audio/SDL_sysaudio.h
--- SDL2-2.32.8/src/audio/SDL_sysaudio.h	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/src/audio/SDL_sysaudio.h	2025-07-27 14:24:12.880841320 +0000
@@ -208,6 +208,7 @@
 extern AudioBootStrap VITAAUD_bootstrap;
 extern AudioBootStrap N3DSAUDIO_bootstrap;
 extern AudioBootStrap EMSCRIPTENAUDIO_bootstrap;
+extern AudioBootStrap AHIAUD_bootstrap;
 extern AudioBootStrap OS2AUDIO_bootstrap;
 
 #endif /* SDL_sysaudio_h_ */
diff -ruN SDL2-2.32.8/src/core/aros/SDL_cpu.c SDL2-2.32.8.aros/src/core/aros/SDL_cpu.c
--- SDL2-2.32.8/src/core/aros/SDL_cpu.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/core/aros/SDL_cpu.c	2025-07-27 14:24:13.576841324 +0000
@@ -0,0 +1,43 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2022 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#include "SDL_stdinc.h"
+
+#include <exec/types.h>
+
+//#include "SDL_library.h"
+
+void SDL_CopyAndSwap16(APTR srcx, APTR destx, LONG units)
+{
+	if (units > 0)
+	{
+//		copy_and_swap16_generic(srcx, destx, units);
+	}
+}
+
+void SDL_CopyAndSwap32(APTR srcx, APTR destx, LONG units)
+{
+	if (units > 0)
+	{
+//		copy_and_swap32_generic(srcx, destx, units);
+	}
+}
diff -ruN SDL2-2.32.8/src/core/aros/SDL_cpu.h SDL2-2.32.8.aros/src/core/aros/SDL_cpu.h
--- SDL2-2.32.8/src/core/aros/SDL_cpu.h	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/core/aros/SDL_cpu.h	2025-07-27 14:24:13.584841324 +0000
@@ -0,0 +1,34 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2020 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#ifndef SDL_CORE_AROS_CPU_H
+#define SDL_CORE_AROS_CPU_H
+
+#include "../../SDL_internal.h"
+
+#ifndef EXEC_TYPES_H
+#include <exec/types.h>
+#endif
+
+extern void SDL_CopyAndSwap16(APTR srcx, APTR destx, LONG units);
+extern void SDL_CopyAndSwap32(APTR srcx, APTR destx, LONG units);
+
+#endif /* SDL_CORE_AROS_CPU_H */
diff -ruN SDL2-2.32.8/src/core/morphos/SDL_mosversion.h SDL2-2.32.8.aros/src/core/morphos/SDL_mosversion.h
--- SDL2-2.32.8/src/core/morphos/SDL_mosversion.h	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/core/morphos/SDL_mosversion.h	2025-07-27 14:24:13.256841322 +0000
@@ -0,0 +1,5 @@
+#define	str(s) #s
+#define 	xstr(s) str(s)
+#define	VERSION		53
+#define	REVISION	21
+#define	VERSTAG	"\0$VER: sdl2.library " xstr(VERSION) "." xstr(REVISION) " (" __AMIGADATE__ ") Â© Bruno Peloille, Szilard Biro, Ilkka Lehtoranta"
diff -ruN SDL2-2.32.8/src/cpuinfo/SDL_cpuinfo.c SDL2-2.32.8.aros/src/cpuinfo/SDL_cpuinfo.c
--- SDL2-2.32.8/src/cpuinfo/SDL_cpuinfo.c	2025-05-08 20:10:28.000000000 +0000
+++ SDL2-2.32.8.aros/src/cpuinfo/SDL_cpuinfo.c	2025-07-29 13:06:27.701401441 +0000
@@ -62,6 +62,16 @@
 #include <setjmp.h>
 #endif
 
+#ifdef __MORPHOS__
+#include <stdlib.h>
+#include <exec/execbase.h>
+#include <exec/system.h>
+#endif
+
+#if defined(__MORPHOS__) || defined(__AROS__)
+#include <proto/exec.h>
+#endif
+
 #if defined(__QNXNTO__)
 #include <sys/syspage.h>
 #endif
@@ -131,7 +141,7 @@
     !((defined(__MACOSX__) && (defined(__ppc__) || defined(__ppc64__))) || (defined(__OpenBSD__) && defined(__powerpc__))) && \
     !(defined(__FreeBSD__) && defined(__powerpc__)) && \
     !(defined(__LINUX__) && defined(__powerpc__) && defined(HAVE_GETAUXVAL)) && \
-    defined(SDL_ALTIVEC_BLITTERS) && defined(HAVE_SETJMP)
+    defined(SDL_ALTIVEC_BLITTERS) && defined(HAVE_SETJMP) && !defined(__MORPHOS__)
 /* This is the brute force way of detecting instruction sets...
    the idea is borrowed from the libmpeg2 library - thanks!
  */
@@ -355,6 +365,13 @@
     if (0 == error) {
         altivec = (hasVectorUnit != 0);
     }
+#elif defined(__MORPHOS__)
+    ULONG has_altivec;
+    if (NewGetSystemAttrs(&has_altivec, sizeof(has_altivec), SYSTEMINFOTYPE_PPC_ALTIVEC, TAG_DONE))
+    {
+      if (has_altivec)
+        altivec = 1;
+    }
 #elif defined(__FreeBSD__) && defined(__powerpc__)
     unsigned long cpufeatures = 0;
     elf_aux_info(AT_HWCAP, &cpufeatures, sizeof(cpufeatures));
@@ -699,6 +716,12 @@
                             &SDL_CPUCount, sizeof(SDL_CPUCount) );
         }
 #endif
+#ifdef __MORPHOS__
+	NewGetSystemAttrs(&SDL_CPUCount, sizeof(SDL_CPUCount), SYSTEMINFOTYPE_CPUCOUNT, TAG_DONE);
+#endif
+#ifdef __AROS__
+ // TODO:
+#endif
 #endif
         /* There has to be at least 1, right? :) */
         if (SDL_CPUCount <= 0) {
@@ -934,6 +957,9 @@
         }
 #elif defined(__FreeBSD__) && defined(CACHE_LINE_SIZE)
         cacheline_size = CACHE_LINE_SIZE;
+#elif __MORPHOS__
+        extern u_int32_t DataL1LineSize;
+        cacheline_size = DataL1LineSize;
 #endif
     }
     return cacheline_size;
@@ -1156,6 +1182,11 @@
             }
         }
 #endif
+#if defined(__MORPHOS__) || defined(__AROS__)
+        if (SDL_SystemRAM <= 0) {
+            SDL_SystemRAM = AvailMem(MEMF_TOTAL) / (1024 * 1024);
+        }
+#endif
 #ifdef __VITA__
         if (SDL_SystemRAM <= 0) {
             /* Vita has 512MiB on SoC, that's split into 256MiB(+109MiB in extended memory mode) for app
diff -ruN SDL2-2.32.8/src/dynapi/SDL_dynapi.h SDL2-2.32.8.aros/src/dynapi/SDL_dynapi.h
--- SDL2-2.32.8/src/dynapi/SDL_dynapi.h	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/src/dynapi/SDL_dynapi.h	2025-07-28 12:54:16.736849927 +0000
@@ -69,6 +69,8 @@
 #define SDL_DYNAMIC_API 0 /* devkitARM doesn't support dynamic linking */
 #elif defined(DYNAPI_NEEDS_DLOPEN) && !defined(HAVE_DLOPEN)
 #define SDL_DYNAMIC_API 0 /* we need dlopen(), but don't have it.... */
+#elif defined(__AROS__)
+#define SDL_DYNAMIC_API 0
 #endif
 
 /* everyone else. This is where we turn on the API if nothing forced it off. */
diff -ruN SDL2-2.32.8/src/events/scancodes_amigaos.h SDL2-2.32.8.aros/src/events/scancodes_amigaos.h
--- SDL2-2.32.8/src/events/scancodes_amigaos.h	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/events/scancodes_amigaos.h	2025-07-29 10:33:58.597401006 +0000
@@ -0,0 +1,144 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../include/SDL_scancode.h"
+
+/* Amiga virtual key code to SDL_Keycode mapping table
+   Sources:
+   - AmigaOS wiki
+*/
+/* *INDENT-OFF* */
+static SDL_Scancode const amigaos_scancode_table[] = {
+    /*  0 */    SDL_SCANCODE_GRAVE,
+    /*  1 */    SDL_SCANCODE_1,
+    /*  2 */    SDL_SCANCODE_2,
+    /*  3 */    SDL_SCANCODE_3,
+    /*  4 */    SDL_SCANCODE_4,
+    /*  5 */    SDL_SCANCODE_5,
+    /*  6 */    SDL_SCANCODE_6,
+    /*  7 */    SDL_SCANCODE_7,
+    /*  8 */    SDL_SCANCODE_8,
+    /*  9 */     SDL_SCANCODE_9,
+    /*  10 */    SDL_SCANCODE_0,
+    /*  11 */    SDL_SCANCODE_MINUS,
+    /*  12 */    SDL_SCANCODE_EQUALS,
+    /*  13 */    SDL_SCANCODE_BACKSLASH,
+    /*  14 */    SDL_SCANCODE_INTERNATIONAL3,
+    /*  15 */    SDL_SCANCODE_KP_0,
+    /*  16 */    SDL_SCANCODE_Q,
+    /*  17 */    SDL_SCANCODE_W,
+    /*  18 */    SDL_SCANCODE_E,
+    /*  19 */    SDL_SCANCODE_R,
+    /*  20 */    SDL_SCANCODE_T,
+    /*  21 */    SDL_SCANCODE_Y,
+    /*  22 */    SDL_SCANCODE_U,
+    /*  23 */    SDL_SCANCODE_I,
+    /*  24 */    SDL_SCANCODE_O,
+    /*  25 */    SDL_SCANCODE_P,
+    /*  26 */    SDL_SCANCODE_LEFTBRACKET,
+    /*  27 */    SDL_SCANCODE_RIGHTBRACKET,
+    /*  28 */    SDL_SCANCODE_UNKNOWN,
+    /*  29 */    SDL_SCANCODE_KP_1,
+    /*  30 */    SDL_SCANCODE_KP_2,
+    /*  31 */    SDL_SCANCODE_KP_3,
+    /*  32 */    SDL_SCANCODE_A,
+    /*  33 */    SDL_SCANCODE_S,
+    /*  34 */    SDL_SCANCODE_D,
+    /*  35 */    SDL_SCANCODE_F,
+    /*  36 */    SDL_SCANCODE_G,
+    /*  37 */    SDL_SCANCODE_H,
+    /*  38 */    SDL_SCANCODE_J,
+    /*  39 */    SDL_SCANCODE_K,
+    /*  40 */    SDL_SCANCODE_L,
+    /*  41 */    SDL_SCANCODE_SEMICOLON,
+    /*  42 */    SDL_SCANCODE_APOSTROPHE,
+    /*  43 */    SDL_SCANCODE_INTERNATIONAL1,
+    /*  44 */    SDL_SCANCODE_UNKNOWN,
+    /*  45 */    SDL_SCANCODE_KP_4,
+    /*  46 */    SDL_SCANCODE_KP_5,
+    /*  47 */    SDL_SCANCODE_KP_6,
+    /*  48 */    SDL_SCANCODE_INTERNATIONAL2,
+    /*  49 */    SDL_SCANCODE_Z,
+    /*  50 */    SDL_SCANCODE_X,
+    /*  51 */    SDL_SCANCODE_C,
+    /*  52 */    SDL_SCANCODE_V,
+    /*  53 */    SDL_SCANCODE_B,
+    /*  54 */    SDL_SCANCODE_N,
+    /*  55 */    SDL_SCANCODE_M,
+    /*  56 */    SDL_SCANCODE_COMMA,
+    /*  57 */    SDL_SCANCODE_PERIOD,
+    /*  58 */    SDL_SCANCODE_SLASH,
+    /*  59 */    SDL_SCANCODE_UNKNOWN, // or SDL_SCANCODE_INTERNATIONAL1,
+    /*  60 */    SDL_SCANCODE_KP_PERIOD,
+    /*  61 */    SDL_SCANCODE_KP_7,
+    /*  62 */    SDL_SCANCODE_KP_8,
+    /*  63 */    SDL_SCANCODE_KP_9,
+    /*  64 */    SDL_SCANCODE_SPACE,
+    /*  65 */    SDL_SCANCODE_BACKSPACE,
+    /*  66 */    SDL_SCANCODE_TAB,
+    /*  67 */    SDL_SCANCODE_KP_ENTER,
+    /*  68 */    SDL_SCANCODE_RETURN,
+    /*  69 */    SDL_SCANCODE_ESCAPE,
+    /*  70 */    SDL_SCANCODE_DELETE,
+    /*  71 */    SDL_SCANCODE_INSERT,
+    /*  72 */    SDL_SCANCODE_PAGEUP,
+    /*  73 */    SDL_SCANCODE_PAGEDOWN,
+    /*  74 */    SDL_SCANCODE_KP_MINUS,
+    /*  75 */    SDL_SCANCODE_F11,
+    /*  76 */    SDL_SCANCODE_UP,
+    /*  77 */    SDL_SCANCODE_DOWN,
+    /*  78 */    SDL_SCANCODE_RIGHT,
+    /*  79 */    SDL_SCANCODE_LEFT,
+    /*  80 */    SDL_SCANCODE_F1,
+    /*  81 */    SDL_SCANCODE_F2,
+    /*  82 */    SDL_SCANCODE_F3,
+    /*  83 */    SDL_SCANCODE_F4,
+    /*  84 */    SDL_SCANCODE_F5,
+    /*  85 */    SDL_SCANCODE_F6,
+    /*  86 */    SDL_SCANCODE_F7,
+    /*  87 */    SDL_SCANCODE_F8,
+    /*  88 */    SDL_SCANCODE_F9,
+    /*  89 */    SDL_SCANCODE_F10,
+    /*  90 */    SDL_SCANCODE_KP_LEFTPAREN,
+    /*  91 */    SDL_SCANCODE_KP_RIGHTPAREN,
+    /*  92 */    SDL_SCANCODE_KP_DIVIDE,
+    /*  93 */    SDL_SCANCODE_KP_MULTIPLY,
+    /*  94 */    SDL_SCANCODE_KP_PLUS,
+    /*  95 */    SDL_SCANCODE_SCROLLLOCK, // or SDL_SCANCODE_HELP,
+    /*  96 */    SDL_SCANCODE_LSHIFT,
+    /*  97 */    SDL_SCANCODE_RSHIFT,
+    /*  98 */    SDL_SCANCODE_CAPSLOCK,
+    /*  99 */    SDL_SCANCODE_LCTRL,
+    /*  100 */    SDL_SCANCODE_LALT,
+    /*  101 */    SDL_SCANCODE_RALT,
+    /*  102 */    SDL_SCANCODE_LGUI,
+    /*  103 */    SDL_SCANCODE_RGUI,
+    /*  104 */    SDL_SCANCODE_UNKNOWN,
+    /*  105 */    SDL_SCANCODE_UNKNOWN,
+    /*  106 */    SDL_SCANCODE_UNKNOWN,
+    /*  107 */    SDL_SCANCODE_MENU,
+    /*  108 */    SDL_SCANCODE_KP_PERIOD,
+    /*  109 */    SDL_SCANCODE_PRINTSCREEN,
+    /*  110 */    SDL_SCANCODE_PAUSE,
+    /*  111 */    SDL_SCANCODE_F12,
+    /*  112 */    SDL_SCANCODE_HOME,
+    /*  113 */    SDL_SCANCODE_END,
+};
+/* *INDENT-ON* */
diff -ruN SDL2-2.32.8/src/file/SDL_rwops.c SDL2-2.32.8.aros/src/file/SDL_rwops.c
--- SDL2-2.32.8/src/file/SDL_rwops.c	2025-01-28 07:47:10.000000000 +0000
+++ SDL2-2.32.8.aros/src/file/SDL_rwops.c	2025-08-05 16:37:40.256632360 +0000
@@ -67,6 +67,35 @@
 #include "nacl_io/nacl_io.h"
 #endif
 
+#ifdef __AROS__
+//#define DEBUG 1
+#include <aros/debug.h>
+#include "../misc/aros/SDL_misc.h"
+#include <proto/dos.h>
+#endif
+
+#ifdef __MORPHOS__
+#include "../core/morphos/SDL_library.h"
+#include "../core/morphos/SDL_misc.h"
+#include <proto/dos.h>
+
+#undef SDLCALL
+#define SDLCALL __saveds
+
+/* This function must preserve all registers except r13 */
+asm
+("\n"
+"	.section \".text\"\n"
+"	.align 2\n"
+"	.type __restore_r13, @function\n"
+"__restore_r13:\n"
+"	lwz 13, 24(3)\n"
+"	blr\n"
+"__end__restore_r13:\n"
+"	.size __restore_r13, __end__restore_r13 - __restore_r13\n"
+);
+#endif
+
 #if defined(__WIN32__) || defined(__GDK__)
 
 /* Functions to read/write Win32 API file pointers */
@@ -311,7 +340,226 @@
 }
 #endif /* defined(__WIN32__) || defined(__GDK__) */
 
-#ifdef HAVE_STDIO_H
+#if defined(__MORPHOS__) || defined(__AROS__)
+static int
+amigaos_file_open(SDL_RWops *context, const char *filename, const char *mode)
+{
+    int flag_r, flag_w, flag_p, flag_a;
+    int rc = -1;
+
+    /* "r" = reading, file must exist */
+    /* "w" = writing, truncate existing, file may not exist */
+    /* "r+"= reading or writing, file must exist            */
+    /* "a" = writing, append file may not exist             */
+    /* "a+"= append + read, file may not exist              */
+    /* "w+" = read, write, truncate. file may not exist    */
+
+    flag_r = strchr(mode, 'r') ? 1 : 0;
+    flag_w = strchr(mode, 'w') ? 1 : 0;
+    flag_p = strchr(mode, '+') ? 1 : 0;
+    flag_a = strchr(mode, 'a') ? 1 : 0;
+
+    if (flag_r || flag_w || flag_a)
+    {
+        size_t mode = MODE_OLDFILE;
+        BPTR fh;
+
+        if (flag_a)
+        {
+            mode = MODE_READWRITE;
+        }
+        else if (flag_w)
+        {
+            mode = MODE_NEWFILE;
+        }
+
+        fh = Open(filename, mode);
+
+        context->hidden.amigaosio.Writable = (flag_w || flag_a || flag_p) ? 1 : 0;
+        context->hidden.amigaosio.Readable = (flag_r || flag_p) ? 1 : 0;
+
+        context->hidden.amigaosio.autoclose = 1;
+        context->hidden.amigaosio.AMIGAOSIO_BPTR = fh;
+
+        if (fh)
+        {
+            rc = 0;
+
+            context->hidden.amigaosio.AppendMode = 0;
+            context->hidden.amigaosio.NoSeek = 0;
+            context->hidden.amigaosio.IsAtEnd = 0;
+
+            if (flag_a)
+            {
+                context->hidden.amigaosio.AppendMode = 1;
+
+                if (!flag_p)
+                {
+                    context->hidden.amigaosio.NoSeek = 1;
+                    context->hidden.amigaosio.IsAtEnd = 1;
+                    Seek(fh, 0, OFFSET_END);
+                }
+            }
+        }
+    }
+
+    return rc;
+}
+
+static Sint64 SDLCALL
+amigaos_file_size(SDL_RWops * context)
+{
+    struct FileInfoBlock fib;
+
+#if defined(__MORPHOS__)
+    if (ExamineFH64(context->hidden.amigaosio.fp.dos, &fib, TAG_DONE))
+        return fib.fib_Size64;
+#else
+    if (ExamineFH(context->hidden.amigaosio.AMIGAOSIO_BPTR, &fib))
+        return fib.fib_Size;
+#endif
+
+    return -1;
+}
+
+static Sint64 SDLCALL
+amigaos_file_seek(SDL_RWops *context, Sint64 offset, int whence)
+{
+    Sint64 rc = -1;
+
+    if (!context->hidden.amigaosio.NoSeek)
+    {
+        LONG how = OFFSET_BEGINNING;
+
+        switch (whence)
+        {
+			case RW_SEEK_SET: how = OFFSET_BEGINNING; break;
+            case RW_SEEK_CUR: how = OFFSET_CURRENT; break;
+            case RW_SEEK_END: how = OFFSET_END; break;
+
+			default: return SDL_SetError("Unknown value for 'whence'");
+        }
+
+        context->hidden.amigaosio.IsAtEnd = 0;
+
+#if defined(__MORPHOS__)
+        if (Seek64(context->hidden.amigaosio.fp.dos, offset, how) == -1)
+#else
+        if (Seek(context->hidden.amigaosio.AMIGAOSIO_BPTR, offset, how) == -1)
+#endif
+        {
+            SDL_Error(SDL_EFSEEK);
+        }
+        else
+        {
+            if (how == OFFSET_END && offset == 0)
+                context->hidden.amigaosio.IsAtEnd = 1;
+
+#if defined(__MORPHOS__)
+            rc = Seek64(context->hidden.amigaosio.fp.dos, 0, OFFSET_CURRENT);
+#else
+            rc = Seek(context->hidden.amigaosio.AMIGAOSIO_BPTR, 0, OFFSET_CURRENT);
+#endif
+        }
+    }
+
+    return rc;
+}
+
+static size_t SDLCALL
+amigaos_file_read(SDL_RWops *context, void *ptr, size_t size, size_t maxnum)
+{
+    size_t rsize = size * maxnum, result;
+
+    if (context->hidden.amigaosio.Readable)
+    {
+        if ((result = Read(context->hidden.amigaosio.AMIGAOSIO_BPTR, ptr, rsize)) != rsize)
+        {
+            SDL_Error(SDL_EFWRITE);
+        }
+    }
+    else
+    {
+        result = 0;
+    }
+
+    return result / size;
+}
+
+static size_t SDLCALL
+amigaos_file_write(SDL_RWops *context, const void *ptr, size_t size, size_t num)
+{
+    size_t wnum = 0;
+    //D(bug("[SDL2:rwops] %s()\n", __func__));
+
+    if (context->hidden.amigaosio.Writable)
+    {
+        size_t wsize, result;
+
+        if (context->hidden.amigaosio.AppendMode && !context->hidden.amigaosio.IsAtEnd)
+        {
+            if (Seek(context->hidden.amigaosio.AMIGAOSIO_BPTR, 0, OFFSET_END) == -1)
+            {
+                SDL_Error(SDL_EFWRITE);
+                return 0;
+            }
+
+            context->hidden.amigaosio.IsAtEnd = 1;
+        }
+
+        wsize = size * num;
+
+        if ((result = Write(context->hidden.amigaosio.AMIGAOSIO_BPTR, (APTR)ptr, wsize)) != wsize)
+        {
+            SDL_Error(SDL_EFWRITE);
+        }
+
+        wnum = result / size;
+    }
+
+    return wnum;
+}
+
+static int SDLCALL
+amigaos_file_close(SDL_RWops *context)
+{
+    if (context->hidden.amigaosio.fp.dos != 0)
+    {
+        if (context->hidden.amigaosio.autoclose) {
+            Close(context->hidden.amigaosio.AMIGAOSIO_BPTR);
+        }
+
+        SDL_FreeRW(context);
+    }
+
+    return(0);
+}
+
+SDL_RWops * SDL_RWFromFP_clib(void *fp,
+                             int autoclose,
+                             Sint64 (*size)(struct SDL_RWops *),
+                             Sint64 (*seek)(struct SDL_RWops *, Sint64, int),
+                             size_t (*read)(struct SDL_RWops *, void *, size_t, size_t),
+                             size_t (*write)(struct SDL_RWops *, const void *, size_t, size_t),
+                             int (*close)(struct SDL_RWops *))
+{
+    SDL_RWops *rwops;
+    D(bug("[SDL2:rwops] %s()\n", __func__));
+
+    rwops = SDL_AllocRW();
+    if ( rwops != NULL ) {
+        rwops->size = size;
+        rwops->seek = seek;
+        rwops->read = read;
+        rwops->write = write;
+        rwops->close = close;
+        rwops->type = SDL_RWOPS_STDFILE;
+        rwops->hidden.amigaosio.fp.libc = fp;
+        rwops->hidden.amigaosio.autoclose = autoclose;
+    }
+    return(rwops);
+}
+#elif defined(HAVE_STDIO_H)
 
 #ifdef HAVE_FOPEN64
 #define fopen fopen64
@@ -528,7 +776,8 @@
 
 /* Functions to create SDL_RWops structures from various data sources */
 
-#if defined(HAVE_STDIO_H) && !(defined(__WIN32__) || defined(__GDK__))
+#if !defined(__MORPHOS__) && !defined(__AROS__) && \
+      defined(HAVE_STDIO_H) && !(defined(__WIN32__) || defined(__GDK__))
 static SDL_bool IsRegularFileOrPipe(FILE *f)
 {
     #ifdef __WINRT__
@@ -624,6 +873,38 @@
     rwops->write = windows_file_write;
     rwops->close = windows_file_close;
     rwops->type = SDL_RWOPS_WINFILE;
+#elif defined(__MORPHOS__) || defined(__AROS__)
+    rwops = SDL_AllocRW();
+    if (!rwops)
+        return NULL; /* SDL_SetError already setup by SDL_AllocRW() */
+
+    rwops->size  = amigaos_file_size;
+    rwops->seek  = amigaos_file_seek;
+    rwops->read  = amigaos_file_read;
+    rwops->write = amigaos_file_write;
+    rwops->close = amigaos_file_close;
+    rwops->type = SDL_RWOPS_MORPHOSFILE;
+
+    char *mpath;
+    int rc = -1;
+
+#if defined(__AROS__)
+    mpath = AROS_ConvertPath(file);
+#else
+    mpath = MOS_ConvertPath(file);
+#endif
+
+    if (mpath)
+    {
+        rc = amigaos_file_open(rwops,file,mode);
+        SDL_free(mpath);
+    }
+
+    if (rc < 0)
+    {
+        SDL_FreeRW(rwops);
+        return NULL;
+    }
 #elif defined(HAVE_STDIO_H)
     {
 #if defined(__APPLE__) && !defined(SDL_FILE_DISABLED) // TODO: add dummy?
@@ -653,7 +934,7 @@
     return rwops;
 }
 
-#ifdef HAVE_STDIO_H
+#if defined(HAVE_STDIO_H) && !defined(__MORPHOS__) && !defined(__AROS__)
 SDL_RWops *SDL_RWFromFP(FILE * fp, SDL_bool autoclose)
 {
     SDL_RWops *rwops = NULL;
@@ -741,6 +1022,10 @@
     if (!area) {
         SDL_OutOfMemory();
     } else {
+#if defined(__MORPHOS__)
+        register APTR DataSeg __asm("r13");
+        area->r13 = DataSeg;
+#endif
         area->type = SDL_RWOPS_UNKNOWN;
     }
     return area;
diff -ruN SDL2-2.32.8/src/filesystem/aros/SDL_sysfilesystem.c SDL2-2.32.8.aros/src/filesystem/aros/SDL_sysfilesystem.c
--- SDL2-2.32.8/src/filesystem/aros/SDL_sysfilesystem.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/filesystem/aros/SDL_sysfilesystem.c	2025-08-05 16:29:56.128628931 +0000
@@ -0,0 +1,148 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2020 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifdef SDL_FILESYSTEM_AROS
+
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+/* System dependent filesystem routines                                */
+
+#include "SDL_error.h"
+#include "SDL_filesystem.h"
+
+#include "../../misc/aros/SDL_misc.h"
+
+#include <aros/debug.h>
+#include <proto/dos.h>
+
+char *
+SDL_GetBasePath(void)
+{
+	BPTR lock = Lock("PROGDIR:", ACCESS_READ);
+	char *path = NULL;
+
+	D(bug("[SDL2:sysfs] %s()\n", __func__));
+
+	if (lock)
+	{
+		size_t len = 128;
+
+		for (;;)
+		{
+			char *tmp = SDL_malloc(len);
+
+			if (NameFromLock(lock, tmp, len))
+			{
+				path = AROS_ConvertUTF8Text(tmp);
+
+				SDL_free(tmp);
+				break;
+			}
+
+			SDL_free(tmp);
+
+			len *= 2;
+
+			if (IoErr() != ERROR_LINE_TOO_LONG)
+				break;
+		}
+
+		UnLock(lock);
+	}
+
+	return path;
+}
+
+static char *
+SDL_RemoveInvalidChars(const char *src)
+{
+	if (src)
+	{
+		char *s = SDL_strdup(src);
+		char *p = s;
+
+		if (s)
+		{
+			char c;
+
+			while ((c = *p))
+			{
+				if (c == '/' || c == ':')
+					*p = ' ';
+
+				p++;
+			}
+		}
+
+		return s;
+	} else
+		return NULL;
+}
+
+char *
+SDL_GetPrefPath(const char *org, const char *app)
+{
+	char *p1 = SDL_RemoveInvalidChars(org);
+	char *path = NULL;
+	char *p2 = SDL_RemoveInvalidChars(app);
+
+	int len = sizeof("ENVARC:");
+	if (p1) len += SDL_strlen(p1) + 1;
+	if (p2) len += SDL_strlen(p2) + 1;
+	char *tmp = SDL_malloc(len);
+	
+	if (tmp)
+	{
+		BPTR lock;
+
+		strcpy(tmp, "ENVARC:");
+		if (p1) {
+			AddPart(tmp, p1, len);
+			if ((lock = CreateDir(tmp)))
+				UnLock(lock);
+
+		}
+		if (p2)
+		{
+			AddPart(tmp, p2, len);
+			if ((lock = CreateDir(tmp)))
+				UnLock(lock);
+		}
+		
+		path = AROS_ConvertUTF8Text(tmp);
+
+		SDL_free(tmp);
+		
+	} else {
+		
+		SDL_OutOfMemory();
+		return NULL;
+	}
+
+	if (p2) SDL_free(p2);
+	if (p1) SDL_free(p1);
+
+	return path;
+}
+
+#endif /* SDL_FILESYSTEM_AROS */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff -ruN SDL2-2.32.8/src/joystick/morphos/SDL_sysjoystick.c SDL2-2.32.8.aros/src/joystick/morphos/SDL_sysjoystick.c
--- SDL2-2.32.8/src/joystick/morphos/SDL_sysjoystick.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/joystick/morphos/SDL_sysjoystick.c	2025-07-27 14:24:15.220841332 +0000
@@ -0,0 +1,508 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#include "SDL_sysjoystick_c.h"
+
+#ifdef SDL_JOYSTICK_MORPHOS
+
+#include "../SDL_sysjoystick.h"
+#include "../SDL_joystick_c.h"
+#include "SDL_endian.h"
+#include "SDL_joystick.h"
+
+#include <exec/execbase.h>
+#include <libraries/sensors.h>
+#include <libraries/sensors_hid.h>
+#define USE_INLINE_STDARG
+#include <proto/sensors.h>
+#undef USE_INLINE_STDARG
+
+// SDL2 deadzone is around 409, we need 1638
+#define DEADZONE_MIN (-0.05)
+#define DEADZONE_MAX (0.05)
+
+#define JOYSTICK_MIN -1.0
+#define JOYSTICK_MAX 1.0
+
+#define CLAMP(val) \
+			(((val) <= (DEADZONE_MAX) && (val) >= (DEADZONE_MIN)) ? (0) : \
+			((val) > (JOYSTICK_MAX)) ? (JOYSTICK_MAX) : (((val) < (JOYSTICK_MIN)) ? (JOYSTICK_MIN) : (val)))
+
+APTR sensorlist;
+APTR JoySensor[MAX_JOYSTICKS];
+int joystick_count;
+
+static int MORPHOS_JoystickInit(void)
+{
+	int rc = 0;
+
+	APTR sensor = NULL;
+	ULONG device_index = 0;
+
+	D("[%s] Obtain sensor list...\n", __FUNCTION__);
+	sensorlist = ObtainSensorsListTags(SENSORS_Class, SensorClass_HID, TAG_DONE);
+	while ((sensor = NextSensor(sensor, sensorlist, NULL)) && device_index < MAX_JOYSTICKS)
+	{
+		JoySensor[device_index++] = sensor;
+	}
+
+	D("[%s] Found %ld joysticks...\n", __FUNCTION__, device_index);
+	joystick_count = device_index;
+	
+	return rc;
+}
+
+static int MORPHOS_JoystickGetCount(void)
+{
+	return joystick_count;
+}
+
+static void MORPHOS_JoystickDetect(void)
+{
+}
+
+static const char *MORPHOS_JoystickGetDeviceName(int device_index)
+{
+	APTR sensor = JoySensor[device_index];
+	const char *name = NULL;
+	GetSensorAttrTags(sensor, SENSORS_HID_Name, (IPTR)&name, TAG_DONE);
+	return name;
+}
+
+static const char *MORPHOS_JoystickGetDevicePath(int device_index)
+{
+    return NULL;
+}
+
+static int MORPHOS_JoystickGetDeviceSteamVirtualGamepadSlot(int device_index)
+{
+    return -1;
+}
+
+static int MORPHOS_JoystickGetDevicePlayerIndex(int device_index)
+{
+    return device_index;
+}
+
+static void MORPHOS_JoystickSetDevicePlayerIndex(int device_index, int player_index)
+{
+}
+
+
+static SDL_JoystickGUID MORPHOS_JoystickGetDeviceGUID(int device_index)
+{
+	SDL_JoystickGUID guid;
+	APTR sensor = JoySensor[device_index];
+	Uint16 *guid16 = (Uint16 *)guid.data;
+	const char *name = NULL;
+
+	ULONG product, vendor;
+	
+	GetSensorAttrTags(sensor,
+			SENSORS_HID_Name, (IPTR)&name,
+			SENSORS_HID_Product, (IPTR)&product,
+			SENSORS_HID_Vendor, (IPTR)&vendor,
+			TAG_DONE);
+
+	SDL_zero(guid);
+	SDL_memset(guid.data, 0, sizeof(guid.data));
+
+	*guid16++ = SDL_SwapLE16(SDL_HARDWARE_BUS_USB);
+    *guid16++ = 0;
+
+    if (vendor && product)
+	{
+        *guid16++ = SDL_SwapLE16(vendor);
+        *guid16++ = 0;
+        *guid16++ = SDL_SwapLE16(product);
+        *guid16++ = 0;
+        *guid16++ = 0;
+        *guid16++ = 0;
+    } 
+	else
+	{
+        SDL_strlcpy((char*)guid16, name, sizeof(guid.data) - 4);
+    }
+	
+	return guid;
+}
+
+static SDL_JoystickID MORPHOS_JoystickGetDeviceInstanceID(int device_index)
+{
+	return device_index;
+}
+
+static int MORPHOS_JoystickOpen(SDL_Joystick *joystick, int device_index)
+{
+	D("[%s]\n", __FUNCTION__);
+	APTR sensor = JoySensor[device_index];
+	int rc = -1;
+
+	if (sensor) {
+		size_t buttons = 0, naxes = 0, nhats = 0, nsticks = 0, nrumbles=0;
+		CONST_STRPTR name = "<unknown>";
+		struct joystick_hwdata *hwdata = SDL_calloc(device_index + 1, sizeof(*hwdata));
+		if (!hwdata) {
+			return SDL_OutOfMemory();
+		}
+		hwdata->main_sensor = sensor;
+
+		hwdata->child_sensors = ObtainSensorsListTags(
+			SENSORS_Parent, (IPTR)hwdata->main_sensor,
+			SENSORS_Class, SensorClass_HID,
+			TAG_DONE);
+
+		sensor = NULL;
+		while ((sensor = NextSensor(sensor, hwdata->child_sensors, NULL))) 
+		{
+			ULONG type = SensorType_HIDInput_Unknown/*, Limb, color, id*/;
+			/*GetSensorAttrTags(sensor, 
+								SENSORS_HIDInput_ID, (IPTR)&id, 
+								SENSORS_HIDInput_Name, (IPTR)&name, 
+								SENSORS_HIDInput_Limb, (IPTR)&Limb, 
+								SENSORS_HIDInput_Color, (IPTR)&color, 
+								TAG_DONE);
+			D("[%s] sensor id: %d name: %s Limb:%d LimbName:%s color:%d\n", __FUNCTION__, id, name, Limb, color);	*/
+			
+			if (GetSensorAttrTags(sensor, SENSORS_Type, (IPTR)&type, TAG_DONE))
+			{
+				switch (type) 
+				{
+					case SensorType_HIDInput_Trigger:
+						if (buttons < MAX_BUTTONS) 
+						{
+							hwdata->button[buttons++] = sensor;
+						}
+						break;
+					case SensorType_HIDInput_Stick:
+						if (nhats < MAX_HATS)
+						{
+							hwdata->hat[nhats++] = sensor;
+						}
+						break;
+					case SensorType_HIDInput_Analog:
+					case SensorType_HIDInput_AnalogStick:
+					case SensorType_HIDInput_3DStick:
+						if (nsticks < MAX_STICKS) 
+						{
+							hwdata->stick[nsticks] = sensor;
+							hwdata->stickType[nsticks] = type;
+							nsticks++;
+							if (type == SensorType_HIDInput_AnalogStick)
+								naxes += 2;
+							else if (type == SensorType_HIDInput_3DStick)
+								naxes += 4;
+							else
+								naxes++;
+						}
+						break;
+					case SensorType_HIDInput_Rumble:
+						if (nrumbles < MAX_RUMBLE)
+						{
+							GetSensorAttrTags(sensor, SENSORS_HID_Name, (IPTR)&name, TAG_DONE);
+							hwdata->rumble[nrumbles] = sensor;
+							nrumbles++;
+						}
+						break;
+					case SensorType_HIDInput_Battery:
+						GetSensorAttrTags(sensor, SENSORS_HID_Name, (IPTR)&name, TAG_DONE);
+					    // Force "Xbox360 Controller" (WIRED) to use SDL_JOYSTICK_POWER_WIRED
+						if (strcmp((const char *)MORPHOS_JoystickGetDeviceName(device_index),(const char *)"Xbox360 Controller") == 0)
+						{
+							SDL_PrivateJoystickBatteryLevel(joystick, SDL_JOYSTICK_POWER_WIRED);  
+							hwdata->battery = NULL;
+						} else {							
+							hwdata->battery = sensor;
+						}
+						break;
+					case SensorType_HIDInput_Knob:
+						GetSensorAttrTags(sensor, SENSORS_HID_Name, (IPTR)&name, TAG_DONE);
+						break;
+					case SensorType_HIDInput_Wheel:
+						GetSensorAttrTags(sensor, SENSORS_HID_Name, (IPTR)&name, TAG_DONE);
+						break;
+					default:
+						//D("[%s] unknown SensorType: %d\n", __FUNCTION__, type);
+						continue;
+				}
+			}
+		}
+
+		joystick->naxes = naxes;
+		joystick->nhats = nhats;
+		joystick->nbuttons = buttons;
+		hwdata->numSticks = nsticks;
+		hwdata->numRumbles = nrumbles;
+		joystick->hwdata = hwdata;
+		joystick->name = (char *)MORPHOS_JoystickGetDeviceName(device_index);
+		rc = 0;
+	} else {
+		SDL_SetError("Failed to open device");
+	}
+	return rc;
+}
+
+static int MORPHOS_JoystickRumble(SDL_Joystick * joystick, Uint16 low_frequency_rumble, Uint16 high_frequency_rumble, Uint32 msDuration)
+{
+	struct joystick_hwdata *hwdata = joystick->hwdata;
+	if (hwdata) 
+	{
+		if (hwdata->numRumbles)
+		{
+			//ULONG msDuration = SDL_MAX_RUMBLE_DURATION_MS;
+			
+			DOUBLE lpower=(DOUBLE)(low_frequency_rumble/65535), hpower=(DOUBLE)(high_frequency_rumble/65535);
+
+			D("[%s] SetSensorAttr lpower=%f - hpower=%f - duration=%d\n", __FUNCTION__,lpower, hpower, msDuration);
+
+			struct TagItem lfreq[] = {
+				{SENSORS_HIDInput_Rumble_Power, (IPTR)&lpower}, 
+				{SENSORS_HIDInput_Rumble_Duration, msDuration}, 
+				{TAG_DONE}
+			};
+			struct TagItem hfreq[] = {
+				{SENSORS_HIDInput_Rumble_Power, (IPTR)&hpower}, 
+				{SENSORS_HIDInput_Rumble_Duration, msDuration}, 
+				{TAG_DONE}	
+			};
+			
+			if (hwdata->rumble[0])
+				SetSensorAttr(hwdata->rumble[0], lfreq);
+			
+			if (hwdata->rumble[1])
+				SetSensorAttr(hwdata->rumble[1], hfreq);
+		} else {
+			return SDL_Unsupported();
+		}
+	}		
+    return 0;
+}
+
+static int MORPHOS_JoystickRumbleTriggers(SDL_Joystick *joystick, Uint16 left_rumble, Uint16 right_rumble)
+{
+    return SDL_Unsupported();
+}
+
+static Uint32 MORPHOS_JoystickGetCapabilities(SDL_Joystick *joystick)
+{
+    Uint32 result = 0;
+	struct joystick_hwdata *hwdata = joystick->hwdata;
+	if (hwdata) 
+	{
+		if (hwdata->numRumbles)
+		{
+        	result |= SDL_JOYCAP_RUMBLE;
+		}
+    }
+
+    return result;
+}
+
+static int MORPHOS_JoystickSetLED(SDL_Joystick *joystick, Uint8 red, Uint8 green, Uint8 blue)
+{
+    return SDL_Unsupported();
+}
+
+static int MORPHOS_JoystickSendEffect(SDL_Joystick *joystick, const void *data, int size)
+{
+    return SDL_Unsupported();
+}
+
+static int MORPHOS_JoystickSetSensorsEnabled(SDL_Joystick *joystick, SDL_bool enabled)
+{
+    return SDL_Unsupported();
+}
+
+static void MORPHOS_JoystickUpdate(SDL_Joystick *joystick)
+{
+	struct joystick_hwdata *hwdata = joystick->hwdata;
+	if (hwdata) 
+	{
+		int i, j;
+		Sint16 sval;
+		double btn_value, bt_value, x_value, y_value, z_value, ns_value, ew_value, z_rotation;
+
+		for (i = 0; i < joystick->nbuttons; i++) 
+		{
+			GetSensorAttrTags(hwdata->button[i], SENSORS_HIDInput_Value, (IPTR)&btn_value, TAG_DONE);
+			if ((joystick->buttons[i] && btn_value == 0.0) || (joystick->buttons[i] == 0 && btn_value > 0.0)) 
+			{
+				SDL_PrivateJoystickButton(joystick, i, btn_value == 0.0 ? 0 : 1);
+			}
+		}
+
+		for (i = 0; i < joystick->nhats; i++) 
+		{
+			GetSensorAttrTags(hwdata->hat[i],
+				SENSORS_HIDInput_EW_Value, (IPTR)&ew_value,
+				SENSORS_HIDInput_NS_Value, (IPTR)&ns_value,
+				TAG_DONE);
+			Uint8 value_hat = SDL_HAT_CENTERED;
+			if (ns_value >= 1.0) {
+				value_hat |= SDL_HAT_DOWN;
+			} else if (ns_value <= -1.0) {
+				value_hat |= SDL_HAT_UP;
+			}
+			if (ew_value >= 1.0) {
+				value_hat |= SDL_HAT_RIGHT;
+			} else if (ew_value <= -1.0) {
+				value_hat |= SDL_HAT_LEFT;
+			}
+			SDL_PrivateJoystickHat(joystick, i, value_hat);
+		}
+		
+		j = 0;
+		for (i = 0; i < hwdata->numSticks; i++) 
+		{
+			switch (hwdata->stickType[i]) 
+			{
+				case SensorType_HIDInput_3DStick:
+					GetSensorAttrTags(hwdata->stick[i],
+						SENSORS_HIDInput_X_Index, (IPTR)&x_value,
+						SENSORS_HIDInput_Y_Index, (IPTR)&y_value,
+						SENSORS_HIDInput_Z_Index, (IPTR)&z_value,
+						SENSORS_HIDInput_Z_Rotation, (IPTR)&z_rotation,
+						TAG_DONE);
+
+					sval = (Sint16)(CLAMP(x_value) * SDL_JOYSTICK_AXIS_MAX);
+					SDL_PrivateJoystickAxis(joystick, j, sval);
+
+					sval = (Sint16)(CLAMP(y_value) * SDL_JOYSTICK_AXIS_MAX);
+					SDL_PrivateJoystickAxis(joystick, j+1, sval);
+
+					sval = (Sint16)(CLAMP(z_value) * SDL_JOYSTICK_AXIS_MAX);
+					SDL_PrivateJoystickAxis(joystick, j+2, sval);
+
+					sval = (Sint16)(CLAMP(z_rotation) * SDL_JOYSTICK_AXIS_MAX);
+					SDL_PrivateJoystickAxis(joystick, j+3, sval);
+					
+					j += 4;
+					break;
+
+				case SensorType_HIDInput_Analog:
+					GetSensorAttrTags(hwdata->stick[i], SENSORS_HIDInput_Value, (IPTR)&btn_value, TAG_DONE);
+
+					sval = (Sint16)(btn_value * SDL_JOYSTICK_AXIS_MAX);
+					SDL_PrivateJoystickAxis(joystick, j, sval);
+
+					j++;
+					break;
+
+				case SensorType_HIDInput_AnalogStick:
+					GetSensorAttrTags(hwdata->stick[i],
+						SENSORS_HIDInput_EW_Value, (IPTR)&ew_value,
+						SENSORS_HIDInput_NS_Value, (IPTR)&ns_value,
+						TAG_DONE);
+
+					sval = (Sint16)(CLAMP(ew_value) * SDL_JOYSTICK_AXIS_MAX);
+					SDL_PrivateJoystickAxis(joystick, j, sval);
+
+					sval = (Sint16)(CLAMP(ns_value) * SDL_JOYSTICK_AXIS_MAX);
+					SDL_PrivateJoystickAxis(joystick, j+1, sval);
+
+					j += 2;
+					break;
+			}
+		}
+		
+		if (hwdata->battery) 
+		{
+			SDL_JoystickPowerLevel ePowerLevel = SDL_JOYSTICK_POWER_UNKNOWN;
+			GetSensorAttrTags(hwdata->battery,
+						SENSORS_HIDInput_Value, (IPTR)&bt_value,
+						TAG_DONE);
+			ULONG level = bt_value*100;
+			switch (level)
+			{
+			   case 0 ... 5:
+					ePowerLevel = SDL_JOYSTICK_POWER_EMPTY;
+					break;
+			   case 6 ... 20:
+				   ePowerLevel = SDL_JOYSTICK_POWER_LOW;
+					break;
+			   case 21 ... 70:
+					ePowerLevel = SDL_JOYSTICK_POWER_MEDIUM;
+					break;
+			   case 71 ... 100:
+					ePowerLevel = SDL_JOYSTICK_POWER_FULL;
+					break;
+			}
+			SDL_PrivateJoystickBatteryLevel(joystick, ePowerLevel);  
+		}
+	}
+}
+
+void MORPHOS_JoystickClose(SDL_Joystick *joystick)
+{
+	D("[%s]\n", __FUNCTION__);
+	struct joystick_hwdata *hwdata = joystick->hwdata;
+	if (hwdata) 
+	{
+		if (hwdata->child_sensors) 
+		{
+			ReleaseSensorsList(hwdata->child_sensors, NULL);
+			hwdata->child_sensors = NULL;
+		}
+		SDL_free(hwdata);
+		joystick->hwdata = NULL;
+	}
+}
+
+void MORPHOS_JoystickQuit(void)
+{
+	D("[%s]\n", __FUNCTION__);
+	if (sensorlist) {
+		ReleaseSensorsList(sensorlist, NULL);
+		sensorlist = NULL;
+	}
+}
+
+static SDL_bool MORPHOS_JoystickGetGamepadMapping(int device_index, SDL_GamepadMapping *out)
+{
+    return SDL_FALSE;
+}
+
+SDL_JoystickDriver SDL_MORPHOS_JoystickDriver =
+{
+    MORPHOS_JoystickInit,
+    MORPHOS_JoystickGetCount,
+    MORPHOS_JoystickDetect,
+    MORPHOS_JoystickGetDeviceName,
+	MORPHOS_JoystickGetDevicePath,
+	MORPHOS_JoystickGetDeviceSteamVirtualGamepadSlot,
+    MORPHOS_JoystickGetDevicePlayerIndex,
+    MORPHOS_JoystickSetDevicePlayerIndex,
+    MORPHOS_JoystickGetDeviceGUID,
+    MORPHOS_JoystickGetDeviceInstanceID,
+    MORPHOS_JoystickOpen,
+    MORPHOS_JoystickRumble,
+    MORPHOS_JoystickRumbleTriggers,
+    MORPHOS_JoystickGetCapabilities,
+    MORPHOS_JoystickSetLED,
+	MORPHOS_JoystickSendEffect,
+	MORPHOS_JoystickSetSensorsEnabled,
+    MORPHOS_JoystickUpdate,
+    MORPHOS_JoystickClose,
+    MORPHOS_JoystickQuit,
+	MORPHOS_JoystickGetGamepadMapping
+};
+
+#endif
diff -ruN SDL2-2.32.8/src/joystick/morphos/SDL_sysjoystick_c.h SDL2-2.32.8.aros/src/joystick/morphos/SDL_sysjoystick_c.h
--- SDL2-2.32.8/src/joystick/morphos/SDL_sysjoystick_c.h	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/joystick/morphos/SDL_sysjoystick_c.h	2025-07-27 14:24:15.224841332 +0000
@@ -0,0 +1,54 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2020 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#include "../../SDL_internal.h"
+
+#ifdef SDL_JOYSTICK_MORPHOS
+
+#include <exec/types.h>
+#include "SDL_joystick.h"
+
+#define MAX_JOYSTICKS 	32
+#define MAX_BUTTONS     16
+#define MAX_HATS        8
+#define MAX_STICKS      8
+#define MAX_RUMBLE		2
+
+struct joystick_hwdata
+{
+	APTR main_sensor; // Main HID sensor
+	APTR child_sensors; // List of specific sub-sensor entries
+	APTR button[MAX_BUTTONS]; // SensorType_HIDInput_Trigger
+	APTR hat[MAX_HATS]; // SensorType_HIDInput_Stick
+	APTR stick[MAX_STICKS]; // SensorType_HIDInput_Analog, SensorType_HIDInput_AnalogStick, SensorType_HIDInput_3DStick
+	APTR battery; 	// SensorType_HIDInput_Battery 
+	APTR rumble[MAX_RUMBLE]; // SensorType_HIDInput_Rumble
+
+	ULONG stickType[MAX_STICKS];
+	int numSticks;
+	int numRumbles;
+
+	// hot plug support
+	struct MsgPort *notifyPort;
+	APTR sensorsNotify;
+};
+
+#endif
\ No newline at end of file
diff -ruN SDL2-2.32.8/src/joystick/SDL_gamecontrollerdb.h SDL2-2.32.8.aros/src/joystick/SDL_gamecontrollerdb.h
--- SDL2-2.32.8/src/joystick/SDL_gamecontrollerdb.h	2025-01-18 15:07:12.000000000 +0000
+++ SDL2-2.32.8.aros/src/joystick/SDL_gamecontrollerdb.h	2025-07-27 14:24:15.440841333 +0000
@@ -997,6 +997,10 @@
 #ifdef SDL_JOYSTICK_VITA
     "0000000050535669746120436f6e7400,PSVita Controller,crc:d598,a:b2,b:b1,back:b10,dpdown:b6,dpleft:b7,dpright:b9,dpup:b8,leftshoulder:b4,leftstick:b14,lefttrigger:a4,leftx:a0,lefty:a1,rightshoulder:b5,rightstick:b15,righttrigger:a5,rightx:a2,righty:a3,start:b11,x:b3,y:b0,",
 #endif
+#ifdef  SDL_JOYSTICK_MORPHOS
+	  "030000004c050000c405000000000000,PlayStation 4 Dualshock Controller,platform:MorphOS,a:b6,b:b7,x:b4,y:b5,back:b3,start:b2,leftstick:b8,rightstick:b9,leftshoulder:b0,rightshoulder:b1,dpup:h0.1,dpdown:h0.4,dpleft:h0.8,dpright:h0.2,leftx:a0,lefty:a1,rightx:a2,righty:a3,lefttrigger:+a4,righttrigger:+a5,",
+	  "030000005e0400008e02000000000000,Xbox360 Controller,platform:MorphOS,a:b7,b:b8,x:b5,y:b6,back:b2,guide:b4,start:b3,leftstick:b9,rightstick:b10,leftshoulder:b0,rightshoulder:b1,dpup:h0.1,dpdown:h0.4,dpleft:h0.8,dpright:h0.2,leftx:a0,lefty:a1,rightx:a2,righty:a3,lefttrigger:+a4,righttrigger:+a5,",
+#endif
 #ifdef SDL_JOYSTICK_N3DS
     "000000004e696e74656e646f20334400,Nintendo 3DS,crc:3210,a:b0,b:b1,back:b2,dpdown:b7,dpleft:b5,dpright:b4,dpup:b6,leftshoulder:b9,lefttrigger:b14,leftx:a0,lefty:a1,rightshoulder:b8,righttrigger:b15,rightx:a2,righty:a3,start:b3,x:b10,y:b11,",
 #endif
diff -ruN SDL2-2.32.8/src/joystick/SDL_joystick.c SDL2-2.32.8.aros/src/joystick/SDL_joystick.c
--- SDL2-2.32.8/src/joystick/SDL_joystick.c	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/src/joystick/SDL_joystick.c	2025-08-05 23:02:40.106981062 +0000
@@ -100,6 +100,9 @@
 #ifdef SDL_JOYSTICK_VIRTUAL
     &SDL_VIRTUAL_JoystickDriver,
 #endif
+#ifdef SDL_JOYSTICK_MORPHOS
+    &SDL_MORPHOS_JoystickDriver,
+#endif
 #ifdef SDL_JOYSTICK_VITA
     &SDL_VITA_JoystickDriver,
 #endif
@@ -1413,7 +1416,11 @@
             /* Just update the expiration */
             retval = 0;
         } else {
+#ifdef __MORPHOS__
+            retval = joystick->driver->Rumble(joystick, low_frequency_rumble, high_frequency_rumble, duration_ms);
+#else
             retval = joystick->driver->Rumble(joystick, low_frequency_rumble, high_frequency_rumble);
+#endif
             if (retval == 0) {
                 joystick->rumble_resend = SDL_GetTicks() + SDL_RUMBLE_RESEND_MS;
                 if (joystick->rumble_resend == 0) {
@@ -1637,7 +1644,7 @@
 
 void SDL_JoystickQuit(void)
 {
-    int i;
+    long int i;
 
     SDL_LockJoysticks();
 
@@ -2202,7 +2209,11 @@
 
         if (joystick->rumble_resend &&
             SDL_TICKS_PASSED(now, joystick->rumble_resend)) {
+#ifdef __MORPHOS__
+			joystick->driver->Rumble(joystick, joystick->low_frequency_rumble, joystick->high_frequency_rumble, 100/*duration_ms*/);
+#else
             joystick->driver->Rumble(joystick, joystick->low_frequency_rumble, joystick->high_frequency_rumble);
+#endif
             joystick->rumble_resend = now + SDL_RUMBLE_RESEND_MS;
             if (joystick->rumble_resend == 0) {
                 joystick->rumble_resend = 1;
diff -ruN SDL2-2.32.8/src/joystick/SDL_sysjoystick.h SDL2-2.32.8.aros/src/joystick/SDL_sysjoystick.h
--- SDL2-2.32.8/src/joystick/SDL_sysjoystick.h	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/src/joystick/SDL_sysjoystick.h	2025-07-27 14:24:15.472841333 +0000
@@ -191,7 +191,11 @@
     int (*Open)(SDL_Joystick *joystick, int device_index);
 
     /* Rumble functionality */
+#ifdef __MORPHOS__
+    int (*Rumble)(SDL_Joystick *joystick, Uint16 low_frequency_rumble, Uint16 high_frequency_rumble, Uint32 duration_ms);
+#else
     int (*Rumble)(SDL_Joystick *joystick, Uint16 low_frequency_rumble, Uint16 high_frequency_rumble);
+#endif
     int (*RumbleTriggers)(SDL_Joystick *joystick, Uint16 left_rumble, Uint16 right_rumble);
 
     /* Capability detection */
@@ -253,7 +257,9 @@
 extern SDL_JoystickDriver SDL_PSP_JoystickDriver;
 extern SDL_JoystickDriver SDL_VITA_JoystickDriver;
 extern SDL_JoystickDriver SDL_N3DS_JoystickDriver;
-
+#ifdef __MORPHOS__
+extern SDL_JoystickDriver SDL_MORPHOS_JoystickDriver;
+#endif
 /* Ends C function definitions when using C++ */
 #ifdef __cplusplus
 }
diff -ruN SDL2-2.32.8/src/locale/aros/SDL_syslocale.c SDL2-2.32.8.aros/src/locale/aros/SDL_syslocale.c
--- SDL2-2.32.8/src/locale/aros/SDL_syslocale.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/locale/aros/SDL_syslocale.c	2025-08-04 16:32:11.280791557 +0000
@@ -0,0 +1,98 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+//#define DEBUG 1
+#include <aros/debug.h>
+
+#include "../../SDL_internal.h"
+#include "../SDL_syslocale.h"
+
+#include <proto/dos.h>
+#include <proto/utility.h>
+#include <libraries/iffparse.h>
+
+#include <stdio.h>
+
+struct loc
+{
+	const char *name;
+	const char *codeLang;
+};
+
+static const struct loc locs[] =
+{
+	{ "català",		"ca_ES" }, 
+	{ "dansk",		"da_DK" },
+	{ "deutsch",	"de_DE" },
+	{ "english",	"en_GB" },
+	{ "español",	"es_ES" },
+	{ "français",	"fr_FR" },
+	{ "greek",		"el_GR" },
+	{ "hrvatski",	"hr_HR" },
+	{ "italiano",	"it_IT" },
+	{ "magyar",		"hu_HU" },
+	{ "malti",		"mt_MT"	},
+	{ "nederlands",	"nl_NL" },
+	{ "norsk",		"nn_NO" },
+	{ "polski",		"pl_PL" },
+	{ "português",	"pt_PT" },
+	{ "shqipja"		"sq_AL" },
+	{ "suomi",		"fi_FI" },
+	{ "svenska",	"sv_SE" },
+	{ "türkçe",		"tr_TR" },
+	{ "èe¹tina",	"cs_CZ" },
+	{ "íslenska", 	"is_IS" },  
+	{ NULL,			NULL } 
+};
+
+void
+SDL_SYS_GetPreferredLocales(char *buf, size_t buflen)
+{
+	D(bug("[SDL2] %s()\n", __func__));
+	
+	char language[80];
+	language[0] = '\0';
+	SDL_bool found = SDL_FALSE;
+
+	// check the LANGUAGE env variable
+	if (GetVar("LANGUAGE", language, sizeof(language), 0) > 0)
+	{
+		int i;
+		const struct loc *curLoc = NULL;
+
+		for(i=0;;i++)
+		{
+			curLoc = &locs[i];
+
+			if(Strnicmp(language, curLoc->name, sizeof(curLoc->name)) == 0)
+			{
+			  D("[%s] found language name for '%s'\n", __FUNCTION__, curLoc->codeLang);
+			  snprintf(buf, buflen, curLoc->codeLang);
+			  found = SDL_TRUE;
+			  break;
+			}
+		}
+
+	}
+	if (!found)
+		snprintf(buf, buflen, "en_GB");  
+
+}
diff -ruN SDL2-2.32.8/src/misc/amigaos/SDL_sysurl.c SDL2-2.32.8.aros/src/misc/amigaos/SDL_sysurl.c
--- SDL2-2.32.8/src/misc/amigaos/SDL_sysurl.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/misc/amigaos/SDL_sysurl.c	2025-07-27 14:24:16.128841337 +0000
@@ -0,0 +1,48 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#if defined(__AROS__)
+#include <aros/debug.h>
+#endif
+
+#include "../SDL_sysurl.h"
+#include "../../SDL_internal.h"
+
+#include <proto/openurl.h>
+
+int
+SDL_SYS_OpenURL(const char *url)
+{
+	static const struct TagItem URLTags[] = {{TAG_DONE, 0}};
+
+	D(bug("[SDL2:AHI] %s('%s')\n", __func__, url));
+
+	if (OpenURLBase) {
+		if(!URL_OpenA((STRPTR)url, (struct TagItem*) URLTags)) {
+			SDL_SetError("URL open failed");
+			return SDL_Unsupported();
+		}	
+	} else {
+		return SDL_Unsupported();
+	}
+    return 0;
+}
+
diff -ruN SDL2-2.32.8/src/misc/aros/SDL_getenv.c SDL2-2.32.8.aros/src/misc/aros/SDL_getenv.c
--- SDL2-2.32.8/src/misc/aros/SDL_getenv.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/misc/aros/SDL_getenv.c	2025-08-04 18:43:16.964792808 +0000
@@ -0,0 +1,77 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2022 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#include "SDL_stdinc.h"
+
+#include <proto/dos.h>
+
+#ifndef EXEC_TYPES_H
+#include <exec/types.h>
+#endif
+#include <sys/types.h>
+
+char *SDL_getenv(const char *name)
+{
+	if (!name)
+		return NULL;
+
+	char *value = NULL;
+	char varname[128];
+	char dummy[32];
+	size_t len;
+
+	SDL_snprintf(varname, sizeof(varname), "SDL2/%s", name);
+
+	if (GetVar(varname, dummy, sizeof(dummy), GVF_BINARY_VAR) == -1)
+		return NULL;
+	
+	len = IoErr() + 1;
+	
+	if ((value = SDL_malloc(len)))
+	{
+		if (GetVar(varname, value, len, GVF_GLOBAL_ONLY) == -1)
+		{
+			SDL_free(value);
+			value = NULL;
+		}
+	}
+	return value;
+}
+
+int SDL_setenv(const char *name, const char *value, int overwrite)
+{
+	if (!name)
+		return -1;
+
+	char varname[128];
+	char dummy[32];
+	BOOL exist = FALSE;
+
+	SDL_snprintf(varname, sizeof(varname), "SDL2/%s", name);
+
+	if (GetVar(varname, dummy, sizeof(dummy), GVF_BINARY_VAR) != -1)
+			exist = TRUE;
+	if (!exist || overwrite)
+		if (SetVar(varname, value, -1, GVF_GLOBAL_ONLY))
+			return 0;
+	return -1;
+}
diff -ruN SDL2-2.32.8/src/misc/aros/SDL_misc.c SDL2-2.32.8.aros/src/misc/aros/SDL_misc.c
--- SDL2-2.32.8/src/misc/aros/SDL_misc.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/misc/aros/SDL_misc.c	2025-08-04 18:19:55.948791136 +0000
@@ -0,0 +1,140 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2022 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#include "SDL_stdinc.h"
+
+#include <proto/dos.h>
+
+#ifndef EXEC_TYPES_H
+#include <exec/types.h>
+#endif
+#include <sys/types.h>
+
+// Convert UTF-8 to ISO-8859-1
+char *
+AROS_ConvertUTF8Text(const char *src)
+{
+    if (!src) return NULL;
+
+    // Worst-case: every byte becomes one ASCII char + null terminator
+    size_t len = 0;
+    const char *p = src;
+    while (*p) len++, p++;
+
+    char *dst = SDL_malloc(len + 1);
+    if (!dst) return NULL;
+
+    size_t out = 0;
+    while (*src) {
+        unsigned char c = (unsigned char)*src;
+        if (c < 0x80) {
+            // ASCII
+            dst[out++] = *src++;
+        } else {
+            // Multibyte UTF-8 sequence
+            if ((c & 0xE0) == 0xC0) src += 2;		// 2-byte
+            else if ((c & 0xF0) == 0xE0) src += 3;	// 3-byte
+            else if ((c & 0xF8) == 0xF0) src += 4;	// 4-byte
+            else src++;								// Invalid
+            dst[out++] = '?';
+        }
+    }
+
+    dst[out] = '\0';
+	return dst;
+}
+
+// Convert ISO-8859-1 to UTF-8
+char *
+AROS_ConvertTextUTF8(const char *src)
+{
+    if (!src) return NULL;
+
+    size_t len = SDL_strlen(src);
+    char *dst = SDL_malloc(len + 1);
+    if (!dst) return NULL;
+
+    /* Copy directly (including null terminator) 
+	 * - ASCII bytes are valid UTF-8 bytes
+	 */
+    SDL_memcpy(dst, src, len + 1);
+    return dst;
+}
+
+char *
+AROS_ConvertPath(const char *fn)
+{
+	CONST_STRPTR src = fn;
+	ULONG flen = SDL_strlen(fn);
+	BOOL colon = FALSE;
+	char *dst, *path = SDL_malloc(flen + 2 + 128);
+
+	dst = path;
+
+	if (*src == '/')
+	{
+		/* really depends on filesystem layout, hope for the best */
+		colon	= 1;
+		src++;
+	}
+
+	while ((size_t)src < (size_t)(fn + flen))
+	{
+		const char *end = SDL_strchr(src, '/');
+		int len;
+
+		if(!end)
+			end = fn + flen; /* last component */
+
+		len = (size_t)end - (size_t)src;
+
+		if(len == 0 || (len == 1 && src[0] == '.'))
+		{
+			/* remove repeated slashes and . */
+		}
+		else
+		{
+			if (len == 1 && colon)
+			{
+				*dst++ = ':';
+				colon  = FALSE;
+			}
+			else if (len == 2 && src[0] == '.' && src[1] == '.')
+			{
+				/* replace .. with the empty string */
+			}
+			else
+			{
+				SDL_memmove((void *)dst, (void *)src, len);
+				dst += len;
+			}
+
+			if(end < fn + flen)
+				*dst++ = '/';
+		}
+
+		src = end + 1;
+	}
+
+	*dst++ = '\0';
+	return path;
+}
diff -ruN SDL2-2.32.8/src/misc/aros/SDL_misc.h SDL2-2.32.8.aros/src/misc/aros/SDL_misc.h
--- SDL2-2.32.8/src/misc/aros/SDL_misc.h	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/misc/aros/SDL_misc.h	2025-08-04 18:35:49.536792718 +0000
@@ -0,0 +1,35 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2022 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#ifndef SDL_MISC_AROS_MISC_H
+#define SDL_MISC_AROS_MISC_H
+
+#include "../../SDL_internal.h"
+
+#ifndef EXEC_TYPES_H
+#include <exec/types.h>
+#endif
+
+extern char *AROS_ConvertUTF8Text(const char *src);
+extern char *AROS_ConvertTextUTF8(const char *src);
+extern char *AROS_ConvertPath(const char *fn);
+
+#endif /* SDL_MISC_AROS_MISC_H */
diff -ruN SDL2-2.32.8/src/power/aros/SDL_syspower.c SDL2-2.32.8.aros/src/power/aros/SDL_syspower.c
--- SDL2-2.32.8/src/power/aros/SDL_syspower.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/power/aros/SDL_syspower.c	2025-07-29 12:46:22.777400298 +0000
@@ -0,0 +1,36 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2021 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifndef SDL_POWER_DISABLED
+#ifdef SDL_POWER_AROS
+
+#include "SDL_power.h"
+
+SDL_bool
+SDL_GetPowerInfo_AROS(SDL_PowerState *state, int *seconds, int *percent)
+{
+	return SDL_TRUE;
+}
+
+#endif /* SDL_POWER_AROS */
+#endif /* SDL_POWER_DISABLED */
+
diff -ruN SDL2-2.32.8/src/power/SDL_power.c SDL2-2.32.8.aros/src/power/SDL_power.c
--- SDL2-2.32.8/src/power/SDL_power.c	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/src/power/SDL_power.c	2025-07-29 12:44:23.481400442 +0000
@@ -78,7 +78,12 @@
 #ifdef SDL_POWER_EMSCRIPTEN /* handles Emscripten */
     SDL_GetPowerInfo_Emscripten,
 #endif
-
+#ifdef SDL_POWER_MORPHOS        /* handles MorphOS */
+    SDL_GetPowerInfo_MorphOS,
+#endif
+#ifdef SDL_POWER_AROS        /* handles AROS */
+    SDL_GetPowerInfo_AROS,
+#endif
 #ifdef SDL_POWER_HARDWIRED
     SDL_GetPowerInfo_Hardwired,
 #endif
diff -ruN SDL2-2.32.8/src/power/SDL_syspower.h SDL2-2.32.8.aros/src/power/SDL_syspower.h
--- SDL2-2.32.8/src/power/SDL_syspower.h	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/src/power/SDL_syspower.h	2025-07-29 12:43:55.325400476 +0000
@@ -42,6 +42,12 @@
 SDL_bool SDL_GetPowerInfo_N3DS(SDL_PowerState *, int *, int *);
 SDL_bool SDL_GetPowerInfo_WinRT(SDL_PowerState *, int *, int *);
 SDL_bool SDL_GetPowerInfo_Emscripten(SDL_PowerState *, int *, int *);
+#ifdef SDL_POWER_MORPHOS
+SDL_bool SDL_GetPowerInfo_MorphOS(SDL_PowerState *, int *, int *);
+#endif
+#ifdef SDL_POWER_AROS
+SDL_bool SDL_GetPowerInfo_AROS(SDL_PowerState *, int *, int *);
+#endif
 
 /* this one is static in SDL_power.c */
 /* SDL_bool SDL_GetPowerInfo_Hardwired(SDL_PowerState *, int *, int *);*/
diff -ruN SDL2-2.32.8/src/render/opengl/SDL_render_gl.c SDL2-2.32.8.aros/src/render/opengl/SDL_render_gl.c
--- SDL2-2.32.8/src/render/opengl/SDL_render_gl.c	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/src/render/opengl/SDL_render_gl.c	2025-08-05 16:37:28.748631871 +0000
@@ -21,7 +21,15 @@
 #include "../../SDL_internal.h"
 
 #if SDL_VIDEO_RENDER_OGL
+#if defined(__AROS__)
+//#define DEBUG 1
+#include <aros/debug.h>
+#define DV(...)
+#endif
 #include "SDL_hints.h"
+#ifdef __MORPHOS__
+#define _NO_PPCINLINE
+#endif
 #include "../../video/SDL_sysvideo.h" /* For SDL_GL_SwapWindowWithResult */
 #include "SDL_opengl.h"
 #include "../SDL_sysrender.h"
@@ -1678,6 +1686,10 @@
     /*const char *vendor = (const char *) data->glGetString(GL_VENDOR);*/
     const char *renderer = (const char *)data->glGetString(GL_RENDERER);
 
+    if (renderer == NULL) {
+        return SDL_TRUE;
+    }
+
 #if defined(__WINDOWS__) || defined(__WINGDK__)
     if (SDL_strcmp(renderer, "GDI Generic") == 0) {
         return SDL_FALSE; /* Microsoft's fallback software renderer. Fix your system! */
@@ -1709,6 +1721,16 @@
     const char *hint;
     SDL_bool non_power_of_two_supported = SDL_FALSE;
 
+#ifdef SDL_VIDEO_DRIVER_AROS
+    window_flags = SDL_GetWindowFlags(window);
+    if (!(window_flags & SDL_WINDOW_OPENGL)) {
+        char *enable_gl_aros;
+        enable_gl_aros = SDL_getenv("GL_renderer");
+        if (!enable_gl_aros || *enable_gl_aros != '1')
+            goto error;
+    }
+#endif
+
     SDL_GL_GetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, &profile_mask);
     SDL_GL_GetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, &major);
     SDL_GL_GetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, &minor);
@@ -1860,6 +1882,12 @@
         renderer->info.max_texture_height = value;
     }
 
+#if defined(__AROS__)
+	DV(bug("GL_ARB_texture_non_power_of_two: %s\n", data->GL_ARB_texture_non_power_of_two_supported ? "ENABLED" : "DISABLED"));
+	DV(bug("GL_ARB_texture_rectangle: %s\n", SDL_GL_ExtensionSupported("GL_ARB_texture_rectangle") ? "ENABLED" : "DISABLED"));
+	DV(bug("GL_EXT_texture_rectangle: %s\n", SDL_GL_ExtensionSupported("GL_EXT_texture_rectangle") ? "ENABLED" : "DISABLED"));
+#endif
+
     /* Check for multitexture support */
     if (SDL_GL_ExtensionSupported("GL_ARB_multitexture")) {
         data->glActiveTextureARB = (PFNGLACTIVETEXTUREARBPROC)SDL_GL_GetProcAddress("glActiveTextureARB");
@@ -1868,11 +1896,19 @@
             data->glGetIntegerv(GL_MAX_TEXTURE_UNITS_ARB, &data->num_texture_units);
         }
     }
+#if defined(__AROS__)
+	DV(bug("GL_ARB_multitexture_supported: %s\n", data->GL_ARB_multitexture_supported ? "ENABLED" : "DISABLED"));
+#endif
 
     /* Check for shader support */
     if (SDL_GetHintBoolean(SDL_HINT_RENDER_OPENGL_SHADERS, SDL_TRUE)) {
         data->shaders = GL_CreateShaderContext();
     }
+
+#if defined(__AROS__)
+	DV(bug("OpenGL shaders: %s\n", data->shaders ? "ENABLED" : "DISABLED"));
+#endif
+
     SDL_LogInfo(SDL_LOG_CATEGORY_RENDER, "OpenGL shaders: %s",
                 data->shaders ? "ENABLED" : "DISABLED");
 #if SDL_HAVE_YUV
@@ -1913,6 +1949,10 @@
             SDL_GL_GetProcAddress("glCheckFramebufferStatusEXT");
         renderer->info.flags |= SDL_RENDERER_TARGETTEXTURE;
     }
+#if defined(__AROS__)
+	DV(bug("GL_EXT_framebuffer_object: %s\n", data->GL_EXT_framebuffer_object_supported ? "ENABLED" : "DISABLED"));
+#endif
+
     data->framebuffers = NULL;
 
     /* Set up parameters for rendering */
diff -ruN SDL2-2.32.8/src/render/opengl/SDL_shaders_gl.c SDL2-2.32.8.aros/src/render/opengl/SDL_shaders_gl.c
--- SDL2-2.32.8/src/render/opengl/SDL_shaders_gl.c	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/src/render/opengl/SDL_shaders_gl.c	2025-07-27 14:24:16.620841339 +0000
@@ -23,6 +23,11 @@
 #if SDL_VIDEO_RENDER_OGL
 
 #include "SDL_stdinc.h"
+
+#ifdef __MORPHOS__
+#define _NO_PPCINLINE
+#endif
+
 #include "SDL_opengl.h"
 #include "SDL_video.h"
 #include "SDL_shaders_gl.h"
diff -ruN SDL2-2.32.8/src/SDL.c SDL2-2.32.8.aros/src/SDL.c
--- SDL2-2.32.8/src/SDL.c	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/src/SDL.c	2025-07-28 20:45:10.753574555 +0000
@@ -49,7 +49,6 @@
 #include "haptic/SDL_haptic_c.h"
 #include "joystick/SDL_joystick_c.h"
 #include "sensor/SDL_sensor_c.h"
-#include "thread/SDL_thread_c.h"
 
 /* Initialization/Cleanup routines */
 #ifndef SDL_TIMERS_DISABLED
@@ -101,6 +100,9 @@
     exit(exitcode);
 #elif defined(__HAIKU__)  /* Haiku has _Exit, but it's not marked noreturn. */
     _exit(exitcode);
+#elif defined(__MORPHOS__)
+    extern void (*morphos_exit)(int exitcode);
+    morphos_exit(exitcode);
 #elif defined(HAVE__EXIT) /* Upper case _Exit() */
     _Exit(exitcode);
 #else
@@ -114,7 +116,6 @@
 #else
 static SDL_bool SDL_MainIsReady = SDL_TRUE;
 #endif
-static SDL_bool SDL_main_thread_initialized = SDL_FALSE;
 static SDL_bool SDL_bInMainQuit = SDL_FALSE;
 static Uint8 SDL_SubsystemRefCount[32];
 
@@ -180,36 +181,6 @@
     SDL_MainIsReady = SDL_TRUE;
 }
 
-void SDL_InitMainThread(void)
-{
-    if (SDL_main_thread_initialized) {
-        return;
-    }
-
-    SDL_InitTLSData();
-#ifndef SDL_TIMERS_DISABLED
-    SDL_TicksInit();
-#endif
-    SDL_LogInit();
-
-    SDL_main_thread_initialized = SDL_TRUE;
-}
-
-static void SDL_QuitMainThread(void)
-{
-    if (!SDL_main_thread_initialized) {
-        return;
-    }
-
-    SDL_LogQuit();
-#ifndef SDL_TIMERS_DISABLED
-    SDL_TicksQuit();
-#endif
-    SDL_QuitTLSData();
-
-    SDL_main_thread_initialized = SDL_FALSE;
-}
-
 int SDL_InitSubSystem(Uint32 flags)
 {
     Uint32 flags_initialized = 0;
@@ -218,6 +189,8 @@
         return SDL_SetError("Application didn't initialize properly, did you include SDL_main.h in the file containing your main() function?");
     }
 
+    SDL_LogInit();
+
     /* Clear the error message */
     SDL_ClearError();
 
@@ -233,6 +206,10 @@
     }
 #endif
 
+#ifndef SDL_TIMERS_DISABLED
+    SDL_TicksInit();
+#endif
+
     /* Initialize the event subsystem */
     if (flags & SDL_INIT_EVENTS) {
 #ifndef SDL_EVENTS_DISABLED
@@ -374,7 +351,7 @@
         }
         SDL_PrivateSubsystemRefCountIncr(SDL_INIT_SENSOR);
         flags_initialized |= SDL_INIT_SENSOR;
-#else
+#elif !__MORPHOS__
         SDL_SetError("SDL not built with sensor support");
         goto quit_and_error;
 #endif
@@ -520,6 +497,10 @@
 #endif
     SDL_QuitSubSystem(SDL_INIT_EVERYTHING);
 
+#ifndef SDL_TIMERS_DISABLED
+    SDL_TicksQuit();
+#endif
+
 #ifdef SDL_USE_LIBDBUS
     SDL_DBus_Quit();
 #endif
@@ -527,12 +508,14 @@
     SDL_ClearHints();
     SDL_AssertionsQuit();
 
+    SDL_LogQuit();
+
     /* Now that every subsystem has been quit, we reset the subsystem refcount
      * and the list of initialized subsystems.
      */
     SDL_memset(SDL_SubsystemRefCount, 0x0, sizeof(SDL_SubsystemRefCount));
 
-    SDL_QuitMainThread();
+    SDL_TLSCleanup();
 
     SDL_bInMainQuit = SDL_FALSE;
 }
@@ -580,6 +563,8 @@
     return "AIX";
 #elif defined(__ANDROID__)
     return "Android";
+#elif defined(__AROS__)
+    return "AROS";
 #elif defined(__BSDI__)
     return "BSDI";
 #elif defined(__DREAMCAST__)
@@ -636,6 +621,8 @@
     return "PlayStation 2";
 #elif defined(__PSP__)
     return "PlayStation Portable";
+#elif defined(__MORPHOS__)
+    return "MorphOS";
 #elif defined(__VITA__)
     return "PlayStation Vita";
 #elif defined(__NGAGE__)
diff -ruN SDL2-2.32.8/src/SDL_error.c SDL2-2.32.8.aros/src/SDL_error.c
--- SDL2-2.32.8/src/SDL_error.c	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/src/SDL_error.c	2025-07-30 18:46:14.000000000 +0000
@@ -60,6 +60,43 @@
     return -1;
 }
 
+#ifdef __MORPHOS__
+int
+SDL_VSetError(const char *fmt, va_list ap)
+{
+	
+	/* Ignore call if invalid format pointer was passed */
+    if (fmt != NULL) {
+
+		va_list ap_copy;
+        int result;
+        SDL_error *error = SDL_GetErrBuf();
+
+        error->error = 1;  /* mark error as valid */
+        va_copy(ap_copy, ap);
+        result = SDL_vsnprintf(error->str, error->len, fmt, ap_copy);
+        va_end(ap_copy);
+        if (result >= 0 && (size_t)result >= error->len && error->realloc_func) {
+            size_t len = (size_t)result + 1;
+            char *str = (char *)error->realloc_func(error->str, len);
+            if (str) {
+                error->str = str;
+                error->len = len;
+                SDL_vsnprintf(error->str, error->len, fmt, ap);
+            }
+        }
+		
+        if (SDL_LogGetPriority(SDL_LOG_CATEGORY_ERROR) <= SDL_LOG_PRIORITY_DEBUG) {
+            /* If we are in debug mode, print out the error message */
+            SDL_LogDebug(SDL_LOG_CATEGORY_ERROR, "%s", error->str);
+        }
+    }
+
+    return -1;
+}
+#endif
+
+#if !defined(__AROS__) || defined(SDL2_AROS_SHARED) || defined(SDL2_AROS_STATIC)
 /* Available for backwards compatibility */
 const char *SDL_GetError(void)
 {
@@ -120,4 +157,6 @@
     return errstr;
 }
 
+#endif
+
 /* vi: set ts=4 sw=4 expandtab: */
diff -ruN SDL2-2.32.8/src/SDL_log.c SDL2-2.32.8.aros/src/SDL_log.c
--- SDL2-2.32.8/src/SDL_log.c	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/src/SDL_log.c	2025-07-30 18:47:19.000000000 +0000
@@ -40,6 +40,10 @@
 #include <android/log.h>
 #endif
 
+#if defined(__MORPHOS__) || defined(__AROS__)
+#include <proto/exec.h>
+#endif
+
 #include "stdlib/SDL_vacopy.h"
 
 /* The size of the stack buffer to use for rendering log messages. */
@@ -47,6 +51,7 @@
 
 #define DEFAULT_CATEGORY -1
 
+#if !defined(__AROS__) || defined(SDL2_AROS_SHARED) || defined(SDL2_AROS_STATIC)
 typedef struct SDL_LogLevel
 {
     int category;
@@ -296,6 +301,7 @@
     }
     SDL_forced_priority = SDL_FALSE;
 }
+#endif
 
 void SDL_Log(SDL_PRINTF_FORMAT_STRING const char *fmt, ...)
 {
@@ -369,6 +375,7 @@
     va_end(ap);
 }
 
+#if !defined(__AROS__) || defined(SDL2_AROS_SHARED) || defined(SDL2_AROS_STATIC)
 #ifdef __ANDROID__
 static const char *GetCategoryPrefix(int category)
 {
@@ -573,6 +580,10 @@
             (void)fclose(pFile);
         }
     }
+#elif defined(__MORPHOS__) || defined(__AROS__)
+	{
+    	NewRawDoFmt("%s: %s\n", (APTR)1, NULL, SDL_priority_prefixes[priority], message);
+	}
 #elif defined(__3DS__)
     {
         FILE *pFile;
@@ -607,5 +618,6 @@
     SDL_log_function = callback;
     SDL_log_userdata = userdata;
 }
+#endif
 
 /* vi: set ts=4 sw=4 expandtab: */
diff -ruN SDL2-2.32.8/src/stdlib/SDL_stdlib.c SDL2-2.32.8.aros/src/stdlib/SDL_stdlib.c
--- SDL2-2.32.8/src/stdlib/SDL_stdlib.c	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/src/stdlib/SDL_stdlib.c	2025-07-27 14:24:17.192841344 +0000
@@ -28,7 +28,9 @@
 /* This file contains portable stdlib functions for SDL */
 
 #include "SDL_stdinc.h"
+#if !defined(__AROS__)
 #include "../libm/math_libm.h"
+#endif
 
 double
 SDL_atan(double x)
diff -ruN SDL2-2.32.8/src/stdlib/SDL_string.c SDL2-2.32.8.aros/src/stdlib/SDL_string.c
--- SDL2-2.32.8/src/stdlib/SDL_string.c	2025-03-10 22:45:43.000000000 +0000
+++ SDL2-2.32.8.aros/src/stdlib/SDL_string.c	2025-07-30 18:43:56.000000000 +0000
@@ -54,22 +54,23 @@
     return 0;
 }
 
+#if !defined(__AROS__) || defined(SDL2_AROS_SHARED) || defined(SDL2_AROS_STATIC)
 #if !defined(HAVE_VSSCANF) || !defined(HAVE_STRTOL) || !defined(HAVE_STRTOUL) || !defined(HAVE_STRTOD)
 /**
- * Parses an unsigned long long and returns the unsigned value and sign bit.
+ * Parses an Uint64 and returns the unsigned value and sign bit.
  *
  * Positive values are clamped to ULLONG_MAX.
  * The result `value == 0 && negative` indicates negative overflow
  * and might need to be handled differently depending on whether a
  * signed or unsigned integer is being parsed.
  */
-static size_t SDL_ScanUnsignedLongLongInternal(const char *text, int count, int radix, unsigned long long *valuep, SDL_bool *negativep)
+static size_t SDL_ScanUnsignedLongLongInternal(const char *text, int count, int radix, Uint64 *valuep, SDL_bool *negativep)
 {
-    const unsigned long long ullong_max = ~0ULL;
+    const Uint64 ullong_max = ~0ULL;
 
     const char *text_start = text;
     const char *number_start = text_start;
-    unsigned long long value = 0;
+    Uint64 value = 0;
     SDL_bool negative = SDL_FALSE;
     SDL_bool overflow = SDL_FALSE;
 
@@ -92,7 +93,7 @@
         }
         number_start = text;
         do {
-            unsigned long long digit;
+            Uint64 digit;
             if (*text >= '0' && *text <= '9') {
                 digit = *text - '0';
             } else if (radix > 10) {
@@ -145,7 +146,7 @@
 static size_t SDL_ScanLong(const char *text, int count, int radix, long *valuep)
 {
     const unsigned long long_max = (~0UL) >> 1;
-    unsigned long long value;
+    Uint64 value;
     SDL_bool negative;
     size_t len = SDL_ScanUnsignedLongLongInternal(text, count, radix, &value, &negative);
     if (negative) {
@@ -167,7 +168,7 @@
 static size_t SDL_ScanUnsignedLong(const char *text, int count, int radix, unsigned long *valuep)
 {
     const unsigned long ulong_max = ~0UL;
-    unsigned long long value;
+    Uint64 value;
     SDL_bool negative;
     size_t len = SDL_ScanUnsignedLongLongInternal(text, count, radix, &value, &negative);
     if (negative) {
@@ -190,7 +191,7 @@
 static size_t SDL_ScanUintPtrT(const char *text, int radix, uintptr_t *valuep)
 {
     const uintptr_t uintptr_max = ~(uintptr_t)0;
-    unsigned long long value;
+    Uint64 value;
     SDL_bool negative;
     size_t len = SDL_ScanUnsignedLongLongInternal(text, 0, 16, &value, &negative);
     if (negative) {
@@ -212,12 +213,12 @@
 #if !defined(HAVE_VSSCANF) || !defined(HAVE_STRTOLL) || !defined(HAVE_STRTOULL)
 static size_t SDL_ScanLongLong(const char *text, int count, int radix, Sint64 *valuep)
 {
-    const unsigned long long llong_max = (~0ULL) >> 1;
-    unsigned long long value;
+    const Uint64 llong_max = (~0ULL) >> 1;
+    Uint64 value;
     SDL_bool negative;
     size_t len = SDL_ScanUnsignedLongLongInternal(text, count, radix, &value, &negative);
     if (negative) {
-        const unsigned long long abs_llong_min = llong_max + 1;
+        const Uint64 abs_llong_min = llong_max + 1;
         if (value == 0 || value > abs_llong_min) {
             value = 0ULL - abs_llong_min;
         } else {
@@ -234,7 +235,7 @@
 #if !defined(HAVE_VSSCANF) || !defined(HAVE_STRTOULL)
 static size_t SDL_ScanUnsignedLongLong(const char *text, int count, int radix, Uint64 *valuep)
 {
-    const unsigned long long ullong_max = ~0ULL;
+    const Uint64 ullong_max = ~0ULL;
     SDL_bool negative;
     size_t len = SDL_ScanUnsignedLongLongInternal(text, count, radix, valuep, &negative);
     if (negative) {
@@ -927,7 +928,7 @@
 #if defined(HAVE_STRTOLL)
     return strtoll(string, endp, base);
 #else
-    long long value = 0;
+    Sint64 value = 0;
     size_t len = SDL_ScanLongLong(string, 0, base, &value);
     if (endp) {
         *endp = (char *)string + len;
@@ -941,7 +942,7 @@
 #if defined(HAVE_STRTOULL)
     return strtoull(string, endp, base);
 #else
-    unsigned long long value = 0;
+    Uint64 value = 0;
     size_t len = SDL_ScanUnsignedLongLong(string, 0, base, &value);
     if (endp) {
         *endp = (char *)string + len;
@@ -1058,6 +1059,7 @@
     return result;
 #endif /* HAVE_STRNCASECMP */
 }
+#endif /* !__AROS__ */
 
 int SDL_sscanf(const char *text, SDL_SCANF_FORMAT_STRING const char *fmt, ...)
 {
@@ -1069,6 +1071,7 @@
     return rc;
 }
 
+#if !defined(__AROS__) || defined(SDL2_AROS_SHARED) || defined(SDL2_AROS_STATIC)
 #ifdef HAVE_VSSCANF
 int SDL_vsscanf(const char *text, const char *fmt, va_list ap)
 {
@@ -1470,6 +1473,7 @@
     return retval;
 }
 #endif /* HAVE_VSSCANF */
+#endif /* !__AROS__ */
 
 int SDL_snprintf(SDL_OUT_Z_CAP(maxlen) char *text, size_t maxlen, SDL_PRINTF_FORMAT_STRING const char *fmt, ...)
 {
@@ -1483,6 +1487,7 @@
     return retval;
 }
 
+#if !defined(__AROS__) || defined(SDL2_AROS_SHARED) || defined(SDL2_AROS_STATIC)
 #if defined(HAVE_LIBC) && defined(__WATCOMC__)
 /* _vsnprintf() doesn't ensure nul termination */
 int SDL_vsnprintf(SDL_OUT_Z_CAP(maxlen) char *text, size_t maxlen, const char *fmt, va_list ap)
@@ -1744,7 +1749,7 @@
         return SDL_PrintString(text, maxlen, info, NULL);
     }
 
-    SDL_ulltoa((unsigned long long)(uintptr_t)value, num, 16);
+    SDL_ulltoa((Uint64)(uintptr_t)value, num, 16);
     length = SDL_PrintString(text, maxlen, info, "0x");
     return length + SDL_PrintString(TEXT_AND_LEN_ARGS, info, num);
 }
@@ -1969,6 +1974,7 @@
 
 #undef TEXT_AND_LEN_ARGS
 #endif /* HAVE_VSNPRINTF */
+#endif /* !__AROS__ */
 
 int SDL_asprintf(char **strp, SDL_PRINTF_FORMAT_STRING const char *fmt, ...)
 {
@@ -1982,6 +1988,7 @@
     return retval;
 }
 
+#if !defined(__AROS__) || defined(SDL2_AROS_SHARED) || defined(SDL2_AROS_STATIC)
 int SDL_vasprintf(char **strp, const char *fmt, va_list ap)
 {
     int retval;
@@ -2026,3 +2033,4 @@
         }
     }
 }
+#endif
diff -ruN SDL2-2.32.8/src/thread/aros/SDL_sysmutex.c SDL2-2.32.8.aros/src/thread/aros/SDL_sysmutex.c
--- SDL2-2.32.8/src/thread/aros/SDL_sysmutex.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/thread/aros/SDL_sysmutex.c	2025-07-28 10:23:45.073287295 +0000
@@ -0,0 +1,104 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2021 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+/* An implementation of mutexes using semaphores */
+
+#include "SDL_thread.h"
+#include "SDL_systhread_c.h"
+
+#include <proto/exec.h>
+
+
+struct SDL_mutex
+{
+    struct SignalSemaphore sem;
+};
+
+/* Create a mutex */
+SDL_mutex *
+SDL_CreateMutex(void)
+{
+    SDL_mutex *mutex;
+
+    /* Allocate mutex memory */
+    mutex = (SDL_mutex *) SDL_malloc(sizeof(*mutex));
+    if (mutex) {
+        /* Create the mutex semaphore, with initial value 1 */
+        memset(&mutex->sem, 0, sizeof(mutex->sem));
+        InitSemaphore(&mutex->sem);
+    } else {
+        SDL_OutOfMemory();
+    }
+    return mutex;
+}
+
+/* Free the mutex */
+void
+SDL_DestroyMutex(SDL_mutex * mutex)
+{
+    if (mutex)
+        SDL_free(mutex);
+}
+
+/* Lock the mutex */
+int
+SDL_LockMutex(SDL_mutex * mutex)
+{
+#if SDL_THREADS_DISABLED
+    return 0;
+#else
+    if (mutex == NULL)
+        return SDL_SetError("Passed a NULL mutex");
+
+    ObtainSemaphore(&mutex->sem);
+    return 0;
+#endif /* SDL_THREADS_DISABLED */
+}
+
+/* try Lock the mutex */
+int
+SDL_TryLockMutex(SDL_mutex * mutex)
+{
+#if SDL_THREADS_DISABLED
+    return 0;
+#else
+    if (mutex == NULL)
+        return SDL_SetError("Passed a NULL mutex");
+
+    return AttemptSemaphore(&mutex->sem) ? 0 : SDL_MUTEX_TIMEDOUT;
+#endif /* SDL_THREADS_DISABLED */
+}
+
+/* Unlock the mutex */
+int
+SDL_mutexV(SDL_mutex * mutex)
+{
+#if SDL_THREADS_DISABLED
+    return 0;
+#else
+    if (mutex == NULL)
+        return SDL_SetError("Passed a NULL mutex");
+
+    ReleaseSemaphore(&mutex->sem);
+    return 0;
+#endif /* SDL_THREADS_DISABLED */
+}
diff -ruN SDL2-2.32.8/src/thread/aros/SDL_sysmutex_c.h SDL2-2.32.8.aros/src/thread/aros/SDL_sysmutex_c.h
--- SDL2-2.32.8/src/thread/aros/SDL_sysmutex_c.h	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/thread/aros/SDL_sysmutex_c.h	2025-07-27 14:24:17.416841400 +0000
@@ -0,0 +1,22 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+/* vi: set ts=4 sw=4 expandtab: */
diff -ruN SDL2-2.32.8/src/thread/aros/SDL_syssem.c SDL2-2.32.8.aros/src/thread/aros/SDL_syssem.c
--- SDL2-2.32.8/src/thread/aros/SDL_syssem.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/thread/aros/SDL_syssem.c	2025-07-27 14:24:17.420841400 +0000
@@ -0,0 +1,272 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2021 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+/* An implementation of semaphores using mutexes and condition variables */
+
+#include "SDL_timer.h"
+#include "SDL_thread.h"
+#include "SDL_systhread_c.h"
+
+#include <devices/timer.h>
+#include <dos/dos.h>
+#include <exec/execbase.h>
+#include <proto/exec.h>
+
+
+#if SDL_THREADS_DISABLED
+
+SDL_sem *
+SDL_CreateSemaphore(Uint32 initial_value)
+{
+    SDL_SetError("SDL not built with thread support");
+    return (SDL_sem *) 0;
+}
+
+void
+SDL_DestroySemaphore(SDL_sem * sem)
+{
+}
+
+int
+SDL_SemTryWait(SDL_sem * sem)
+{
+    return SDL_SetError("SDL not built with thread support");
+}
+
+int
+SDL_SemWaitTimeout(SDL_sem * sem, Uint32 timeout)
+{
+    return SDL_SetError("SDL not built with thread support");
+}
+
+int
+SDL_SemWait(SDL_sem * sem)
+{
+    return SDL_SetError("SDL not built with thread support");
+}
+
+Uint32
+SDL_SemValue(SDL_sem * sem)
+{
+    return 0;
+}
+
+int
+SDL_SemPost(SDL_sem * sem)
+{
+    return SDL_SetError("SDL not built with thread support");
+}
+
+#else
+
+struct waitnode
+{
+	struct Message msg;
+	struct MsgPort port;
+};
+
+struct SDL_semaphore
+{
+    Uint32 sem_value;
+    struct MinList waitlist;
+    struct SignalSemaphore sem;
+};
+
+extern void InitQPort(struct MsgPort *port);
+
+static
+void mywaitinit(struct timerequest *r, Uint32 timeout, struct waitnode *wn)
+{
+    extern struct timerequest GlobalTimeReq;
+    struct timerequest *req = &GlobalTimeReq;
+
+    r->tr_node.io_Message.mn_Node.ln_Type = NT_REPLYMSG;
+    r->tr_node.io_Message.mn_ReplyPort    = &wn->port;
+    r->tr_node.io_Device                  = req->tr_node.io_Device;
+    r->tr_node.io_Unit                    = req->tr_node.io_Unit;
+}
+
+SDL_sem *
+SDL_CreateSemaphore(Uint32 initial_value)
+{
+    SDL_sem *sem;
+
+    sem = (SDL_sem *) SDL_malloc(sizeof(*sem));
+    if (!sem) {
+        SDL_OutOfMemory();
+        return NULL;
+    }
+
+    sem->sem_value = initial_value;
+
+    NEWLIST(&sem->waitlist);
+    memset(&sem->sem, 0, sizeof(sem->sem));
+    InitSemaphore(&sem->sem);
+
+    return sem;
+}
+
+/* WARNING:
+   You cannot call this function when another thread is using the semaphore.
+*/
+void
+SDL_DestroySemaphore(SDL_sem * sem)
+{
+    if (sem) {
+        ObtainSemaphore(&sem->sem);
+
+        sem->sem_value = (Uint32)-1;
+
+        while (!IsListEmpty((struct List *) &sem->waitlist)) {
+            struct waitnode *wn;
+
+            for (wn = (struct waitnode *) sem->waitlist.mlh_Head; wn->msg.mn_Node.ln_Succ; wn = (struct waitnode *) wn->msg.mn_Node.ln_Succ)
+                ReplyMsg(&wn->msg);
+
+            if (SDL_SemWaitTimeout(sem, 10) < 0)
+                break;
+        }
+
+        ReleaseSemaphore(&sem->sem);
+
+        SDL_free(sem);
+    }
+}
+
+int
+SDL_SemTryWait(SDL_sem * sem)
+{
+    int retval = SDL_MUTEX_TIMEDOUT;
+
+    if (!sem)
+        return SDL_SetError("Passed a NULL semaphore");
+
+    if (sem->sem_value > 0) {
+        ObtainSemaphore(&sem->sem);
+
+        if (sem->sem_value > 0) {
+            --sem->sem_value;
+            retval = 0;
+        }
+
+        ReleaseSemaphore(&sem->sem);
+    }
+
+    return retval;
+}
+
+int
+SDL_SemWaitTimeout(SDL_sem * sem, Uint32 timeout)
+{
+    int retval = SDL_MUTEX_TIMEDOUT;
+    struct waitnode wn;
+
+    if (!sem)
+        return SDL_SetError("Passed a NULL semaphore");
+
+    /* Try semaphore */
+    ObtainSemaphore(&sem->sem);
+
+    if (sem->sem_value > 0) {
+        --sem->sem_value;
+        retval = 0;
+    }
+    else if (timeout > 0) {
+        InitQPort(&wn.port);
+        wn.msg.mn_Node.ln_Type = NT_MESSAGE;
+        wn.msg.mn_ReplyPort = &wn.port;
+        ADDTAIL(&sem->waitlist, &wn);
+    }
+
+    ReleaseSemaphore(&sem->sem);
+
+    /* Sem not available and we have timeout */
+    if (retval == SDL_MUTEX_TIMEDOUT && timeout > 0) {
+        struct timerequest req;
+        struct Message *msg;
+
+        mywaitinit(&req, timeout, &wn);
+
+        req.tr_node.io_Command = TR_ADDREQUEST;
+        req.tr_time.tv_secs  = timeout / 1000;
+        req.tr_time.tv_micro = (timeout % 1000) * 1000;
+        SendIO((struct IORequest *) &req);
+
+        msg = WaitPort(&wn.port);
+        retval = 0;
+
+        if (msg != &wn.msg) {
+            ObtainSemaphore(&sem->sem);
+            REMOVE(&wn);
+            retval = wn.msg.mn_Node.ln_Type == NT_REPLYMSG ?  0 : SDL_MUTEX_TIMEDOUT;
+            ReleaseSemaphore(&sem->sem);
+        }
+
+        AbortIO((struct IORequest *) &req);
+        WaitIO((struct IORequest *) &req);
+    }
+
+    return retval;
+}
+
+int
+SDL_SemWait(SDL_sem * sem)
+{
+    return SDL_SemWaitTimeout(sem, SDL_MUTEX_MAXWAIT);
+}
+
+Uint32
+SDL_SemValue(SDL_sem * sem)
+{
+    if (!sem) {
+        SDL_SetError("Passed a NULL semaphore");
+        return -1;
+    }
+
+    return sem->sem_value;
+}
+
+int
+SDL_SemPost(SDL_sem * sem)
+{
+    struct waitnode *wn;
+
+    if (!sem)
+        return SDL_SetError("Passed a NULL semaphore");
+
+    ObtainSemaphore(&sem->sem);
+
+    sem->sem_value++;
+
+   	/* Wake whatever task happens to be first in the waitlist */
+    if ((wn = (APTR)REMHEAD(&sem->waitlist))) {
+        sem->sem_value--;
+        ReplyMsg(&wn->msg);
+    }
+
+    ReleaseSemaphore(&sem->sem);
+
+    return 0;
+}
+
+#endif /* SDL_THREADS_DISABLED */
+/* vi: set ts=4 sw=4 expandtab: */
diff -ruN SDL2-2.32.8/src/thread/aros/SDL_systhread.c SDL2-2.32.8.aros/src/thread/aros/SDL_systhread.c
--- SDL2-2.32.8/src/thread/aros/SDL_systhread.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/thread/aros/SDL_systhread.c	2025-08-03 20:59:50.391376885 +0000
@@ -0,0 +1,176 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2021 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+//#define DEBUG 1
+#include <aros/debug.h>
+
+#include "../../SDL_internal.h"
+
+/* Thread management routines for SDL2 */
+
+#include "SDL_thread.h"
+#include "../SDL_systhread.h"
+
+#include <exec/execbase.h>
+#include <proto/exec.h>
+#include <proto/dos.h>
+
+const char *warn_NoResources = "Not enough resources to create thread";
+
+static AROS_UFH3(Uint32, RunThread,
+    AROS_UFHA(char *,              args, A0),
+    AROS_UFHA(ULONG,               argSize, D0),
+    AROS_UFHA(struct ExecBase *,   SysBase, A6))
+{
+    AROS_USERFUNC_INIT
+
+    struct Task *Parent, *thisTask = FindTask(NULL);
+    SDL_Thread *thread = (SDL_Thread *)thisTask->tc_UserData;
+
+    D(bug("[SDL2:Thread] 0x%p:%s: Entered Thread (0x%p)\n", thisTask, __func__, thread));
+
+//#if defined(PROTO_SDL_H)
+//	/* Have child use parent library base */
+//	__aros_setoffsettable(threadArgs->base);
+//#endif
+
+    if (thread->handle.tp_Parent)
+    {
+        D(bug("[SDL2:Thread] 0x%p:%s: Parent @ 0x%p\n", thisTask, __func__, thread->handle.tp_Parent));
+    }
+
+#if (0)
+    BPTR lock = thread->status;
+    thread->status = 0;
+    BPTR oldDir = CurrentDir(lock);
+#endif
+
+    SDL_RunThread(thread);
+
+    D(bug("[SDL2:Thread] 0x%p:%s: Thread returned\n", thisTask, __func__));
+
+#if (0)
+    UnLock(CurrentDir(oldDir));
+#endif
+
+    if ((thread->handle.tp_Parent) && (thread->handle.tp_PSig != -1))
+        Signal(thread->handle.tp_Parent, (1 << thread->handle.tp_PSig));
+
+    return(0);
+
+    AROS_USERFUNC_EXIT
+}
+
+int
+SDL_SYS_CreateThread(SDL_Thread * thread)
+{
+    thread->handle.tp_Parent    = FindTask(NULL);
+    thread->handle.tp_PSig      = AllocSignal(-1);
+    if (thread->handle.tp_PSig == -1)
+    {
+        SDL_SetError(warn_NoResources);
+        return(-1);
+    }
+
+    D(
+        bug("[SDL2:Thread] %s: Spawning new process from -:\n", __func__);
+        bug("[SDL2:Thread] %s:        parent = 0x%p (thisTask)\n", __func__, thread->handle.tp_Parent);
+        bug("[SDL2:Thread] %s:        psig   = %08x\n", __func__, thread->handle.tp_PSig);
+    )
+
+    /* launch it. .. */
+    thread->handle.tp_Task = (struct Task *)CreateNewProcTags(NP_Output, Output(),
+                                    NP_StackSize, 	(IPTR)(thread->handle.tp_Parent->tc_SPUpper - thread->handle.tp_Parent->tc_SPLower),
+                                    NP_Entry, 		(IPTR)RunThread,
+                                    NP_UserData, 	thread,
+                                    NP_CloseOutput,	FALSE,
+                                    TAG_DONE);
+
+    if(!thread->handle.tp_Task)
+    {
+        SDL_SetError(warn_NoResources);
+        return(-1);
+    }
+
+    return(0);
+}
+
+void
+SDL_SYS_SetupThread(const char *name)
+{
+    struct Task *t = FindTask(NULL);
+    D(bug("[SDL2:Thread] %s('%s')\n", __func__, name));
+    t->tc_Node.ln_Name = (STRPTR)name;
+}
+
+SDL_threadID
+SDL_ThreadID(void)
+{
+    D(bug("[SDL2:Thread] %s()\n", __func__));
+    return (SDL_threadID)FindTask(NULL);
+}
+
+int
+SDL_SYS_SetThreadPriority(SDL_ThreadPriority priority)
+{
+    ssize_t pri = 0;
+
+    D(bug("[SDL2:Thread] %s()\n", __func__));
+
+    switch (priority) {
+    case SDL_THREAD_PRIORITY_LOW:
+        pri = -1;
+        break;
+    case SDL_THREAD_PRIORITY_HIGH:
+        pri = 5;
+        break;
+    case SDL_THREAD_PRIORITY_TIME_CRITICAL:
+        pri = 10;
+        break;
+    default:
+        pri = 0;
+        break;
+    }
+
+    SetTaskPri(FindTask(NULL), pri);
+    return 0;
+}
+
+void
+SDL_SYS_WaitThread(SDL_Thread * thread)
+{
+    D(bug("[SDL2:Thread] %s()\n", __func__));
+
+    if (thread->handle.tp_PSig != -1) {
+        SetSignal(0L,SIGBREAKF_CTRL_F | SIGBREAKF_CTRL_C);
+        Wait(SIGBREAKF_CTRL_F | SIGBREAKF_CTRL_C | (1 << thread->handle.tp_PSig));
+        FreeSignal(thread->handle.tp_PSig);
+    }
+    D(bug("[SDL2:Thread] %s: wait done\n", __func__));
+}
+
+void
+SDL_SYS_DetachThread(SDL_Thread * thread)
+{
+    D(bug("[SDL2:Thread] %s()\n", __func__));
+}
+
+/* vi: set ts=4 sw=4 expandtab: */
diff -ruN SDL2-2.32.8/src/thread/aros/SDL_systhread_c.h SDL2-2.32.8.aros/src/thread/aros/SDL_systhread_c.h
--- SDL2-2.32.8/src/thread/aros/SDL_systhread_c.h	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/thread/aros/SDL_systhread_c.h	2025-08-01 14:11:38.399659885 +0000
@@ -0,0 +1,32 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2021 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#include <exec/types.h>
+
+struct _AROS_ThreadPrivate
+{
+    struct Task *tp_Task;
+    struct Task *tp_Parent;
+    LONG        tp_PSig;
+};
+
+typedef struct _AROS_ThreadPrivate SYS_ThreadHandle;
diff -ruN SDL2-2.32.8/src/thread/generic/SDL_systls.c SDL2-2.32.8.aros/src/thread/generic/SDL_systls.c
--- SDL2-2.32.8/src/thread/generic/SDL_systls.c	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/src/thread/generic/SDL_systls.c	2025-07-27 14:24:17.384841346 +0000
@@ -22,11 +22,6 @@
 #include "../../SDL_internal.h"
 #include "../SDL_thread_c.h"
 
-void SDL_SYS_InitTLSData(void)
-{
-    SDL_Generic_InitTLSData();
-}
-
 SDL_TLSData *SDL_SYS_GetTLSData(void)
 {
     return SDL_Generic_GetTLSData();
@@ -37,9 +32,4 @@
     return SDL_Generic_SetTLSData(data);
 }
 
-void SDL_SYS_QuitTLSData(void)
-{
-    SDL_Generic_QuitTLSData();
-}
-
 /* vi: set ts=4 sw=4 expandtab: */
diff -ruN SDL2-2.32.8/src/thread/n3ds/SDL_syscond.c SDL2-2.32.8.aros/src/thread/n3ds/SDL_syscond.c
--- SDL2-2.32.8/src/thread/n3ds/SDL_syscond.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/thread/n3ds/SDL_syscond.c	2025-07-27 14:24:17.452841347 +0000
@@ -0,0 +1,127 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2025 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifdef SDL_THREAD_N3DS
+
+/* An implementation of condition variables using libctru's CondVar */
+
+#include "SDL_sysmutex_c.h"
+
+struct SDL_cond
+{
+    CondVar cond_variable;
+};
+
+/* Create a condition variable */
+SDL_cond *SDL_CreateCond(void)
+{
+    SDL_cond *cond = (SDL_cond *)SDL_malloc(sizeof(SDL_cond));
+    if (cond) {
+        CondVar_Init(&cond->cond_variable);
+    } else {
+        SDL_OutOfMemory();
+    }
+    return cond;
+}
+
+/* Destroy a condition variable */
+void SDL_DestroyCond(SDL_cond *cond)
+{
+    if (cond) {
+        SDL_free(cond);
+    }
+}
+
+/* Restart one of the threads that are waiting on the condition variable */
+int SDL_CondSignal(SDL_cond *cond)
+{
+    if (!cond) {
+        return SDL_InvalidParamError("cond");
+    }
+
+    CondVar_Signal(&cond->cond_variable);
+    return 0;
+}
+
+/* Restart all threads that are waiting on the condition variable */
+int SDL_CondBroadcast(SDL_cond *cond)
+{
+    if (!cond) {
+        return SDL_InvalidParamError("cond");
+    }
+
+    CondVar_Broadcast(&cond->cond_variable);
+    return 0;
+}
+
+/* Wait on the condition variable for at most 'ms' milliseconds.
+   The mutex must be locked before entering this function!
+   The mutex is unlocked during the wait, and locked again after the wait.
+
+Typical use:
+
+Thread A:
+    SDL_LockMutex(lock);
+    while ( ! condition ) {
+        SDL_CondWait(cond, lock);
+    }
+    SDL_UnlockMutex(lock);
+
+Thread B:
+    SDL_LockMutex(lock);
+    ...
+    condition = true;
+    ...
+    SDL_CondSignal(cond);
+    SDL_UnlockMutex(lock);
+ */
+int SDL_CondWaitTimeout(SDL_cond *cond, SDL_mutex *mutex, Uint32 ms)
+{
+    Result res;
+
+    if (!cond) {
+        return SDL_InvalidParamError("cond");
+    }
+    if (!mutex) {
+        return SDL_InvalidParamError("mutex");
+    }
+
+    res = 0;
+    if (ms == SDL_MUTEX_MAXWAIT) {
+        CondVar_Wait(&cond->cond_variable, &mutex->lock.lock);
+    } else {
+        res = CondVar_WaitTimeout(&cond->cond_variable, &mutex->lock.lock,
+                                  (s64)ms * 1000000LL);
+    }
+
+    return R_SUCCEEDED(res) ? 0 : SDL_MUTEX_TIMEDOUT;
+}
+
+/* Wait on the condition variable forever */
+int SDL_CondWait(SDL_cond *cond, SDL_mutex *mutex)
+{
+    return SDL_CondWaitTimeout(cond, mutex, SDL_MUTEX_MAXWAIT);
+}
+
+#endif /* SDL_THREAD_N3DS */
+
+/* vi: set sts=4 ts=4 sw=4 expandtab: */
diff -ruN SDL2-2.32.8/src/thread/SDL_systhread.h SDL2-2.32.8.aros/src/thread/SDL_systhread.h
--- SDL2-2.32.8/src/thread/SDL_systhread.h	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/src/thread/SDL_systhread.h	2025-07-27 14:24:17.824841353 +0000
@@ -59,18 +59,12 @@
 /* Mark thread as cleaned up as soon as it exits, without joining. */
 extern void SDL_SYS_DetachThread(SDL_Thread *thread);
 
-/* Initialize the global TLS data */
-extern void SDL_SYS_InitTLSData(void);
-
 /* Get the thread local storage for this thread */
 extern SDL_TLSData *SDL_SYS_GetTLSData(void);
 
 /* Set the thread local storage for this thread */
 extern int SDL_SYS_SetTLSData(SDL_TLSData *data);
 
-/* Quit the global TLS data */
-extern void SDL_SYS_QuitTLSData(void);
-
 /* This is for internal SDL use, so we don't need #ifdefs everywhere. */
 extern SDL_Thread *
 SDL_CreateThreadInternal(int(SDLCALL *fn)(void *), const char *name,
diff -ruN SDL2-2.32.8/src/thread/SDL_thread.c SDL2-2.32.8.aros/src/thread/SDL_thread.c
--- SDL2-2.32.8/src/thread/SDL_thread.c	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/src/thread/SDL_thread.c	2025-07-31 14:39:34.385811973 +0000
@@ -28,15 +28,7 @@
 #include "SDL_hints.h"
 #include "../SDL_error_c.h"
 
-/* The storage is local to the thread, but the IDs are global for the process */
-
-static SDL_atomic_t SDL_tls_allocated;
-
-void SDL_InitTLSData(void)
-{
-    SDL_SYS_InitTLSData();
-}
-
+#if !defined(__AROS__) || defined(SDL2_AROS_SHARED) || defined(SDL2_AROS_STATIC)
 SDL_TLSID SDL_TLSCreate(void)
 {
     static SDL_atomic_t SDL_tls_id;
@@ -62,13 +54,6 @@
         return SDL_InvalidParamError("id");
     }
 
-    /* Make sure TLS is initialized.
-     * There's a race condition here if you are calling this from non-SDL threads
-     * and haven't called SDL_Init() on your main thread, but such is life.
-     */
-    SDL_InitTLSData();
-
-    /* Get the storage for the current thread */
     storage = SDL_SYS_GetTLSData();
     if (!storage || (id > storage->limit)) {
         unsigned int i, oldlimit, newlimit;
@@ -85,10 +70,8 @@
             storage->array[i].destructor = NULL;
         }
         if (SDL_SYS_SetTLSData(storage) != 0) {
-            SDL_free(storage);
             return -1;
         }
-        SDL_AtomicIncRef(&SDL_tls_allocated);
     }
 
     storage->array[id - 1].data = SDL_const_cast(void *, value);
@@ -100,7 +83,6 @@
 {
     SDL_TLSData *storage;
 
-    /* Cleanup the storage for the current thread */
     storage = SDL_SYS_GetTLSData();
     if (storage) {
         unsigned int i;
@@ -111,18 +93,6 @@
         }
         SDL_SYS_SetTLSData(NULL);
         SDL_free(storage);
-        (void)SDL_AtomicDecRef(&SDL_tls_allocated);
-    }
-}
-
-void SDL_QuitTLSData(void)
-{
-    SDL_TLSCleanup();
-
-    if (SDL_AtomicGet(&SDL_tls_allocated) == 0) {
-        SDL_SYS_QuitTLSData();
-    } else {
-        /* Some thread hasn't called SDL_CleanupTLS() */
     }
 }
 
@@ -144,27 +114,40 @@
 static SDL_mutex *SDL_generic_TLS_mutex;
 static SDL_TLSEntry *SDL_generic_TLS;
 
-void SDL_Generic_InitTLSData(void)
-{
-    if (!SDL_generic_TLS_mutex) {
-        SDL_generic_TLS_mutex = SDL_CreateMutex();
-    }
-}
-
 SDL_TLSData *SDL_Generic_GetTLSData(void)
 {
     SDL_threadID thread = SDL_ThreadID();
     SDL_TLSEntry *entry;
     SDL_TLSData *storage = NULL;
 
+#ifndef SDL_THREADS_DISABLED
+    if (!SDL_generic_TLS_mutex) {
+        static SDL_SpinLock tls_lock;
+        SDL_AtomicLock(&tls_lock);
+        if (!SDL_generic_TLS_mutex) {
+            SDL_mutex *mutex = SDL_CreateMutex();
+            SDL_MemoryBarrierRelease();
+            SDL_generic_TLS_mutex = mutex;
+            if (!SDL_generic_TLS_mutex) {
+                SDL_AtomicUnlock(&tls_lock);
+                return NULL;
+            }
+        }
+        SDL_AtomicUnlock(&tls_lock);
+    }
+    SDL_MemoryBarrierAcquire();
     SDL_LockMutex(SDL_generic_TLS_mutex);
+#endif /* SDL_THREADS_DISABLED */
+
     for (entry = SDL_generic_TLS; entry; entry = entry->next) {
         if (entry->thread == thread) {
             storage = entry->storage;
             break;
         }
     }
+#ifndef SDL_THREADS_DISABLED
     SDL_UnlockMutex(SDL_generic_TLS_mutex);
+#endif
 
     return storage;
 }
@@ -173,8 +156,8 @@
 {
     SDL_threadID thread = SDL_ThreadID();
     SDL_TLSEntry *prev, *entry;
-    int retval = 0;
 
+    /* SDL_Generic_GetTLSData() is always called first, so we can assume SDL_generic_TLS_mutex */
     SDL_LockMutex(SDL_generic_TLS_mutex);
     prev = NULL;
     for (entry = SDL_generic_TLS; entry; entry = entry->next) {
@@ -193,46 +176,25 @@
         }
         prev = entry;
     }
-    if (!entry && data) {
+    if (!entry) {
         entry = (SDL_TLSEntry *)SDL_malloc(sizeof(*entry));
         if (entry) {
             entry->thread = thread;
             entry->storage = data;
             entry->next = SDL_generic_TLS;
             SDL_generic_TLS = entry;
-        } else {
-            retval = SDL_OutOfMemory();
         }
     }
     SDL_UnlockMutex(SDL_generic_TLS_mutex);
 
-    return retval;
-}
-
-void SDL_Generic_QuitTLSData(void)
-{
-    SDL_TLSEntry *entry;
-
-    /* This should have been cleaned up by the time we get here */
-    SDL_assert(!SDL_generic_TLS);
-    if (SDL_generic_TLS) {
-        SDL_LockMutex(SDL_generic_TLS_mutex);
-        for (entry = SDL_generic_TLS; entry; ) {
-            SDL_TLSEntry *next = entry->next;
-            SDL_free(entry->storage);
-            SDL_free(entry);
-            entry = next;
-        }
-        SDL_generic_TLS = NULL;
-        SDL_UnlockMutex(SDL_generic_TLS_mutex);
-    }
-
-    if (SDL_generic_TLS_mutex) {
-        SDL_DestroyMutex(SDL_generic_TLS_mutex);
-        SDL_generic_TLS_mutex = NULL;
+    if (!entry) {
+        return SDL_OutOfMemory();
     }
+    return 0;
 }
 
+#endif /* !__AROS__*/
+
 /* Non-thread-safe global error variable */
 static SDL_error *SDL_GetStaticErrBuf(void)
 {
@@ -243,6 +205,13 @@
     return &SDL_global_error;
 }
 
+#if defined(__AROS__) && !(defined(SDL2_AROS_SHARED) || defined(SDL2_AROS_STATIC))
+/* Routine to get the thread-specific error variable */
+SDL_error *SDL_GetErrBuf(void)
+{
+    return SDL_GetStaticErrBuf();
+}
+#else
 #ifndef SDL_THREADS_DISABLED
 static void SDLCALL SDL_FreeErrBuf(void *data)
 {
@@ -369,8 +338,6 @@
     SDL_Thread *thread;
     int ret;
 
-    SDL_InitMainThread();
-
     /* Allocate memory for the thread info structure */
     thread = (SDL_Thread *)SDL_calloc(1, sizeof(*thread));
     if (!thread) {
@@ -515,4 +482,6 @@
     }
 }
 
+#endif /* !__AROS__*/
+
 /* vi: set ts=4 sw=4 expandtab: */
diff -ruN SDL2-2.32.8/src/thread/SDL_thread_c.h SDL2-2.32.8.aros/src/thread/SDL_thread_c.h
--- SDL2-2.32.8/src/thread/SDL_thread_c.h	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/src/thread/SDL_thread_c.h	2025-08-01 13:05:57.897960957 +0000
@@ -42,6 +42,10 @@
 #include "n3ds/SDL_systhread_c.h"
 #elif defined(SDL_THREAD_STDCPP)
 #include "stdcpp/SDL_systhread_c.h"
+#elif defined(SDL_THREAD_AROS)
+#include "aros/SDL_systhread_c.h"
+#elif defined(SDL_THREAD_MORPHOS)
+#include "morphos/SDL_systhread_c.h"
 #elif defined(SDL_THREAD_OS2)
 #include "os2/SDL_systhread_c.h"
 #elif defined(SDL_THREAD_NGAGE)
@@ -93,17 +97,17 @@
 /* This is how many TLS entries we allocate at once */
 #define TLS_ALLOC_CHUNKSIZE 4
 
-extern void SDL_InitTLSData(void);
-extern void SDL_QuitTLSData(void);
-
-/* Generic TLS support.
+/* Get cross-platform, slow, thread local storage for this thread.
    This is only intended as a fallback if getting real thread-local
    storage fails or isn't supported on this platform.
  */
-extern void SDL_Generic_InitTLSData(void);
 extern SDL_TLSData *SDL_Generic_GetTLSData(void);
+
+/* Set cross-platform, slow, thread local storage for this thread.
+   This is only intended as a fallback if getting real thread-local
+   storage fails or isn't supported on this platform.
+ */
 extern int SDL_Generic_SetTLSData(SDL_TLSData *data);
-extern void SDL_Generic_QuitTLSData(void);
 
 #endif /* SDL_thread_c_h_ */
 
diff -ruN SDL2-2.32.8/src/timer/aros/SDL_systimer.c SDL2-2.32.8.aros/src/timer/aros/SDL_systimer.c
--- SDL2-2.32.8/src/timer/aros/SDL_systimer.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/timer/aros/SDL_systimer.c	2025-07-30 18:12:50.000000000 +0000
@@ -0,0 +1,119 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#if defined(SDL_TIMER_AROS) && !defined(SDL_TIMERS_DISABLED)
+
+#include "SDL_timer.h"
+
+#include <exec/execbase.h>
+#include <proto/exec.h>
+#include <proto/timer.h>
+
+extern struct timerequest GlobalTimeReq;
+
+static SDL_bool ticks_started = SDL_FALSE;
+static struct timeval basetime;
+
+void
+SDL_TicksInit(void)
+{
+	if (ticks_started)
+		return;
+
+	ticks_started = SDL_TRUE;
+	GetSysTime(&basetime);
+}
+
+void
+SDL_TicksQuit(void)
+{
+	ticks_started = SDL_FALSE;
+}
+
+Uint64
+SDL_GetTicks64(void)
+{
+	struct timeval tv;
+
+	if (!ticks_started)
+		SDL_TicksInit();
+
+	GetSysTime(&tv);
+
+	if (basetime.tv_micro > tv.tv_micro) {
+		tv.tv_secs--;
+		tv.tv_micro += 1000000;
+	}
+
+	return (Uint64)((tv.tv_secs - basetime.tv_secs) * 1000) + ((tv.tv_micro - basetime.tv_micro)/1000);
+}
+
+Uint64
+SDL_GetPerformanceCounter(void)
+{
+	Uint64 val = 0;
+#if !defined(__AROS__)
+	ReadCPUClock(&val);
+#endif
+	return val;
+}
+
+Uint64
+SDL_GetPerformanceFrequency(void)
+{
+	Uint64 ret = 0;
+#if !defined(__AROS__)
+	Uint64 val;
+	ret = ReadCPUClock(&val);
+#endif
+	return ret;
+}
+
+void
+InitQPort(struct MsgPort *port)
+{
+	port->mp_SigBit = SIGB_SINGLE;
+	port->mp_Flags = PA_SIGNAL;
+	port->mp_SigTask = FindTask(NULL);
+	NEWLIST(&port->mp_MsgList);
+}
+
+void
+SDL_Delay(Uint32 ms)
+{
+	struct timerequest req;
+	struct MsgPort port;
+
+	InitQPort(&port);
+
+	req.tr_node.io_Message.mn_Node.ln_Type = 0;
+	req.tr_node.io_Message.mn_ReplyPort = &port;
+	req.tr_node.io_Device = GlobalTimeReq.tr_node.io_Device;
+	req.tr_node.io_Unit = GlobalTimeReq.tr_node.io_Unit;
+	req.tr_node.io_Command = TR_ADDREQUEST;
+	req.tr_time.tv_secs = ms / 1000;
+	req.tr_time.tv_micro = (ms % 1000) * 1000;
+
+	DoIO((struct IORequest *)&req);
+}
+
+#endif /* SDL_TIMER_AROS || SDL_TIMERS_DISABLED */
diff -ruN SDL2-2.32.8/src/video/aros/SDL_arosclipboard.c SDL2-2.32.8.aros/src/video/aros/SDL_arosclipboard.c
--- SDL2-2.32.8/src/video/aros/SDL_arosclipboard.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/video/aros/SDL_arosclipboard.c	2025-08-04 17:04:05.304791353 +0000
@@ -0,0 +1,277 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+//#define DEBUG 1
+#include <aros/debug.h>
+
+#define __NOLIBBASE__
+
+#include "../../SDL_internal.h"
+
+#include "../SDL_sysvideo.h"
+#include "../../misc/aros/SDL_misc.h"
+
+#include <devices/clipboard.h>
+#include <proto/exec.h>
+#include <proto/iffparse.h>
+
+extern struct Library *IFFParseBase;
+
+#define ID_FTXT	MAKE_ID('F','T','X','T')
+#define ID_CHRS	MAKE_ID('C','H','R','S')
+#define ID_UTF8	MAKE_ID('U','T','F','8')
+
+STATIC APTR clipboard_open(void)
+{
+	struct IOClipReq *io;
+	struct MsgPort *mp;
+
+	mp = CreateMsgPort();
+
+	if ((io = (struct IOClipReq *)CreateIORequest(mp,sizeof(struct IOClipReq)))) {
+		if (!(OpenDevice("clipboard.device", 0, (struct IORequest *)io, 0))) {
+			return io;
+		}
+
+		DeleteIORequest((struct IORequest *)io);
+	}
+
+	DeleteMsgPort(mp);
+	return NULL;
+}
+
+STATIC ULONG clipboard_write_data(struct IOClipReq *io, CONST_APTR data, ULONG len)
+{
+	LONG rc;
+
+	io->io_Command = CMD_WRITE;
+	io->io_Data    = (APTR)data;
+	io->io_Length  = len;
+	DoIO( (struct IORequest *)io);
+
+	if (io->io_Actual != len) {
+		io->io_Error = 1;
+	}
+
+	rc = io->io_Error ? FALSE : TRUE;
+	return rc;
+}
+
+
+STATIC VOID clipboard_pad_text(struct IOClipReq *io, ULONG textlen)
+{
+	if (textlen & 1)
+		clipboard_write_data(io, "", 1);
+}
+
+
+STATIC ULONG clipboard_write_header_and_text(struct IOClipReq *io, CONST_STRPTR string, ULONG slen, ULONG ulen)
+{
+	ULONG rc;
+
+	struct
+	{
+		ULONG form;
+		ULONG totalsize;
+		ULONG ftxt;
+		ULONG type;
+		ULONG strlen;
+	} iffheader;
+
+	io->io_Offset = 0;
+	io->io_Error  = 0;
+//	io->io_ClipID = 0;
+
+	iffheader.form      = ID_FORM;
+	iffheader.totalsize = (slen & 1 ? slen + 1 : slen) + (ulen & 1 ? ulen + 1 : ulen) + 12 + 8;
+	iffheader.ftxt      = ID_FTXT;
+	iffheader.type      = ID_CHRS;
+	iffheader.strlen    = slen;
+
+	rc = FALSE;
+
+	if (clipboard_write_data(io, &iffheader, sizeof(iffheader))) {
+		if (clipboard_write_data(io, string, slen)) {
+			clipboard_pad_text(io, slen);
+			rc = TRUE;
+		}
+	}
+
+	return rc;
+}
+
+
+STATIC ULONG clipboard_write_utf8(struct IOClipReq *io, CONST_STRPTR utext, ULONG ulen)
+{
+	ULONG rc;
+
+	struct
+	{
+		ULONG type;
+		ULONG strlen;
+	} utf8_header;
+
+	/* FIXME: For correct operation we should also store font name. Used font
+	 * is relevant with guides written in Japanese for example.
+	 */
+
+	utf8_header.type   = ID_UTF8;
+	utf8_header.strlen = ulen;
+
+	rc = FALSE;
+
+	if (clipboard_write_data(io, &utf8_header, sizeof(utf8_header))) {
+		if (clipboard_write_data(io, utext, ulen)) {
+			clipboard_pad_text(io, ulen);
+			rc = TRUE;
+		}
+	}
+
+	return rc;
+}
+
+STATIC VOID clipboard_finalize(struct IOClipReq *io)
+{
+	io->io_Command = CMD_UPDATE;
+	DoIO((struct IORequest *)io);
+}
+
+STATIC void clipboard_close(struct IOClipReq *io)
+{
+	if (io) {
+		struct MsgPort *mp = io->io_Message.mn_ReplyPort;
+
+		CloseDevice((struct IORequest *)io);
+		DeleteIORequest((struct IORequest *)io);
+		DeleteMsgPort(mp);
+	}
+}
+
+int
+AROS_SetClipboardText(_THIS, const char *text)
+{
+	APTR ctx;
+	int rc = -1;
+
+	if ((ctx = clipboard_open())) {
+		char *stext = NULL;
+		
+		stext = AROS_ConvertUTF8Text(text);
+
+		if (stext) {
+			int ulen = strlen(text);
+
+			if (clipboard_write_header_and_text(ctx, stext, strlen(stext), ulen)) {
+				if (clipboard_write_utf8(ctx, text, ulen))
+					rc = 0;
+			}
+
+			SDL_free(stext);
+			clipboard_finalize(ctx);
+		}
+		
+		clipboard_close(ctx);
+	}
+
+	return rc;
+}
+
+char *
+AROS_GetClipboardText(_THIS)
+{
+	struct IFFHandle *clip = AllocIFF();
+	char *text = NULL;
+
+	if (clip) {
+		clip->iff_Stream = (IPTR)OpenClipboard(0);
+
+		if (clip->iff_Stream) {
+			InitIFFasClip(clip);
+
+			if (!OpenIFF(clip, IFFF_READ)) {
+				if (!StopChunk(clip, ID_FTXT, ID_CHRS) && !StopChunk(clip, ID_FTXT, ID_UTF8)) {
+					BOOL done = FALSE;
+
+					while (done == FALSE && !ParseIFF(clip, IFFPARSE_SCAN)) {
+						struct ContextNode *cn = CurrentChunk(clip);
+
+						if (cn) {
+							LONG size = cn->cn_Size;
+
+							if (cn->cn_Type == ID_FTXT && size > 0) {
+								if (cn->cn_ID == ID_CHRS && !text) {
+									char *tmp = SDL_malloc(size + 1);
+
+									if (tmp) {
+										ReadChunkBytes(clip, tmp, size);
+										tmp[size] = '\0';
+
+										text = AROS_ConvertTextUTF8(tmp);
+
+										SDL_free(tmp);
+									}
+								}
+								else if (cn->cn_ID == ID_UTF8) {
+									if (text)
+										SDL_free(text);
+
+									if ((text = SDL_malloc(size + 1))) {
+										ReadChunkBytes(clip, text, size);
+										text[size] = '\0';
+										done = TRUE;
+										break;
+									}
+								}
+							}
+						}
+					}
+				}
+
+				CloseIFF(clip);
+			}
+
+			CloseClipboard((struct ClipboardHandle *)clip->iff_Stream);
+		}
+
+		FreeIFF(clip);
+	}
+
+	if (text == NULL) {
+		if ((text = SDL_malloc(1)))
+			text[0] = '\0';
+	}
+
+	return text;
+}
+
+SDL_bool
+AROS_HasClipboardText(_THIS)
+{
+	SDL_bool result = SDL_FALSE;
+	char *text = AROS_GetClipboardText(_this);
+
+	if (text) {
+		result = text[0] != '\0' ? SDL_TRUE : SDL_FALSE;
+		SDL_free(text);
+	}
+
+	return result;
+}
diff -ruN SDL2-2.32.8/src/video/aros/SDL_arosclipboard.h SDL2-2.32.8.aros/src/video/aros/SDL_arosclipboard.h
--- SDL2-2.32.8/src/video/aros/SDL_arosclipboard.h	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/video/aros/SDL_arosclipboard.h	2025-07-28 18:29:11.840824792 +0000
@@ -0,0 +1,30 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifndef _SDL_arosclipboard_h
+#define _SDL_arosclipboard_h
+
+extern int AROS_SetClipboardText(_THIS, const char *text);
+extern char *AROS_GetClipboardText(_THIS);
+extern SDL_bool AROS_HasClipboardText(_THIS);
+
+#endif /* _SDL_arosclipboard_h */
diff -ruN SDL2-2.32.8/src/video/aros/SDL_arosevents.c SDL2-2.32.8.aros/src/video/aros/SDL_arosevents.c
--- SDL2-2.32.8/src/video/aros/SDL_arosevents.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/video/aros/SDL_arosevents.c	2025-08-11 17:38:16.825907887 +0000
@@ -0,0 +1,826 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+//#define DEBUG 1
+#include <aros/debug.h>
+
+#define __NOLIBBASE__
+
+#include "../../SDL_internal.h"
+
+#include "SDL_scancode.h"
+#include "../SDL_sysvideo.h"
+#include "../../events/SDL_events_c.h"
+#include "../../events/SDL_mouse_c.h"
+#include "../../events/scancodes_amigaos.h"
+
+#include "SDL_arosvideo.h"
+#include "SDL_aroswindow.h"
+#include "SDL_arosopengl.h"
+#include "SDL_arosmouse.h"
+
+#include "SDL_timer.h"
+#include "SDL_syswm.h"
+#include "SDL.h"
+
+#include <devices/rawkeycodes.h>
+#include <intuition/extensions.h>
+#include <rexx/errors.h>
+#include <rexx/storage.h>
+#include <workbench/workbench.h>
+#include <workbench/startup.h>
+
+#include <libraries/gadtools.h>
+
+#include <hidd/hidd.h>
+
+#include <proto/oop.h>
+#include <proto/dos.h>
+#include <proto/alib.h>
+#include <proto/commodities.h>
+#include <proto/exec.h>
+#include <proto/intuition.h>
+#include <proto/keymap.h>
+#include <proto/locale.h>
+
+#include <stdio.h>
+
+extern struct Library *DOSBase;
+extern struct Library *IntuitionBase;
+extern struct Library *CxBase;
+extern struct Library *OOPBase;
+OOP_AttrBase HiddAttrBase;
+OOP_AttrBase HWAttrBase;
+
+const struct OOP_ABDescr abd[] =
+{
+    {IID_Hidd        ,  &HiddAttrBase },
+    {IID_HW          ,  &HWAttrBase   },
+    {NULL            ,  NULL          }
+};
+
+void AHI_Mute(ULONG mute);
+extern AROS_GlobalMouseState globalMouseState;
+
+const char *aros_str_Unknown = "Unknown";
+
+static int
+AROS_GetButton(int code)
+{
+    switch (code & ~IECODE_UP_PREFIX) {
+        case IECODE_LBUTTON:
+            return SDL_BUTTON_LEFT;
+        case IECODE_RBUTTON:
+            return SDL_BUTTON_RIGHT;
+        case IECODE_MBUTTON:
+            return SDL_BUTTON_MIDDLE;
+        default:
+            return 0;
+    }
+}
+
+static void
+AROS_DispatchMouseButtons(_THIS, struct IntuiMessage *m, const SDL_WindowData *data)
+{
+    SDL_WindowData *sdlwin = (SDL_WindowData *)m->IDCMPWindow->UserData;
+
+    if (sdlwin) {
+        int state = (m->Code & IECODE_UP_PREFIX) ? SDL_RELEASED : SDL_PRESSED;
+        int button = AROS_GetButton(m->Code & ~(IECODE_UP_PREFIX));
+
+        globalMouseState.buttonPressed[button] = state;
+
+        SDL_SendMouseButton(data->window, 0, state, button);
+    }
+
+}
+
+static int
+AROS_TranslateUnicode(struct IntuiMessage *m, char *buffer)
+{
+	int length = 0;
+#if !defined(__AROS__)
+    WCHAR keycode = getv(m, IMSGA_UCS4);
+	length = UTF8_Encode(keycode, buffer);
+#endif
+	return length;
+}
+
+static void
+AROS_DispatchRawKey(_THIS, struct IntuiMessage *m, const SDL_WindowData *data)
+{
+	
+	UWORD code = m->Code;
+	UWORD rawkey = m->Code & 0x7F;
+
+	switch (code) {
+		case RAWKEY_NM_WHEEL_UP:
+			SDL_SendMouseWheel(data->window, 0, 0, 1, SDL_MOUSEWHEEL_NORMAL);
+			break;
+
+		case RAWKEY_NM_WHEEL_DOWN:
+			SDL_SendMouseWheel(data->window, 0, 0, -1, SDL_MOUSEWHEEL_NORMAL);
+			break;
+
+		case RAWKEY_NM_WHEEL_LEFT:
+			SDL_SendMouseWheel(data->window, 0, -1, 0, SDL_MOUSEWHEEL_NORMAL);
+			break;
+
+		case RAWKEY_NM_WHEEL_RIGHT:
+			SDL_SendMouseWheel(data->window, 0, 1, 0,  SDL_MOUSEWHEEL_NORMAL);
+			break;
+
+		case RAWKEY_NM_BUTTON_FOURTH:
+		    globalMouseState.buttonPressed[SDL_BUTTON_X1] = SDL_PRESSED;;
+			SDL_SendMouseButton(data->window, 0, SDL_PRESSED, SDL_BUTTON_X1);
+			break;
+
+		case RAWKEY_NM_BUTTON_FOURTH | IECODE_UP_PREFIX:
+			globalMouseState.buttonPressed[SDL_BUTTON_X1] = SDL_RELEASED;
+			SDL_SendMouseButton(data->window, 0, SDL_RELEASED, SDL_BUTTON_X1);
+			break;
+
+		default:
+			if (rawkey < sizeof(amigaos_scancode_table) / sizeof(amigaos_scancode_table[0])) {
+                SDL_Scancode s = amigaos_scancode_table[rawkey];
+                if (m->Code < 128) {
+                    char text[5] = { 0 };
+					int length = AROS_TranslateUnicode(m, text);
+					SDL_SendKeyboardKey(SDL_PRESSED, s);
+					if (length > 0) {
+						text[length] = '\0';
+						SDL_SendKeyboardText(text);
+					}
+				} else {
+					SDL_SendKeyboardKey(SDL_RELEASED, s);
+				}
+			}
+			break;
+	}
+}
+
+static void
+AROS_MouseMove(_THIS, struct IntuiMessage *m, SDL_WindowData *data)
+{
+    struct Screen *s = data->win->WScreen;
+
+    //D(bug("[SDL2:arosevt] %s: X:%d Y:%d, ScreenX: %d ScreenY: %d\n", __func__, m->MouseX, m->MouseY, s->MouseX, s->MouseY);
+    globalMouseState.x = s->MouseX;
+    globalMouseState.y = s->MouseY;
+
+    if (SDL_GetRelativeMouseMode()) {
+        if (data->first_deltamove) {
+            data->first_deltamove = 0;
+            return;
+        }
+        SDL_SendMouseMotion(data->window, 0, 1, m->MouseX, m->MouseY);
+    } else {
+    	//struct Screen *s = data->win->WScreen;
+        int x = (s->MouseX - data->win->LeftEdge - data->win->BorderLeft);
+        int y = (s->MouseY - data->win->TopEdge - data->win->BorderTop);
+        SDL_SendMouseMotion(data->window, 0, 0, x, y);
+    }
+}
+
+static void
+AROS_HandleActivation(_THIS, struct IntuiMessage *m, SDL_bool activated)
+{
+	D(bug("[SDL2:arosevt] %s()\n", __func__));
+
+	SDL_WindowData *data = (SDL_WindowData *)m->IDCMPWindow->UserData;
+    if (data) {
+        if (data->window) {
+            if (activated) {
+
+                SDL_SendWindowEvent(data->window, SDL_WINDOWEVENT_SHOWN, 0, 0);
+                if (SDL_GetKeyboardFocus() != data->window)
+                    SDL_SetKeyboardFocus(data->window);
+
+                SDL_SetMouseFocus(data->window);
+                AROS_MouseMove(_this, m, data);
+
+            } else {
+                if (SDL_GetKeyboardFocus() == data->window)
+                    SDL_SetKeyboardFocus(NULL);
+                if (SDL_GetMouseFocus() == data->window)
+                    SDL_SetMouseFocus(NULL);
+            }
+        }
+    }
+}
+
+static void
+AROS_ChangeWindow(_THIS, const struct IntuiMessage *m, SDL_WindowData *data)
+{
+	struct Window *w = data->win;
+
+	D(bug("[SDL2:arosevt] %s()\n", __func__));
+
+	if (data->curr_x != w->LeftEdge || data->curr_h != w->TopEdge) {
+		data->curr_x = w->LeftEdge;
+		data->curr_y = w->TopEdge;
+		SDL_SendWindowEvent(data->window, SDL_WINDOWEVENT_MOVED, data->curr_x, data->curr_y);
+	}
+
+	if (data->curr_w != w->Width || data->curr_h != w->Height) {
+		data->curr_w = w->Width;
+		data->curr_h = w->Height;
+		SDL_SendWindowEvent(data->window, SDL_WINDOWEVENT_RESIZED, (data->curr_w - w->BorderLeft - w->BorderRight), (data->curr_h - w->BorderTop - w->BorderBottom));
+#if (0)
+		if (_this->gl_data->gldd_GLACtx)
+        {
+            AROS_GL_ResizeContext(_this, data->window);
+        }
+#endif
+	}
+}
+
+static void AROS_GadgetEvent(_THIS, const struct IntuiMessage *m)
+{
+	D(bug("[SDL2:arosevt] %s()\n", __func__));
+
+	switch (((struct Gadget *)m->IAddress)->GadgetID) {
+		case ETI_Iconify:
+			AROS_HideApp(_this, TRUE);
+			break;
+		case ETI_Jump:
+			D(bug("[SDL2:arosevt] %s: ETI_JUMP\n", __func__));
+			//SDL_WindowData *data = (SDL_WindowData *)m->IDCMPWindow->UserData;
+			//SDL_SetWindowFullscreen(data->window, data->winflags);
+			break;
+	}
+}
+
+static const char porters[] = "Kalamatee (kalamatee@gmail.com), based on the morphos port\n";
+static const char bases[] = "SDL 2.32.8 sources by Ilkka Lehtoranta";
+
+static void
+AROS_AboutSDL(struct Window *window)
+{
+	struct EasyStruct es;
+	es.es_StructSize   = sizeof(struct EasyStruct);
+	es.es_Flags        = 0;
+	es.es_Title        = "SDL2";
+
+	es.es_TextFormat   = "SDL %ld.%ld.%ld -AROS-\nCompiled on " ADATE "\n\nSimple DirectMedia Layer is cross-platform development library designed to\nprovide low level access audio, keyboard, mouse, joysticks, and graphics hardware.\n\nSDL 2.0 is distributed under zlib license.\nThis license allows you to use SDL freely in any software.\n\nPorters:\n%s\nBased on %s\n\nwww.libsdl.org";
+	es.es_GadgetFormat = "Ok";
+
+	EasyRequest(window, &es, NULL, SDL_MAJOR_VERSION, SDL_MINOR_VERSION, SDL_PATCHLEVEL, (IPTR)porters, (IPTR)bases);
+}
+
+static void
+AROS_AboutSystem(struct Window *window)
+{
+	struct EasyStruct es;
+	es.es_StructSize   = sizeof(struct EasyStruct);
+	es.es_Flags        = 0;
+	es.es_Title        = "About System";
+	es.es_TextFormat   = "System: %s - Vendor: %s\n";
+	es.es_GadgetFormat = "Ok";
+
+	char System[256];
+	char Vendor[256];
+
+    const char *hwname = NULL;
+    if (OOP_ObtainAttrBases(abd))
+    {
+        OOP_Object *hwRoot = OOP_NewObject(NULL, CLID_HW_Root, NULL);
+        if (hwRoot)
+        {
+            OOP_GetAttr(hwRoot, aHW_ClassName, (IPTR *)&hwname);
+            if (!hwname)
+                OOP_GetAttr(hwRoot, aHidd_HardwareName, (IPTR *)&hwname);
+        }
+        OOP_ReleaseAttrBases(abd);
+    }
+    if (hwname)
+        hwname = aros_str_Unknown;
+    SDL_snprintf(System, sizeof(System), "%s", hwname);
+    SDL_snprintf(Vendor, sizeof(Vendor), "%s", aros_str_Unknown);
+
+    EasyRequest(window, &es, NULL, System, Vendor);
+}
+
+static void
+AROS_Joystick(struct Window *window)
+{
+	char text1[2000] = "";
+	char text2[254] = "";
+	int i;
+    int controller_count = 0;
+    char guid[64];
+	
+	SDL_InitSubSystem(SDL_INIT_JOYSTICK | SDL_INIT_GAMECONTROLLER);
+	
+	for (i = 0; i < SDL_NumJoysticks(); ++i) {
+    	const char *name;
+		char text[254] = "";
+		SDL_JoystickGetGUIDString(SDL_JoystickGetDeviceGUID(i), guid, sizeof (guid));
+		SDL_Joystick *joystick = SDL_JoystickOpen(i);
+        if (joystick != NULL) {		
+			if (SDL_IsGameController(i)) {
+				controller_count++;
+				name = SDL_GameControllerNameForIndex(i);
+			} else {
+				name = SDL_JoystickNameForIndex(i);	
+			}			
+		
+			snprintf(text, sizeof(text), "%d: %s (guid %s, VID 0x%.4x, PID 0x%.4x, player index = %d)\n",
+				i, name ? name : "Unknown", guid,
+			SDL_JoystickGetDeviceVendor(i), SDL_JoystickGetDeviceProduct(i), SDL_JoystickGetDevicePlayerIndex(i));
+			strcat(text1, text);
+			snprintf(text, sizeof(text),"    Joystick has %d axes, %d hats, %d balls, and %d buttons\n",
+			SDL_JoystickNumAxes(joystick), SDL_JoystickNumHats(joystick),
+			SDL_JoystickNumBalls(joystick), SDL_JoystickNumButtons(joystick));
+			strcat(text1, text);
+			SDL_JoystickClose(joystick);
+		}
+	}
+	
+	snprintf(text2, sizeof(text2),"There are %d game controller(s) attached (%d joystick(s))\n", controller_count, SDL_NumJoysticks());
+	struct EasyStruct es;
+	es.es_StructSize   = sizeof(struct EasyStruct);
+	es.es_Flags        = 0;
+	es.es_Title        = "SDL2 Joystick/GameController";
+	es.es_TextFormat   = "SDL %ld.%ld.%ld -AROS-\n\n%s\n%s";
+	es.es_GadgetFormat = "Ok";
+
+	EasyRequest(window, &es, NULL, SDL_MAJOR_VERSION, SDL_MINOR_VERSION, SDL_PATCHLEVEL, (IPTR)text2, (IPTR)text1);
+}
+
+static int 
+AROS_setenv(const char *name, const char *value, int overwrite)
+{
+	char dummy[2];
+	if (!name || SDL_strlen(name) == 0 || SDL_strchr(name, '=') != NULL || !value) {
+		return (-1);
+	}
+
+	if (!overwrite && GetVar(name, dummy, sizeof(dummy), GVF_GLOBAL_ONLY) != -1) {
+		return 0;
+	}
+	
+	if (SDL_strlen(value) > 0)
+	{		
+		if (!SetVar(name, value, -1, LV_VAR | GVF_GLOBAL_ONLY | GVF_SAVE_VAR)) 
+			return -1;
+	
+	} else {
+		DeleteVar(name, LV_VAR | GVF_GLOBAL_ONLY | GVF_SAVE_VAR);
+	}
+
+	return 0;
+}
+
+static void
+AROS_Priority(ULONG prio)
+{
+	SDL_ThreadPriority Priority = prio ? SDL_THREAD_PRIORITY_LOW : SDL_THREAD_PRIORITY_NORMAL;
+	SDL_SetThreadPriority(Priority);
+	AROS_setenv("SDL_THREAD_PRIORITY_POLICY", (prio ? "-1" : "0"), SDL_TRUE);
+}
+
+void 
+AROS_GlobalMenu(struct Menu * mymenu, UWORD menu, UWORD item, UWORD sub, UWORD check)
+{
+	struct MenuItem *subitem;
+	subitem = ItemAddress(mymenu, FULLMENUNUM(menu, item, sub));
+	if (subitem) {
+		if (check)
+			subitem->Flags |= CHECKED;
+		else
+			subitem->Flags &= ~CHECKED;
+	}
+}
+
+static void
+AROS_HandleMenu(_THIS, struct IntuiMessage *m)
+{
+    SDL_WindowData *data = (SDL_WindowData *)m->IDCMPWindow->UserData;
+    if (data->win) {
+        if (data->menu) {
+            struct MenuItem *item = ItemAddress(data->menu, m->Code);
+            if (item) {
+                switch ((IPTR)GTMENUITEM_USERDATA(item)) {
+                case MID_ABOUT:
+                    AROS_AboutSDL(data->win);
+                    break;
+                case MID_QUIT:
+                    SDL_SendWindowEvent(data->window, SDL_WINDOWEVENT_CLOSE, 0, 0);
+                    break;
+                case MID_HIDE:
+                    AROS_HideApp(_this, TRUE);
+                    break;
+                case MID_MUTE:
+                    AHI_Mute(item->Flags & CHECKED);
+                    break;
+                case MID_PRIORITY:
+                    AROS_Priority(item->Flags & CHECKED);
+                    break;
+                case MID_RRAUTO:
+                    AROS_GlobalMenu(data->menu, 1, 3, 1, 0);
+                    AROS_GlobalMenu(data->menu, 1, 3, 2, 0);
+                    SDL_SetHint(SDL_HINT_RENDER_DRIVER, "");
+                    AROS_setenv("SDL_RENDER_DRIVER", "", SDL_TRUE);
+                    break;
+                case MID_RRGL:
+                    AROS_GlobalMenu(data->menu, 1, 3, 0, 0);
+                    AROS_GlobalMenu(data->menu, 1, 3, 2, 0);
+                    SDL_SetHint(SDL_HINT_RENDER_DRIVER, "opengl");
+                    AROS_setenv("SDL_RENDER_DRIVER", "opengl", SDL_TRUE);
+                    break;
+                case MID_RRSOFT:
+                    AROS_GlobalMenu(data->menu, 1, 3, 0, 0);
+                    AROS_GlobalMenu(data->menu, 1, 3, 1, 0);
+                    SDL_SetHint(SDL_HINT_RENDER_DRIVER, "software");
+                    AROS_setenv("SDL_RENDER_DRIVER", "software", SDL_TRUE);
+                    break;
+                case MID_RVAUTO:
+                    AROS_GlobalMenu(data->menu, 1, 4, 1, 0);
+                    AROS_GlobalMenu(data->menu, 1, 4, 2, 0);
+                    SDL_SetHint(SDL_HINT_RENDER_VSYNC, "");
+                    AROS_setenv("SDL_RENDER_VSYNC", "", SDL_TRUE);
+                    break;
+                case MID_RVENABLE:
+                    AROS_GlobalMenu(data->menu, 1, 4, 0, 0);
+                    AROS_GlobalMenu(data->menu, 1, 4, 2, 0);
+                    SDL_SetHint(SDL_HINT_RENDER_VSYNC, "1");
+                    AROS_setenv("SDL_RENDER_VSYNC", "1", SDL_TRUE);
+                    break;
+                case MID_RVDISABLE:
+                    AROS_GlobalMenu(data->menu, 1, 4, 0, 0);
+                    AROS_GlobalMenu(data->menu, 1, 4, 1, 0);
+                    SDL_SetHint(SDL_HINT_RENDER_VSYNC, "0");
+                    AROS_setenv("SDL_RENDER_VSYNC", "0", SDL_TRUE);
+                    break;
+                case MID_AUTO:
+                    AROS_GlobalMenu(data->menu, 1, 5, 1, 0);
+                    AROS_GlobalMenu(data->menu, 1, 5, 2, 0);
+                    SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "");
+                    AROS_setenv("SDL_RENDER_SCALE_QUALITY", "", SDL_TRUE);
+                    break;
+                case MID_NEAREST:
+                    AROS_GlobalMenu(data->menu, 1, 5, 0, 0);
+                    AROS_GlobalMenu(data->menu, 1, 5, 2, 0);
+                    SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "nearest");
+                    AROS_setenv("SDL_RENDER_SCALE_QUALITY", "nearest", SDL_TRUE);
+                    break;
+                case MID_LINEAR:
+                    AROS_GlobalMenu(data->menu, 1, 5, 0, 0);
+                    AROS_GlobalMenu(data->menu, 1, 5, 1, 0);
+                    SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "linear");
+                    AROS_setenv("SDL_RENDER_SCALE_QUALITY", "linear", SDL_TRUE);
+                    break;
+                case MID_LAUTO:
+                    AROS_GlobalMenu(data->menu, 1, 6, 1, 0);
+                    AROS_GlobalMenu(data->menu, 1, 6, 2, 0);
+                    SDL_SetHint(SDL_HINT_RENDER_LOGICAL_SIZE_MODE, "");
+                    AROS_setenv("SDL_RENDER_LOGICAL_SIZE_MODE", "", SDL_TRUE);
+                    break;
+                case MID_LLETTER:
+                    AROS_GlobalMenu(data->menu, 1, 6, 0, 0);
+                    AROS_GlobalMenu(data->menu, 1, 6, 2, 0);
+                    SDL_SetHint(SDL_HINT_RENDER_LOGICAL_SIZE_MODE, "0");
+                    AROS_setenv("SDL_RENDER_LOGICAL_SIZE_MODE", "0", SDL_TRUE);
+                    break;
+                case MID_LOVERS:
+                    AROS_GlobalMenu(data->menu, 1, 6, 0, 0);
+                    AROS_GlobalMenu(data->menu, 1, 6, 1, 0);
+                    SDL_SetHint(SDL_HINT_RENDER_LOGICAL_SIZE_MODE, "1");
+                    AROS_setenv("SDL_RENDER_LOGICAL_SIZE_MODE", "1", SDL_TRUE);
+                    break;
+                case MID_BAUTO:
+                    AROS_GlobalMenu(data->menu, 1, 7, 1, 0);
+                    AROS_GlobalMenu(data->menu, 1, 7, 2, 0);
+                    SDL_SetHint(SDL_HINT_RENDER_BATCHING, "");
+                    AROS_setenv("SDL_RENDER_BATCHING", "", SDL_TRUE);
+                    break;
+                case MID_BENABLE:
+                    AROS_GlobalMenu(data->menu, 1, 7, 0, 0);
+                    AROS_GlobalMenu(data->menu, 1, 7, 2, 0);
+                    SDL_SetHint(SDL_HINT_RENDER_BATCHING, "0");
+                    AROS_setenv("SDL_RENDER_BATCHING", "0", SDL_TRUE);
+                    break;
+                case MID_BDISABLE:
+                    AROS_GlobalMenu(data->menu, 1, 7, 0, 0);
+                    AROS_GlobalMenu(data->menu, 1, 7, 1, 0);
+                    SDL_SetHint(SDL_HINT_RENDER_BATCHING, "1");
+                    AROS_setenv("SDL_RENDER_BATCHING", "1", SDL_TRUE);
+                    break;
+                case MID_MDEF:
+                    AROS_GlobalMenu(data->menu, 1, 8, 1, 0);
+                    AROS_GlobalMenu(data->menu, 1, 8, 2, 0);
+                    AROS_GlobalMenu(data->menu, 1, 8, 3, 0);
+                    SDL_SetHint(SDL_HINT_RENDER_LINE_METHOD, "");
+                    AROS_setenv("SDL_RENDER_LINE_METHOD", "", SDL_TRUE);
+                    break;
+                case MID_MPOINT:
+                    AROS_GlobalMenu(data->menu, 1, 8, 0, 0);
+                    AROS_GlobalMenu(data->menu, 1, 8, 2, 0);
+                    AROS_GlobalMenu(data->menu, 1, 8, 3, 0);
+                    SDL_SetHint(SDL_HINT_RENDER_LINE_METHOD, "1");
+                    AROS_setenv("SDL_RENDER_LINE_METHOD", "1", SDL_TRUE);
+                    break;
+                case MID_MLINE:
+                    AROS_GlobalMenu(data->menu, 1, 8, 0, 0);
+                    AROS_GlobalMenu(data->menu, 1, 8, 1, 0);
+                    AROS_GlobalMenu(data->menu, 1, 8, 3, 0);
+                    SDL_SetHint(SDL_HINT_RENDER_LINE_METHOD, "2");
+                    AROS_setenv("SDL_RENDER_LINE_METHOD", "2", SDL_TRUE);
+                    break;
+                case MID_MGEO:
+                    AROS_GlobalMenu(data->menu, 1, 8, 0, 0);
+                    AROS_GlobalMenu(data->menu, 1, 8, 1, 0);
+                    AROS_GlobalMenu(data->menu, 1, 8, 2, 0);
+                    SDL_SetHint(SDL_HINT_RENDER_LINE_METHOD, "3");
+                    AROS_setenv("SDL_RENDER_LINE_METHOD", "3", SDL_TRUE);
+                    break;
+                case MID_SHADERS_AUTO:
+                    AROS_GlobalMenu(data->menu, 1, 9, 1, 0);
+                    AROS_GlobalMenu(data->menu, 1, 9, 2, 0);
+                    SDL_SetHint(SDL_HINT_RENDER_BATCHING, "");
+                    AROS_setenv("SDL_RENDER_OPENGL_SHADERS", "", SDL_TRUE);
+                    break;
+                case MID_SHADERS_ENABLE:
+                    AROS_GlobalMenu(data->menu, 1, 9, 0, 0);
+                    AROS_GlobalMenu(data->menu, 1, 9, 2, 0);
+                    SDL_SetHint(SDL_HINT_RENDER_OPENGL_SHADERS, "1");
+                    AROS_setenv("SDL_RENDER_OPENGL_SHADERS", "1", SDL_TRUE);
+                    break;
+                case MID_SHADERS_DISABLE:
+                    AROS_GlobalMenu(data->menu, 1, 9, 0, 0);
+                    AROS_GlobalMenu(data->menu, 1, 9, 1, 0);
+                    SDL_SetHint(SDL_HINT_RENDER_OPENGL_SHADERS, "0");
+                    AROS_setenv("SDL_RENDER_OPENGL_SHADERS", "0", SDL_TRUE);
+                    break;
+                case MID_JOYSTICK:
+                    AROS_Joystick(data->win);
+                    break;
+                case MID_ABOUTSYS:
+                    AROS_AboutSystem(data->win);
+                default:
+                    break;
+                }
+            }
+        }
+    }
+
+}
+
+static void
+AROS_DispatchEvent(_THIS, struct IntuiMessage *m)
+{
+    //D(bug("[SDL2:arosevt] %s: \n", __func__));
+    SDL_WindowData *data = (SDL_WindowData *)m->IDCMPWindow->UserData;
+
+    switch (m->Class) {
+    case IDCMP_MENUPICK:
+        AROS_HandleMenu(_this, m);
+        break;
+
+    case IDCMP_REFRESHWINDOW:
+        BeginRefresh(m->IDCMPWindow);
+        SDL_SendWindowEvent(data->window, SDL_WINDOWEVENT_EXPOSED, 0, 0);
+        EndRefresh(m->IDCMPWindow, TRUE);
+        break;
+
+    case IDCMP_CLOSEWINDOW:
+        SDL_SendWindowEvent(data->window, SDL_WINDOWEVENT_CLOSE, 0, 0);
+        break;
+
+    case IDCMP_MOUSEMOVE:
+        AROS_MouseMove(_this, m, data);
+        break;
+
+    case IDCMP_MOUSEBUTTONS:
+        AROS_DispatchMouseButtons(_this, m, data);
+        break;
+
+    case IDCMP_RAWKEY:
+        AROS_DispatchRawKey(_this, m, data);
+        break;
+
+    case IDCMP_ACTIVEWINDOW:
+        AROS_HandleActivation(_this, m, SDL_TRUE);
+        break;
+
+    case IDCMP_INACTIVEWINDOW:
+        AROS_HandleActivation(_this, m, SDL_FALSE);
+        break;
+
+    case IDCMP_CHANGEWINDOW:
+        AROS_ChangeWindow(_this, m, data);
+        break;
+
+    case IDCMP_GADGETUP:
+        AROS_GadgetEvent(_this, m);
+        break;
+
+    default:
+        break;
+    }
+}
+
+static void
+AROS_CheckBrokerMsg(_THIS)
+{
+	SDL_VideoData *data = (SDL_VideoData *) _this->driverdata;
+	CxMsg *msg;
+
+	while ((msg = (CxMsg *)GetMsg(&data->BrokerPort))) {
+		size_t id = CxMsgID(msg);
+		size_t tp = CxMsgType(msg);
+
+		D(bug("[SDL2:arosevt] %s: check CxMsg\n", __func__));
+
+		ReplyMsg((APTR)msg);
+
+		if (tp == CXM_COMMAND) {
+			switch (id) {
+				case CXCMD_KILL:
+					SDL_SendAppEvent(SDL_QUIT);
+					break;
+
+				case CXCMD_APPEAR:
+					AROS_ShowApp(_this);
+					break;
+
+				case CXCMD_DISAPPEAR:
+					AROS_HideApp(_this, TRUE);
+					break;
+			}
+		}
+	}
+}
+
+static void
+AROS_CheckScreenEvent(_THIS)
+{
+	SDL_VideoData *data = (SDL_VideoData *) _this->driverdata;
+
+#if !defined(__AROS__)
+	for (;;) {
+		struct ScreenNotifyMessage *snm;
+
+		while ((snm = (struct ScreenNotifyMessage *)GetMsg(&data->ScreenNotifyPort)) != NULL) {
+			D(bug("[SDL2:arosevt] %s: check ScreenNotifyMessage\n", __func__));
+
+			switch ((size_t)snm->snm_Value) {
+				case FALSE:
+					AROS_HideApp(_this, FALSE);
+					break;
+
+				case TRUE:
+					AROS_ShowApp(_this);
+					break;
+			}
+		}
+
+		if (data->WScreen)
+			break;
+
+		WaitPort(&data->ScreenNotifyPort);
+	}
+#endif
+}
+
+static void
+AROS_CheckWBEvents(_THIS)
+{
+	SDL_VideoData *data = (SDL_VideoData *) _this->driverdata;
+	struct AppMessage *msg;
+	
+	while ((msg = (struct AppMessage *)GetMsg(&data->WBPort)) != NULL) {
+		D(bug("[SDL2:arosevt] %s: check AppMessage\n", __func__));
+
+		switch (msg->am_Type) {
+			case AMTYPE_APPWINDOW: 
+				{
+				    SDL_Window *window = (SDL_Window *)msg->am_UserData;
+					char filename[1024];
+					struct WBArg *argptr = msg->am_ArgList;
+				    for (int i = 0; i < msg->am_NumArgs; i++) {
+						if (argptr->wa_Lock) {
+							NameFromLock(argptr->wa_Lock, filename, 1024);
+							AddPart(filename, argptr->wa_Name, 1024);
+
+							D(bug("[SDL2:arosevt] %s: SDL_SendDropfile : '%s'\n", __func__, filename));
+							SDL_SendDropFile(window, filename);
+							argptr++;
+						}
+					}
+					SDL_SendDropComplete(window);
+                    SDL_RaiseWindow(window);
+				}
+				break;
+			case AMTYPE_APPICON:
+				AROS_ShowApp(_this);
+				break;
+			default:
+				//D(bug("[SDL2:arosevt] %s: Unknown AppMsg %d %p\n", __func__, msg->am_Type, (APTR)msg->am_UserData));
+				break;
+		}
+
+	}
+}
+
+void
+AROS_PumpEvents(_THIS)
+{
+    SDL_VideoData *data = (SDL_VideoData *)_this->driverdata;
+    struct IntuiMessage *m;
+
+    BOOL check_mousecoord = FALSE;
+    size_t sigs = SetSignal(0, data->ScrNotifySig | data->BrokerSig | data->WBSig | data->WinSig | SIGBREAKF_CTRL_C);
+
+    if (sigs & data->WinSig) {
+        SDL_WindowData *wdata = NULL;
+        while ((m = (struct IntuiMessage *)GetMsg(&data->WinPort))) {
+            wdata = (SDL_WindowData *)m->IDCMPWindow->UserData;
+            if (m->Class == IDCMP_MOUSEMOVE && !SDL_GetRelativeMouseMode())
+                check_mousecoord = TRUE;
+
+            AROS_DispatchEvent(_this, m);
+            ReplyMsg((struct Message *)m);
+        }
+
+        if (wdata && check_mousecoord && wdata->win) {
+            struct Window *w = wdata->win;
+            struct Screen *s = w->WScreen;
+            if (s) {
+                LONG mx = s->MouseX;
+                LONG my = s->MouseY;
+                LONG ws = w->LeftEdge + w->BorderLeft;
+                LONG wy = w->TopEdge + w->BorderTop;
+                LONG wx2 = w->LeftEdge + w->Width - w->BorderRight;
+                LONG wy2 = w->TopEdge + w->Height - w->BorderBottom;
+                if (mx >= ws && my >= wy && mx <= wx2 && my <= wy2) {
+                    struct TagItem winPtrTags[] = {
+                        { WA_Pointer,   0       },
+                        { TAG_DONE,   0       },
+                        { TAG_DONE,     0       }
+                    };
+
+                    w->Flags |= WFLG_RMBTRAP;
+
+                    if (data->CurrentPointer) {
+                        if (!IS_SYSTEM_CURSOR(data->CurrentPointer)) {
+                            SDL_AROSCursor *ac = (SDL_AROSCursor *)data->CurrentPointer;
+                            if (ac->Pointer.ptrclassobj)
+                                winPtrTags[0].ti_Data = (IPTR)ac->Pointer.ptrclassobj;
+                        } else {
+                            if ((((IPTR)data->CurrentPointer->driverdata) == SDL_SYSTEM_CURSOR_WAIT) ||
+                                (((IPTR)data->CurrentPointer->driverdata) == SDL_SYSTEM_CURSOR_WAITARROW)) {
+                                winPtrTags[1].ti_Tag = WA_BusyPointer;
+                                winPtrTags[1].ti_Data = TRUE;
+                            } else {
+                                if (((IPTR)data->CurrentPointer->driverdata) != SDL_SYSTEM_CURSOR_ARROW) {
+                                    D(bug("[SDL2:arosevt] %s: (currently) unhandled cursor type %u\n", __func__, ((IPTR)data->CurrentPointer->driverdata)));
+                                }
+                            }
+                        }
+                    } else {
+                        if (data->BlankPtrObj) {
+                            D(bug("[SDL2:arosevt] %s: setting blank cursor\n", __func__));
+                            winPtrTags[0].ti_Data = (IPTR)data->BlankPtrObj;
+                        }
+                    }
+                    SetWindowPointerA(w, winPtrTags);
+                } else {
+                    w->Flags &= ~WFLG_RMBTRAP;
+                    ClearPointer(w);
+                }
+            }
+        }
+    }
+
+    if (sigs & data->ScrNotifySig && data->ScreenNotifyHandle)
+        AROS_CheckScreenEvent(_this);
+
+    if (sigs & data->BrokerSig)
+        AROS_CheckBrokerMsg(_this);
+
+    if (sigs & data->WBSig)
+        AROS_CheckWBEvents(_this);
+
+    if (sigs & SIGBREAKF_CTRL_C)
+        SDL_SendAppEvent(SDL_QUIT);
+}
diff -ruN SDL2-2.32.8/src/video/aros/SDL_arosevents.h SDL2-2.32.8.aros/src/video/aros/SDL_arosevents.h
--- SDL2-2.32.8/src/video/aros/SDL_arosevents.h	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/video/aros/SDL_arosevents.h	2025-07-28 18:19:36.534462256 +0000
@@ -0,0 +1,29 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifndef _SDL_arosevents_h
+#define _SDL_arosevents_h
+
+extern void AROS_PumpEvents(_THIS);
+extern void AROS_GlobalMenu(struct Menu *mymenu, UWORD menu, UWORD item, UWORD sub, UWORD check);
+
+#endif /* _SDL_arosevents_h */
diff -ruN SDL2-2.32.8/src/video/aros/SDL_arosframebuffer.c SDL2-2.32.8.aros/src/video/aros/SDL_arosframebuffer.c
--- SDL2-2.32.8/src/video/aros/SDL_arosframebuffer.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/video/aros/SDL_arosframebuffer.c	2025-08-04 17:26:42.572790303 +0000
@@ -0,0 +1,156 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2025 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+//#define DEBUG 1
+#include <aros/debug.h>
+
+#define __NOLIBBASE__
+
+#include "../../SDL_internal.h"
+
+#include "SDL_arosvideo.h"
+
+#include <cybergraphx/cybergraphics.h>
+#include <intuition/intuition.h>
+#include <proto/cybergraphics.h>
+#include <graphics/rpattr.h>
+#include <proto/graphics.h>
+
+#ifndef MIN
+#   define MIN(x,y) ((x)<(y)?(x):(y))
+#endif
+
+extern struct Library *GfxBase;
+extern struct Library *CyberGfxBase;
+
+void
+AROS_DestroyWindowFramebuffer(_THIS, SDL_Window * window)
+{
+	D(bug("[SDL2:arosfb] %s()\n", __func__));
+
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+	if (data->bitmap) {
+        FreeBitMap(data->bitmap);
+        data->bitmap = NULL;
+    }
+    if (data->memfb) {
+        FreeVec(data->memfb);
+        data->memfb = NULL;
+    }
+}
+
+int
+AROS_CreateWindowFramebuffer(_THIS, SDL_Window * window, Uint32 * format,
+                            void ** pixels, int *pitch)
+{
+	D(bug("[SDL2:arosfb] %s()\n", __func__));
+
+	APTR lock;
+    APTR base_address;
+    Uint32 bytes_per_row;
+
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+    if (data->bitmap) {
+		D(bug("[SDL2:arosfb] %s: freeing existing bitmap @ 0x%p\n", __func__, data->bitmap));
+        FreeBitMap(data->bitmap);
+    }
+    if (data->memfb) {
+        FreeVec(data->memfb);
+        data->memfb = NULL;
+    }
+
+	if (!data->win) {
+		D(bug("[SDL2:arosfb] %s: ERROR: no window ptr\n", __func__));
+        return SDL_SetError("No system window");
+    }
+	
+#if AROS_BIG_ENDIAN
+    *format = SDL_PIXELFORMAT_BGRA8888;
+#else
+    *format = SDL_PIXELFORMAT_ARGB8888;
+#endif
+	struct BitMap * friend_bitmap = data->win->RPort->BitMap;
+	Uint32 depth =  GetBitMapAttr(friend_bitmap, BMA_DEPTH);
+	data->bitmap = AllocBitMap(window->w, window->h, depth, BMF_MINPLANES|BMF_CLEAR, friend_bitmap);
+	if (!data->bitmap) {
+		D(bug("[SDL2:arosfb] %s: ERROR: failed to allocate a bitmap\n", __func__));
+		return SDL_SetError("Failed to allocate bitmap for framebuffer");
+	} 
+		
+	D("[SDL2:arosfb] %s: Allocate bitmap %d x %d x %d for framebuffer\n", __func__, window->w, window->h, depth);
+	lock = LockBitMapTags(
+        data->bitmap,
+        LBMI_BASEADDRESS, &base_address,
+        LBMI_BYTESPERROW, &bytes_per_row,
+        TAG_DONE);
+
+    if (lock) {
+        *pixels = base_address;
+        *pitch = bytes_per_row;
+
+        UnLockBitMap(lock);
+    } else {
+		D(bug("[SDL2:arosfb] %s: ERROR: failed to lock the bitmap\n", __func__));
+
+        FreeBitMap(data->bitmap);
+        data->bitmap = NULL;
+        data->memfb = AllocVec(window->w * window->h * 4, MEMF_CLEAR);
+        *pixels = data->memfb;
+        *pitch = window->w * 4;
+        if (*pixels == NULL)
+            return SDL_SetError("Failed to lock framebuffer bitmap");
+        return 0;
+    }
+
+	D(bug("[SDL2:arosfb] %s: done\n", __func__));
+
+	return 0;
+}
+
+int
+AROS_UpdateWindowFramebuffer(_THIS, SDL_Window * window, const SDL_Rect * rects, int numrects)
+{
+	D(bug("[SDL2:arosfb] %s()\n", __func__));
+
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+	if (!data->__AGLCtx)
+		if ((data->bitmap || data->memfb) && data->win) {
+			
+			const struct IBox windowBox = {
+					data->win->BorderLeft,
+					data->win->BorderTop,
+					data->win->Width - data->win->BorderLeft - data->win->BorderRight,
+					data->win->Height - data->win->BorderTop - data->win->BorderBottom };
+			
+			for (int i = 0; i < numrects; ++i) {
+				const SDL_Rect * r = &rects[i];
+				int dx = r->x + windowBox.Left;
+				int dy = r->y + windowBox.Top;
+				int w =  MIN(r->w, windowBox.Width);
+				int h = MIN(r->h, windowBox.Height);
+				if (data->bitmap)
+					BltBitMapRastPort(data->bitmap,  r->x, r->y, data->win->RPort, dx, dy, w, h, 0xc0);
+				else if (data->memfb)
+					WritePixelArray(data->memfb, r->x, r->y, window->w * 4, data->win->RPort, dx, dy, w, h, RECTFMT_BGRA32);
+			}
+		}
+	return 0;
+}
diff -ruN SDL2-2.32.8/src/video/aros/SDL_arosframebuffer.h SDL2-2.32.8.aros/src/video/aros/SDL_arosframebuffer.h
--- SDL2-2.32.8/src/video/aros/SDL_arosframebuffer.h	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/video/aros/SDL_arosframebuffer.h	2025-07-28 18:12:17.694941784 +0000
@@ -0,0 +1,30 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifndef _SDL_arosframebuffer_h
+#define _SDL_arosframebuffer_h
+
+extern int AROS_CreateWindowFramebuffer(_THIS, SDL_Window * window, Uint32 * format, void ** pixels, int *pitch);
+extern int AROS_UpdateWindowFramebuffer(_THIS, SDL_Window * window, const SDL_Rect * rects, int numrects);
+extern void AROS_DestroyWindowFramebuffer(_THIS, SDL_Window * window);
+
+#endif /* _SDL_arosframebuffer_h */
diff -ruN SDL2-2.32.8/src/video/aros/SDL_aroskeyboard.c SDL2-2.32.8.aros/src/video/aros/SDL_aroskeyboard.c
--- SDL2-2.32.8/src/video/aros/SDL_aroskeyboard.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/video/aros/SDL_aroskeyboard.c	2025-07-29 12:10:00.333399776 +0000
@@ -0,0 +1,92 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+//#define DEBUG 1
+#include <aros/debug.h>
+
+#define __NOLIBBASE__
+
+#include "../../SDL_internal.h"
+
+#include "../SDL_sysvideo.h"
+#include "../../events/SDL_keyboard_c.h"
+#include "../../events/scancodes_amigaos.h"
+
+#include <proto/keymap.h>
+
+extern struct Library *KeymapBase;
+
+static SDL_Keycode AROS_MapRawKey(UWORD code)
+{
+    struct InputEvent ie;
+    char buffer[2] = {0, 0};
+
+    ie.ie_Class = IECLASS_RAWKEY;
+    ie.ie_SubClass = 0;
+    ie.ie_Code = code;
+    ie.ie_Qualifier = 0;
+    ie.ie_EventAddress = NULL;
+
+    const WORD res = MapRawKey(&ie, buffer, sizeof(buffer), NULL);
+    if (res == 1)
+    {
+        return buffer[0];
+    }
+
+	D(bug("[SDL2:aroskb] %s: %u->%d\n", __func__, code, res));
+
+    return 0;
+}
+
+static void AROS_UpdateKeymap(_THIS)
+{
+    SDL_Keycode keymap[SDL_NUM_SCANCODES];
+
+    SDL_GetDefaultKeymap(keymap);
+
+    for (int i = 0; i < SDL_arraysize(amigaos_scancode_table); i++) {
+        /* Make sure this scancode is a valid character scancode */
+        const SDL_Scancode scancode  = amigaos_scancode_table[i];
+        if (scancode == SDL_SCANCODE_UNKNOWN)
+            continue;
+
+        /* If this key is one of the non-mappable keys, ignore it */
+        /* Don't allow the number keys right above the qwerty row to translate or the top left key (grave/backquote) */
+        /* Not mapping numbers fixes the French layout, giving numeric keycodes for the number keys, which is the expected behavior */
+        if ((keymap[scancode] & SDLK_SCANCODE_MASK) || scancode == SDL_SCANCODE_GRAVE) 
+            continue;
+
+        keymap[scancode] = AROS_MapRawKey(i);
+    }
+
+    SDL_SetKeymap(0, keymap, SDL_NUM_SCANCODES, SDL_FALSE);
+}
+
+void AROS_InitKeyboard(_THIS)
+{
+    AROS_UpdateKeymap(_this);
+  
+    SDL_SetScancodeName(SDL_SCANCODE_APPLICATION, "Menu");
+    SDL_SetScancodeName(SDL_SCANCODE_LGUI, "Left Command");
+    SDL_SetScancodeName(SDL_SCANCODE_RGUI, "Right Command");
+	//SDL_SetScancodeName(SDL_SCANCODE_LCTRL, "Control");
+
+}
diff -ruN SDL2-2.32.8/src/video/aros/SDL_aroskeyboard.h SDL2-2.32.8.aros/src/video/aros/SDL_aroskeyboard.h
--- SDL2-2.32.8/src/video/aros/SDL_aroskeyboard.h	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/video/aros/SDL_aroskeyboard.h	2025-07-28 18:28:38.729149009 +0000
@@ -0,0 +1,28 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifndef _SDL_aroskeyboard_h
+#define _SDL_aroskeyboard_h
+
+extern void AROS_InitKeyboard(_THIS);
+
+#endif /* _SDL_aroskeyboard_h */
diff -ruN SDL2-2.32.8/src/video/aros/SDL_arosmessagebox.c SDL2-2.32.8.aros/src/video/aros/SDL_arosmessagebox.c
--- SDL2-2.32.8/src/video/aros/SDL_arosmessagebox.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/video/aros/SDL_arosmessagebox.c	2025-08-04 17:11:26.948791539 +0000
@@ -0,0 +1,97 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+//#define DEBUG 1
+#include <aros/debug.h>
+
+#define __NOLIBBASE__
+
+#include "../../SDL_internal.h"
+
+#include "SDL_messagebox.h"
+#include "../SDL_sysvideo.h"
+#include "../../misc/aros/SDL_misc.h"
+
+#include <proto/exec.h>
+#include <proto/muimaster.h>
+
+int
+AROS_ShowMessageBox(const SDL_MessageBoxData *mbd, int *buttonid)
+{
+	struct Library *MUIMasterBase = OpenLibrary("muimaster.library", 0);
+	int rc = -1;
+
+	D(bug("[SDL2:arosmb] %s()\n", __func__));
+
+	if (MUIMasterBase) {
+		const char *title = NULL;
+        title = AROS_ConvertUTF8Text(mbd->title);
+        if (title) {
+            const char *message = NULL;
+            message = AROS_ConvertUTF8Text(mbd->message);
+            if (message) {
+                size_t i, tlen = 1024;
+                char *btxt;
+
+                btxt = SDL_malloc(tlen);
+
+                if (btxt) {
+                    char *buf = btxt;
+
+                    for (i = 0; i < mbd->numbuttons; i++) {
+                        if (i > 0)
+                            *buf++ = '|';
+
+                        if (mbd->buttons[i].flags & SDL_MESSAGEBOX_BUTTON_RETURNKEY_DEFAULT)
+                            *buf++ = '*';
+
+#if !defined(__AROS__)
+                        buf += ConvertTagList((APTR)mbd->buttons[i].text, -1, buf, -1, MIBENUM_UTF_8, MIBENUM_SYSTEM, NULL);
+#else
+                        strcpy(buf, mbd->buttons[i].text);
+                        buf += strlen(mbd->buttons[i].text);
+#endif
+                    }
+
+                    *buf = '\0';
+
+                    rc = MUI_RequestA(NULL, NULL, 0, title == NULL ? "SDL2" : title, btxt, message, NULL);
+
+                    if (rc == 0)
+                        rc = mbd->numbuttons - 1;
+                    else
+                        rc -= 1;
+
+                    *buttonid = mbd->buttons[rc].buttonid;
+
+                    SDL_free(btxt);
+                    rc = 0;
+                }
+                SDL_free(message);
+            }
+            SDL_free(title);
+        }
+
+		CloseLibrary(MUIMasterBase);
+	}
+
+	return rc;
+}
diff -ruN SDL2-2.32.8/src/video/aros/SDL_arosmessagebox.h SDL2-2.32.8.aros/src/video/aros/SDL_arosmessagebox.h
--- SDL2-2.32.8/src/video/aros/SDL_arosmessagebox.h	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/video/aros/SDL_arosmessagebox.h	2025-07-28 18:25:11.655177990 +0000
@@ -0,0 +1,28 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifndef _SDL_arosmessagebox_h
+#define _SDL_arosmessagebox_h
+
+extern int AROS_ShowMessageBox(const SDL_MessageBoxData *mbd, int *buttonid);
+
+#endif /* _SDL_arosmessagebox_h */
diff -ruN SDL2-2.32.8/src/video/aros/SDL_arosmodes.c SDL2-2.32.8.aros/src/video/aros/SDL_arosmodes.c
--- SDL2-2.32.8/src/video/aros/SDL_arosmodes.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/video/aros/SDL_arosmodes.c	2025-08-04 17:15:50.112794155 +0000
@@ -0,0 +1,490 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+//#define DEBUG 1
+#include <aros/debug.h>
+
+#define __NOLIBBASE__
+
+#include "../../SDL_internal.h"
+
+#include "SDL_arosmodes.h"
+#include "SDL_arosvideo.h"
+
+#include <aros/cpu.h>
+
+#include <cybergraphx/cybergraphics.h>
+#include <intuition/extensions.h>
+#include <intuition/monitorclass.h>
+#include <proto/alib.h>
+#include <proto/cybergraphics.h>
+#include <proto/graphics.h>
+#include <proto/intuition.h>
+#include <proto/exec.h>
+
+extern struct Library *GfxBase;
+extern struct Library *IntuitionBase;
+
+static int
+AROS_GetRefreshRate(struct Screen *s)
+{
+	D(bug("[SDL2:arosmodes] %s()\n", __func__));
+
+    ULONG freq = 60;
+
+    if (s) {
+
+        ULONG modeid = getv(s, SA_DisplayID);
+        APTR handle = FindDisplayInfo(modeid);
+        if (handle) {
+            struct MonitorInfo mi;
+
+            if (GetDisplayInfoData(handle, (UBYTE *)&mi, sizeof(mi), DTAG_MNTR, 0) >= sizeof(mi))
+                if (mi.TotalRows)
+                    freq = (ULONG)(1000000000L / ((FLOAT)mi.TotalColorClocks * 280.0 * (FLOAT)mi.TotalRows / 1000.0) + 5.0);
+        }
+    }
+	D(bug("[SDL2:arosmodes] %s: returning %u\n", __func__, freq));
+	return freq;
+}
+
+static Uint32
+AROS_SDLPixelFormatToDepth(Uint32 pixfmt)
+{
+	switch (pixfmt) {
+		case SDL_PIXELFORMAT_INDEX8:
+			return 8;
+
+		case SDL_PIXELFORMAT_RGB555:
+			return 15;
+
+		case SDL_PIXELFORMAT_RGB565:
+		case SDL_PIXELFORMAT_BGR565:
+			return 16;
+
+		case SDL_PIXELFORMAT_RGB888:
+		case SDL_PIXELFORMAT_BGR888:
+			return 24;
+
+		default:
+		case SDL_PIXELFORMAT_ABGR8888:
+		case SDL_PIXELFORMAT_ARGB8888:
+		case SDL_PIXELFORMAT_BGRA8888:
+		case SDL_PIXELFORMAT_RGBA8888:
+			return 32;
+	}
+}
+
+static Uint32
+AROS_GetSDLPixelFormat(Uint32 pixfmt, Uint32 default_pixfmt)
+{
+	switch (pixfmt) {
+#if AROS_BIG_ENDIAN
+		case PIXFMT_LUT8   : 
+			return SDL_PIXELFORMAT_INDEX8;
+		case PIXFMT_BGR15:	 // 		case PIXFMT_RGB15X : 
+		case PIXFMT_BGR15PC:	
+			return default_pixfmt; //
+		case PIXFMT_RGB15PC: 
+		case PIXFMT_RGB15  : 
+			return SDL_PIXELFORMAT_RGB555;
+		case PIXFMT_RGB16  : 
+		case PIXFMT_RGB16PC: 
+			return SDL_PIXELFORMAT_RGB565;
+		case PIXFMT_BGR16  : 
+		case PIXFMT_BGR16PC: 
+			return SDL_PIXELFORMAT_BGR565;
+		case PIXFMT_RGB24  : 
+			return SDL_PIXELFORMAT_RGB888;
+		case PIXFMT_BGR24  : 
+			return SDL_PIXELFORMAT_BGR888;
+		case PIXFMT_ARGB32 : 
+			return SDL_PIXELFORMAT_ARGB8888;
+		case PIXFMT_BGRA32 : 
+			return SDL_PIXELFORMAT_BGRA8888;
+		case PIXFMT_RGBA32 : 
+			return SDL_PIXELFORMAT_RGBA8888;
+		default            : 
+			return SDL_PIXELFORMAT_BGRA8888;
+#else
+		case PIXFMT_LUT8   : 
+			return SDL_PIXELFORMAT_INDEX8;
+		case PIXFMT_BGR15:	 // 		case PIXFMT_RGB15X : 
+		case PIXFMT_BGR15PC:	
+			return default_pixfmt; //
+		case PIXFMT_RGB15PC: 
+		case PIXFMT_RGB15  : 
+			return SDL_PIXELFORMAT_BGR555;
+		case PIXFMT_RGB16  : 
+		case PIXFMT_RGB16PC: 
+			return SDL_PIXELFORMAT_BGR565;
+		case PIXFMT_BGR16  : 
+		case PIXFMT_BGR16PC: 
+			return SDL_PIXELFORMAT_RGB565;
+		case PIXFMT_RGB24  : 
+			return SDL_PIXELFORMAT_BGR888;
+		case PIXFMT_BGR24  : 
+			return SDL_PIXELFORMAT_RGB888;
+		case PIXFMT_ARGB32 : 
+			return SDL_PIXELFORMAT_BGRA8888;
+		case PIXFMT_BGRA32 : 
+			return SDL_PIXELFORMAT_ARGB8888;
+		case PIXFMT_RGBA32 : 
+			return SDL_PIXELFORMAT_ABGR8888;
+		default            : 
+			return SDL_PIXELFORMAT_ARGB8888;
+#endif
+	}
+}
+
+#if defined(PIXFMT_RGB15X)
+#define MAX_SDL_PIXEL_FORMATS 15
+#else
+#define MAX_SDL_PIXEL_FORMATS 14
+#endif
+
+static const struct
+{
+	Uint32 PixFmt, NewPixFmt;
+} pixelformats[MAX_SDL_PIXEL_FORMATS] =
+{
+	{ PIXFMT_LUT8, SDL_PIXELFORMAT_INDEX8 },
+	{ PIXFMT_RGB15, SDL_PIXELFORMAT_RGB555 },
+#if defined(PIXFMT_RGB15X)
+	{ PIXFMT_RGB15X, SDL_PIXELFORMAT_RGB555 },
+#endif
+	{ PIXFMT_BGR15, SDL_PIXELFORMAT_BGR555 },
+	{ PIXFMT_RGB15PC, SDL_PIXELFORMAT_RGB555 },
+	{ PIXFMT_BGR15PC, SDL_PIXELFORMAT_BGR555 },
+	{ PIXFMT_RGB16, SDL_PIXELFORMAT_RGB565 },
+	{ PIXFMT_BGR16, SDL_PIXELFORMAT_BGR565 },
+	{ PIXFMT_RGB16PC, SDL_PIXELFORMAT_RGB565 },
+	{ PIXFMT_BGR16PC, SDL_PIXELFORMAT_BGR565 },
+	{ PIXFMT_RGB24, SDL_PIXELFORMAT_RGB888 },
+	{ PIXFMT_BGR24, SDL_PIXELFORMAT_BGR888 },
+	{ PIXFMT_ARGB32, SDL_PIXELFORMAT_ARGB8888 },
+	{ PIXFMT_BGRA32, SDL_PIXELFORMAT_BGRA8888 },
+	{ PIXFMT_RGBA32, SDL_PIXELFORMAT_RGBA8888 },
+};
+
+int
+AROS_InitModes(_THIS)
+{
+	D(bug("[SDL2:arosmodes] %s()\n", __func__));
+
+	Uint32 pixfmt = SDL_PIXELFORMAT_BGRA8888;
+	int width = 1920, height = 1080, dispcount = 0;
+	SDL_VideoDisplay display;
+	SDL_DisplayMode mode;
+	Object **monitors;
+	STRPTR monitorname = NULL;
+	struct Screen *s;
+	APTR mon = NULL;
+
+	SDL_zero(display);
+
+	mode.w = 1920;
+	mode.h = 1080;
+	mode.refresh_rate = 60;
+#if AROS_BIG_ENDIAN
+	mode.format = SDL_PIXELFORMAT_BGRA8888;
+#else
+	mode.format = SDL_PIXELFORMAT_RGBA8888;
+#endif
+	mode.driverdata = NULL;
+
+	s = LockPubScreen(NULL);
+
+	if (s) {
+		SDL_DisplayModeData *modedata;
+
+		// This is not actual view size but virtual screens are so 90s
+		width = s->Width;
+		height = s->Height;
+
+#if AROS_BIG_ENDIAN
+		pixfmt = AROS_GetSDLPixelFormat(getv(s, SA_PixelFormat), SDL_PIXELFORMAT_BGRA8888);
+#else
+		pixfmt = AROS_GetSDLPixelFormat(getv(s, SA_PixelFormat), SDL_PIXELFORMAT_RGBA8888);
+#endif
+		mon = (APTR)getv(s, SA_MonitorObject);
+
+		modedata = SDL_malloc(sizeof(*modedata));
+
+		if (modedata) {
+			modedata->monitor = mon;
+
+			mode.format = pixfmt;
+			mode.w = width;
+			mode.h = height;
+			mode.refresh_rate = (int)AROS_GetRefreshRate(s) / 1000;
+			mode.driverdata = SDL_malloc(4);
+
+			display.desktop_mode = mode;
+			display.current_mode = mode;
+			display.driverdata = modedata;
+			GetAttr(MA_MonitorName, mon, (IPTR *)&monitorname);
+			display.name = monitorname;
+
+			SDL_AddVideoDisplay(&display, SDL_FALSE);
+			dispcount++;
+
+			mode.driverdata = NULL;
+
+			
+			D(bug("[SDL2:arosmodes] %s:  Added Workbench screen - monitor @ 0x%p - name='%s'\n", __func__, mon, display.name));
+		}
+		UnlockPubScreen(NULL, s);
+	}
+
+	// Add other monitors (not desktop)
+	if ((monitors = GetMonitorList(NULL))) {
+		APTR m;
+		int i, j;
+
+		for (i = 0; (m = monitors[i]); i++) {
+			
+			if (m != mon) {
+				D(bug("[SDL2:arosmodes] %s: Adding additional monitor @ 0x%p\n", __func__, monitors[i]));
+
+				SDL_DisplayModeData *modedata = SDL_malloc(sizeof(*modedata));
+
+				if (modedata) {
+					ULONG *fmt = (ULONG *)getv(m, MA_PixelFormats);
+
+					for (j = MAX_SDL_PIXEL_FORMATS - 1; j >= 0; j--) {
+						pixfmt = pixelformats[j].PixFmt;
+
+						if (fmt[pixfmt]) {
+							mode.format = pixelformats[j].NewPixFmt;
+							
+							D(bug("[SDL2:arosmodes] %s: Add %ld/%ld pixfmt %ld\n", __func__, mode.w, mode.h, mode.format));
+							break;
+						}
+					}
+
+					modedata->monitor = m;
+
+					display.desktop_mode = mode;
+					display.current_mode = mode;
+					display.driverdata = modedata;
+					GetAttr(MA_MonitorName, m, (IPTR *)&monitorname);
+					display.name = monitorname;
+					
+					D(bug("[SDL2:arosmodes] %s: Add video display '%s'\n", __func__, display.name));
+
+					SDL_AddVideoDisplay(&display, SDL_FALSE);
+					dispcount++;
+				}
+			}
+		}
+
+		FreeMonitorList(monitors);
+	}
+
+	return dispcount > 0 ? 0 : -1;
+}
+
+void
+AROS_GetDisplayModes(_THIS, SDL_VideoDisplay * sdl_display)
+{
+	SDL_DisplayModeData *md = sdl_display->driverdata;
+
+	D(bug("[SDL2:arosmodes] %s()\n", __func__));
+
+	if (md) {
+		Object **modes = NULL;
+#if !defined(__AROS__)
+		modes = GetMonitorModesList(md->monitor, NULL);
+#endif
+		if (modes) {
+			int modei = 0;
+			while (modes[modei]) {
+				SDL_DisplayMode mode = sdl_display->desktop_mode;
+#if !defined(__AROS__)
+				Boopsiobject *amode = modes[modei++];
+#else
+				APTR amode;
+#endif
+				ULONG modeid = INVALID_ID;
+				STRPTR name = NULL;
+				ULONG width = 0;
+				ULONG height = 0;
+				ULONG pixelfmt = PIXFMT_ARGB32;
+#if !defined(__AROS__)
+				GetAttr(MA_Mode_Name, amode, (IPTR *)&name);
+				GetAttr(MA_Mode_ModeID, amode, (IPTR *)&modeid);
+				GetAttr(MA_Mode_Width, amode, (IPTR *)&width);
+				GetAttr(MA_Mode_Height, amode, (IPTR *)&height);
+				GetAttr(MA_Mode_PixelFormat, amode, (IPTR *)&pixelfmt);
+#endif
+				mode.w = width;
+				mode.h = height;
+				float vert = 0, hori = 0;
+#if !defined(__AROS__)
+				DoMethod(amode, MM_Mode_GetRefreshFrequencies, &hori, &vert);
+#endif
+				mode.refresh_rate = (int)hori;
+#if AROS_BIG_ENDIAN
+				mode.format = AROS_GetSDLPixelFormat(pixelfmt, SDL_PIXELFORMAT_BGRA8888);
+#else
+				mode.format = AROS_GetSDLPixelFormat(pixelfmt, SDL_PIXELFORMAT_RGBA8888);
+#endif
+
+				//D("[%s] Mode %s - pixelfmt %ld\n", __func__, name, pixelfmt);
+				mode.driverdata = sdl_display->desktop_mode.driverdata ? SDL_malloc(4) : NULL;
+				SDL_AddDisplayMode(sdl_display, &mode);
+			}
+#if !defined(__AROS__)
+			FreeMonitorModesList(modes);
+#endif
+		}
+	}
+				
+}
+
+int
+AROS_GetScreen(_THIS, BYTE fullscreen, SDL_bool support3d)
+{
+	SDL_VideoData *data = (SDL_VideoData *) _this->driverdata;
+	struct Screen *screen;
+	int use_wb_screen = 0;
+	ULONG openError = 0;
+
+	D(bug("[SDL2:arosmodes] %s()\n", __func__));
+
+	if (!fullscreen && data->ScrMonName == NULL) {
+		data->CustomScreen = NULL;
+		screen = LockPubScreen(NULL);
+		use_wb_screen = 1;
+
+		D(bug("[SDL2:arosmodes] %s: Use WB Screen\n", __func__));
+
+	} else {
+
+		screen = OpenScreenTags(NULL,
+				SA_GammaControl, TRUE,
+				SA_Width, data->ScrWidth,
+				SA_Height, data->ScrHeight,
+				SA_Depth, data->ScrDepth,
+				data->ScrMonName ? SA_MonitorName : TAG_IGNORE , data->ScrMonName,
+				SA_Quiet, TRUE,
+				SA_ShowTitle, FALSE,
+				SA_Title, (IPTR)"SDL2",
+				SA_AdaptSize, TRUE,
+				SA_ErrorCode, (IPTR)&openError,
+				TAG_DONE);
+
+		if (screen)
+			data->CustomScreen = screen;
+	}
+
+	if (screen == NULL) {
+		if (data->ScrMonName != NULL)
+			screen = LockPubScreen("Workbench");
+
+		if (screen == NULL) {
+			switch (openError) {
+            case OSERR_NOMONITOR:
+                SDL_SetError("Monitor for display mode not available");
+                break;
+            case OSERR_NOCHIPS:
+                SDL_SetError("Newer custom chips required");
+                break;
+            case OSERR_NOMEM:
+            case OSERR_NOCHIPMEM:
+                SDL_OutOfMemory();
+                break;
+            case OSERR_PUBNOTUNIQUE:
+                SDL_SetError("Public screen name not unique");
+                break;
+            case OSERR_UNKNOWNMODE:
+            case OSERR_TOODEEP:
+                SDL_SetError("Unknown display mode");
+                break;
+            case OSERR_ATTACHFAIL:
+                SDL_SetError("Attachment failed");
+                break;
+            default:
+				SDL_SetError("Failed to get screen.");
+				break;
+			}
+			return -1;
+		}
+		use_wb_screen = 1;
+	}
+
+	data->WScreen = screen;
+
+#if !defined(__AROS__)
+	if (use_wb_screen) {
+		data->ScreenNotifyHandle = AddWorkbenchClient(&data->ScreenNotifyPort, -20);
+	}
+#endif
+
+	if (data->ScreenSaverSuspendCount) {
+		size_t i;
+
+		for (i = data->ScreenSaverSuspendCount; i > 0; i--)
+			SetAttrs(screen, SA_StopBlanker, TRUE, TAG_DONE);
+	}
+
+	return 0;
+}
+
+int
+AROS_SetDisplayMode(_THIS, SDL_VideoDisplay *display, SDL_DisplayMode *mode)
+{
+	SDL_VideoData *data = (SDL_VideoData *) _this->driverdata;
+
+	D(bug("[SDL2:arosmodes] %s()\n", __func__));
+
+	AROS_CloseWindows(_this);
+	AROS_CloseDisplay(_this);
+
+	data->sdlpixfmt = mode->format;
+	data->ScrMonName = NULL;
+
+	// NULL means non-WB mode
+	data->ScrWidth = mode->w;
+	data->ScrHeight = mode->h;
+	data->ScrDepth = AROS_SDLPixelFormatToDepth(mode->format);
+
+	if (mode->driverdata == NULL) {
+		data->ScrMonName = display->name;
+
+		D(bug("[SDL2:arosmodes] %s: Use monitor %s\n", __func__, data->ScrMonName));
+	}
+
+    return 0;
+}
+
+int
+AROS_GetDisplayBounds(_THIS, SDL_VideoDisplay * display, SDL_Rect * rect)
+{
+	
+	rect->x = 0;
+    rect->y = 0;
+    rect->w = display->current_mode.w;
+    rect->h = display->current_mode.h;
+
+    return 0;
+}
diff -ruN SDL2-2.32.8/src/video/aros/SDL_arosmodes.h SDL2-2.32.8.aros/src/video/aros/SDL_arosmodes.h
--- SDL2-2.32.8/src/video/aros/SDL_arosmodes.h	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/video/aros/SDL_arosmodes.h	2025-07-28 17:58:38.549756245 +0000
@@ -0,0 +1,43 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifndef _SDL_arosmodes_h
+#define _SDL_arosmodes_h
+
+#include "../SDL_sysvideo.h"
+
+#ifndef EXEC_TYPES_H
+#include <exec/types.h>
+#endif
+
+typedef struct
+{
+	APTR monitor;
+} SDL_DisplayModeData;
+
+extern int AROS_InitModes(_THIS);
+extern void AROS_GetDisplayModes(_THIS, SDL_VideoDisplay * sdl_display);
+extern int AROS_SetDisplayMode(_THIS, SDL_VideoDisplay *display, SDL_DisplayMode *mode);
+extern int AROS_GetScreen(_THIS, BYTE FullScreen, SDL_bool support3d);
+extern int AROS_GetDisplayBounds(_THIS, SDL_VideoDisplay * display, SDL_Rect * rect);
+
+#endif /* _SDL_arosmodes_h */
diff -ruN SDL2-2.32.8/src/video/aros/SDL_arosmouse.c SDL2-2.32.8.aros/src/video/aros/SDL_arosmouse.c
--- SDL2-2.32.8/src/video/aros/SDL_arosmouse.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/video/aros/SDL_arosmouse.c	2025-08-11 17:38:43.709907834 +0000
@@ -0,0 +1,375 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+//#define DEBUG 1
+#include <aros/debug.h>
+
+#define __NOLIBBASE__
+
+#include "../../SDL_internal.h"
+
+#include "SDL_arosmouse.h"
+#include "SDL_arosvideo.h"
+
+#include "../../events/SDL_mouse_c.h"
+#include "SDL_hints.h"
+
+#include <cybergraphx/cybergraphics.h>
+#include <devices/input.h>
+#include <intuition/pointerclass.h>
+#include <proto/cybergraphics.h>
+#include <proto/exec.h>
+#include <proto/graphics.h>
+#include <proto/dos.h>
+#include <dos/rdargs.h>
+
+extern struct Library *IntuitionBase;
+extern struct Library *DOSBase;
+extern struct Library *GfxBase;
+extern struct Library *CyberGfxBase;
+
+AROS_GlobalMouseState globalMouseState;
+
+static SDL_Cursor *
+AROS_CreateCursor(SDL_Surface * surface, int hot_x, int hot_y)
+{
+	SDL_AROSCursor *cursor;
+
+	D(bug("[SDL2:arosmouse] %s(0x%p, %d, %d)\n", __func__, surface, hot_x, hot_y));
+
+	cursor = SDL_malloc(sizeof(*cursor));
+	if (cursor) {
+		SDL_AROSCursor *ac = SDL_malloc(sizeof(*ac));
+		struct BitMap *bmp;
+
+		cursor->Cursor.next = NULL;
+		cursor->Cursor.driverdata = &cursor->Pointer;
+		cursor->Pointer.offx = hot_x;
+		cursor->Pointer.offy = hot_y;
+
+		bmp = AllocBitMap(surface->w, surface->h, 32, BMF_MINPLANES | BMF_CLEAR | BMF_SPECIALFMT | SHIFT_PIXFMT(PIXFMT_ARGB32), NULL);
+		if (bmp != NULL) {
+			struct RastPort rp;
+
+			InitRastPort(&rp);
+			rp.BitMap = bmp;
+
+			if (SDL_LockSurface(surface) == 0) {
+				WritePixelArray(surface->pixels, 0, 0, surface->pitch, &rp, 0, 0, surface->w, surface->h, RECTFMT_ARGB);
+				Object *ptrclassobj = NewObject(NULL, POINTERCLASS,
+								POINTERA_BitMap, bmp,
+								POINTERA_XOffset, -hot_x,
+								POINTERA_YOffset, -hot_y,
+								TAG_DONE);
+
+				cursor->Pointer.ptrclassobj = ptrclassobj;
+				D(bug("[SDL2:arosmouse] %s: allocated pointerobject @ 0x%p\n", __func__, cursor->Pointer.ptrclassobj));
+				SDL_UnlockSurface(surface);
+			} else {
+				bug("[SDL2:arosmouse] %s: failed to lock surface\n", __func__);
+			}
+			FreeBitMap(bmp);
+		} else {
+			bug("[SDL2:arosmouse] %s: failed to allocate bitmap\n", __func__);
+			SDL_free(cursor);
+			cursor = NULL;
+			return NULL;
+		}
+	} else {
+		bug("[SDL2:arosmouse] %s: failed to allocate storage\n", __func__);
+	}
+
+	return (cursor) ? &cursor->Cursor : NULL;
+}
+
+static SDL_Cursor *
+AROS_CreateSystemCursor(SDL_SystemCursor id)
+{
+	SDL_Cursor *cursor;
+
+	D(bug("[SDL2:arosmouse] %s(%u)\n", __func__, id));
+
+	cursor = SDL_malloc(sizeof(*cursor));
+	if (cursor) {
+#if !defined(__AROS__)
+		size_t type = POINTERTYPE_NORMAL;
+		cursor->next = NULL;
+		switch (id) {
+			default:
+			case SDL_SYSTEM_CURSOR_ARROW:     type = POINTERTYPE_NORMAL; break;
+			case SDL_SYSTEM_CURSOR_IBEAM:     type = POINTERTYPE_SELECTTEXT; break;
+			case SDL_SYSTEM_CURSOR_WAIT:      type = POINTERTYPE_BUSY; break;
+			case SDL_SYSTEM_CURSOR_CROSSHAIR: type = POINTERTYPE_AIMING; break;
+			case SDL_SYSTEM_CURSOR_WAITARROW: type = POINTERTYPE_WORKING; break;
+			case SDL_SYSTEM_CURSOR_SIZENWSE:  type = POINTERTYPE_DIAGONALRESIZE2; break;
+			case SDL_SYSTEM_CURSOR_SIZENESW:  type = POINTERTYPE_DIAGONALRESIZE1; break;
+			case SDL_SYSTEM_CURSOR_SIZEWE:    type = POINTERTYPE_HORIZONTALRESIZE; break;
+			case SDL_SYSTEM_CURSOR_SIZENS:    type = POINTERTYPE_VERTICALRESIZE; break;
+			case SDL_SYSTEM_CURSOR_SIZEALL:   type = POINTERTYPE_MOVE; break;
+			case SDL_SYSTEM_CURSOR_NO:        type = POINTERTYPE_NOTAVAILABLE; break;
+			case SDL_SYSTEM_CURSOR_HAND:      type = POINTERTYPE_SELECTLINK; break;
+		}
+		cursor->driverdata = (APTR)type;
+#else
+		cursor->next = NULL;
+		cursor->driverdata = (APTR)id;
+#endif
+	} else {
+		SDL_OutOfMemory();
+	}
+
+	return cursor;
+}
+
+static void
+AROS_FreeCursor(SDL_Cursor *cursor)
+{
+	D(bug("[SDL2:arosmouse] %s(0x%p)\n", __func__, cursor));
+
+	if (!IS_SYSTEM_CURSOR(cursor))
+	{
+		SDL_AROSCursor *ac = (SDL_AROSCursor *)cursor;
+		bug("[SDL2:arosmouse] %s: custom cursor (ptr object @ 0x%p)\n", __func__, ac->Pointer.ptrclassobj);
+		if (ac->Pointer.ptrclassobj)
+		{
+			DisposeObject(ac->Pointer.ptrclassobj);
+			ac->Pointer.ptrclassobj = NULL;
+		}
+	}
+
+	SDL_free(cursor);
+}
+
+static int
+AROS_ShowCursor(SDL_Cursor * cursor)
+{
+	SDL_VideoDevice *video = SDL_GetVideoDevice();
+	SDL_VideoData *data = (SDL_VideoData *)video->driverdata;
+
+	D(bug("[SDL2:arosmouse] %s(0x%p)\n", __func__, cursor));
+
+	if (IS_SYSTEM_CURSOR(cursor)) {
+		D(bug("[SDL2:arosmouse] %s: system cursor %u\n", __func__, (cursor) ? (IPTR)cursor->driverdata : 0));
+		if (data->CurrentPointer != cursor) {
+			SDL_WindowData *wd;
+			ForeachNode(&data->windowlist, wd) {
+				if (wd->win) {
+					if (cursor == NULL) {
+						D(bug("[SDL2:arosmouse] %s: blanking cursor for win 0x%p (blank ptrobj @ 0x%p)\n", __func__, wd->win, data->BlankPtrObj));
+						if (data->BlankPtrObj)
+							SetWindowPointer(wd->win, WA_Pointer, (IPTR)data->BlankPtrObj, TAG_DONE);
+					} else {
+						if (((IPTR)cursor->driverdata == SDL_SYSTEM_CURSOR_WAIT) ||
+							((IPTR)cursor->driverdata == SDL_SYSTEM_CURSOR_WAITARROW)) {
+							SetWindowPointer(wd->win, WA_Pointer, 0, WA_BusyPointer, TRUE, TAG_DONE);
+						} else {
+							if ((IPTR)cursor->driverdata != SDL_SYSTEM_CURSOR_ARROW) {
+								D(bug("[SDL2:arosmouse] %s: (currently) unhandled cursor type %u\n", __func__, ((IPTR)cursor->driverdata)));
+							}
+							SetWindowPointer(wd->win, WA_Pointer, 0, TAG_DONE);
+						}
+					}
+                }
+            }
+		}
+	} else {
+		SDL_AROSCursor *ac = (SDL_AROSCursor *)cursor;
+		SDL_WindowData *wd;
+
+		D(bug("[SDL2:arosmouse] %s: custom cursor @ 0x%p\n", __func__, ac));
+
+		ForeachNode(&data->windowlist, wd) {
+            if (wd->win) {
+                if (ac->Pointer.ptrclassobj) {
+					D(bug("[SDL2:arosmouse] %s: calling SetWindowPointer 0x%p\n", __func__, ac->Pointer.ptrclassobj));
+                    SetWindowPointer(wd->win, WA_Pointer, (IPTR)ac->Pointer.ptrclassobj, TAG_DONE);
+				}
+            }
+        }
+	}
+
+	D(bug("[SDL2:arosmouse] %s: setting current cursor to 0x%p\n", __func__, cursor));
+	data->CurrentPointer = cursor;
+
+	return 0;
+}
+
+static void
+AROS_WarpMouse(SDL_Window * window, int x, int y)
+{
+	SDL_WindowData *data = (SDL_WindowData *)window->driverdata;
+	struct Window *win;
+
+	BOOL warpHostPointer;
+	warpHostPointer = !SDL_GetRelativeMouseMode() && (window == SDL_GetMouseFocus());
+
+	if (warpHostPointer) {
+
+		if ((win = data->win)) {
+			struct MsgPort *port;
+			struct IOStdReq *req;
+
+			port = CreateMsgPort();
+			if (port) {
+				req = CreateIORequest(port, sizeof(*req));
+				if (req) {
+					if (OpenDevice("input.device", 0, (struct IORequest *)req, 0) == 0) {
+						struct InputEvent ie = { 0 };
+						struct IEPointerPixel newpos = { 0 };
+
+						newpos.iepp_Screen = win->WScreen;
+						newpos.iepp_Position.X = x + win->BorderLeft + win->LeftEdge;
+						newpos.iepp_Position.Y = y + win->BorderTop + win->TopEdge;
+
+						ie.ie_EventAddress = &newpos;
+						ie.ie_NextEvent = NULL;
+						ie.ie_Class = IECLASS_NEWPOINTERPOS;
+						ie.ie_SubClass = IESUBCLASS_PIXEL;
+						ie.ie_Code = IECODE_NOBUTTON;
+						ie.ie_Qualifier = 0;
+
+						req->io_Data = &ie;
+						req->io_Length = sizeof(ie);
+						req->io_Command = IND_WRITEEVENT;
+
+						DoIO((struct IORequest *)req);
+						CloseDevice((struct IORequest *)req);
+					}
+				}
+
+				DeleteMsgPort(port);
+			}
+		}
+	} else {
+		SDL_SendMouseMotion(window,0, SDL_GetRelativeMouseMode(), x, y);
+	}
+}
+
+static int
+AROS_SetRelativeMouseMode(SDL_bool enabled)
+{
+	D(bug("[SDL2:arosmouse] %s()\n", __func__));
+
+	SDL_VideoDevice *video = SDL_GetVideoDevice();
+	SDL_VideoData *data = (SDL_VideoData *)video->driverdata;
+	SDL_WindowData *wd;
+	size_t or_mask, and_mask;
+
+	if (enabled) {
+		or_mask = IDCMP_DELTAMOVE;
+		and_mask = ~0;
+	} else {
+		or_mask = 0;
+		and_mask = ~IDCMP_DELTAMOVE;
+	}
+
+	ForeachNode(&data->windowlist, wd)
+		if (wd->win)
+			ModifyIDCMP(wd->win, (wd->win->IDCMPFlags | or_mask) & and_mask);
+
+	return 0;
+}
+
+static Uint32
+AROS_GetDoubleClickTimeInMillis(_THIS)
+{
+    Uint32 interval = 500;
+
+    struct RDArgs rda;
+    SDL_memset(&rda, 0, sizeof(rda));
+    rda.RDA_Source.CS_Buffer = (STRPTR)SDL_LoadFile("ENV:sys/mouse.conf", (size_t *)&rda.RDA_Source.CS_Length);
+    if (rda.RDA_Source.CS_Buffer) {
+        IPTR *array[4] = {0};
+        if (ReadArgs("Pointer/K,RMBEmulationQualifier/K,DoubleClickS/N/K,DoubleClickM/N/K,/F", (IPTR *)array, &rda)) {
+			if (array[2] != 0L && array[3] != 0L)
+            	interval = *array[2] * 1000 + *array[3] / 1000;
+
+	    	FreeArgs(&rda);
+        }
+        SDL_free(rda.RDA_Source.CS_Buffer);
+    }
+
+    return interval;
+}
+
+static Uint32
+AROS_GetGlobalMouseState(int *x, int *y)
+{
+    Uint32 buttons = 0;
+
+    if (x) {
+        *x = globalMouseState.x;
+    }
+
+    if (y) {
+        *y = globalMouseState.y;
+    }
+
+    if (globalMouseState.buttonPressed[SDL_BUTTON_LEFT]) {
+        buttons |= SDL_BUTTON_LMASK;
+    }
+
+    if (globalMouseState.buttonPressed[SDL_BUTTON_MIDDLE]) {
+        buttons |= SDL_BUTTON_MMASK;
+    }
+
+    if (globalMouseState.buttonPressed[SDL_BUTTON_RIGHT]) {
+        buttons |= SDL_BUTTON_RMASK;
+    }
+    
+    if (globalMouseState.buttonPressed[SDL_BUTTON_X1]) {
+        buttons |= SDL_BUTTON_X1MASK;
+    }
+
+    return buttons;
+}
+
+void
+AROS_InitMouse(_THIS)
+{
+	SDL_Mouse *mouse = SDL_GetMouse();
+	char buffer[16];
+
+	mouse->CreateCursor = AROS_CreateCursor;
+	mouse->CreateSystemCursor = AROS_CreateSystemCursor;
+	mouse->ShowCursor = AROS_ShowCursor;
+	mouse->FreeCursor = AROS_FreeCursor;
+	mouse->WarpMouse = AROS_WarpMouse;
+	mouse->SetRelativeMouseMode = AROS_SetRelativeMouseMode;
+    mouse->GetGlobalMouseState = AROS_GetGlobalMouseState;
+
+	SDL_SetDefaultCursor(AROS_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW));
+	SDL_SetHint(SDL_HINT_MOUSE_DOUBLE_CLICK_TIME,  SDL_uitoa(AROS_GetDoubleClickTimeInMillis(_this), buffer, 10));
+}
+
+void
+AROS_QuitMouse(_THIS)
+{
+	SDL_Mouse *mouse = SDL_GetMouse();
+
+	D(bug("[SDL2:arosmouse] %s()\n", __func__));
+
+	if ( mouse->def_cursor ) {
+		SDL_free(mouse->def_cursor);
+		mouse->def_cursor = NULL;
+		mouse->cur_cursor = NULL;
+	}
+}
diff -ruN SDL2-2.32.8/src/video/aros/SDL_arosmouse.h SDL2-2.32.8.aros/src/video/aros/SDL_arosmouse.h
--- SDL2-2.32.8/src/video/aros/SDL_arosmouse.h	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/video/aros/SDL_arosmouse.h	2025-08-11 16:08:35.165908881 +0000
@@ -0,0 +1,54 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifndef _SDL_arosmouse_h
+#define _SDL_arosmouse_h
+
+#include "SDL_arosvideo.h"
+
+#include <proto/intuition.h>
+
+#define IS_SYSTEM_CURSOR(cursor) (cursor == NULL || ((IPTR)cursor->driverdata) < SDL_NUM_SYSTEM_CURSORS)
+
+typedef struct
+{
+	Object                      *ptrclassobj;
+	int                         offx, offy;
+} SDL_AROSPointerData;
+
+typedef struct
+{
+	struct SDL_Cursor           Cursor;
+	SDL_AROSPointerData         Pointer;
+} SDL_AROSCursor;
+
+typedef struct
+{
+    int                         x;
+    int                         y;
+    int                         buttonPressed[SDL_BUTTON_X1 + 1];
+} AROS_GlobalMouseState;
+
+extern void AROS_InitMouse(_THIS);
+extern void AROS_QuitMouse(_THIS);
+
+#endif /* _SDL_arosmouse_h */
diff -ruN SDL2-2.32.8/src/video/aros/SDL_arosopengl.c SDL2-2.32.8.aros/src/video/aros/SDL_arosopengl.c
--- SDL2-2.32.8/src/video/aros/SDL_arosopengl.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/video/aros/SDL_arosopengl.c	2025-08-04 19:10:18.512575026 +0000
@@ -0,0 +1,269 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2025 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#include "../../SDL_internal.h"
+
+#if SDL_VIDEO_OPENGL_AGL
+#define SDL_VIDEO_OPENGL_AGL_INTERN
+#define __NOLIBBASE__
+//#define DEBUG 1
+#include <aros/debug.h>
+
+#include "SDL_error.h"
+#include "SDL_syswm.h"
+#include "../SDL_sysvideo.h"
+#include "SDL_arosvideo.h"
+#include "SDL_arosmodes.h"
+#include "SDL_aroswindow.h"
+#include "SDL_arosopengl.h"
+
+#include <proto/exec.h>
+
+#include <proto/intuition.h>
+#include <proto/graphics.h>
+
+extern struct ExecBase *SysBase;
+extern struct Library *GfxBase;
+#define GLBase (_this->gl_data->gldd_GLBase)
+
+int
+AROS_GL_LoadLibrary(_THIS, const char *path)
+{
+	D(
+		bug("[SDL2:arosgl] %s()\n", __func__);
+		if (path)
+			bug("[SDL2:arosgl] %s: path = '%s'\n", __func__, path);
+	)
+
+	if (!GLBase)
+		GLBase = OpenLibrary("gl.library", 20); 
+
+	if (GLBase) {
+		D(bug("[SDL2:arosgl] %s: glABase @ 0x%p\n", __func__, GLBase));
+#if (0)
+			if (SDL2Base->appGLABase)				
+				*SDL2Base->appGLABase = GLBase;	
+#endif
+            _this->gl_config.driver_loaded = 1;
+
+			return 0;
+	} else 
+		SDL_SetError("Failed to open gl.library");
+
+	return -1;
+}
+
+void *
+AROS_GL_GetProcAddress(_THIS, const char *proc)
+{
+	void *func = NULL;
+
+	D(bug("[SDL2:arosgl] %s('%s')\n", __func__, proc));
+
+	if (GLBase) 
+	{
+		func = glAGetProcAddress(proc);
+		if (!func) {
+			SDL_SetError("Couldn't find OpenGL symbol");
+		}
+	}
+	D(bug("[SDL2:arosgl] %s: returning 0x%p\n", __func__, func));
+	return func;
+}
+
+void
+AROS_GL_UnloadLibrary(_THIS)
+{
+	D(bug("[SDL2:arosgl] %s()\n", __func__));
+
+#if (0)
+	if (SDL2Base->appGLABase && *SDL2Base->appGLABase)
+#endif
+	if (GLBase) {
+		D(bug("[SDL2:arosgl] %s: closing glABase @ 0x%p\n", __func__, GLBase));
+		CloseLibrary(GLBase);
+		GLBase = NULL;
+#if (0)
+		*SDL2Base->appGLABase = GLBase;
+#endif
+		_this->gl_config.driver_loaded = 0;
+	}
+}
+
+int
+AROS_GL_MakeCurrent(_THIS, SDL_Window * window, SDL_GLContext context)
+{
+    D(bug("[SDL2:arosgl] %s(0x%p)\n", __func__, context));
+
+    if (window)
+	{
+		if (_this->gl_data->gldd_GLACtx != context)
+		{
+			struct TagItem tags[2];
+			SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+			D(bug("[SDL2:arosgl] %s: attaching ctx to window @ 0x%p\n", __func__, data->win));
+			if ((_this->gl_data->gldd_GLACtx = context) != NULL)
+			{
+				tags[0].ti_Tag = GLA_Window;
+				tags[0].ti_Data = (IPTR)data->win;
+				tags[1].ti_Tag = TAG_DONE;
+				glASetRast(context, tags);
+			}
+		}
+		SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+		data->__AGLCtx = context;
+		glAMakeCurrent(context);
+    }
+	return 0;
+}
+
+SDL_GLContext
+AROS_GL_CreateContext(_THIS, SDL_Window * window)
+{
+    D(bug("[SDL2:arosgl] %s()\n", __func__));
+
+    struct TagItem ctxAttribs [10];
+	LONG i = 0;
+
+    if ( _this->gl_config.red_size   != 0 &&
+            _this->gl_config.blue_size  != 0 &&
+            _this->gl_config.green_size != 0 ) {
+
+		if(!_this->gl_config.stereo ) {
+			/* Required window pointer  */
+			SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+			ctxAttribs[i].ti_Tag = GLA_Window;	ctxAttribs[i++].ti_Data = (IPTR)data->win;
+
+			/* _this->gl_config.double_buffer - skipped, GLA always double-buffer */
+			/* _this->gl_config.multisamplebuffers - currently not supported */
+			/* _this->gl_config.multisamplesample - currently not supported */
+
+			/* no depth buffer ? */
+			if ( _this->gl_config.depth_size == 0 ) 
+			{
+				ctxAttribs[i].ti_Tag = GLA_NoDepth;
+				ctxAttribs[i++].ti_Data = GL_TRUE;
+			}
+			/* no stencil buffer ? */
+			if ( _this->gl_config.stencil_size == 0 )
+			{
+				ctxAttribs[i].ti_Tag = GLA_NoStencil;
+				ctxAttribs[i++].ti_Data = GL_TRUE;
+			}
+			/* no accum buffer ? */
+			if ( _this->gl_config.accum_red_size   == 0 && 
+				_this->gl_config.accum_blue_size  == 0 &&
+				_this->gl_config.accum_green_size == 0 )
+			{
+				ctxAttribs[i].ti_Tag = GLA_NoAccum;
+				ctxAttribs[i++].ti_Data = GL_TRUE;
+			}
+
+			/* done */
+			ctxAttribs[i].ti_Tag = TAG_DONE;
+
+			GLAContext newCtx = glACreateContext(ctxAttribs);
+			if ((newCtx) && (_this->gl_data->gldd_GLACtx == NULL))
+				AROS_GL_MakeCurrent(_this, window, newCtx);
+
+			D(bug("[SDL2:arosgl] %s: new glAContext @ 0x%p\n", __func__, newCtx));
+			return newCtx;
+		}
+		else {
+			SDL_SetError("gl.library does not support stereo buffer");
+		}
+	}
+	else {
+		SDL_SetError("gl.library does not work with indexed color");
+	}
+	return NULL;
+}
+
+void
+AROS_GL_GetDrawableSize(_THIS, SDL_Window *window, int *width, int *height)
+{
+#if (0)
+	SDL_WindowData *data = window->driverdata;
+    int w = 0;
+    int h = 0;
+    if (data->win) {
+			w = data->win->Width - data->win->BorderLeft - data->win->BorderRight;
+			h = data->win->Height - data->win->BorderTop - data->win->BorderBottom;
+	}
+   // D("[SDL2:arosgl] %s: System window size (%d * %d), SDL window size (%d * %d)\n", __func__, w, h, window->w, window->h);
+    if (width)
+        *width = w;
+    if (height)
+        *height = h;
+#endif
+}
+
+int
+AROS_GL_SetSwapInterval(_THIS, int interval)
+{
+    D(bug("[SDL2:arosgl] %s(%d)\n", __func__, interval));
+
+	switch (interval) {
+		case 0:
+		case 1:
+			_this->gl_data->gldd_Interval = (interval ? TRUE : FALSE);
+			return 0;
+		default:
+			return -1;
+	}	
+}
+
+int
+AROS_GL_GetSwapInterval(_THIS)
+{
+    D(bug("[SDL2:arosgl] %s()\n", __func__));
+
+	return _this->gl_data->gldd_Interval ? 1 : 0;
+}
+
+int
+AROS_GL_SwapWindow(_THIS, SDL_Window * window)
+{
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+
+    D(bug("[SDL2:arosgl] %s(0x%p)\n", __func__, window));
+
+	if (!data->win || !_this->gl_data->gldd_GLACtx)
+		return 0;
+
+	glASwapBuffers(_this->gl_data->gldd_GLACtx);
+
+	return 0;
+}
+
+void
+AROS_GL_DeleteContext(_THIS, SDL_GLContext context)
+{
+    D(bug("[SDL2:arosgl] %s(0x%p)\n", __func__, context));
+
+	if ((GLBase) && (context)) {
+		if (_this->gl_data->gldd_GLACtx == context)
+			_this->gl_data->gldd_GLACtx = NULL;
+		glADestroyContext(context);
+	}
+}
+
+#endif /* SDL_VIDEO_OPENGL_AGL */
diff -ruN SDL2-2.32.8/src/video/aros/SDL_arosopengl.h SDL2-2.32.8.aros/src/video/aros/SDL_arosopengl.h
--- SDL2-2.32.8/src/video/aros/SDL_arosopengl.h	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/video/aros/SDL_arosopengl.h	2025-08-03 20:44:17.961309549 +0000
@@ -0,0 +1,61 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+/* TinyGL implementation of SDL OpenGL support */
+
+#ifndef _SDL_arosopengl_h
+#define _SDL_arosopengl_h
+
+#include "../../SDL_internal.h"
+
+#include <GL/gla.h>
+
+struct SDL_GLDriverData
+{
+  struct Library    *gldd_GLBase;
+  GLAContext        *gldd_GLACtx;
+  int               gldd_Interval;
+#if (0)
+    struct Library          **GLABasePtr;
+	void                    **GLAContext;
+	unsigned int		    (*MyGetMaximumContextVersion)(struct Library *GLABase);
+#endif
+};
+
+#if !defined(SDL_VIDEO_OPENGL_AGL_INTERN)
+/* SDL functions */
+extern int AROS_GL_LoadLibrary(_THIS, const char *path);
+extern void *AROS_GL_GetProcAddress(_THIS, const char *proc);
+extern void AROS_GL_UnloadLibrary(_THIS);
+extern SDL_GLContext AROS_GL_CreateContext(_THIS, SDL_Window * window);
+extern int AROS_GL_MakeCurrent(_THIS, SDL_Window * window, SDL_GLContext context);
+extern void AROS_GL_GetDrawableSize(_THIS, SDL_Window * window, int *w, int *h);
+extern int AROS_GL_SetSwapInterval(_THIS, int interval);
+extern int AROS_GL_GetSwapInterval(_THIS);
+extern int AROS_GL_SwapWindow(_THIS, SDL_Window * window);
+extern void AROS_GL_DeleteContext(_THIS, SDL_GLContext context);
+
+/* Non-SDL functions */
+extern int AROS_GL_ResizeContext(_THIS, SDL_Window *window);
+extern SDL_bool AROS_GL_InitContext(_THIS, SDL_Window * window, GLAContext *glcont);
+#endif /* !SDL_VIDEO_OPENGL_AGL_INTERN */
+
+#endif /* _SDL_arosopengl_h */
diff -ruN SDL2-2.32.8/src/video/aros/SDL_arosshape.c SDL2-2.32.8.aros/src/video/aros/SDL_arosshape.c
--- SDL2-2.32.8/src/video/aros/SDL_arosshape.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/video/aros/SDL_arosshape.c	2025-07-29 12:13:48.561399854 +0000
@@ -0,0 +1,196 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+//#define DEBUG 1
+#include <aros/debug.h>
+
+#define __NOLIBBASE__
+
+#include "../../SDL_internal.h"
+
+#include "../SDL_sysvideo.h"
+
+#include "SDL_arosshape.h"
+#include "SDL_aroswindow.h"
+
+#include <intuition/extensions.h>
+#include <proto/graphics.h>
+#include <proto/intuition.h>
+
+extern struct Library *GfxBase;
+
+SDL_WindowShaper*
+AROS_CreateShaper(SDL_Window *window)
+{
+	D(bug("[SDL2:arosshape] %s()\n", __func__));
+
+	SDL_WindowShaper *result;
+
+	if ((result = SDL_malloc(sizeof(*result)))) {
+		result->window = window;
+		result->mode.mode = ShapeModeDefault;
+		result->mode.parameters.binarizationCutoff = 1;
+		result->userx = window->x;
+		result->usery = window->y;
+		result->driverdata = NULL;
+
+		window->shaper = result;
+	} else {
+		SDL_OutOfMemory();
+	}
+
+	return result;
+}
+
+int
+AROS_ResizeWindowShape(SDL_Window* window)
+{
+	D(bug("[SDL2:arosshape] %s()\n", __func__));
+
+	SDL_WindowShaper *shaper = window->shaper;
+
+	shaper->userx = window->x;
+	shaper->usery = window->y;
+
+	return 0;
+}
+
+static void
+AROS_ShapeToRegion(struct Region *region, SDL_Surface *shape, const SDL_WindowShapeMode mode)
+{
+	D(bug("[SDL2:arosshape] %s()\n", __func__));
+
+	Uint32 y, bpr = shape->format->BytesPerPixel, pitch;
+	const Uint8 *pixels;
+	SDL_Color key;
+
+	D(bug("[SDL2:arosshape] %s: mode: %ld\n", __func__, mode.mode));
+
+	if (SDL_MUSTLOCK(shape))
+		SDL_LockSurface(shape);
+
+	pixels = shape->pixels;
+	pitch = shape->pitch;
+
+	for (y = 0; y < shape->h; y++) {
+		struct Rectangle rect;
+		int x, have_transp = 0;
+
+		for (x = 0; x < shape->w; x++) {
+			Uint32 pixel_value = 0, mask_value = 0;
+			Uint8 *pixel = (Uint8 *)(pixels) + (y * pitch) + (x * bpr);
+			Uint8 r, g, b, alpha;
+
+			switch (bpr) {
+				case 1:
+					pixel_value = *(Uint8*)pixel;
+					break;
+
+				case 2:
+					pixel_value = *(Uint16*)pixel;
+					break;
+
+				case 3:
+					pixel_value = *(Uint32*)pixel & (~shape->format->Amask);
+					break;
+
+				case 4:
+					pixel_value = *(Uint32*)pixel;
+					break;
+			}
+
+			SDL_GetRGBA(pixel_value, shape->format, &r, &g, &b, &alpha);
+
+			switch (mode.mode) {
+				case ShapeModeDefault:
+					mask_value = (alpha >= 1 ? 1 : 0);
+					break;
+
+				case ShapeModeBinarizeAlpha:
+					mask_value = (alpha >= mode.parameters.binarizationCutoff ? 1 : 0);
+					break;
+
+				case ShapeModeReverseBinarizeAlpha:
+					mask_value = (alpha <= mode.parameters.binarizationCutoff ? 1 : 0);
+					break;
+
+				case ShapeModeColorKey:
+					key = mode.parameters.colorKey;
+					mask_value = ((key.r != r || key.g != g || key.b != b) ? 1 : 0);
+					break;
+			}
+
+			if (have_transp == 0) {
+				if (mask_value == 0) {
+					rect.MinX = x;
+					rect.MinY = y;
+					rect.MaxY = y;
+					have_transp = 1;
+				}
+			} else {
+				if (mask_value == 1) {
+					rect.MaxX = x - 1;
+					have_transp = 0;
+					OrRectRegion(region, &rect);
+				}
+			}
+		}
+
+		if (have_transp) {
+			rect.MaxX = shape->w - 1;
+			OrRectRegion(region, &rect);
+		}
+	}
+
+	if (SDL_MUSTLOCK(shape))
+		SDL_UnlockSurface(shape);
+}
+
+int
+AROS_SetWindowShape(SDL_WindowShaper *shaper, SDL_Surface *shape, SDL_WindowShapeMode *mode)
+{
+	SDL_WindowData *data = shaper->window->driverdata;
+	struct Region *old = data->region;
+	struct Region *region = NewRegion();
+
+	D(bug("[SDL2:arosshape] %s: shaper: 0x%08lx, window: 0x%08lx, driverdata: 0x%08lx, old: 0x%08lx\n", __func__, shaper, shaper->window, data, old));
+
+	if (region) {
+		data->region = region;
+
+		AROS_ShapeToRegion(region, shape, shaper->mode);
+
+		if (data->win) {
+#if !defined(__AROS__)
+			size_t tags[] = { TRANSPCONTROL_REGION, (size_t)region, TAG_DONE };
+			D(bug("[SDL2:arosshape] %s:  Set transparency region (0x%08lx)\n", __func__, region));
+			TransparencyControl(data->win, TRANSPCONTROLMETHOD_INSTALLREGION, (struct TagItem *)&tags);
+#endif
+		}
+
+		D(bug("[SDL2:arosshape] %s:  DisposeRegion(0x%08lx)\n", __func__, old));
+
+		if (old)
+			DisposeRegion(old);
+	}
+
+	return 0;
+}
diff -ruN SDL2-2.32.8/src/video/aros/SDL_arosshape.h SDL2-2.32.8.aros/src/video/aros/SDL_arosshape.h
--- SDL2-2.32.8/src/video/aros/SDL_arosshape.h	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/video/aros/SDL_arosshape.h	2025-07-28 18:18:43.334984401 +0000
@@ -0,0 +1,34 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifndef _SDL_arosshape_h
+#define _SDL_arosshape_h
+
+typedef struct
+{
+} SDL_ShapeData;
+
+extern SDL_WindowShaper *AROS_CreateShaper(SDL_Window *window);
+extern int AROS_ResizeWindowShape(SDL_Window* window);
+extern int AROS_SetWindowShape(SDL_WindowShaper *shaper, SDL_Surface *shape, SDL_WindowShapeMode *shape_mode);
+
+#endif /* _SDL_arosshape_h */
diff -ruN SDL2-2.32.8/src/video/aros/SDL_arosvideo.c SDL2-2.32.8.aros/src/video/aros/SDL_arosvideo.c
--- SDL2-2.32.8/src/video/aros/SDL_arosvideo.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/video/aros/SDL_arosvideo.c	2025-08-11 18:44:33.969907939 +0000
@@ -0,0 +1,472 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+//#define DEBUG 1
+#include <aros/debug.h>
+
+#define __NOLIBBASE__
+
+#include "../../SDL_internal.h"
+
+#include "SDL_video.h"
+#include "SDL_mouse.h"
+#include "../SDL_sysvideo.h"
+#include "../SDL_pixels_c.h"
+#include "SDL_hints.h"
+
+#include "SDL_arosclipboard.h"
+
+#include "SDL_arosframebuffer.h"
+#include "SDL_aroskeyboard.h"
+#include "SDL_arosmodes.h"
+#include "SDL_arosmouse.h"
+#include "SDL_arosshape.h"
+#include "SDL_arosvideo.h"
+#include "SDL_aroswindow.h"
+#include "SDL_arosmessagebox.h"
+#include "SDL_arosopengl.h"
+
+#include <exec/execbase.h>
+#include <intuition/pointerclass.h>
+#include <cybergraphx/cybergraphics.h>
+#include <graphics/rastport.h>
+#include <graphics/rpattr.h>
+#include <dos/bptr.h>
+
+#include <proto/cybergraphics.h>
+#include <proto/commodities.h>
+#include <proto/dos.h>
+#include <proto/exec.h>
+#include <proto/graphics.h>
+#include <proto/icon.h>
+#include <proto/intuition.h>
+#include <proto/wb.h>
+
+
+#include "SDL_arosevents.h"
+
+extern struct Library *DOSBase;
+extern struct Library *WorkbenchBase;
+extern struct Library *GfxBase;
+extern struct Library *CxBase;
+extern struct Library *IconBase;
+extern struct Library *IntuitionBase;
+
+#define	SDLAROSBLANKPOINTERSIZE ((1 + 16 + 1) * 2)
+const UWORD blankPointerData[SDLAROSBLANKPOINTERSIZE] = {
+	0,12,
+	0x8000, 0x0000,
+	0x0000, 0x0000,
+	0x0000, 0x0000,
+	0x0000, 0x0000,
+	0x0000, 0x0000,
+	0x0000, 0x0000,
+	0x0000, 0x0000,
+	0x0000, 0x0000,
+	0x0000, 0x0000,
+	0x0000, 0x0000,
+	0x0000, 0x0000,
+	0x0000, 0x0000,//
+	0x0000, 0x0000,
+	0x0000, 0x0000,
+	0x0000, 0x0000,
+	0x0000, 0x0000,
+	0,0
+};
+
+void
+AROS_CloseDisplay(_THIS)
+{
+	SDL_VideoData *data = (SDL_VideoData *) _this->driverdata;
+	D(bug("[SDL2:arosvideo] %s: CustomScreen=0x%08lx  WScreen=0x%08lx \n", __func__, data->CustomScreen, data->WScreen));
+
+	if (data->CustomScreen) {
+		CloseScreen(data->CustomScreen);
+	}
+	else if (data->WScreen) {
+		if (data->ScreenSaverSuspendCount) {
+			size_t i;
+
+			for (i = data->ScreenSaverSuspendCount; i > 0; i--)
+				SetAttrs(data->WScreen, SA_StopBlanker, FALSE, TAG_DONE);
+		}
+
+		UnlockPubScreen(NULL, data->WScreen);
+
+#if !defined(__AROS__)
+		if (data->ScreenNotifyHandle) {
+			while (!RemWorkbenchClient(data->ScreenNotifyHandle))
+				Delay(10);
+
+			data->ScreenNotifyHandle = NULL;
+		}
+#endif
+	}
+
+	data->CustomScreen = NULL;
+	data->WScreen = NULL;
+}
+
+size_t getv(APTR obj, size_t attr)
+{
+	IPTR val = 0;
+	GetAttr(attr, obj, (IPTR *)&val);
+	return (size_t)val;
+}
+
+void
+AROS_HideApp(_THIS, size_t with_app_icon)
+{
+	SDL_VideoData *data = (SDL_VideoData *) _this->driverdata;
+	D(bug("[SDL2:arosvideo] %s: %siconify\n", __func__, with_app_icon ? "" : "no "));
+
+    SDL_WindowData *wd;
+    ForeachNode(&data->windowlist, wd)
+    {
+        struct Window *win = wd->win;
+        if (win)
+            AROS_SetWindowOpacity(_this, wd->window, 0.0);
+    }
+
+	if (with_app_icon && data->AppIcon)
+		data->AppIconRef = AddAppIconA(0, 0, FilePart(data->FullAppName), &data->WBPort, 0, data->AppIcon, NULL);
+}
+
+void
+AROS_ShowApp(_THIS)
+{
+    D(bug("[SDL2:arosvideo] %s()\n", __func__));
+
+	SDL_VideoData *data = (SDL_VideoData *) _this->driverdata;
+
+	if (data->AppIconRef) {
+		struct Message *msg;
+
+		RemoveAppIcon(data->AppIconRef);
+		data->AppIconRef = NULL;
+
+		while ((msg = GetMsg(&data->WBPort)) != NULL)
+			ReplyMsg(msg);
+	}
+
+    SDL_WindowData *wd;
+    ForeachNode(&data->windowlist, wd)
+    {
+        struct Window *win = wd->win;
+        if (win) {
+            AROS_SetWindowOpacity(_this, wd->window, 1.0);
+            AROS_WindowToFront(win);
+        }
+    }
+
+}
+
+static int
+AROS_VideoInit(_THIS)
+{
+	D(bug("[SDL2:arosvideo] %s()\n", __func__));
+
+	if (AROS_InitModes(_this) < 0)
+	{
+		D(bug("[SDL2:arosvideo] %s: failed to initialize video modes\n", __func__));
+		return SDL_SetError("Failed to initialize modes");
+	}
+
+	AROS_InitKeyboard(_this);
+	AROS_InitMouse(_this);
+
+	SDL_SetHint(SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS, SDL_FALSE);
+	SDL_SetHint(SDL_HINT_GAMECONTROLLERCONFIG_FILE, "ENV:gamecontrollerdb.txt");
+	SDL_SetHint(SDL_HINT_POLL_SENTINEL, "0");
+
+	return 0;
+}
+
+static void
+AROS_VideoQuit(_THIS)
+{
+	D(bug("[SDL2:arosvideo] %s()\n", __func__));
+
+	AROS_CloseWindows(_this);
+	AROS_CloseDisplay(_this);
+	AROS_QuitMouse(_this);
+}
+
+static void
+AROS_DeleteDevice(SDL_VideoDevice * device)
+{
+	D(bug("[SDL2:arosvideo] %s()\n", __func__));
+	SDL_VideoData *data = (SDL_VideoData *) device->driverdata;
+
+	if (data->BlankPtrObj) {
+		DisposeObject(data->BlankPtrObj);
+	}
+
+	FreeSignal(data->ScreenNotifyPort.mp_SigBit);
+	FreeSignal(data->BrokerPort.mp_SigBit);
+	FreeSignal(data->WBPort.mp_SigBit);
+	FreeSignal(data->WinPort.mp_SigBit);
+
+	if (data->BrokerRef)
+		DeleteCxObjAll(data->BrokerRef);
+
+	if (data->AppIcon)
+		FreeDiskObject(data->AppIcon);
+
+	SDL_free(data);
+	SDL_free(device);
+}
+
+void
+AROS_SuspendScreenSaver(_THIS)
+{
+	SDL_VideoData *data = (SDL_VideoData *) _this->driverdata;
+	LONG suspend = _this->suspend_screensaver;
+
+	D(bug("[SDL2:arosvideo] %s: screen 0x%08lx, suspend %ld\n", __func__, data->WScreen, suspend));
+
+	if (suspend == 0 && data->ScreenSaverSuspendCount == 0)
+		return;
+
+	data->ScreenSaverSuspendCount += suspend ? 1 : -1;
+
+	if (data->WScreen)
+		SetAttrs(data->WScreen, SA_StopBlanker, suspend, TAG_DONE);
+}
+
+static CONST_STRPTR
+AROS_GetTaskName()
+{
+	struct Process *task = (struct Process *)FindTask(NULL);
+	STRPTR name = "SDL";
+
+	if (task->pr_Task.tc_Node.ln_Type == NT_PROCESS || task->pr_Task.tc_Node.ln_Type == NT_TASK) {
+		if (task->pr_Task.tc_Node.ln_Type == NT_PROCESS && task->pr_CLI) {
+			struct CommandLineInterface *cli = (struct CommandLineInterface *)BADDR(task->pr_CLI);
+
+			if (cli->cli_Module && cli->cli_CommandName) {
+				CONST_STRPTR src = (CONST_STRPTR)AROS_BSTR_ADDR(cli->cli_CommandName);
+				size_t len = AROS_BSTR_strlen(cli->cli_CommandName) + 1;
+
+				if (len > 1) {
+					if (src[1] == '"' && src[len] == '"')
+					{
+						len -= 2;
+						src++;
+					}
+
+					STRPTR tmpname = SDL_malloc(len);
+					if (tmpname)
+					{
+						name = tmpname;
+						stccpy(name, src, len);
+					}
+				}
+			}
+		} else {
+			size_t len = strlen(task->pr_Task.tc_Node.ln_Name) + sizeof("PROGDIR:") + 1;
+			STRPTR tmpname = SDL_malloc(len);
+			if (tmpname) {
+				name = tmpname;
+				strcpy(name, "PROGDIR:");
+				strcpy((APTR)((IPTR)name + 8), task->pr_Task.tc_Node.ln_Name);
+				D(bug("[SDL2:arosvideo] %s: using task name '%s'\n", __func__, name));
+			}
+		}
+	}
+
+	D(bug("[SDL2:arosvideo] %s: '%s'\n", __func__, name));
+
+	return name;
+}
+
+static void
+AROS_InitPort(struct MsgPort *port)
+{
+	port->mp_Node.ln_Name = "SDL";
+	port->mp_Flags = PA_SIGNAL;
+	port->mp_SigTask = FindTask(NULL);
+	NEWLIST(&port->mp_MsgList);
+	port->mp_SigBit = AllocSignal(-1);
+}
+
+static void
+AROS_InitBroker(SDL_VideoData *data)
+{
+	D(bug("[SDL2:arosvideo] %s()\n", __func__));
+	
+	STRPTR name = FilePart(data->FullAppName);
+	data->AppBroker.nb_Version = NB_VERSION;
+	data->AppBroker.nb_Name = name;
+	data->AppBroker.nb_Title = name;
+	data->AppBroker.nb_Descr = "SDL";
+	data->AppBroker.nb_Unique = NBU_DUPLICATE;
+	data->AppBroker.nb_Flags = COF_SHOW_HIDE;
+	data->AppBroker.nb_Pri = 0;
+	data->AppBroker.nb_Port = &data->BrokerPort;
+	data->AppBroker.nb_ReservedChannel = 0;
+	data->BrokerRef = CxBroker(&data->AppBroker, NULL);
+	if (data->BrokerRef)
+		ActivateCxObj(data->BrokerRef, 1);
+}
+
+Object *AROS_SDLCreateBlankPtr(void)
+{
+	Object *ptrObj = NULL;
+    struct TagItem pointertags[] = {
+        {POINTERA_BitMap, 		(IPTR)blankPointerData	},
+        {POINTERA_XOffset, 		0      					},
+        {POINTERA_YOffset, 		0      					},
+        {SPRITEA_OldDataFormat,	TRUE					},
+        {SPRITEA_Width, 		16						},
+        {SPRITEA_OutputHeight,	16       				},
+        {TAG_DONE,              0              			}
+    };
+
+    ptrObj = NewObjectA(NULL, POINTERCLASS, pointertags);
+	D(bug("[SDL2:arosvideo] %s: returning 0x%p\n", __func__, ptrObj));
+	return ptrObj;
+}
+
+static SDL_VideoDevice *
+AROS_CreateDevice()
+{
+	/* Initialize all variables that we clean on shutdown */
+	SDL_VideoDevice *device = (SDL_VideoDevice *) SDL_calloc(1, sizeof(SDL_VideoDevice) + sizeof(struct SDL_GLDriverData));
+	D(bug("[SDL2:arosvideo] %s()\n", __func__));
+
+	if (device) {
+		SDL_VideoData *data = (struct SDL_VideoData *) SDL_calloc(1, sizeof(SDL_VideoData));
+
+		device->driverdata = data;
+		device->gl_data = (APTR)((IPTR)device + sizeof(SDL_VideoDevice));
+
+		if (data) {
+			AROS_InitPort(&data->ScreenNotifyPort);
+			AROS_InitPort(&data->BrokerPort);
+			AROS_InitPort(&data->WBPort);
+			AROS_InitPort(&data->WinPort);
+
+			data->BlankPtrObj = AROS_SDLCreateBlankPtr();
+
+			data->ScrNotifySig = 1 << data->ScreenNotifyPort.mp_SigBit;
+			data->BrokerSig = 1 << data->BrokerPort.mp_SigBit;
+			data->WBSig = 1 << data->WBPort.mp_SigBit;
+			data->WinSig = 1 << data->WinPort.mp_SigBit;
+
+#if AROS_BIG_ENDIAN
+			data->sdlpixfmt = SDL_PIXELFORMAT_ARGB8888;
+#else
+			data->sdlpixfmt = SDL_PIXELFORMAT_BGRA8888;
+#endif
+
+			NEWLIST(&data->windowlist);
+
+			data->FullAppName = AROS_GetTaskName();
+			data->AppIcon = GetDiskObject((STRPTR)data->FullAppName);
+
+			if (data->AppIcon == NULL)
+				data->AppIcon = GetDiskObject((STRPTR)"ENVARC:Sys/def_SDL");
+
+			if (data->AppIcon) {
+				data->AppIcon->do_CurrentX = NO_ICON_POSITION;
+				data->AppIcon->do_CurrentY = NO_ICON_POSITION;
+				data->AppIcon->do_Type = 0;
+			}
+
+			AROS_InitBroker(data);
+
+			data->VideoDevice = device;
+
+			/* Set the function pointers */
+			device->VideoInit = AROS_VideoInit;
+			device->VideoQuit = AROS_VideoQuit;
+			device->GetDisplayModes = AROS_GetDisplayModes;
+			device->GetDisplayBounds = AROS_GetDisplayBounds;
+			device->SetDisplayMode = AROS_SetDisplayMode;
+			device->SuspendScreenSaver = AROS_SuspendScreenSaver;
+			device->PumpEvents = AROS_PumpEvents;
+			device->CreateSDLWindow = AROS_CreateWindow;
+			device->CreateSDLWindowFrom = AROS_CreateWindowFrom;
+			device->SetWindowTitle = AROS_SetWindowTitle;
+			device->SetWindowIcon = AROS_SetWindowIcon;
+			device->SetWindowPosition = AROS_SetWindowPosition;
+			device->SetWindowSize = AROS_SetWindowSize;
+			device->SetWindowMinimumSize = AROS_SetWindowMinimumSize;
+			device->SetWindowMaximumSize = AROS_SetWindowMaximumSize;
+			device->ShowWindow = AROS_ShowWindow;
+			device->HideWindow = AROS_HideWindow;
+			device->RaiseWindow = AROS_RaiseWindow;
+			device->MaximizeWindow = AROS_MaximizeWindow;
+			device->MinimizeWindow = AROS_MinimizeWindow;
+			device->RestoreWindow = AROS_RestoreWindow;
+			device->SetWindowBordered = AROS_SetWindowBordered;
+			device->SetWindowAlwaysOnTop = AROS_SetWindowAlwaysOnTop;
+			device->SetWindowFullscreen = AROS_SetWindowFullscreen;
+ 			device->SetWindowGammaRamp = AROS_SetWindowGammaRamp;
+			device->SetWindowMouseGrab = AROS_SetWindowGrab;
+			device->DestroyWindow = AROS_DestroyWindow;
+			device->CreateWindowFramebuffer = AROS_CreateWindowFramebuffer;
+			device->UpdateWindowFramebuffer = AROS_UpdateWindowFramebuffer;
+			device->DestroyWindowFramebuffer = AROS_DestroyWindowFramebuffer;
+			device->GetWindowWMInfo = AROS_GetWindowWMInfo;
+			device->shape_driver.CreateShaper = AROS_CreateShaper;
+			device->shape_driver.SetWindowShape = AROS_SetWindowShape;
+			device->shape_driver.ResizeWindowShape = AROS_ResizeWindowShape;
+			device->GL_LoadLibrary = AROS_GL_LoadLibrary;
+			device->GL_GetProcAddress = AROS_GL_GetProcAddress;
+			device->GL_UnloadLibrary = AROS_GL_UnloadLibrary;
+			device->GL_CreateContext = AROS_GL_CreateContext;
+			device->GL_MakeCurrent = AROS_GL_MakeCurrent;
+			device->GL_GetDrawableSize = AROS_GL_GetDrawableSize;
+			device->GL_SetSwapInterval = AROS_GL_SetSwapInterval;
+			device->GL_GetSwapInterval = AROS_GL_GetSwapInterval;
+			device->GL_SwapWindow = AROS_GL_SwapWindow;
+			device->GL_DeleteContext = AROS_GL_DeleteContext;
+			device->SetClipboardText = AROS_SetClipboardText;
+			device->GetClipboardText = AROS_GetClipboardText;
+			device->HasClipboardText = AROS_HasClipboardText;
+			device->SetWindowResizable = AROS_SetWindowResizable;
+			device->GetWindowBordersSize = AROS_GetWindowBordersSize;
+			device->SetWindowOpacity = AROS_SetWindowOpacity;
+			device->FlashWindow = AROS_FlashWindow;
+			//device->SetWindowHitTest = AROS_SetWindowHitTest;
+			device->free = AROS_DeleteDevice;
+
+			D(bug("[SDL2:arosvideo] %s: instance @ 0x%p\n", __func__, device));
+			return device;
+		}
+
+		SDL_free(device);
+	}
+
+	SDL_OutOfMemory();
+
+	D(bug("[SDL2:arosvideo] %s: returning NULL\n", __func__));
+
+	return NULL;
+}
+
+VideoBootStrap AROS_bootstrap = {
+	"aros", "SDL AROS Cgfx/AGL video driver",
+	AROS_CreateDevice,
+    AROS_ShowMessageBox
+};
diff -ruN SDL2-2.32.8/src/video/aros/SDL_arosvideo.h SDL2-2.32.8.aros/src/video/aros/SDL_arosvideo.h
--- SDL2-2.32.8/src/video/aros/SDL_arosvideo.h	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/video/aros/SDL_arosvideo.h	2025-08-11 13:14:51.279276526 +0000
@@ -0,0 +1,98 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifndef _SDL_arosvideo_h
+#define _SDL_arosvideo_h
+
+#include "SDL_keycode.h"
+
+#include "../SDL_sysvideo.h"
+#include "../../events/SDL_mouse_c.h"
+
+#include "SDL_arosclipboard.h"
+#include "SDL_aroswindow.h"
+
+#ifndef EXEC_PORTS_H
+#include <exec/ports.h>
+#endif
+
+#ifndef LIBRARIES_COMMODITIES_H
+#include <libraries/commodities.h>
+#endif
+
+/* Private display data */
+
+struct DiskObject;
+
+typedef struct SDL_VideoData
+{
+	struct MsgPort ScreenNotifyPort;
+	struct MsgPort BrokerPort;
+	struct MsgPort WBPort;
+	struct MsgPort WinPort;
+
+	size_t ScrNotifySig, BrokerSig, WBSig, WinSig;
+
+	struct Screen *WScreen;
+	struct Screen *CustomScreen;
+
+	struct MinList windowlist;
+
+    Object *BlankPtrObj;
+	SDL_Cursor *CurrentPointer;
+	ULONG sdlpixfmt;
+
+	ULONG coltab[256];
+	UBYTE gammatable[3][256];
+
+	LONG ScreenSaverSuspendCount;
+
+	APTR ScreenNotifyHandle;
+
+	CONST_STRPTR FullAppName;
+	struct DiskObject *AppIcon;
+
+	APTR AppIconRef;
+	APTR BrokerRef;
+
+	struct NewBroker AppBroker;
+
+	// Screen information
+	size_t ScrWidth, ScrHeight, ScrDepth;
+	CONST_STRPTR ScrMonName;
+
+	SDL_VideoDevice *VideoDevice;
+
+	BYTE FullScreen;
+	BYTE vsyncEnabled;
+	
+} SDL_VideoData;
+
+/* SDL functions */
+extern void AROS_CloseDisplay(_THIS);
+extern void AROS_HideApp(_THIS, size_t with_app_icon);
+extern void AROS_ShowApp(_THIS);
+
+/* Non-SDL functions */
+extern size_t getv(APTR obj, size_t attr);
+
+#endif /* _SDL_arosvideo_h */
diff -ruN SDL2-2.32.8/src/video/aros/SDL_aroswindow.c SDL2-2.32.8.aros/src/video/aros/SDL_aroswindow.c
--- SDL2-2.32.8/src/video/aros/SDL_aroswindow.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/video/aros/SDL_aroswindow.c	2025-08-11 16:17:46.169908885 +0000
@@ -0,0 +1,1049 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+//#define DEBUG 1
+#include <aros/debug.h>
+
+#define __NOLIBBASE__
+
+#include "../../SDL_internal.h"
+
+#include "SDL_hints.h"
+#include "SDL_syswm.h"
+#include "SDL_timer.h"
+#include "SDL_version.h"
+#include "../SDL_sysvideo.h"
+#include "../SDL_pixels_c.h"
+#include "../../misc/aros/SDL_misc.h"
+#include "../../events/SDL_keyboard_c.h"
+#include "../../events/SDL_events_c.h"
+#include "../../events/SDL_mouse_c.h"
+
+#include "SDL_arosvideo.h"
+#include "SDL_arosmodes.h"
+#include "SDL_arosmouse.h"
+#include "SDL_arosopengl.h"
+#include "SDL_arosevents.h"
+
+#include <sys/param.h>
+
+#include <intuition/extensions.h>
+#include <proto/alib.h>
+#include <proto/exec.h>
+#include <proto/gadtools.h>
+#include <proto/graphics.h>
+#include <proto/intuition.h>
+#include <proto/wb.h>
+#include <proto/dos.h>
+
+extern struct Library *IntuitionBase;
+extern struct Library *GadToolsBase;
+extern struct Library *DOSBase;
+extern struct Library *WorkbenchBase;
+extern struct Library *GfxBase;
+
+struct NewMenu SDL_NewMenu[] =
+{
+	{ NM_TITLE, (char *)"Project", 0, 0, 0, (APTR)MID_PROJECT },
+	{ NM_ITEM , (char *)"About...", (const STRPTR)"A", 0, 0, (APTR)MID_ABOUT },
+	{ NM_ITEM, NM_BARLABEL, NULL, 0, 0, NULL },
+	{ NM_ITEM , (char *)"About Joystick", (const STRPTR)"J", 0, 0, (APTR)MID_JOYSTICK},
+	{ NM_ITEM , (char *)"About System", (const STRPTR)"S", 0, 0, (APTR)MID_ABOUTSYS},
+	{ NM_ITEM, NM_BARLABEL, NULL, 0, 0, NULL },
+	{ NM_ITEM , (char *)"Hide", (const STRPTR)"H", 0, 0, (APTR)MID_HIDE },
+	{ NM_ITEM, NM_BARLABEL, NULL, 0, 0, NULL },
+	{ NM_ITEM , (char *)"Quit", (const STRPTR)"Q", 0, 0, (APTR)MID_QUIT},
+	{ NM_TITLE, (char *)"Options", 0, 0, 0, (APTR)MID_OPTIONS },
+	{ NM_ITEM , (char *)"Mute Sound", (const STRPTR)"M", (CHECKIT | MENUTOGGLE), 0, (APTR)MID_MUTE},
+	{ NM_ITEM , (char *)"Low CPU Priority", (const STRPTR)"P", (CHECKIT | MENUTOGGLE), 0, (APTR)MID_PRIORITY},
+	{ NM_ITEM, NM_BARLABEL, NULL, 0, 0, NULL },
+#if (0)
+	{ NM_ITEM, (char *)"HINT RENDER DRIVER", 0, 0, 0, (APTR)MID_RRENDER },
+	{ NM_SUB, (char *)"Default", 0, (CHECKED | CHECKIT | MENUTOGGLE), 0, (APTR)MID_RRAUTO },
+	{ NM_SUB, (char *)"OpenGL", 0, (CHECKIT | MENUTOGGLE), 0, (APTR)MID_RRGL },
+	{ NM_SUB, (char *)"Software", 0, (CHECKIT | MENUTOGGLE), 0, (APTR)MID_RRSOFT },
+	{ NM_ITEM, (char *)"HINT RENDER VSYNC", 0, 0, 0, (APTR)MID_RVSYNC },
+	{ NM_SUB, (char *)"Default", 0, (CHECKED | CHECKIT | MENUTOGGLE), 0, (APTR)MID_RVAUTO },
+	{ NM_SUB, (char *)"Enabled", 0, (CHECKIT | MENUTOGGLE), 0, (APTR)MID_RVENABLE },
+	{ NM_SUB, (char *)"Disabled", 0, (CHECKIT | MENUTOGGLE), 0, (APTR)MID_RVDISABLE },
+	{ NM_ITEM, (char *)"HINT RENDER SCALER", 0, 0, 0, (APTR)MID_RSCALER},
+	{ NM_SUB, (char *)"Default", 0, (CHECKED | CHECKIT | MENUTOGGLE), 0, (APTR)MID_AUTO },
+	{ NM_SUB, (char *)"Nearest", 0, (CHECKIT | MENUTOGGLE), 0, (APTR)MID_NEAREST },
+	{ NM_SUB, (char *)"Linear", 0, (CHECKIT | MENUTOGGLE), 0, (APTR)MID_LINEAR },
+	{ NM_ITEM, (char *)"HINT RENDER LOGICAL SIZE", 0, 0, 0, (APTR)MID_LLOGICAL},
+	{ NM_SUB, (char *)"Default", 0, (CHECKED | CHECKIT | MENUTOGGLE), 0, (APTR)MID_LAUTO },
+	{ NM_SUB, (char *)"Letterbox / sidebars", 0, (CHECKIT | MENUTOGGLE), 0, (APTR)MID_LLETTER },
+	{ NM_SUB, (char *)"Overscan", 0, (CHECKIT | MENUTOGGLE), 0, (APTR)MID_LOVERS },
+	{ NM_ITEM, (char *)"HINT RENDER BATCHING", 0, 0, 0, (APTR)MID_RBATCHING },
+	{ NM_SUB, (char *)"Default", 0, (CHECKED | CHECKIT | MENUTOGGLE), 0, (APTR)MID_BAUTO },
+	{ NM_SUB, (char *)"Enabled", 0, (CHECKIT | MENUTOGGLE), 0, (APTR)MID_BENABLE },
+	{ NM_SUB, (char *)"Disabled", 0, (CHECKIT | MENUTOGGLE), 0, (APTR)MID_BDISABLE },
+	{ NM_ITEM, (char *)"HINT RENDER LINE METHOD", 0, 0, 0, (APTR)MID_RMETHOD },
+	{ NM_SUB, (char *)"Default", 0, (CHECKED | CHECKIT | MENUTOGGLE), 0, (APTR)MID_MDEF },
+	{ NM_SUB, (char *)"Point API", 0, (CHECKIT | MENUTOGGLE), 0, (APTR)MID_MPOINT },
+	{ NM_SUB, (char *)"Line API", 0, (CHECKIT | MENUTOGGLE), 0, (APTR)MID_MLINE },
+	{ NM_SUB, (char *)"Geometry API", 0, (CHECKIT | MENUTOGGLE), 0, (APTR)MID_MGEO },
+	{ NM_ITEM, (char *)"HINT RENDER SHADERS", 0, 0, 0, (APTR)MID_SHADERS },
+	{ NM_SUB, (char *)"Default", 0, (CHECKED | CHECKIT | MENUTOGGLE), 0, (APTR)MID_SHADERS_AUTO },
+	{ NM_SUB, (char *)"Enabled", 0, (CHECKIT | MENUTOGGLE), 0, (APTR)MID_SHADERS_ENABLE },
+	{ NM_SUB, (char *)"Disabled", 0, (CHECKIT | MENUTOGGLE), 0, (APTR)MID_SHADERS_DISABLE },
+#endif
+	{ NM_END , NULL, NULL, 0, 0, NULL }
+};
+
+static void 
+AROS_CloseWindowSafely(SDL_Window *sdlwin, struct Window *win)
+{
+	D(bug("[SDL2:aroswindow] %s()\n", __func__));
+
+	if (SDL_GetKeyboardFocus() == sdlwin)
+		SDL_SetKeyboardFocus(NULL);
+
+	if (SDL_GetMouseFocus() == sdlwin)
+		SDL_SetMouseFocus(NULL);
+		
+    if ((sdlwin->flags & SDL_WINDOW_FOREIGN) == 0) {
+        struct IntuiMessage *msg, *tmp;
+
+        Forbid();
+
+        ForeachNodeSafe(&win->UserPort->mp_MsgList, msg, tmp)
+        {
+            if (msg->IDCMPWindow == win) {
+                REMOVE(&msg->ExecMessage.mn_Node);
+                ReplyMsg(&msg->ExecMessage);
+            }
+        }
+
+		win->UserPort = NULL;
+		ModifyIDCMP(win, 0);
+
+		SDL_WindowData *data = (SDL_WindowData *) sdlwin->driverdata;
+		if (data->menuactive == TRUE) {
+            ClearMenuStrip(win);
+            FreeMenus(data->menu);
+            data->menu = NULL;
+            FreeVisualInfo(data->menuvisualinfo);
+            data->menuvisualinfo = NULL;
+            data->menuactive = FALSE;
+        }
+
+        CloseWindow(win);
+
+        Permit();
+    }
+}
+
+void 
+AROS_CloseWindows(_THIS)
+{
+	D(bug("[SDL2:aroswindow] %s()\n", __func__));
+
+    SDL_VideoData *data = (SDL_VideoData *)_this->driverdata;
+    SDL_WindowData *wd;
+
+    ForeachNode(&data->windowlist, wd)
+    {
+        struct Window *win = wd->win;
+
+        if (win) {
+            wd->win = NULL;
+            AROS_CloseWindowSafely(wd->window, win);
+        }
+    }
+}
+
+void 
+AROS_OpenWindows(_THIS)
+{
+	D(bug("[SDL2:aroswindow] %s()\n", __func__));
+
+    SDL_VideoData *data = (SDL_VideoData *)_this->driverdata;
+    SDL_WindowData *wd;
+
+    ForeachNode(&data->windowlist, wd)
+    {
+        if (!(wd->window->flags & SDL_WINDOW_FOREIGN) && (wd->winflags & SDL_AROS_WINDOW_SHOWN)) {
+            if (wd->win == NULL) {
+                AROS_ShowWindow_Internal(_this, wd->window);
+            } else {
+                if ((wd->window->flags & SDL_WINDOW_FULLSCREEN_DESKTOP) == SDL_WINDOW_FULLSCREEN_DESKTOP) {
+                    AROS_RecreateWindow(_this, wd->window);
+                } else if (wd->winflags & SDL_AROS_WINDOW_FULLSCREEN_DESKTOP) {
+                    wd->winflags &= ~SDL_AROS_WINDOW_FULLSCREEN_DESKTOP;
+                    wd->window->flags &= ~SDL_WINDOW_FULLSCREEN_DESKTOP;
+                    AROS_RecreateWindow(_this, wd->window);
+                }
+            }
+        }
+    }
+}
+
+static int
+AROS_SetupWindowData(_THIS, SDL_Window *window, struct Window *win)
+{
+	D(bug("[SDL2:aroswindow] %s()\n", __func__));
+	
+	SDL_VideoData *data = (SDL_VideoData *) _this->driverdata;
+	SDL_WindowData *wd = SDL_calloc(1, sizeof(*wd));
+	
+	if (wd) {
+		window->driverdata = wd;
+		ADDHEAD(&data->windowlist, wd);
+		wd->bitmap = NULL;
+		wd->region = NULL;
+		wd->fb = NULL;
+		wd->window = window;
+		wd->win = win;
+		wd->grabbed = -1;
+		wd->sdlflags = 0;
+		wd->window_title = NULL;
+		wd->videodata = data;
+		wd->first_deltamove = 0;
+		wd->winflags = 0;
+		wd->appmsg = NULL;
+		wd->menu = NULL;     
+	    wd->menuvisualinfo = NULL;
+        wd->menuactive = FALSE;
+		if (win)
+			win->UserData = (APTR)wd;
+		else {
+			wd->old_w = 0;
+			wd->old_h = 0;
+			wd->old_x = 0;
+			wd->old_y = 0;
+		}
+	} else {
+		return SDL_OutOfMemory();
+	}
+	return 0;
+}
+
+int
+AROS_CreateWindow(_THIS, SDL_Window * window)
+{
+	return AROS_SetupWindowData(_this, window, NULL);
+}
+
+int
+AROS_CreateWindowFrom(_THIS, SDL_Window * window, const void *data)
+{
+	struct Window *win = (struct Window *)data;
+	size_t flags;
+
+	if (win->Title && win->Title != (APTR)-1)
+	{
+		window->title = AROS_ConvertTextUTF8(win->Title);
+	}
+
+	flags = (window->flags | SDL_WINDOW_SHOWN | SDL_WINDOW_FOREIGN) & ~SDL_WINDOW_MINIMIZED;
+
+	if (win->Flags & WFLG_SIZEGADGET)
+		flags |= SDL_WINDOW_RESIZABLE;
+	else
+		flags &= ~SDL_WINDOW_RESIZABLE;
+
+	if (win->Flags & WFLG_BORDERLESS)
+		flags |= SDL_WINDOW_BORDERLESS;
+	else
+		flags &= ~SDL_WINDOW_BORDERLESS;
+
+	if (win->Flags & WFLG_WINDOWACTIVE) {
+		flags |= SDL_WINDOW_INPUT_FOCUS;
+		SDL_SetKeyboardFocus(window);
+	}
+
+	window->flags = flags;
+
+	return AROS_SetupWindowData(_this, window, win);
+}
+
+void
+AROS_SetWindowTitle(_THIS, SDL_Window * window)
+{
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+
+	if (data->win) {
+		APTR title = NULL;
+		APTR old = data->window_title;
+		title = AROS_ConvertUTF8Text(window->title);
+		D(bug("[SDL2:aroswindow] %s to %s (0x%08lx)\n", __func__, window->title, title, data->win));
+		SetWindowTitles(data->win, title, title);
+		data->window_title = title;
+		SDL_free(old);
+	}
+}
+
+void
+AROS_SetWindowIcon(_THIS, SDL_Window * window, SDL_Surface * icon)
+{
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+	D(bug("[SDL2:aroswindow] %s: wnd 0x%08lx - TODO convert this icon to appicon \n", __func__, data->win));
+}
+
+void
+AROS_SetWindowPosition(_THIS, SDL_Window * window)
+{
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+
+	D(bug("[SDL2:aroswindow] %s: 0x%08lx\n", __func__, data->win));
+
+	if (data->win) {
+		SDL_VideoData *vd = data->videodata;
+		size_t top = window->y;
+
+		top = MAX((vd->CustomScreen == NULL ? vd->WScreen->BarHeight + 1 : 0), top);
+
+		ChangeWindowBox(data->win, window->x, top, data->win->Width, data->win->Height);
+	}
+}
+
+void
+AROS_SetWindowMinimumSize(_THIS, SDL_Window * window)
+{
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+
+	D(bug("[SDL2:aroswindow] %s:  0x%08lx\n", __func__, data->win));
+
+	if (data->win) {
+		SDL_VideoData *vd = data->videodata;
+		size_t min_h = window->min_h, min_w = window->min_w;
+
+		if ((window->flags & SDL_WINDOW_BORDERLESS) == 0) {
+			min_w += data->win->BorderLeft + data->win->BorderRight;
+			min_h += data->win->BorderTop + data->win->BorderBottom;
+		}
+
+		min_h = MIN(vd->WScreen->Height - (vd->CustomScreen == NULL ? vd->WScreen->BarHeight + 1 : 0), min_h);
+
+		WindowLimits(data->win, min_w, min_h, data->win->MaxWidth, MAX(data->win->MaxHeight, min_h));
+	}
+}
+
+void
+AROS_SetWindowMaximumSize(_THIS, SDL_Window * window)
+{
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+
+	D(bug("[SDL2:aroswindow] %s: 0x%08lx\n", __func__, data->win));
+
+	if (data->win) {
+		SDL_VideoData *vd = data->videodata;
+		size_t max_h = window->max_h, max_w = window->max_w;
+
+		if ((window->flags & SDL_WINDOW_BORDERLESS) == 0) {
+			max_w += data->win->BorderLeft + data->win->BorderRight;
+			max_h += data->win->BorderTop + data->win->BorderBottom;
+		}
+
+		max_h = MIN(vd->WScreen->Height - (vd->CustomScreen == NULL ? vd->WScreen->BarHeight + 1 : 0), max_h);
+
+		WindowLimits(data->win, data->win->MinWidth, MIN(data->win->MinHeight, max_h), max_w, max_h);
+	}
+}
+
+void
+AROS_SetWindowSize(_THIS, SDL_Window * window)
+{
+	D(bug("[SDL2:aroswindow] %s()\n", __func__));
+
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+
+	if (data->win) {
+		SDL_VideoData *vd = data->videodata;
+		size_t h = window->h, w = window->w; 
+
+		if ((window->flags & SDL_WINDOW_BORDERLESS) == 0) {
+			w += data->win->BorderLeft + data->win->BorderRight;
+			h += data->win->BorderTop + data->win->BorderBottom;
+		}
+
+		h = MIN(vd->WScreen->Height - (vd->CustomScreen == NULL ? vd->WScreen->BarHeight + 1 : 0), h);
+
+		ChangeWindowBox(data->win, data->win->LeftEdge, data->win->TopEdge, w, h);
+	}
+}
+
+void
+AROS_WindowToFront(struct Window *win)
+{
+	D(bug("[SDL2:aroswindow] %s: wnd 0x%08lx\n", __func__, win));
+
+	ActivateWindow(win);
+	WindowToFront(win);
+}
+
+void
+AROS_ShowWindow_Internal(_THIS, SDL_Window * window) 
+{
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+	SDL_VideoData *vd = data->videodata;
+
+	D(bug("[SDL2:aroswindow] %s: wnd 0x%08lx, scr 0x%08lx\n", __func__, data->win, vd->WScreen));
+
+	if (data->win == NULL && (data->sdlflags & SDL_WINDOW_MINIMIZED) == 0) {
+		struct Screen *scr;
+		size_t flags = WFLG_SIMPLE_REFRESH | WFLG_REPORTMOUSE | WFLG_ACTIVATE;
+		size_t w = window->w, h = window->h;
+		size_t min_w = window->min_w, min_h = window->min_h;
+		size_t left = window->x, top = window->y;
+
+		int maxheight, barheight = 0;
+		BYTE fullscreen = data->winflags & SDL_AROS_WINDOW_FULLSCREEN;
+		BYTE fs_desktop = data->winflags & SDL_AROS_WINDOW_FULLSCREEN_DESKTOP;
+		
+		SDL_bool win_resizable = (window->flags & SDL_WINDOW_RESIZABLE && !fullscreen);
+
+		data->winflags |= SDL_AROS_WINDOW_SHOWN;
+		
+		if (vd->WScreen == NULL)
+			AROS_GetScreen(vd->VideoDevice, vd->FullScreen, (window->flags & SDL_WINDOW_OPENGL) != 0);
+		
+		scr = vd->WScreen;
+		
+		size_t max_w = window->max_w ? window->max_w : (win_resizable ? scr->Width : w);
+		size_t max_h = window->max_h ? window->max_h : (win_resizable ? scr->Height : h);
+	
+		D(bug("[SDL2:aroswindow] %s: initial sizes %ld/%ld and max: %ld/%ld\n", __func__, w, h, max_w, max_h));
+		D(bug("[SDL2:aroswindow] %s: screen 0x%08lx is %ld/%ld\n", __func__, scr, scr->Width, scr->Height));
+
+#if !defined(__AROS__)
+		// Add border sizes
+		APTR di = GetScreenDrawInfo(scr);
+		if (vd->CustomScreen == NULL)
+			barheight = GetSkinInfoAttrA(di, SI_ScreenTitlebarHeight, NULL);
+		FreeScreenDrawInfo(scr, di);
+#endif
+
+		if (!fs_desktop)
+			maxheight = scr->Height - barheight;
+		else
+			maxheight = scr->Height;
+
+		if (fullscreen) {
+			w = scr->Width;
+			h = maxheight;
+			top = left = 0;
+		} else if (data->sdlflags & SDL_WINDOW_MAXIMIZED) { // Maximize window
+			int border_w = 0, border_h = 0;
+#if !defined(__AROS__)
+			border_w = GetSkinInfoAttrA(di, SI_BorderLeft    , NULL) + GetSkinInfoAttrA(di, SI_BorderRight, NULL);
+			border_h = GetSkinInfoAttrA(di, SI_BorderTopTitle, NULL) + GetSkinInfoAttrA(di, win_resizable ? SI_BorderBottomSize : SI_BorderBottom, NULL);
+#endif
+			D(bug("[SDL2:aroswindow] %s: Border width %ld, border height %ld, bar height %ld\n", __func__, border_w, border_h, barheight));
+
+			max_w = MAX(w, max_w) - border_w;
+			max_h = MAX(h, max_h) - border_h;
+			max_h = MIN(maxheight - border_h, max_h);
+
+			left = 0;
+			top = barheight;
+
+			w = max_w;
+			h = max_h;
+
+			D(bug("[SDL2:aroswindow] %s: maximize to %ld/%ld\n", __func__, w, h));
+		}
+
+		min_w = MIN(min_w, scr->Width);
+		min_h = MIN(min_h, maxheight);
+		max_w = MIN(max_w, scr->Width);
+		max_h = MIN(max_h, maxheight);
+		w = MAX(min_w, w);
+		h = MAX(min_h, h);
+
+		if (window->flags & SDL_WINDOW_BORDERLESS || fullscreen)
+			flags |= WFLG_BORDERLESS;
+		else
+			flags |= WFLG_DRAGBAR | WFLG_DEPTHGADGET | WFLG_CLOSEGADGET;
+
+		SDL_bool win_top = (window->flags & SDL_WINDOW_ALWAYS_ON_TOP && !fullscreen);
+		if (win_resizable)
+			flags |= WFLG_SIZEGADGET | WFLG_SIZEBBOTTOM;
+
+		if (fullscreen)
+			win_top = SDL_TRUE;
+		
+		if (data->window_title == NULL)
+		{
+			data->window_title = AROS_ConvertUTF8Text(window->title);
+		}
+		D(bug("[SDL2:aroswindow] %s: min %ld/%ld, normal %ld/%ld, max %ld/%ld\n", __func__, min_w, min_h, w, h, max_w, max_h));
+
+		ULONG opacity_value = ((window->opacity) * (ULONG_MAX));
+		
+		data->win = OpenWindowTags(NULL,
+			WA_Left, left, WA_Top, top,
+			WA_InnerWidth, w,
+			WA_InnerHeight, h,
+			WA_MinWidth, win_resizable ? 32 : min_w,
+			WA_MinHeight, win_resizable ? 32 : min_h,
+			WA_MaxWidth, win_resizable ? -1 : max_w,
+			WA_MaxHeight, win_resizable ? -1 : max_h,
+			WA_Flags, flags,
+			vd->CustomScreen ? WA_CustomScreen : TAG_IGNORE, vd->CustomScreen,
+			vd->CustomScreen ? TAG_IGNORE : WA_PubScreen, vd->WScreen,
+			(window->flags & SDL_WINDOW_BORDERLESS || fullscreen) ? TAG_IGNORE : WA_ScreenTitle, data->window_title,
+			(window->flags & SDL_WINDOW_BORDERLESS || fullscreen) ? TAG_IGNORE : WA_Title, data->window_title,
+#if !defined(__AROS__)
+			data->region ? WA_TransparentRegion : TAG_IGNORE, data->region,
+			WA_UserPort, &vd->WinPort,
+			WA_Opacity, opacity_value,
+			WA_FrontWindow, win_top ? TRUE : FALSE,
+#endif
+			WA_AutoAdjust, TRUE,
+			vd->CustomScreen ? TAG_IGNORE : WA_ExtraTitlebarGadgets, ETG_ICONIFY,
+			TAG_DONE);
+
+		if (data->win) {
+			D(bug("[SDL2:aroswindow] %s: current cursor = 0x%p\n", __func__, vd->CurrentPointer));
+			if (IS_SYSTEM_CURSOR(vd->CurrentPointer)) {
+				if (vd->CurrentPointer == NULL) {
+					D(bug("[SDL2:aroswindow] %s: using blank pointer (blank ptrobj @ 0x%p)\n", __func__, vd->BlankPtrObj));
+					if (vd->BlankPtrObj)
+						SetWindowPointer(data->win, WA_Pointer, (IPTR)vd->BlankPtrObj, TAG_DONE);
+				} else {
+					if (((IPTR)vd->CurrentPointer->driverdata == SDL_SYSTEM_CURSOR_WAIT) ||
+						((IPTR)vd->CurrentPointer->driverdata == SDL_SYSTEM_CURSOR_WAITARROW)) {
+						SetWindowPointer(data->win, WA_Pointer, 0, WA_BusyPointer, TRUE, TAG_DONE);
+					} else {
+						if ((IPTR)vd->CurrentPointer->driverdata != SDL_SYSTEM_CURSOR_ARROW) {
+							bug("[SDL2:aroswindow] %s: unhandled cursor type %u\n", __func__, ((IPTR)vd->CurrentPointer->driverdata));
+						}
+						SetWindowPointer(data->win, WA_Pointer, 0, TAG_DONE);
+					}
+				}
+			} else{
+				SDL_AROSCursor *ac = (SDL_AROSCursor *)vd->CurrentPointer;
+				D(bug("[SDL2:aroswindow] %s: using custom cursor 0x%p\n", __func__, ac));
+				if (ac && ac->Pointer.ptrclassobj) {
+					SetWindowPointer(data->win, WA_Pointer, (IPTR)ac->Pointer.ptrclassobj, TAG_DONE);
+				}
+			}
+
+			data->win->UserPort = &vd->WinPort;
+			ModifyIDCMP(data->win, IDCMP_CLOSEWINDOW | IDCMP_RAWKEY | IDCMP_MOUSEMOVE | IDCMP_DELTAMOVE | IDCMP_MOUSEBUTTONS | IDCMP_REFRESHWINDOW | IDCMP_ACTIVEWINDOW | IDCMP_INACTIVEWINDOW | IDCMP_CHANGEWINDOW | IDCMP_GADGETUP | IDCMP_MENUPICK);
+
+			data->curr_x = data->win->LeftEdge;
+			data->curr_y = data->win->TopEdge;
+			data->curr_w = data->win->Width;
+			data->curr_h = data->win->Height;
+			data->first_deltamove = TRUE;
+            data->menuactive = FALSE;
+            data->win->UserData = (APTR)data;
+
+			/* Menu */
+            if (!fullscreen) {
+                data->menuvisualinfo = GetVisualInfoA(vd->WScreen, NULL);
+                if (data->menuvisualinfo) {
+                    data->menu = CreateMenusA(SDL_NewMenu, NULL);
+                    if (data->menu) {
+                        if (!LayoutMenusA(data->menu, data->menuvisualinfo, NULL)) {
+                            ClearMenuStrip(data->win);
+                            FreeMenus(data->menu);
+                            FreeVisualInfo(data->menuvisualinfo);
+                            data->menuactive = FALSE;
+                        } else {
+                            data->menuactive = TRUE;
+                        }
+                    } else {
+                        FreeVisualInfo(data->menuvisualinfo);
+                        data->menuactive = FALSE;
+                    }
+                }
+            } else {
+				ScreenToFront(vd->CustomScreen);
+			}
+
+            if (data->menuactive == TRUE) {
+				if (SetMenuStrip(data->win, data->menu)) {
+#if (0)
+					char *val = AROS_GetEnv("SDL_THREAD_PRIORITY_POLICY");
+					if (val && strlen(val)>0 && strcmp(val, "-1")==0) {
+						SDL_SetThreadPriority(SDL_THREAD_PRIORITY_LOW);
+						AROS_GlobalMenu(data->menu, 1, 1, 0, 1);
+					}
+					val = AROS_GetEnv("SDL_RENDER_DRIVER");
+					if (val && strlen(val)>0) {					
+						AROS_GlobalMenu(data->menu, 1, 3, 0, 0);
+						AROS_GlobalMenu(data->menu, 1, 3, 1, (strcmp(val, "opengl")==0 ? 1 : 0));
+						AROS_GlobalMenu(data->menu, 1, 3, 2, (strcmp(val, "opengl")==0 ? 0 : 1));
+						SDL_SetHint(SDL_HINT_RENDER_DRIVER, (strcmp(val, "opengl")==0 ? "opengl" : "software"));
+					}
+					val = AROS_GetEnv("SDL_RENDER_VSYNC");
+					if (val && strlen(val)>0) {
+						AROS_GlobalMenu(data->menu, 1, 4, 0, 0);
+						AROS_GlobalMenu(data->menu, 1, 4, 1, (strcmp(val, "1")==0 ? 1 : 0));
+						AROS_GlobalMenu(data->menu, 1, 4, 2, (strcmp(val, "1")==0 ? 0 : 1));
+						SDL_SetHint(SDL_HINT_RENDER_VSYNC, (strcmp(val, "1")==0 ? "1" :"0"));
+					}
+					val = AROS_GetEnv("SDL_RENDER_SCALE_QUALITY");
+					if (val && strlen(val)>0) {
+						AROS_GlobalMenu(data->menu, 1, 5, 0, 0);
+						AROS_GlobalMenu(data->menu, 1, 5, 1, (strcmp(val, "nearest")==0 ? 1 : 0));
+						AROS_GlobalMenu(data->menu, 1, 5, 2, (strcmp(val, "nearest")==0 ? 0 : 1));
+						SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, (strcmp(val, "nearest")==0 ? "nearest" : "linear"));
+					}
+					val = AROS_GetEnv("SDL_RENDER_LOGICAL_SIZE_MODE");
+					if (val && strlen(val)>0) {
+						AROS_GlobalMenu(data->menu, 1, 6, 0, 0);
+						AROS_GlobalMenu(data->menu, 1, 6, 1, (strcmp(val, "0")==0 ? 1 : 0));
+						AROS_GlobalMenu(data->menu, 1, 6, 2, (strcmp(val, "0")==0 ? 0 : 1));
+						SDL_SetHint(SDL_HINT_RENDER_LOGICAL_SIZE_MODE, (strcmp(val, "0")==0 ? "0" : "1"));
+					}
+					val = AROS_GetEnv("SDL_RENDER_BATCHING");
+					if (val && strlen(val)>0) {
+						AROS_GlobalMenu(data->menu, 1, 7, 0, 0);
+						AROS_GlobalMenu(data->menu, 1, 7, 1, (strcmp(val, "0")==0 ? 1 : 0));
+						AROS_GlobalMenu(data->menu, 1, 7, 2, (strcmp(val, "0")==0 ? 0 : 1));
+						SDL_SetHint(SDL_HINT_RENDER_BATCHING, (strcmp(val, "0")==0 ? "0" : "1"));
+					}
+					val = AROS_GetEnv("SDL_RENDER_LINE_METHOD");
+					if (val && strlen(val)>0) {
+						AROS_GlobalMenu(data->menu, 1, 8, 0, 0);
+						AROS_GlobalMenu(data->menu, 1, 8, 1, (strcmp(val, "1")==0 ? 1 : 0));
+						AROS_GlobalMenu(data->menu, 1, 8, 2, (strcmp(val, "2")==0 ? 1 : 0));
+						AROS_GlobalMenu(data->menu, 1, 8, 3, (strcmp(val, "3")==0 ? 1 : 0));
+						SDL_SetHint(SDL_HINT_RENDER_LINE_METHOD, (strcmp(val, "1")==0 ? "1" : (strcmp(val, "2")==0 ? "2" : "3")));
+					}
+					val = AROS_GetEnv("SDL_RENDER_OPENGL_SHADERS");
+					if (val && strlen(val)>0) {
+						AROS_GlobalMenu(data->menu, 1, 9, 0, 0);
+						AROS_GlobalMenu(data->menu, 1, 9, 1, (strcmp(val, "1")==0 ? 1 : 0));
+						AROS_GlobalMenu(data->menu, 1, 9, 2, (strcmp(val, "0")==0 ? 1 : 0));
+						SDL_SetHint(SDL_HINT_RENDER_OPENGL_SHADERS, (strcmp(val, "0")==0 ? "0" : "1"));
+					}
+#endif
+				}
+			}
+
+			if (!data->appmsg) {
+				data->appmsg = AddAppWindow(0, (IPTR)window, data->win, &vd->WBPort, TAG_DONE);
+				if (!data->appmsg)
+				{
+					D(bug("[SDL2:aroswindow] %s: ERROR AddAppWindow \n", __func__));
+				}
+			}
+			
+#if !defined(__AROS__)
+			if (data->grabbed > 0)
+				DoMethod((Object *)data->win, WM_ObtainEvents);
+#endif
+		}
+		
+	} else if (data->win) {
+		AROS_WindowToFront(data->win);
+	}
+}
+
+void
+AROS_ShowWindow(_THIS, SDL_Window *window)
+{
+	D(bug("[SDL2:aroswindow] %s()\n", __func__));
+
+	AROS_ShowWindow_Internal(_this, window);
+}
+
+void
+AROS_HideWindow(_THIS, SDL_Window *window)
+{
+	D(bug("[SDL2:aroswindow] %s()\n", __func__));
+
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+	
+	if (data->win) {
+		data->winflags &= ~SDL_AROS_WINDOW_SHOWN;
+		AROS_CloseWindowSafely(window, data->win);
+		data->win = NULL;
+	}
+	
+}
+
+void
+AROS_RaiseWindow(_THIS, SDL_Window * window)
+{
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+
+	D(bug("[SDL2:aroswindow] %s: wnd 0x%08lx\n", __func__, data->win));
+
+	if (data->win)
+		AROS_WindowToFront(data->win);
+}
+
+void
+AROS_MaximizeWindow(_THIS, SDL_Window * window)
+{
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+	SDL_VideoData *vd = (SDL_VideoData *) data->videodata;
+
+	D(bug("[SDL2:aroswindow] %s: wnd 0x%08lx - w=%d, h=%d\n", __func__, data->win, data->win->MaxWidth, data->win->MaxHeight));
+	
+	if (data->win && window->flags & SDL_WINDOW_RESIZABLE) {
+		
+		data->sdlflags |=  SDL_WINDOW_MAXIMIZED;
+		data->sdlflags &= ~SDL_WINDOW_MINIMIZED;
+		
+		ChangeWindowBox(data->win, 0, (vd->CustomScreen == NULL ? data->win->WScreen->BarHeight + 1 : 0), data->win->MaxWidth, data->win->MaxHeight);
+	}
+}
+
+void
+AROS_MinimizeWindow(_THIS, SDL_Window * window)
+{
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+
+	D(bug("[SDL2:aroswindow] %s: wnd 0x%08lx\n", __func__, data->win));
+
+	data->sdlflags |=  SDL_WINDOW_MINIMIZED;
+	data->sdlflags &= ~SDL_WINDOW_MAXIMIZED;
+
+	AROS_HideWindow(_this, window);
+}
+
+void
+AROS_RestoreWindow(_THIS, SDL_Window * window)
+{
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+
+	D(bug("[SDL2:aroswindow] %s: wnd 0x%08lx\n", __func__, data->win));
+
+	if (data->win) {
+		data->sdlflags &= ~(SDL_WINDOW_MINIMIZED | SDL_WINDOW_MAXIMIZED);
+
+		ChangeWindowBox(data->win, window->x, window->y, window->w, window->h);
+		AROS_WindowToFront(data->win);
+	}
+}
+
+void
+AROS_SetWindowFullscreen(_THIS, SDL_Window * window, SDL_VideoDisplay * _display, SDL_bool fullscreen)
+{
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+	SDL_VideoData *vd = data->videodata;
+
+	if (fullscreen) {
+		data->winflags |= SDL_AROS_WINDOW_FULLSCREEN;
+		if ((window->flags & SDL_WINDOW_FULLSCREEN_DESKTOP) == SDL_WINDOW_FULLSCREEN_DESKTOP) {
+			data->winflags |= SDL_AROS_WINDOW_FULLSCREEN_DESKTOP;
+		}	
+		int ww, hh;
+		SDL_GetWindowSize(window, &ww, &hh);
+		
+		data->old_x = data->curr_x;
+		data->old_y = data->curr_y;
+		data->old_w = ww;
+		data->old_h = hh;
+
+		D(bug("[SDL2:aroswindow] %s: Save actual position %d,%d and size %d,%d\n", __func__, data->old_x, data->old_y, data->old_w, data->old_h));
+		
+	} else {
+		
+		data->winflags &= ~SDL_AROS_WINDOW_FULLSCREEN;
+
+		if ((data->old_w && data->old_h) && (data->old_w != data->curr_w && data->old_h != data->curr_h)) {
+			D(bug("[SDL2:aroswindow] %s: Change position %d,%d and size %d,%d\n", __func__, data->old_x, data->old_y, data->old_w, data->old_h));
+			window->x = data->old_x;
+			window->y = data->old_y;
+			window->w = data->old_w;
+			window->h = data->old_h;
+			data->old_w = 0;
+			data->old_h = 0;
+			data->old_x = 0;
+			data->old_y = 0;		
+		}
+
+	}
+	vd->FullScreen = fullscreen;
+
+	AROS_OpenWindows(_this);
+}
+
+int
+AROS_SetWindowGammaRamp(_THIS, SDL_Window * window, const Uint16 * ramp)
+{
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+	SDL_VideoData *vd = data->videodata;
+	int i;
+
+	for (i = 0; i < 256; i++) {
+		vd->gammatable[0][i] = ramp[0*256 + i] >> 8;
+		vd->gammatable[1][i] = ramp[1*256 + i] >> 8;
+		vd->gammatable[2][i] = ramp[2*256 + i] >> 8;
+	}
+
+	if (vd->CustomScreen) {
+		SetAttrs(vd->CustomScreen,
+			SA_GammaRed,   (IPTR)vd->gammatable[0],
+			SA_GammaGreen, (IPTR)vd->gammatable[1],
+			SA_GammaBlue,  (IPTR)vd->gammatable[2],
+			TAG_DONE);
+	}
+
+	return 0;
+}
+
+void
+AROS_SetWindowGrab(_THIS, SDL_Window * window, SDL_bool grabbed)
+{
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+
+	if (data->win && data->grabbed != (grabbed ? 1 : 0)) {
+		D(bug("[SDL2:aroswindow] %s: %s\n", __func__, grabbed ? "grabbed" : "not grabbed"));
+
+		data->grabbed = grabbed ? 1 : 0;
+
+		if (grabbed && (data->win->Flags & WFLG_WINDOWACTIVE) == 0)
+			AROS_WindowToFront(data->win);
+#if !defined(__AROS__)
+		DoMethod((Object *)data->win, grabbed ? WM_ObtainEvents : WM_ReleaseEvents);
+#endif
+	}
+}
+
+void
+AROS_DestroyWindow(_THIS, SDL_Window * window)
+{
+	D(bug("[SDL2:aroswindow] %s()\n", __func__));
+
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+	
+	window->driverdata = NULL;
+
+	if (data) {
+		SDL_VideoData *videodata = (SDL_VideoData *) data->videodata;
+
+		REMOVE(&data->node);
+
+		if (data->win) {
+			AROS_CloseWindowSafely(window, data->win);
+			data->win = NULL;
+		}
+		if (data->region)
+			DisposeRegion(data->region);
+
+		if (IsListEmpty((struct List *)&videodata->windowlist)) {
+			D(bug("[SDL2:aroswindow] %s: Was last window... get rid of screen.\n", __func__));
+			AROS_CloseDisplay(_this);
+		}
+
+		SDL_free(data->window_title);
+		SDL_free(data);
+	}
+}
+
+SDL_bool
+AROS_GetWindowWMInfo(_THIS, SDL_Window * window, struct SDL_SysWMinfo * info)
+{
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+
+	if (info->version.major >= SDL_MAJOR_VERSION) {
+		info->subsystem = SDL_SYSWM_AROS;
+		info->info.intui.window = data->win;
+		return SDL_TRUE;
+	} else {
+		SDL_SetError("Application not compiled with SDL %d\n", SDL_MAJOR_VERSION);
+		return SDL_FALSE;
+	}
+}
+
+static void 
+AROS_CloseWindow(SDL_Window *window)
+{
+    SDL_WindowData *data = (SDL_WindowData *)window->driverdata;
+	D(bug("[SDL2:aroswindow] %s: 0x%08lx\n", __func__, data->win));
+
+    if (data->win) {
+        if (data->appmsg) {
+            if (RemoveAppWindow(data->appmsg)) {
+                data->appmsg = NULL;
+            }
+        }
+
+		struct Window *win = data->win;
+        if (data->menuactive == TRUE) {
+            ClearMenuStrip(win);
+            FreeMenus(data->menu);
+            data->menu = NULL;
+            FreeVisualInfo(data->menuvisualinfo);
+            data->menuvisualinfo = NULL;
+            data->menuactive = FALSE;
+        }
+        CloseWindow(win);
+        data->win = NULL;
+    }
+}
+
+void 
+AROS_RecreateWindow(_THIS, SDL_Window * window)
+{
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+	D(bug("[SDL2:aroswindow] %s: 0x%08lx\n", __func__, data->win));
+	
+    if (window->flags & SDL_WINDOW_FOREIGN) {
+		D(bug("[SDL2:aroswindow] %s: Cannot modify native window '%s'\n", __func__, window->title));
+        return;
+    }
+
+    if (data->win) {
+		D(bug("[SDL2:aroswindow] %s: Closing system window '%s' before re-creation\n", __func__, window->title));
+        AROS_CloseWindow(window);
+    }
+
+    AROS_ShowWindow_Internal(_this, window);
+
+    if (data->win) { // Make sure the new window is active
+        AROS_ShowWindow(_this, window);
+    }
+}
+
+void
+AROS_SetWindowAlwaysOnTop(_THIS, SDL_Window * window, SDL_bool on_top)
+{
+	D(bug("[SDL2:aroswindow] %s()\n", __func__));
+
+	AROS_RecreateWindow(_this, window);
+}
+
+/* int
+AROS_SetWindowHitTest(SDL_Window *window, SDL_bool enabled)
+{
+    return 0;
+}*/
+
+void
+AROS_SetWindowResizable(_THIS, SDL_Window * window, SDL_bool resizable)
+{
+	D(bug("[SDL2:aroswindow] %s()\n", __func__));
+
+	AROS_RecreateWindow(_this, window);
+}
+
+void
+AROS_SetWindowBordered(_THIS, SDL_Window * window, SDL_bool bordered)
+{
+	D(bug("[SDL2:aroswindow] %s()\n", __func__));
+
+	AROS_RecreateWindow(_this, window);
+}
+
+static SDL_bool
+AROS_SetWindowOpacityPrivate(_THIS, SDL_Window * window, ULONG value)
+{
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+	
+	LONG ret = 0;
+#if !defined(__AROS__)
+	ret = SetAttrs(data->win, WA_Opacity, value, TAG_DONE);
+#endif
+	if (ret) {
+		D(bug("[SDL2:aroswindow] %s: Failed to set window opaqueness to %lu\n", __func__, value));
+		return SDL_FALSE;
+	}
+
+	return SDL_TRUE;
+}
+
+int
+AROS_SetWindowOpacity(_THIS, SDL_Window * window, float opacity)
+{
+    SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+	if (!data->win) 
+		return 0;
+	
+    ULONG value = ((opacity) * (ULONG_MAX));
+
+	D(bug("[SDL2:aroswindow] %s: set window opaqueness to %lu\n", __func__, value));
+	int ret = 0;
+#if !defined(__AROS__)
+	ret = AROS_SetWindowOpacityPrivate(_this, window, value) ? 0 : -1;
+#endif
+    return ret;
+}
+
+static void
+AROS_FlashOperationPrivate(_THIS, SDL_Window * window)
+{
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+    if (data->win) {
+
+		ULONG value_old = 0;
+#if !defined(__AROS__)
+		value_old = getv(data->win, WA_Opacity);
+#endif
+		WindowToFront(data->win);
+		const Uint32 start = SDL_GetTicks();
+		ULONG elapsed = 0;
+		ULONG value = 0;
+		
+		while (TRUE) {
+			elapsed = SDL_GetTicks() - start;
+			if (elapsed > 200) break;
+			value = 128 + 127 * sinf(elapsed * 3.14159f / 50.0f) * (ULONG_MAX);
+			AROS_SetWindowOpacityPrivate(_this, window, value);	
+			SDL_Delay(1);
+		}
+		
+		ActivateWindow(data->win);
+		AROS_SetWindowOpacityPrivate(_this, window, value_old);
+	}
+}
+
+int
+AROS_FlashWindow(_THIS, SDL_Window * window, SDL_FlashOperation operation)
+{
+	D(bug("[SDL2:aroswindow] %s()\n", __func__));
+
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+	if (!data->win) 
+		return 0;
+	
+	switch(operation)
+	{
+		case SDL_FLASH_BRIEFLY:
+		case SDL_FLASH_UNTIL_FOCUSED:
+			AROS_FlashOperationPrivate(_this, window);
+			break;
+		case SDL_FLASH_CANCEL:
+			break;
+	}
+	
+	return 0;
+}
+
+int
+AROS_GetWindowBordersSize(_THIS, SDL_Window * window, int *top, int *left, int *bottom, int *right)
+{
+	SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+	
+	if (top)
+		*top = data->win->BorderTop;
+	
+	if (left)
+		*left = data->win->BorderLeft;
+	
+	if (bottom)
+		*bottom = data->win->BorderBottom;
+	
+	if (right)
+		*right = data->win->BorderRight;	
+	
+	return 0;
+}
diff -ruN SDL2-2.32.8/src/video/aros/SDL_aroswindow.h SDL2-2.32.8.aros/src/video/aros/SDL_aroswindow.h
--- SDL2-2.32.8/src/video/aros/SDL_aroswindow.h	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/src/video/aros/SDL_aroswindow.h	2025-08-11 00:37:06.556441007 +0000
@@ -0,0 +1,136 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifndef _SDL_aroswindow_h
+#define _SDL_aroswindow_h
+
+#ifndef EXEC_NODES_H
+#include <exec/nodes.h>
+#endif
+
+#include <GL/gla.h>
+#include <proto/gadtools.h>
+
+enum
+{
+	MID_PROJECT = 0x0010,
+	MID_ABOUT,
+	MID_JOYSTICK,
+	MID_ABOUTSYS,
+	MID_HIDE,
+	MID_QUIT,
+	MID_OPTIONS,
+	MID_MUTE,
+	MID_PRIORITY,
+	MID_RRENDER, MID_RRAUTO, MID_RRGL, MID_RRSOFT,
+	MID_RVSYNC, MID_RVAUTO, MID_RVENABLE, MID_RVDISABLE,
+	MID_RSCALER, MID_AUTO, MID_NEAREST, MID_LINEAR,
+	MID_LLOGICAL, MID_LAUTO, MID_LLETTER,MID_LOVERS,
+	MID_RBATCHING, MID_BAUTO, MID_BENABLE, MID_BDISABLE,
+	MID_SHADERS, MID_SHADERS_AUTO, MID_SHADERS_ENABLE, MID_SHADERS_DISABLE, 
+	MID_RMETHOD, MID_MDEF, MID_MPOINT, MID_MLINE, MID_MGEO
+};
+
+typedef struct
+{
+	Uint32 kludge1, kludge2, bpr, pixfmt;
+	Uint8 buffer[0];
+} SDL_Framebuffer;
+
+typedef struct
+{
+	struct MinNode node;
+
+	struct Region *region;
+	SDL_Framebuffer *fb;
+
+	SDL_Window *window;
+	struct Window *win;
+	struct AppWindow *appmsg;
+
+	// Localized window title, use SDL_free() to deallocate
+	char *window_title;
+
+	struct SDL_VideoData *videodata;
+
+	GLAContext *__AGLCtx;
+	
+	// Currently known window position and dimensions
+	LONG curr_x, curr_y, curr_w, curr_h;
+	int old_w, old_h, old_x, old_y;
+
+	// Flags that must be taken into account at AROS_ShowWindow()
+	Uint32 sdlflags;
+
+	BYTE grabbed;
+	BYTE first_deltamove;
+	BYTE winflags;
+	
+	APTR menuvisualinfo;
+	struct Menu *menu;
+	BOOL menuactive;
+	
+	struct BitMap *bitmap;
+	APTR memfb;
+} SDL_WindowData;
+
+/* Is this window shown (not iconified) */
+#define SDL_AROS_WINDOW_SHOWN      (1 << 0)
+#define SDL_AROS_WINDOW_FULLSCREEN (1 << 1)
+#define SDL_AROS_WINDOW_FULLSCREEN_DESKTOP (1 << 2)
+
+/* SDL functions */
+extern int AROS_CreateWindow(_THIS, SDL_Window * window);
+extern int AROS_CreateWindowFrom(_THIS, SDL_Window * window, const void *data);
+extern void AROS_SetWindowTitle(_THIS, SDL_Window * window);
+extern void AROS_SetWindowIcon(_THIS, SDL_Window * window, SDL_Surface * icon);
+extern void AROS_SetWindowPosition(_THIS, SDL_Window * window);
+extern void AROS_SetWindowMinimumSize(_THIS, SDL_Window * window);
+extern void AROS_SetWindowMaximumSize(_THIS, SDL_Window * window);
+extern void AROS_SetWindowSize(_THIS, SDL_Window * window);
+extern void AROS_ShowWindow(_THIS, SDL_Window * window);
+extern void AROS_HideWindow(_THIS, SDL_Window * window);
+extern void AROS_RaiseWindow(_THIS, SDL_Window * window);
+extern void AROS_MaximizeWindow(_THIS, SDL_Window * window);
+extern void AROS_MinimizeWindow(_THIS, SDL_Window * window);
+extern void AROS_RestoreWindow(_THIS, SDL_Window * window);
+extern void AROS_SetWindowBordered(_THIS, SDL_Window * window, SDL_bool bordered);
+extern void AROS_SetWindowFullscreen(_THIS, SDL_Window * window, SDL_VideoDisplay * display, SDL_bool fullscreen);
+extern int AROS_SetWindowGammaRamp(_THIS, SDL_Window * window, const Uint16 * ramp);
+extern void AROS_SetWindowGrab(_THIS, SDL_Window * window, SDL_bool grabbed);
+extern void AROS_DestroyWindow(_THIS, SDL_Window * window);
+extern SDL_bool AROS_GetWindowWMInfo(_THIS, SDL_Window * window, struct SDL_SysWMinfo *info);
+extern void AROS_ShowWindow_Internal(_THIS, SDL_Window * window);
+extern void AROS_SetWindowAlwaysOnTop(_THIS, SDL_Window * window, SDL_bool on_top);
+extern void AROS_SetWindowResizable (_THIS, SDL_Window * window, SDL_bool resizable);
+extern int AROS_SetWindowOpacity(_THIS, SDL_Window * window, float opacity);
+extern int AROS_GetWindowBordersSize(_THIS, SDL_Window * window, int * top, int * left, int * bottom, int * right);
+extern int AROS_FlashWindow(_THIS, SDL_Window * window, SDL_FlashOperation);
+//extern int AROS_SetWindowHitTest(SDL_Window *window, SDL_bool enabled);
+
+/* Non-SDL functions */
+extern void AROS_CloseWindows(_THIS);
+extern void AROS_OpenWindows(_THIS);
+extern void AROS_RecreateWindow(_THIS, SDL_Window * window);
+extern void AROS_WindowToFront(struct Window *win);
+
+#endif /* _SDL_aroswindow_h */
diff -ruN SDL2-2.32.8/src/video/SDL_sysvideo.h SDL2-2.32.8.aros/src/video/SDL_sysvideo.h
--- SDL2-2.32.8/src/video/SDL_sysvideo.h	2025-05-19 21:24:41.000000000 +0000
+++ SDL2-2.32.8.aros/src/video/SDL_sysvideo.h	2025-07-27 14:24:21.564841406 +0000
@@ -484,6 +484,9 @@
 extern VideoBootStrap NGAGE_bootstrap;
 extern VideoBootStrap OS2DIVE_bootstrap;
 extern VideoBootStrap OS2VMAN_bootstrap;
+extern VideoBootStrap MORPHOS_bootstrap;
+extern VideoBootStrap AROS_bootstrap;
+
 
 /* Use SDL_OnVideoThread() sparingly, to avoid regressions in use cases that currently happen to work */
 extern SDL_bool SDL_OnVideoThread(void);
diff -ruN SDL2-2.32.8/src/video/SDL_video.c SDL2-2.32.8.aros/src/video/SDL_video.c
--- SDL2-2.32.8/src/video/SDL_video.c	2025-05-19 21:24:41.000000000 +0000
+++ SDL2-2.32.8.aros/src/video/SDL_video.c	2025-08-03 22:32:07.312795313 +0000
@@ -132,6 +132,12 @@
 #ifdef SDL_VIDEO_DRIVER_EMSCRIPTEN
     &Emscripten_bootstrap,
 #endif
+#ifdef SDL_VIDEO_DRIVER_AROS
+    &AROS_bootstrap,
+#endif
+#ifdef SDL_VIDEO_DRIVER_MORPHOS
+    &MORPHOS_bootstrap,
+#endif
 #ifdef SDL_VIDEO_DRIVER_QNX
     &QNX_bootstrap,
 #endif
@@ -1314,6 +1320,10 @@
                 SDL_SendWindowEvent(window, SDL_WINDOWEVENT_RESIZED, fullscreen_mode.w, fullscreen_mode.h);
 #endif
             }
+#if defined(__MORPHOS__) || defined(__AROS__)
+            // Force window on new screen
+            _this->SetWindowFullscreen(_this, window, SDL_GetDisplayForWindow(window), SDL_TRUE);
+#endif
         }
     }
     return 0;
@@ -2701,6 +2711,9 @@
 #if defined(__EMSCRIPTEN__)
         attempt_texture_framebuffer = SDL_FALSE;
 #endif
+#if defined(__MORPHOS__) || defined(__AROS__)
+		attempt_texture_framebuffer = SDL_FALSE;
+#endif
     }
     return attempt_texture_framebuffer;
 }
@@ -3240,7 +3253,9 @@
 
 static SDL_bool ShouldMinimizeOnFocusLoss(SDL_Window *window)
 {
+#if !defined(__MORPHOS__) && !defined(__AROS__)
     const char *hint;
+#endif
 
     if (!(window->flags & SDL_WINDOW_FULLSCREEN) || window->is_destroying) {
         return SDL_FALSE;
@@ -3263,6 +3278,7 @@
     }
 #endif
 
+#if !defined(__MORPHOS__) && !defined(__AROS__)
     /* Real fullscreen windows should minimize on focus loss so the desktop video mode is restored */
     hint = SDL_GetHint(SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS);
     if (!hint || !*hint || SDL_strcasecmp(hint, "auto") == 0) {
@@ -3273,6 +3289,8 @@
             return SDL_TRUE;
         }
     }
+#endif
+
     return SDL_GetHintBoolean(SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS, SDL_FALSE);
 }
 
@@ -3341,7 +3359,12 @@
     /* Make no context current if this is the current context window */
     if (window->flags & SDL_WINDOW_OPENGL) {
         if (_this->current_glwin == window) {
+#if defined(__MORPHOS__)
+            // Hack to kill context before destroy window (in case when user doesnt call SDL_GL_DeleteContext !)
+            SDL_GL_DeleteContext(_this->current_glctx);
+#else
             SDL_GL_MakeCurrent(window, NULL);
+#endif
         }
     }
 
diff -ruN SDL2-2.32.8/test/checkkeys.c SDL2-2.32.8.aros/test/checkkeys.c
--- SDL2-2.32.8/test/checkkeys.c	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/test/checkkeys.c	2025-07-27 14:24:22.628841422 +0000
@@ -305,7 +305,8 @@
         loop();
     }
 #endif
-
+	SDL_DestroyRenderer(renderer);
+	SDL_DestroyWindow(window);
     SDL_Quit();
     return 0;
 }
diff -ruN SDL2-2.32.8/test/controllermap.c SDL2-2.32.8.aros/test/controllermap.c
--- SDL2-2.32.8/test/controllermap.c	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/test/controllermap.c	2025-07-27 14:24:22.668841422 +0000
@@ -741,6 +741,10 @@
         return 2;
     }
 
+#ifdef __MORPHOS__	
+	SDL_RenderClear(screen);
+#endif
+
     while (!done && SDL_NumJoysticks() == 0) {
         SDL_Event event;
 
@@ -802,7 +806,7 @@
 
     SDL_DestroyWindow(window);
 
-    SDL_QuitSubSystem(SDL_INIT_VIDEO | SDL_INIT_JOYSTICK);
+    SDL_Quit();
 
     return 0;
 }
diff -ruN SDL2-2.32.8/test/testfile.c SDL2-2.32.8.aros/test/testfile.c
--- SDL2-2.32.8/test/testfile.c	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/test/testfile.c	2025-07-27 14:24:22.984841427 +0000
@@ -64,6 +64,11 @@
     SDL_RWops *rwops = NULL;
     char test_buf[30];
 
+    if (SDL_Init(0) == -1) {
+        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "SDL_Init() failed: %s\n", SDL_GetError());
+        return 1;
+    }
+
     /* Enable standard application logging */
     SDL_LogSetPriority(SDL_LOG_CATEGORY_APPLICATION, SDL_LOG_PRIORITY_INFO);
 
@@ -353,5 +358,8 @@
     rwops->close(rwops);
     SDL_Log("test5 OK\n");
     cleanup();
+
+    SDL_Quit();
+
     return 0; /* all ok */
 }
diff -ruN SDL2-2.32.8/test/testgamecontroller.c SDL2-2.32.8.aros/test/testgamecontroller.c
--- SDL2-2.32.8/test/testgamecontroller.c	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/test/testgamecontroller.c	2025-07-27 14:24:23.000841427 +0000
@@ -967,7 +967,7 @@
     CloseVirtualController();
     SDL_DestroyRenderer(screen);
     SDL_DestroyWindow(window);
-    SDL_QuitSubSystem(SDL_INIT_VIDEO | SDL_INIT_JOYSTICK | SDL_INIT_GAMECONTROLLER);
+    SDL_Quit();
 
     return 0;
 }
diff -ruN SDL2-2.32.8/test/testgl2.c SDL2-2.32.8.aros/test/testgl2.c
--- SDL2-2.32.8/test/testgl2.c	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/test/testgl2.c	2025-07-27 14:24:23.016841427 +0000
@@ -22,6 +22,9 @@
 
 #ifdef HAVE_OPENGL
 
+#ifdef __MORPHOS__
+#define _NO_PPCINLINE
+#endif
 #include "SDL_opengl.h"
 
 typedef struct GL_Context
diff -ruN SDL2-2.32.8/test/testhaptic.c SDL2-2.32.8.aros/test/testhaptic.c
--- SDL2-2.32.8/test/testhaptic.c	2024-01-22 22:20:00.000000000 +0000
+++ SDL2-2.32.8.aros/test/testhaptic.c	2025-07-27 14:24:23.052841428 +0000
@@ -99,6 +99,7 @@
         HapticPrintSupported(haptic);
     } else {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "No Haptic devices found!\n");
+        SDL_Quit();
         return 1;
     }
 
diff -ruN SDL2-2.32.8/test/testnativeamigaos.c SDL2-2.32.8.aros/test/testnativeamigaos.c
--- SDL2-2.32.8/test/testnativeamigaos.c	1970-01-01 00:00:00.000000000 +0000
+++ SDL2-2.32.8.aros/test/testnativeamigaos.c	2025-07-29 13:10:38.697400191 +0000
@@ -0,0 +1,45 @@
+/*
+  Copyright (C) 1997-2017 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely.
+*/
+
+#include "testnative.h"
+
+#ifdef TEST_NATIVE_AMIGAOS
+
+#include <proto/intuition.h>
+
+static void *
+CreateWindowAmigaOS(int w, int h)
+{
+	struct Window *window = OpenWindowTags(NULL,
+		WA_InnerWidth, w,
+		WA_InnerHeight, h,
+		WA_Title, "Native window",
+		WA_IDCMP, IDCMP_CLOSEWINDOW,
+		TAG_DONE);
+
+	return (void *) window;
+}
+
+static void
+DestroyWindowAmigaOS(void *window)
+{
+	CloseWindow(window);
+}
+
+NativeWindowFactory AmigaOSWindowFactory = {
+    "mos",
+    CreateWindowAmigaOS,
+    DestroyWindowAmigaOS
+};
+
+#endif
+
diff -ruN SDL2-2.32.8/test/testnative.c SDL2-2.32.8.aros/test/testnative.c
--- SDL2-2.32.8/test/testnative.c	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/test/testnative.c	2025-07-29 13:13:12.805400295 +0000
@@ -36,6 +36,9 @@
 #ifdef TEST_NATIVE_OS2
     &OS2WindowFactory,
 #endif
+#ifdef TEST_NATIVE_AMIGAOS
+    &AmigaOSWindowFactory,
+#endif
     NULL
 };
 static NativeWindowFactory *factory = NULL;
@@ -46,10 +49,13 @@
 static void
 quit(int rc)
 {
-    SDL_VideoQuit();
     if (native_window && factory) {
         factory->DestroyNativeWindow(native_window);
     }
+
+    SDL_VideoQuit();
+    SDL_Quit();
+
     exit(rc);
 }
 
@@ -177,8 +183,15 @@
     }
 
     /* Main render loop */
+#ifdef TEST_NATIVE_AMIGAOS
+	done = 2000;
+	while (done) {
+		done--;
+		SDL_Delay(5);
+#else
     done = 0;
     while (!done) {
+#endif
         /* Check for events */
         while (SDL_PollEvent(&event)) {
             switch (event.type) {
@@ -200,6 +213,8 @@
         MoveSprites(renderer, sprite);
     }
 
+    SDL_DestroyRenderer(renderer);
+
     quit(0);
 
     return 0; /* to prevent compiler warning */
diff -ruN SDL2-2.32.8/test/testnative.h SDL2-2.32.8.aros/test/testnative.h
--- SDL2-2.32.8/test/testnative.h	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/test/testnative.h	2025-07-29 13:11:40.633400415 +0000
@@ -49,3 +49,13 @@
 #define TEST_NATIVE_OS2
 extern NativeWindowFactory OS2WindowFactory;
 #endif
+
+#ifdef SDL_VIDEO_DRIVER_MORPHOS
+#define TEST_NATIVE_AMIGAOS
+extern NativeWindowFactory AmigaOSWindowFactory;
+#endif
+
+#ifdef SDL_VIDEO_DRIVER_AROS
+#define TEST_NATIVE_AMIGAOS
+extern NativeWindowFactory AmigaOSWindowFactory;
+#endif
diff -ruN SDL2-2.32.8/test/testoffscreen.c SDL2-2.32.8.aros/test/testoffscreen.c
--- SDL2-2.32.8/test/testoffscreen.c	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/test/testoffscreen.c	2025-07-27 14:24:23.160841429 +0000
@@ -107,6 +107,7 @@
     if (SDL_VideoInit("offscreen") < 0) {
         SDL_Log("Couldn't initialize the offscreen video driver: %s\n",
                 SDL_GetError());
+        SDL_Quit();
         return SDL_FALSE;
     }
 
diff -ruN SDL2-2.32.8/test/testrumble.c SDL2-2.32.8.aros/test/testrumble.c
--- SDL2-2.32.8/test/testrumble.c	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/test/testrumble.c	2025-07-27 14:24:23.208841430 +0000
@@ -98,6 +98,7 @@
         SDL_Log("Device: %s\n", SDL_HapticName(i));
     } else {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "No Haptic devices found!\n");
+        SDL_Quit();
         return 1;
     }
 
diff -ruN SDL2-2.32.8/test/testshape.c SDL2-2.32.8.aros/test/testshape.c
--- SDL2-2.32.8/test/testshape.c	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/test/testshape.c	2025-07-27 14:24:23.236841430 +0000
@@ -112,7 +112,8 @@
         }
         SDL_free(pictures);
         SDL_VideoQuit();
-        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not create shaped window for SDL_Shape.");
+        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not create shaped window for SDL_Shape. %s", SDL_GetError());
+        SDL_Quit();
         exit(-4);
     }
     renderer = SDL_CreateRenderer(window, -1, 0);
@@ -204,6 +205,7 @@
     SDL_free(pictures);
     /* Call SDL_VideoQuit() before quitting. */
     SDL_VideoQuit();
+    SDL_Quit();
 
     return 0;
 }
diff -ruN SDL2-2.32.8/test/torturethread.c SDL2-2.32.8.aros/test/torturethread.c
--- SDL2-2.32.8/test/torturethread.c	2025-01-01 15:47:53.000000000 +0000
+++ SDL2-2.32.8.aros/test/torturethread.c	2025-07-27 14:24:23.348841432 +0000
@@ -88,7 +88,9 @@
         return 1;
     }
 
+#ifndef __MORPHOS__
     (void)signal(SIGSEGV, SIG_DFL);
+#endif
     for (i = 0; i < NUMTHREADS; i++) {
         char name[64];
         (void)SDL_snprintf(name, sizeof(name), "Parent%d", i);
diff -ruN SDL2-2.32.8/WhatsNew.txt SDL2-2.32.8.aros/WhatsNew.txt
--- SDL2-2.32.8/WhatsNew.txt	2024-01-28 03:46:25.000000000 +0000
+++ SDL2-2.32.8.aros/WhatsNew.txt	2025-07-27 14:24:24.824841453 +0000
@@ -77,6 +77,9 @@
 * Enabled IME soft keyboard input
 * Added version checking to make sure the SDL Java and C code are compatible
 
+MorphOS:
+* fix redraw surface after iconify window (fix bug with liteXL)
+
 
 ---------------------------------------------------------------------------
 2.24.0:
