diff -ruN openal-soft-1.19.1/Alc/ALc.c openal-soft-1.19.1.aros/Alc/ALc.c
--- openal-soft-1.19.1/Alc/ALc.c	2018-10-11 22:05:31.000000000 +0000
+++ openal-soft-1.19.1.aros/Alc/ALc.c	2025-08-02 16:25:17.312099898 +0000
@@ -63,6 +63,9 @@
 };
 
 static struct BackendInfo BackendList[] = {
+#ifdef HAVE_AHI
+    { "ahi", ALCahiBackendFactory_getFactory },
+#endif
 #ifdef HAVE_JACK
     { "jack", ALCjackBackendFactory_getFactory },
 #endif
@@ -1000,7 +1003,7 @@
     }
     FillCPUCaps(capfilter);
 
-#ifdef _WIN32
+#if defined(_WIN32) || defined(__amigaos4__)
     RTPrioLevel = 1;
 #else
     RTPrioLevel = 0;
diff -ruN openal-soft-1.19.1/Alc/backends/ahi.c openal-soft-1.19.1.aros/Alc/backends/ahi.c
--- openal-soft-1.19.1/Alc/backends/ahi.c	1970-01-01 00:00:00.000000000 +0000
+++ openal-soft-1.19.1.aros/Alc/backends/ahi.c	2025-08-02 20:37:18.352892723 +0000
@@ -0,0 +1,384 @@
+/**
+ * OpenAL cross platform audio library
+ * Copyright (C) 1999-2007 by authors.
+ * This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ *  License along with this library; if not, write to the
+ *  Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ *  Boston, MA  02111-1307, USA.
+ * Or go to http://www.gnu.org/copyleft/lgpl.html
+ */
+
+#include "config.h"
+
+#include <sys/ioctl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+#include <math.h>
+
+#include "alMain.h"
+#include "alu.h"
+#include "alconfig.h"
+#include "ringbuffer.h"
+#include "threads.h"
+#include "compat.h"
+
+#include "backends/base.h"
+
+#include <devices/ahi.h>
+#include <proto/exec.h>
+
+static const ALCchar ahi_device[] = "AHI Default";
+
+static const char *ahi_driver = "ahi.device";
+
+typedef struct ALCplaybackAHI {
+	DERIVE_FROM_TYPE(ALCbackend);
+
+	int ahi_fmt;
+
+	struct MsgPort *ahip;
+	struct AHIRequest *ahir[2];
+	struct AHIRequest *link;
+
+	ALubyte *mix_data[2];
+	int data_size;
+
+	volatile int killNow;
+	althrd_t thread;
+} ALCplaybackAHI;
+
+
+typedef struct {
+    al_string name;
+    al_string device_name;
+} DevMap;
+TYPEDEF_VECTOR(DevMap, vector_DevMap)
+
+static vector_DevMap PlaybackDevices;
+static vector_DevMap CaptureDevices;
+
+static void clear_devlist(vector_DevMap *devlist)
+{
+#define FREE_DEV(i) do {                                                      \
+    AL_STRING_DEINIT((i)->name);                                              \
+    AL_STRING_DEINIT((i)->device_name);                                       \
+} while(0)
+    VECTOR_FOR_EACH(DevMap, *devlist, FREE_DEV);
+    VECTOR_RESIZE(*devlist, 0, 0);
+#undef FREE_DEV
+}
+
+static int ALCplaybackAHI_mixerProc(void *ptr);
+
+static void ALCplaybackAHI_Construct(ALCplaybackAHI *self, ALCdevice *device);
+static DECLARE_FORWARD(ALCplaybackAHI, ALCbackend, void, Destruct)
+static ALCenum ALCplaybackAHI_open(ALCplaybackAHI *self, const ALCchar *name);
+static void ALCplaybackAHI_close(ALCplaybackAHI *self);
+static ALCboolean ALCplaybackAHI_reset(ALCplaybackAHI *self);
+static ALCboolean ALCplaybackAHI_start(ALCplaybackAHI *self);
+static void ALCplaybackAHI_stop(ALCplaybackAHI *self);
+static DECLARE_FORWARD2(ALCplaybackAHI, ALCbackend, ALCenum, captureSamples, ALCvoid*, ALCuint)
+static DECLARE_FORWARD(ALCplaybackAHI, ALCbackend, ALCuint, availableSamples)
+static DECLARE_FORWARD(ALCplaybackAHI, ALCbackend, ClockLatency, getClockLatency)
+static DECLARE_FORWARD(ALCplaybackAHI, ALCbackend, void, lock)
+static DECLARE_FORWARD(ALCplaybackAHI, ALCbackend, void, unlock)
+DECLARE_DEFAULT_ALLOCATORS(ALCplaybackAHI)
+DEFINE_ALCBACKEND_VTABLE(ALCplaybackAHI);
+
+static int ALCplaybackAHI_mixerProc(void *ptr) {
+	ALCplaybackAHI *self = (ALCplaybackAHI*)ptr;
+	ALCdevice *device = STATIC_CAST(ALCbackend, self)->mDevice;
+	struct MsgPort *ahip = self->ahip;
+	ALint frameSize;
+	ALint cb = 0;
+
+    SetRTPriority();
+    althrd_setname(althrd_current(), MIXER_THREAD_NAME);
+
+	ahip->mp_SigTask = FindTask(NULL);
+	ahip->mp_SigBit = AllocSignal(-1);
+	ahip->mp_Flags = PA_SIGNAL;
+
+	frameSize = FrameSizeFromDevFmt(device->FmtChans, device->FmtType, device->AmbiOrder);
+
+	while(!self->killNow && ATOMIC_LOAD(&device->Connected, almemory_order_acquire)) {
+		ALint len = self->data_size;
+		ALubyte *WritePtr = self->mix_data[cb];
+		struct AHIRequest *ahir = self->ahir[cb];
+
+		aluMixData(device, WritePtr, len/frameSize);
+
+		ahir->ahir_Std.io_Message.mn_Node.ln_Pri = 127;
+		ahir->ahir_Std.io_Command = CMD_WRITE;
+		ahir->ahir_Std.io_Data    = WritePtr;
+		ahir->ahir_Std.io_Length  = len;
+		ahir->ahir_Frequency = device->Frequency;
+		ahir->ahir_Type      = self->ahi_fmt;
+		ahir->ahir_Volume    = 0x10000;
+		ahir->ahir_Position  = 0x8000;
+		ahir->ahir_Link      = self->link;
+	   	SendIO((struct IORequest*)ahir);
+
+		if(self->link != NULL) {
+			WaitIO((struct IORequest*)self->link);
+		}
+
+		self->link = ahir;
+		cb ^= 1;
+	}
+
+	if(self->link != NULL) {
+		WaitIO((struct IORequest*)self->link);
+	}
+
+	ahip->mp_Flags = PA_IGNORE;
+	FreeSignal(ahip->mp_SigBit);
+	ahip->mp_SigTask = NULL;
+	ahip->mp_SigBit = -1;
+
+	return 0;
+}
+
+static void ALCplaybackAHI_Construct(ALCplaybackAHI *self, ALCdevice *device) {
+	ALCbackend_Construct(STATIC_CAST(ALCbackend, self), device);
+	SET_VTABLE2(ALCplaybackAHI, ALCbackend, self);
+}
+
+static int get_ahi_format(ALCdevice *device) {
+	switch(ChannelsFromDevFmt(device->FmtChans, device->AmbiOrder)) {
+	case 1:
+		switch(device->FmtType) {
+		case DevFmtUByte:
+			device->FmtType = DevFmtByte;
+		case DevFmtByte:
+			return AHIST_M8S;
+		case DevFmtUShort:
+			device->FmtType = DevFmtShort;
+		case DevFmtShort:
+			return AHIST_M16S;
+		case DevFmtUInt:
+		case DevFmtFloat:
+			device->FmtType = DevFmtInt;
+		case DevFmtInt:
+			return AHIST_M32S;
+		default:
+			break;
+		}
+		break;
+	case 2:
+		switch(device->FmtType) {
+		case DevFmtUByte:
+			device->FmtType = DevFmtByte;
+		case DevFmtByte:
+			return AHIST_S8S;
+		case DevFmtUShort:
+			device->FmtType = DevFmtShort;
+		case DevFmtShort:
+			return AHIST_S16S;
+		case DevFmtUInt:
+		case DevFmtFloat:
+			device->FmtType = DevFmtInt;
+		case DevFmtInt:
+			return AHIST_S32S;
+		default:
+			break;
+		}
+		break;
+	default:
+		break;
+	}
+	ERR("Unknown format?! chans: %d type: %d\n", device->FmtChans, device->FmtType);
+	return -1;
+}
+
+static ALCenum ALCplaybackAHI_open(ALCplaybackAHI *self, const ALCchar *name) {
+	ALCdevice *device = STATIC_CAST(ALCbackend, self)->mDevice;
+
+	if(!name)
+		name = ahi_device;
+	else if(strcmp(name, ahi_device) != 0)
+		return ALC_INVALID_VALUE;
+
+	self->killNow = 0;
+
+	self->ahi_fmt = get_ahi_format(device);
+	if(self->ahi_fmt == -1)
+		return ALC_INVALID_VALUE;
+
+	self->ahip = CreateMsgPort();
+
+	self->ahir[0] = (struct AHIRequest*)CreateIORequest(self->ahip, sizeof(struct AHIRequest));
+	if(self->ahir[0] == NULL) {
+		return ALC_OUT_OF_MEMORY;
+	}
+
+	self->ahir[0]->ahir_Version = 4;
+
+	if(OpenDevice("ahi.device", AHI_DEFAULT_UNIT, (struct IORequest *)self->ahir[0], 0)
+		!= 0)
+	{
+		return ALC_OUT_OF_MEMORY;
+	}
+
+	self->ahir[1] = (struct AHIRequest*)CreateIORequest(self->ahip, sizeof(struct AHIRequest));
+	if(self->ahir[1] == NULL) {
+		return ALC_OUT_OF_MEMORY;
+	}
+
+        CopyMem(self->ahir[0], self->ahir[1], sizeof(struct AHIRequest));
+
+	alstr_copy_cstr(&device->DeviceName, name);
+
+	return ALC_NO_ERROR;
+}
+
+static void ALCplaybackAHI_close(ALCplaybackAHI *self) {
+	CloseDevice((struct IORequest*)self->ahir[0]);
+	DeleteIORequest(self->ahir[1]);
+	DeleteIORequest(self->ahir[0]);
+	self->ahir[0] = self->ahir[1] = NULL;
+
+	DeleteMsgPort(self->ahip);
+	self->ahip = NULL;
+
+	self->ahi_fmt = -1;
+}
+
+static ALCboolean ALCplaybackAHI_reset(ALCplaybackAHI *self) {
+	ALCdevice *device = STATIC_CAST(ALCbackend, self)->mDevice;
+
+	self->ahi_fmt = get_ahi_format(device);
+	if(self->ahi_fmt == -1)
+		return ALC_FALSE;
+
+	SetDefaultChannelOrder(device);
+
+	return ALC_TRUE;
+}
+
+static ALCboolean ALCplaybackAHI_start(ALCplaybackAHI *self) {
+	ALCdevice *device = STATIC_CAST(ALCbackend, self)->mDevice;
+
+	self->data_size = device->UpdateSize * FrameSizeFromDevFmt(device->FmtChans, device->FmtType, device->AmbiOrder);
+
+	self->mix_data[0] = AllocVec(self->data_size, MEMF_ANY);
+	self->mix_data[1] = AllocVec(self->data_size, MEMF_ANY);
+
+	if(self->mix_data[0] != NULL && self->mix_data[1] != NULL) {
+		self->killNow = 0;
+		if(althrd_create(&self->thread, ALCplaybackAHI_mixerProc, self) == althrd_success)
+			return ALC_TRUE;
+	}
+
+	FreeVec(self->mix_data[1]);
+	FreeVec(self->mix_data[0]);
+	self->mix_data[0] = self->mix_data[1] = NULL;
+
+	return ALC_FALSE;
+}
+
+static void ALCplaybackAHI_stop(ALCplaybackAHI *self) {
+	int res;
+
+	if(self->killNow)
+		return;
+
+	self->killNow = 1;
+	althrd_join(self->thread, &res);
+
+	FreeVec(self->mix_data[1]);
+	FreeVec(self->mix_data[0]);
+	self->mix_data[0] = self->mix_data[1] = NULL;
+}
+
+typedef struct ALCahiBackendFactory {
+	DERIVE_FROM_TYPE(ALCbackendFactory);
+} ALCahiBackendFactory;
+#define ALCAHIBACKENDFACTORY_INITIALIZER { { GET_VTABLE2(ALCahiBackendFactory, ALCbackendFactory) } }
+
+ALCbackendFactory *ALCahiBackendFactory_getFactory(void);
+
+static ALCboolean ALCahiBackendFactory_init(ALCahiBackendFactory *self);
+static void ALCahiBackendFactory_deinit(ALCahiBackendFactory*self);
+static ALCboolean ALCahiBackendFactory_querySupport(ALCahiBackendFactory *self, ALCbackend_Type type);
+static void ALCahiBackendFactory_probe(ALCahiBackendFactory *self, enum DevProbe type, al_string *outnames);
+static ALCbackend* ALCahiBackendFactory_createBackend(ALCahiBackendFactory *self, ALCdevice *device, ALCbackend_Type type);
+DEFINE_ALCBACKENDFACTORY_VTABLE(ALCahiBackendFactory);
+
+ALCbackendFactory *ALCahiBackendFactory_getFactory(void) {
+	static ALCahiBackendFactory factory = ALCAHIBACKENDFACTORY_INITIALIZER;
+	return STATIC_CAST(ALCbackendFactory, &factory);
+}
+
+ALCboolean ALCahiBackendFactory_init(ALCahiBackendFactory* UNUSED(self)) {
+    VECTOR_INIT(PlaybackDevices);
+    VECTOR_INIT(CaptureDevices);
+
+	ConfigValueStr(NULL, "ahi", "device", &ahi_driver);
+
+	return ALC_TRUE;
+}
+
+void ALCahiBackendFactory_deinit(ALCahiBackendFactory* UNUSED(self)) {
+    clear_devlist(&PlaybackDevices);
+    VECTOR_DEINIT(PlaybackDevices);
+
+    clear_devlist(&CaptureDevices);
+    VECTOR_DEINIT(CaptureDevices);
+}
+
+ALCboolean ALCahiBackendFactory_querySupport(ALCahiBackendFactory* UNUSED(self), ALCbackend_Type type) {
+	if(type == ALCbackend_Playback)
+		return ALC_TRUE;
+	return ALC_FALSE;
+}
+
+void ALCahiBackendFactory_probe(ALCahiBackendFactory* UNUSED(self), enum DevProbe type, al_string *outnames) {
+	switch(type) {
+#define APPEND_OUTNAME(i) do {                                                \
+    if(!alstr_empty((i)->name))                                               \
+        alstr_append_range(outnames, VECTOR_BEGIN((i)->name),                 \
+                           VECTOR_END((i)->name)+1);                          \
+} while(0)
+		case ALL_DEVICE_PROBE:
+//			AppendAllDevicesList(ahi_device);
+            VECTOR_FOR_EACH(const DevMap, PlaybackDevices, APPEND_OUTNAME);
+			break;
+		case CAPTURE_DEVICE_PROBE:
+            VECTOR_FOR_EACH(const DevMap, CaptureDevices, APPEND_OUTNAME);
+			break;
+	}
+}
+
+ALCbackend* ALCahiBackendFactory_createBackend(ALCahiBackendFactory* UNUSED(self), ALCdevice *device, ALCbackend_Type type) {
+	if(type == ALCbackend_Playback) {
+		ALCplaybackAHI *backend;
+
+		backend = ALCplaybackAHI_New(sizeof(*backend));
+		if(!backend) return NULL;
+		memset(backend, 0, sizeof(*backend));
+
+		ALCplaybackAHI_Construct(backend, device);
+
+		return STATIC_CAST(ALCbackend, backend);
+    }
+
+    return NULL;
+}
+
diff -ruN openal-soft-1.19.1/Alc/backends/base.h openal-soft-1.19.1.aros/Alc/backends/base.h
--- openal-soft-1.19.1/Alc/backends/base.h	2018-10-11 22:05:31.000000000 +0000
+++ openal-soft-1.19.1.aros/Alc/backends/base.h	2020-01-15 04:16:20.082121100 +0000
@@ -137,6 +137,7 @@
 }
 
 
+ALCbackendFactory *ALCahiBackendFactory_getFactory(void);
 ALCbackendFactory *ALCpulseBackendFactory_getFactory(void);
 ALCbackendFactory *ALCalsaBackendFactory_getFactory(void);
 ALCbackendFactory *ALCcoreAudioBackendFactory_getFactory(void);
diff -ruN openal-soft-1.19.1/Alc/bformatdec.h openal-soft-1.19.1.aros/Alc/bformatdec.h
--- openal-soft-1.19.1/Alc/bformatdec.h	2018-10-11 22:05:31.000000000 +0000
+++ openal-soft-1.19.1.aros/Alc/bformatdec.h	2025-08-02 21:28:29.364929972 +0000
@@ -24,9 +24,9 @@
 /* NOTE: These are scale factors as applied to Ambisonics content. Decoder
  * coefficients should be divided by these values to get proper N3D scalings.
  */
-const ALfloat N3D2N3DScale[MAX_AMBI_COEFFS];
-const ALfloat SN3D2N3DScale[MAX_AMBI_COEFFS];
-const ALfloat FuMa2N3DScale[MAX_AMBI_COEFFS];
+extern const ALfloat N3D2N3DScale[MAX_AMBI_COEFFS];
+extern const ALfloat SN3D2N3DScale[MAX_AMBI_COEFFS];
+extern const ALfloat FuMa2N3DScale[MAX_AMBI_COEFFS];
 
 
 struct AmbDecConf;
diff -ruN openal-soft-1.19.1/Alc/helpers.c openal-soft-1.19.1.aros/Alc/helpers.c
--- openal-soft-1.19.1/Alc/helpers.c	2018-10-11 22:05:31.000000000 +0000
+++ openal-soft-1.19.1.aros/Alc/helpers.c	2025-08-02 21:20:18.908066022 +0000
@@ -102,13 +102,19 @@
 #ifndef _WIN32
 #include <sys/types.h>
 #include <sys/stat.h>
+#if !defined(__AROS__)
 #include <sys/mman.h>
+#endif
 #include <fcntl.h>
 #include <unistd.h>
 #elif defined(_WIN32_IE)
 #include <shlobj.h>
 #endif
 
+#ifdef __amigaos4__
+#include <proto/exec.h>
+#endif
+
 #include "alMain.h"
 #include "alu.h"
 #include "cpu_caps.h"
@@ -980,6 +986,7 @@
         return ret;
     }
 
+#if !defined(__AROS__)
     ptr = mmap(NULL, sbuf.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
     if(ptr == MAP_FAILED)
     {
@@ -987,6 +994,7 @@
         close(fd);
         return ret;
     }
+#endif
 
     ret.fd = fd;
     ret.ptr = ptr;
@@ -996,7 +1004,9 @@
 
 void UnmapFileMem(const struct FileMapping *mapping)
 {
+#if !defined(__AROS__)
     munmap(mapping->ptr, mapping->len);
+#endif
     close(mapping->fd);
 }
 
@@ -1010,6 +1020,9 @@
 #ifdef _WIN32
     if(RTPrioLevel > 0)
         failed = !SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);
+#elif defined(__amigaos4__)
+	if(RTPrioLevel > 0)
+		IExec->SetTaskPri(IExec->FindTask(NULL), 10);
 #elif defined(HAVE_PTHREAD_SETSCHEDPARAM) && !defined(__OpenBSD__)
     if(RTPrioLevel > 0)
     {
